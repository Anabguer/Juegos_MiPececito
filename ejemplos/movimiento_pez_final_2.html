<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Demo movimiento pez ‚Äî Tamagotchi (m√≥vil + crisis, limpieza con burbujas)</title>
  <style>
    :root{--bg:#0b2a3a;--panel:#0e364c;--accent:#5ce1e6;--ok:#7ae582;--warn:#ffd166;--bad:#ef476f;--muted:#9ecae1}
    html,body{height:100%;margin:0;background:#001923;color:#eaf6ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
    .phone{width:390px;height:844px;max-width:94vw;max-height:94vh;border-radius:28px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.45), 0 2px 8px rgba(0,0,0,.35);border:1px solid #123b52;display:flex;flex-direction:column;margin:auto}
    @media (max-width:420px){.phone{width:100vw;height:100vh;border-radius:0;box-shadow:none;border:0}}
    header{padding:.6rem .8rem;background:#012c3c;border-bottom:1px solid #08364a;display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;justify-content:space-between}
    header h1{font-size:.95rem;margin:0;opacity:.95}
    .btn{appearance:none;border:1px solid #0a4259;border-radius:12px;padding:.45rem .6rem;font-weight:600;cursor:pointer;background:#0a5a76;color:#fff}
    .btn:active{transform:translateY(1px)}
    .btn.ok{background:var(--ok);color:#053b47;border-color:#2c7f4d}
    .btn.warn{background:var(--warn);color:#222;border-color:#9b7b0b}
    .btn.bad{background:var(--bad);color:#fff;border-color:#b02140}
    .btn.ghost{background:#0b3147;color:#cbe6ff;border:1px solid #184b69}
    #aquarium{position:relative;flex:1 1 auto}
    canvas{display:block;width:100%;height:100%;position:absolute;inset:0;z-index:1;background:var(--tankBg, radial-gradient(120% 80% at 50% 15%, #0d3a58 0%, #07283a 50%, #041e2a 100%))} 
    #aquarium{position:relative}
    #lottieContainer{position:absolute;inset:0;z-index:2;pointer-events:none}
    #lottieAnchor{position:absolute;left:0;top:0;transform:translate(-50%,-50%);will-change:transform,filter}
    .hud{z-index:3}
    .toast{z-index:4}
    .hud{position:absolute;left:12px;bottom:12px;background:#041d2aa8;border:1px solid #0f3b56;color:#bfe2ff;padding:.5rem .6rem;border-radius:12px;font-size:.8rem;backdrop-filter: blur(2px)}
    .bars{display:grid;grid-template-columns:64px 140px;gap:.25rem .5rem; align-items:center}
    .bar{width:140px;height:10px;background:#0c3b54;border-radius:999px;overflow:hidden;border:1px solid #215d79}
    .fill{height:100%}
    .hunger{background:linear-gradient(90deg,#ef476f,#ff8fab)}
    .dirt{background:linear-gradient(90deg,#7cc000,#a3f07f)}
    .fun{background:linear-gradient(90deg,#5ce1e6,#9be7ff)}
    .controls{padding:.5rem .6rem;display:grid;grid-template-columns:repeat(4,1fr);gap:.35rem;background:#012c3c;border-top:1px solid #08364a}
    .toast{position:absolute;top:10px;left:50%;transform:translateX(-50%);padding:.4rem .6rem;background:#032233c7;border:1px solid #135070;border-radius:10px;font-weight:600}
    @keyframes ping{0%{box-shadow:0 0 0 0 rgba(155,231,255,.9)}100%{box-shadow:0 0 0 14px rgba(155,231,255,0)}}
    .pulse{animation:ping 1.1s ease-out}
  </style>
  <!-- Lottie (para pez SVG animado) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
</head>
<body>
  <div class="phone">
    <header>
      <h1>üê† Tamagotchi: m√≥vil + crisis</h1>
      <button class="btn ghost" id="btnReset">Reset</button>
    </header>

    <section id="aquarium">
      <canvas id="c"></canvas>
      <div id="lottieContainer"><div id="lottieAnchor"></div></div>
      <div class="hud" id="hud">
        <div style="font-weight:700;margin-bottom:.25rem">Estado</div>
        <div class="bars">
          <div>Hambre</div>
          <div class="bar"><div class="fill hunger" id="barH" style="width:25%"></div></div>
          <div>Suciedad</div>
          <div class="bar"><div class="fill dirt" id="barD" style="width:65%"></div></div>
          <div>Diversi√≥n</div>
          <div class="bar"><div class="fill fun" id="barF" style="width:70%"></div></div>
        </div>
        <div id="modeTxt" style="margin-top:.35rem;opacity:.85">Feliz</div>
      </div>
      <div class="toast" id="toast" style="display:none"></div>
    </section>

    <section class="controls">
      <button class="btn ok"   id="btnFeed">Dar de comer</button>
      <button class="btn ok"   id="btnPlay">Jugar (celebrar)</button>
      <button class="btn ok"   id="btnClean">Limpiar</button>
      <button class="btn warn" id="btnDropFood">Soltar comida</button>
      <button class="btn bad"  id="btnCrisisH">Crisis Hambre</button>
      <button class="btn bad"  id="btnCrisisD">Crisis Suciedad</button>
      <button class="btn bad"  id="btnCrisisB">Crisis Aburrimiento</button>
      <button class="btn ghost" id="btnTests">üîç Tests</button>
    </section>
  </div>

<script>
(function(){
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const toast = document.getElementById("toast");
  const barH = document.getElementById("barH");
  const barD = document.getElementById("barD");
  const barF = document.getElementById("barF");
  const modeTxt = document.getElementById("modeTxt");

  // === RENDER ===
  const RENDER_MODE = 'canvas'; // usa 'canvas' por defecto; si pones fish.json activo puedes cambiar a 'lottie' // 'canvas' o 'lottie'
  let lottiePlayer = null, lottieAnchor = null, lottieScale = 1;

  function viewW(){ return canvas.width/(window.devicePixelRatio||1); }
  function viewH(){ return canvas.height/(window.devicePixelRatio||1); }

  function resize(){
    const r = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = document.querySelector(".phone").clientHeight - 160;
    canvas.width  = Math.max(1, Math.floor(cssW * r));
    canvas.height = Math.max(1, Math.floor(cssH * r));
    // El canvas se pinta con su propio transform en draw(); aqu√≠ s√≥lo clamp de pez
    const pad=16, W=viewW(), H=viewH();
    fish.x = clamp(fish.x, pad, W-pad);
    fish.y = clamp(fish.y, pad, H-pad);
  }
  window.addEventListener("resize", resize);
  setTimeout(resize,0);
  // inicializa Lottie si procede
  function initLottie(path, scale=1){
    lottieAnchor = document.getElementById('lottieAnchor');
    if(RENDER_MODE!=='lottie' || !window.lottie || !lottieAnchor) return;
    lottieScale = scale;
    lottiePlayer = lottie.loadAnimation({ container: lottieAnchor, renderer:'svg', loop:true, autoplay:true, path });
  }
  // Cambia esta ruta por tu JSON Lottie (pez)
  initLottie('fish.json', 1.0);

  const needs = { hunger: 25, dirt: 65, fun: 70 };
  const FINGER_FUN_GAIN = 0.25;
  const CRISIS_LVL = 75;
  const MAX_BUBBLES = 1400;
  const PELLET_FAMILIES = [
    {h:38,s:85,l:62},  // honey gold
    {h:30,s:80,l:58},  // amber
    {h:46,s:68,l:70},  // oat
    {h:28,s:60,l:55},  // caramel
    {h:60,s:35,l:65},  // olive-muted
    {h:22,s:55,l:54}   // light brown
  ];
  function hslStr(h,s,l){ return `hsl(${Math.round(h)} ${Math.round(s)}% ${Math.round(l)}%)`; }
  function vary(val, amt, min, max){ const v = val + (Math.random()*2-1)*amt; return clamp(v, min, max); }
  function pelletColors(){
    const base = PELLET_FAMILIES[Math.floor(Math.random()*PELLET_FAMILIES.length)];
    const h = vary(base.h, 5, 10, 70);
    const s = vary(base.s, 10, 20, 95);
    const l = vary(base.l, 8, 35, 85);
    const strokeL = Math.max(10, l - 22);
    const strokeS = Math.max(25, Math.round(s*0.85));
    return { fill: hslStr(h,s,l), stroke: hslStr(h, strokeS, strokeL) };
  }

  const state = {
    time: 0,
    food: [],
    bubbles: [],
    tinyBubbles: [],
    labels: [],
    flyers: [],
    ripples: [],
    cleaningActive: false,
    cleanEmitT: 0,
    cleanDur: 2.6,
    dirtStart: 0,
    crisis: { hunger:false, dirt:false, bored:false },
    lastTap: {x:0, y:0},
    _lastDrawOrder: []
  };

  const fish = {
    x: 200, y: 220, vx:0, vy:0, facing:1,
    baseSpeed: 140, maxSpeed: 300, maxAccel: 900,
    wanderTimer: 0, wanderDir: {x:1,y:0}, swimPhase:0,
    desire: null, size: 26, happyBurst:0, spinKind:"eat",
    bottomHome: () => ({x: viewW()-70, y: viewH()-70}),
    topHome:    () => ({x: 70, y: 70}),
    returnToBottom: false,
    blinkT: 0,
    nextBlink: 2 + Math.random()*4,
    breathT: 2 + Math.random()*3
  };

  byId("btnDropFood").onclick = ()=> dropFood();
  byId("btnFeed").onclick = ()=> { needs.hunger = Math.max(0, needs.hunger-40); celebrate("¬°√ëam!"); };
  byId("btnPlay").onclick = ()=> { needs.fun = Math.min(100, needs.fun+35); celebrate("¬°A jugar!"); };
  byId("btnClean").onclick = ()=> cleanAll();
  byId("btnCrisisH").onclick = ()=> { needs.hunger = 80; showToast("Crisis de hambre"); };
  byId("btnCrisisD").onclick = ()=> { needs.dirt = 80; showToast("Crisis de suciedad"); };
  byId("btnCrisisB").onclick = ()=> { needs.fun = 20; showToast("Crisis de aburrimiento"); };
  byId("btnReset").onclick  = ()=> resetAll();
  byId("btnTests").onclick  = ()=> runTests();
  function byId(id){ return document.getElementById(id); }

  canvas.addEventListener("click", (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    state.lastTap = {x,y};
    // efecto onda/ripple siempre, aunque est√© en crisis
    state.ripples.push({x, y, t:0, dur:0.9});

    if(state.crisis.hunger || state.crisis.dirt || state.crisis.bored) return;
    fish.desire = {x: clamp(x, 24, viewW()-24), y: clamp(y, 24, viewH()-24)};
  });

  let last = performance.now();
  requestAnimationFrame(function tick(now){
    const dt = Math.min((now - last)/1000, 0.05); last = now; state.time += dt;
    autoNeeds(dt);
    updateCrisisFlags();
    updateFood(dt);
    updateCleaning(dt);
    updateFlyers(dt);
    updateTinyBubbles(dt);
    updateRipples(dt);
    updateFish(dt);
    draw();
    requestAnimationFrame(tick);
  });

  function autoNeeds(dt){
    const minutes = dt/60;
    needs.hunger = clamp(needs.hunger + 0.1*minutes, 0, 100);
    needs.dirt   = clamp(needs.dirt   + (1/15)*minutes, 0, 100);
    needs.fun    = clamp(needs.fun    - (1/8)*minutes, 0, 100);
    barH.style.width = needs.hunger + "%";
    barD.style.width = needs.dirt + "%";
    barF.style.width = needs.fun + "%";
  }

  function isCrisis(kind){
    if(kind==="hunger") return needs.hunger >= CRISIS_LVL;
    if(kind==="dirt")   return needs.dirt   >= CRISIS_LVL;
    if(kind==="bored")  return needs.fun    <= 100-CRISIS_LVL;
  }

  function updateCrisisFlags(){
    state.crisis.hunger = isCrisis("hunger");
    state.crisis.dirt   = isCrisis("dirt");
    state.crisis.bored  = isCrisis("bored");
    let mode = "Feliz";
    if(state.crisis.hunger) mode = "Crisis: Hambre (esquina ‚Üë, casi quieto)";
    else if(state.crisis.dirt) mode = "Crisis: Suciedad (esquina ‚Üì, lento)";
    else if(state.crisis.bored) mode = "Crisis: Aburrimiento (pasa de ti)";
    modeTxt.textContent = mode;
  }

  function resetAll(){
    needs.hunger=25; needs.dirt=65; needs.fun=70;
    state.food.length=0; state.bubbles.length=0; state.labels.length=0; state.flyers.length=0;
    state.cleanEmitT=0; state.cleaningActive=false;
    fish.x=viewW()*0.5; fish.y=viewH()*0.55; fish.vx=fish.vy=0; fish.desire=null; fish.happyBurst=0; fish.returnToBottom=false;
    showToast("Reset");
  }

  function dropFood(){
    const x = Math.random()*viewW();
    const col = pelletColors();
    const r = 2.6 + Math.random()*1.2;
    state.food.push({x, y: 10, vx: 0, vy: 6 + Math.random()*6, bottomT: 0, colorFill: col.fill, colorStroke: col.stroke, r});
  }

  function updateFood(dt){
    const h = viewH(); const drag=0.99;
    for(const f of state.food){
      if(f.bottomT>0){ f.bottomT += dt; }
      else { f.vy = Math.min(f.vy + 80*dt, 90); f.y += f.vy * dt; f.x += f.vx * dt; f.vx *= drag; if(f.y>h-12){ f.y=h-12; f.vy=0; f.vx=0; f.bottomT = 0.001; } }
    }
    for(let i=state.food.length-1;i>=0;i--){
      const f = state.food[i];
      if(dist(fish.x,fish.y,f.x,f.y) < 22){
        state.food.splice(i,1);
        needs.hunger = clamp(needs.hunger-35, 0, 100);
        needs.dirt = clamp(needs.dirt+8, 0, 100);
        state.labels.push({x:fish.x, y:fish.y-12, text:"√ëam", a:1, vy:40, life:1.4});
        fish.happyBurst = Math.max(fish.happyBurst, 1.2);
        fish.spinKind = "eat";
        if(state.crisis.hunger) { needs.hunger = Math.min(needs.hunger, 60); }
      } else if(f.bottomT>0 && f.bottomT>8){ state.food.splice(i,1); }
    }
  }

  // --- LIMPIEZA CON BURBUJAS ---
  function cleanAll(){
    state.cleaningActive = true;
    state.cleanEmitT = state.cleanDur; // tiempo emitiendo burbujas
    state.dirtStart = needs.dirt;
    fish.happyBurst = 3.2; fish.spinKind = "clean";
    showToast("¬°Pecera limpi√°ndose!");
    // Lote inicial inmediato: que se vean desde el primer frame y nazcan DENTRO del canvas
    emitCleanBubbles();
  }

  function emitCleanBubbles(){
    const W=viewW(), H=viewH();
    const vents = Math.max(16, Math.floor(W/24));
    const perVent = 2; // por frame
    for(let i=0;i<vents;i++){
      const baseX = (i+0.5)*(W/vents) + (Math.random()-0.5)*8;
      for(let k=0;k<perVent;k++){
        const vy = 260 + Math.random()*120; // subida m√°s r√°pida y constante
        const y0 = H - 1.5 + Math.random()*0.5; // nacen pegadas al borde inferior
        const dur = (H + 24) / vy; // duraci√≥n exacta hasta salir
        const x0 = clamp(baseX + (Math.random()-0.5)*6, 2, W-2);
        state.bubbles.push({
          x: x0,
          y: y0,
          x0: x0,
          y0: y0,
          r: 1.5 + Math.random()*2.8,
          vy,
          t: 0,
          dur,
          wob: Math.random()*Math.PI*2,
          wobSpd: 1.5 + Math.random()*1.2,
          wobAmp: 6 + Math.random()*10,
          from: "clean"
        });
      }
    }
    // control de memoria
    if(state.bubbles.length>MAX_BUBBLES) state.bubbles.splice(0, state.bubbles.length-MAX_BUBBLES);
  }

  function updateCleaning(dt){
    if(state.cleaningActive){
      state.cleanEmitT -= dt;
      emitCleanBubbles();
      const p = clamp(1 - Math.max(state.cleanEmitT,0)/state.cleanDur, 0, 1);
      // baja la suciedad de forma global (no barrido)
      needs.dirt = clamp((1-p)*state.dirtStart, 0, 100);
      barD.style.width = needs.dirt + "%";
      if(state.cleanEmitT <= 0){ state.cleaningActive = false; }
    }

    // mover burbujas (cinem√°tica param√©trica: sin saltos ni parones)
    for(const b of state.bubbles){
      if(b.dur){
        if(b.t===0){ b.t += 0.016; } // peque√±o empuj√≥n inicial para evitar cualquier snapping del primer frame
        b.t += dt;
        const p = Math.min(1, b.t / b.dur);
        b.y = b.y0 - p * (viewH() + 24);
        b.x = b.x0 + Math.sin(state.time*b.wobSpd + b.wob) * b.wobAmp;
      } else { // compatibilidad con burbujas antiguas
        b.y -= b.vy*dt;
        b.x += Math.sin(state.time*b.wobSpd + b.wob) * b.wobAmp * dt;
      }
    }
    // eliminar al finalizar la trayectoria
    for(let i=state.bubbles.length-1;i>=0;i--){
      const b = state.bubbles[i];
      if( (b.dur && b.t>=b.dur) || (!b.dur && b.y < -12) ) state.bubbles.splice(i,1);
    }
    for(let i=state.bubbles.length-1;i>=0;i--){ if(state.bubbles[i].y < -12) state.bubbles.splice(i,1); }

    // cuando no queden burbujas, suciedad = 0 (garant√≠a) y fin
    if(!state.cleaningActive && needs.dirt>0 && state.bubbles.length===0){ needs.dirt=0; barD.style.width="0%"; }
  }

  function celebrate(msg){
    fish.happyBurst = Math.max(fish.happyBurst, 1.3);
    fish.spinKind = "eat";
    showToast(msg);
  }

  function showToast(message){
    toast.textContent = message;
    toast.style.display = "block";
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{ toast.style.display = "none"; }, 1500);
  }

  function launchHeartToFun(){
    const crect = canvas.getBoundingClientRect();
    const frect = barF.getBoundingClientRect();
    const ex = frect.left + frect.width*0.9 - crect.left;
    const ey = frect.top + frect.height*0.5 - crect.top;
    const sx = fish.x, sy = fish.y;
    const cx = (sx+ex)/2; const cy = Math.min(sy,ey) - 100;
    state.flyers.push({t:0,dur:1.8,sx,sy,cx,cy,ex,ey, given:false});
  }

  function updateFlyers(dt){
    for(const f of state.flyers){ f.t += dt/f.dur; }
    for(let i=state.flyers.length-1;i>=0;i--){
      const f = state.flyers[i];
      if(f.t>=1){
        if(!f.given){ needs.fun = clamp(needs.fun + FINGER_FUN_GAIN, 0, 100); barF.classList.remove("pulse"); void barF.offsetWidth; barF.classList.add("pulse"); f.given = true; }
        state.flyers.splice(i,1);
      }
    }
  }

  function updateFish(dt){
    // parpadeo y respiraci√≥n
    fish.blinkT = Math.max(0, fish.blinkT - dt);
    fish.nextBlink -= dt; if(fish.nextBlink<=0 && fish.blinkT<=0){ fish.blinkT = 0.12; fish.nextBlink = 2 + Math.random()*4; }
    fish.breathT -= dt; if(fish.breathT<=0 && !state.cleaningActive){ emitMouthBubbles(3 + Math.floor(Math.random()*3)); fish.breathT = 2 + Math.random()*3; }

    fish.swimPhase += dt * 3.2;
    let targetV = {vx:0, vy:0};
    let speedMul = 1.0;

    const inHunger = state.crisis.hunger;
    const inDirt   = state.crisis.dirt;
    const inBored  = state.crisis.bored;

    if(fish.happyBurst>0){
      const w = (fish.spinKind==="clean") ? 13.0 : 6.0;
      const R = (fish.spinKind==="clean") ? 140 : 55;
      const a = state.time*w;
      targetV = {vx: Math.cos(a)*R*0.65, vy: Math.sin(a)*R*0.65};
      speedMul = (fish.spinKind==="clean") ? 1.8 : 1.25;
      fish.happyBurst = Math.max(0, fish.happyBurst - (fish.spinKind==="clean"? 0.6:1.6)*dt);
    }
    else if(inHunger && state.food.length){
      const best = nearestFood();
      const s = seek(fish.x, fish.y, best.x, best.y, fish.maxSpeed*1.0);
      speedMul = 1.25; targetV = {vx:s.vx, vy:s.vy};
    }
    else if(inHunger){
      const home = fish.topHome();
      const s = seek(fish.x, fish.y, home.x, home.y, 60);
      speedMul = 0.5;
      if(s.dist>20){ targetV = {vx:s.vx*0.5, vy:s.vy*0.5}; }
      else { targetV = {vx: Math.sin(fish.swimPhase)*6, vy: Math.cos(fish.swimPhase*1.2)*3}; }
    }
    else if(inDirt && state.food.length){
      const best = nearestFood();
      const s = seek(fish.x, fish.y, best.x, best.y, fish.maxSpeed*0.6);
      speedMul = 0.85; targetV = {vx:s.vx, vy:s.vy}; fish.returnToBottom = true;
    }
    else if(inDirt){
      const home = fish.bottomHome();
      const s = seek(fish.x, fish.y, home.x, home.y, 70);
      speedMul = 0.7;
      if(s.dist>20){ targetV = {vx:s.vx*0.5, vy:s.vy*0.5}; }
      else { targetV = {vx: Math.sin(fish.swimPhase)*5, vy: Math.cos(fish.swimPhase*1.2)*2}; }
    }
    else if(inBored){
      const home = {x: viewW()*0.5, y: viewH()-70};
      const s = seek(fish.x, fish.y, home.x, home.y, 80);
      speedMul = 0.9;
      if(s.dist>18){ targetV = {vx:s.vx*0.6, vy:s.vy*0.6}; }
      else { targetV = {vx: Math.sin(fish.swimPhase)*7, vy: Math.cos(fish.swimPhase*1.5)*3}; }
    }
    else if(fish.desire){
      const s = seek(fish.x, fish.y, fish.desire.x, fish.desire.y, fish.maxSpeed*0.9);
      const t = clamp(s.dist/120, 0.25, 1);
      targetV = {vx: s.vx*t, vy: s.vy*t};
      if(s.dist < 22){ fish.desire = null; targetV = {vx:0,vy:0}; launchHeartToFun(); }
    } else if(state.food.length){
      const f = nearestFood();
      const d = dist(fish.x,fish.y,f.x,f.y);
      const s = seek(fish.x, fish.y, f.x, f.y, fish.maxSpeed*0.9);
      const t = clamp(d/90, 0.35, 1);
      targetV = {vx:s.vx*t, vy:s.vy*t};
    } else {
      fish.wanderTimer -= dt; if(fish.wanderTimer<=0){
        const angle = (Math.random()*Math.PI*2);
        fish.wanderDir.x = Math.cos(angle); fish.wanderDir.y = Math.sin(angle)*0.33;
        fish.wanderTimer = 0.8 + Math.random()*1.1;
      }
      const cruise = fish.baseSpeed*1.1;
      targetV = {vx: fish.wanderDir.x*cruise + Math.cos(fish.swimPhase)*16,
                 vy: fish.wanderDir.y*cruise + Math.sin(fish.swimPhase*1.8)*16};
    }

    const maxSpeed = fish.maxSpeed * speedMul;
    const maxAccel = fish.maxAccel * speedMul;
    const ax = clamp(targetV.vx - fish.vx, -maxAccel, maxAccel);
    const ay = clamp(targetV.vy - fish.vy, -maxAccel, maxAccel);
    fish.vx += ax*dt; fish.vy += ay*dt;

    fish.x += fish.vx*dt; fish.y += fish.vy*dt;

    const pad = 16, W = viewW(), H = viewH();
    if(fish.x < pad){ fish.x = pad; if(fish.vx<0) fish.vx *= -0.5; }
    if(fish.x > W-pad){ fish.x = W-pad; if(fish.vx>0) fish.vx *= -0.5; }
    if(fish.y < pad){ fish.y = pad; if(fish.vy<0) fish.vy *= -0.5; }
    if(fish.y > H-pad){ fish.y = H-pad; if(fish.vy>0) fish.vy *= -0.5; }

    if(Math.abs(fish.vx)>2){ fish.facing = fish.vx>0 ? 1 : -1; }
  }

  function nearestFood(){
    let best=null,bestD=1e9; for(const f of state.food){const d=dist(fish.x,fish.y,f.x,f.y); if(d<bestD){bestD=d; best=f;}} return best||null;
  }

  // --- RESPIRACI√ìN: burbujitas desde la boca ---
  function fishMouthPos(){
    const s = fish.size; const bodyW = s*2.2, bodyH = s*1.2;
    const mx = fish.x + (fish.facing>0 ? 1 : -1) * (bodyW*0.42);
    const my = fish.y - bodyH*0.12;
    return {x:mx, y:my};
  }
  function emitMouthBubbles(n=4, x0, y0){
    const {x:mx,y:my} = (x0!==undefined? {x:x0,y:y0} : fishMouthPos());
    for(let i=0;i<n;i++){
      state.tinyBubbles.push({
        x: mx + (Math.random()*6-3),
        y: my + (Math.random()*6-3),
        r: 0.9 + Math.random()*1.3,
        vy: 50 + Math.random()*40,
        wob: Math.random()*Math.PI*2,
        wobSpd: 1.2 + Math.random()*0.8,
        wobAmp: 3 + Math.random()*4,
        a: 1,
        life: 1.2
      });
    }
  }
  function updateTinyBubbles(dt){
    for(const b of state.tinyBubbles){
      b.y -= b.vy*dt;
      b.x += Math.sin(state.time*b.wobSpd + b.wob) * b.wobAmp * dt;
      b.life -= dt; b.a = Math.max(0, b.life/1.2);
    }
    for(let i=state.tinyBubbles.length-1;i>=0;i--){
      const b = state.tinyBubbles[i];
      if(b.life<=0 || b.y < -12) state.tinyBubbles.splice(i,1);
    }
  }

  // --- ONDAS EN EL AGUA (ripples) ---
  function updateRipples(dt){
    for(const r of state.ripples){ r.t += dt; }
    for(let i=state.ripples.length-1;i>=0;i--){ if(state.ripples[i].t>=state.ripples[i].dur) state.ripples.splice(i,1); }
  }
  function drawRipples(){
    ctx.save();
    for(const r of state.ripples){
      const t = Math.min(1, r.t/r.dur);
      const R = 10 + t*28;
      ctx.globalAlpha = (1-t)*0.6;
      ctx.lineWidth = 2*(1-t)+0.6;
      ctx.strokeStyle = "rgba(200,230,255,0.9)";
      ctx.beginPath(); ctx.arc(r.x, r.y, R, 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  // DIBUJO DE COMIDA (pellets visibles)
  function drawFood(){
    ctx.save();
    for(const f of state.food){
      ctx.beginPath(); ctx.arc(f.x, f.y, (f.r||3), 0, Math.PI*2);
      ctx.fillStyle = (f.colorFill || '#ffd166'); ctx.fill();
      ctx.lineWidth=1; ctx.strokeStyle = (f.colorStroke || '#9b7b0b'); ctx.stroke();
    }
    ctx.restore();
  }

  function updateLottieSprite(){
    if(RENDER_MODE!=='lottie' || !lottieAnchor) return;
    // Posiciona y orienta el Lottie en coordenadas CSS (coinciden con viewW/viewH)
    const sx = (fish.facing>0 ? 1 : -1);
    lottieAnchor.style.transform = `translate(${fish.x}px, ${fish.y}px) translate(-50%,-50%) scaleX(${sx}) scale(${lottieScale})`;
    // Filtros por estado
    if(state.crisis.hunger || state.crisis.dirt || state.crisis.bored){
      lottieAnchor.style.filter = state.crisis.dirt ? 'brightness(0.9) saturate(0.9)' : 'brightness(0.95)';
    } else {
      lottieAnchor.style.filter = 'none';
    }
  }

  function drawFish(){
    const s = fish.size; const x=fish.x, y=fish.y;
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(fish.facing,1);

    const bodyW = s*2.2, bodyH = s*1.2;
    const hue = (state.crisis.hunger||state.crisis.dirt||state.crisis.bored) ? 200 : 190 + Math.sin(state.time*1.2)*10;
    const body = `hsl(${hue} 70% 60%)`;

    ctx.fillStyle = body; ctx.strokeStyle = "#053b47"; ctx.lineWidth=2;
    roundRect(ctx, -bodyW*0.5, -bodyH*0.5, bodyW, bodyH, bodyH*0.5, true, true);

    ctx.beginPath(); ctx.moveTo(-bodyW*0.5,0);
    ctx.quadraticCurveTo(-bodyW*0.85, -bodyH*0.7, -bodyW*1.0, 0);
    ctx.quadraticCurveTo(-bodyW*0.85, bodyH*0.7, -bodyW*0.5, 0);
    ctx.fillStyle = `hsl(${hue} 70% 50%)`; ctx.fill(); ctx.stroke();

    ctx.save(); ctx.translate(0,-bodyH*0.52);
    ctx.rotate(Math.sin(state.time*5)*0.08);
    ctx.fillStyle = `hsl(${hue} 70% 55%)`;
    ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(16,-8); ctx.lineTo(28,0); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();

    // ojo / parpadeo
    if(fish.blinkT>0){
      ctx.strokeStyle="#001018"; ctx.lineWidth=2.2; ctx.beginPath();
      ctx.moveTo(bodyW*0.20,-bodyH*0.12); ctx.lineTo(bodyW*0.30,-bodyH*0.12); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.arc(bodyW*0.25,-bodyH*0.12, 3.5, 0, Math.PI*2); ctx.fillStyle="#001018"; ctx.fill();
    }

    ctx.restore();
  }

  function draw(){
    const w = viewW(), h = viewH();
    // Limpieza total en p√≠xeles f√≠sicos y fijamos el transform cada frame
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const r = window.devicePixelRatio || 1;
    ctx.setTransform(r,0,0,r,0,0);
    state._lastDrawOrder = [];

    // fondo
    drawBackgroundDecor(w,h);

    // ondas de click
    drawRipples();

    // capa de suciedad (desaparece seg√∫n needs.dirt)
    const murk = needs.dirt/100;
    if(murk>0){ ctx.fillStyle = `rgba(70,110,60,${0.12 + murk*0.28})`; ctx.fillRect(0,0,w,h); }

    // comida
    drawFood();

    // pez (seg√∫n modo)
    if(RENDER_MODE==='canvas'){
      drawFish();
    } else {
      updateLottieSprite();
    }
    state._lastDrawOrder.push("fish");

    // burbujas por ENCIMA del pez (exhalaci√≥n + limpieza)
    ctx.save();
    // exhalaci√≥n peque√±ita
    for(const b of state.tinyBubbles){
      ctx.globalAlpha = Math.max(0.2, b.a||0.8);
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fillStyle="#e8fbff"; ctx.fill();
      ctx.lineWidth=0.7; ctx.strokeStyle="rgba(255,255,255,0.8)"; ctx.stroke();
    }
    // limpieza
    for(const b of state.bubbles){
      ctx.globalAlpha=0.95;
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fillStyle="#dff7ff"; ctx.fill();
      ctx.lineWidth=0.9; ctx.strokeStyle="rgba(255,255,255,0.75)"; ctx.stroke();
    }
    ctx.restore();
    state._lastDrawOrder.push("bubbles");

    // labels y corazones
    for(const f of state.flyers){
      const t = Math.min(1,f.t); const u = 1-t;
      const x = u*u*f.sx + 2*u*t*f.cx + t*t*f.ex;
      const y = u*u*f.sy + 2*u*t*f.cy + t*t*f.ey;
      ctx.save(); ctx.globalAlpha = 0.9; ctx.font='bold 18px system-ui,Segoe UI,Arial'; ctx.fillStyle='rgba(255,120,160,1)'; ctx.fillText('‚ù§', x-6, y); ctx.restore();
    }
    for(const L of state.labels){ ctx.save(); ctx.globalAlpha=Math.max(0,L.a); ctx.font="bold 22px system-ui,Segoe UI,Arial"; ctx.fillStyle="#ffe6ee"; ctx.strokeStyle="rgba(180,40,90,0.9)"; ctx.lineWidth=3; ctx.strokeText(L.text,L.x-18,L.y); ctx.fillText(L.text,L.x-18,L.y); ctx.restore(); L.y -= L.vy*0.016; L.a -= 0.8*0.016; L.life -= 0.016; }
    for(let i=state.labels.length-1;i>=0;i--){ if(state.labels[i].life<=0 || state.labels[i].a<=0) state.labels.splice(i,1); }
  }

  function drawBackgroundDecor(w,h){
    ctx.fillStyle = "#0b2d3e";
    ctx.beginPath(); ctx.moveTo(0,h-50);
    for(let x=0;x<=w;x+=40){ const y = h-50 + Math.sin((x+state.time*40)*0.015)*6; ctx.lineTo(x,y); }
    ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath(); ctx.fill();
    for(let i=0;i<6;i++){
      const x = (i+0.5)*(w/6);
      ctx.strokeStyle = "#20a07d"; ctx.lineWidth = 8; ctx.lineCap="round";
      ctx.beginPath(); const base = h-50, top = base-80 - Math.sin(state.time*2+i)*10;
      ctx.moveTo(x, base); ctx.quadraticCurveTo(x-10, base-40, x+8, top); ctx.stroke();
    }
    for(let i=0;i<8;i++){
      const bx = (i*97 + (state.time*20)%w)%w; const by = h - ((state.time*30 + i*80)%h);
      ctx.globalAlpha = 0.4; ctx.beginPath(); ctx.arc(bx, by, 3+(i%3), 0, Math.PI*2); ctx.fillStyle="#c7f0ff"; ctx.fill(); ctx.globalAlpha=1;
    }
  }

  function runTests(){
    const results = [];
    results.push(["helpers view", typeof viewW==="function" && typeof viewH==="function"]);
    results.push(["showToast", typeof showToast==="function"]);
    results.push(["cleanAll", typeof cleanAll==="function"]);
    results.push(["drawFish", typeof drawFish==="function"]);
    results.push(["emitMouthBubbles", typeof emitMouthBubbles==="function"]);
    results.push(["drawRipples", typeof drawRipples==="function"]);
    // respiraci√≥n: crea y sube
    const tb0 = state.tinyBubbles.length; emitMouthBubbles(4, fish.x, fish.y); updateTinyBubbles(0.3);
    const breathOk = state.tinyBubbles.length>tb0 && state.tinyBubbles.some(b=>b.y < fish.y);
    results.push(["Burbujitas respiran y suben", breathOk]);

    // bordes
    const oldX=fish.x, oldY=fish.y; fish.x=-100; fish.y=-100; updateFish(0.016); const inside1 = (fish.x>=16 && fish.y>=16); results.push(["Clamp sup-izq", inside1]);
    fish.x=viewW()+100; fish.y=viewH()+100; updateFish(0.016); const inside2 = (fish.x<=viewW()-16 && fish.y<=viewH()-16); results.push(["Clamp inf-der", inside2]);

    // limpieza con burbujas: aparecen y suben
    cleanAll(); updateCleaning(1.0);
    const midUp = state.bubbles.some(b=>b.y < viewH()*0.5);
    results.push(["Burbujas alcanzan mitad", midUp]);
    for(let t=0;t<3.0;t+=0.25){ updateCleaning(0.25); }
    const cleaned = needs.dirt === 0 && state.cleaningActive === false;
    results.push(["Limpieza completa", cleaned]);

    // tests adicionales (no afectan a los previos)
    results.push(["emitCleanBubbles definido", typeof emitCleanBubbles==="function"]);
    cleanAll(); updateCleaning(0); // lote inmediato
    const H=viewH();
    const bornAtBottom = state.bubbles.some(b=>b.from==="clean" && b.y>=H-6);
    results.push(["Burbujas nacen dentro (borde)", bornAtBottom]);

    // render
    let drawOk=true; try{ draw(); }catch(e){ drawOk=false; }
    results.push(["draw() sin excepci√≥n", drawOk]);

    const ok = results.every(r=>r[1]);
    showToast((ok?"‚úÖ":"‚ö†Ô∏è")+" Tests: "+results.map(r=>`${r[0]}=${r[1]?"OK":"FALLO"}`).join(" | "));
    fish.x=oldX; fish.y=oldY; // no tocamos bars aqu√≠
  }

  function roundRect(ctx, x,y,w,h,r, fill, stroke){ const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }
  function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
  function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
  function seek(fx,fy, tx,ty, maxSpeed){ const dx = tx - fx, dy = ty - fy; const d = Math.hypot(dx,dy) || 1; return {vx: dx/d*maxSpeed, vy: dy/d*maxSpeed, dist:d}; }
})();
</script>
</body>
</html>

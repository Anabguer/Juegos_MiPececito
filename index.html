<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>üê† Mi Pececito - Tamagotchi Virtual</title>
    
    <!-- üé® CSS INTEGRADO PARA EVITAR PROBLEMAS DE CARGA -->
    
    <style>
        /* üé® VARIABLES CSS GLOBALES */
        :root {
          --bg-primary: #08243a;
          --bg-secondary: #1d4b6b;
          --bg-accent: #2a6287;
          --text-primary: #e9f6ff;
          --text-secondary: rgba(233, 246, 255, 0.8);
          --fish-baby-body: #d9ccff;
          --fish-baby-tail: #ff9ecf;
          --fish-baby-fin: #ffd0e2;
          --fish-baby-stripe: #ffba7a;
          --fish-young-body: #b1a1ff;
          --fish-young-tail: #f191cd;
          --fish-young-fin: #f1c4e4;
          --fish-young-stripe: #ffa960;
          --fish-adult-body: #5a48c8;
          --fish-adult-tail: #d073c6;
          --fish-adult-fin: #e2a8d6;
          --fish-adult-stripe: #ff9745;
          --button-primary: #205b86;
          --button-hover: #2a6287;
          --button-active: #1a4a73;
          --button-radius: 12px;
          --button-size: 80px;
          --badge-size: 64px;
          --bubble-size: 48px;
          --good-item: #4CAF50;
          --bad-item: #F44336;
          --star-color: #FFD700;
          --coin-color: #FF8C42;
          --fish-baby-size: 46px;
          --fish-young-size: 52px;
          --fish-adult-size: 60px;
            --egg-size: 130px; /* Tama√±o ajustado para m√≥vil */
          --pellet-size: 16px;
          --star-size: 32px;
          --transition-fast: 0.15s ease;
          --transition-smooth: 0.3s ease;
          --transition-slow: 0.6s ease;
          --bounce-animation: cubic-bezier(0.68, -0.55, 0.265, 1.55);
          --mobile-padding: 12px;
          --desktop-padding: 20px;
          --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.25);
          --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.4);
          --blur-light: blur(4px);
          --blur-strong: blur(10px);
          --rank-bronze: #CD7F32;
          --rank-silver: #C0C0C0;
          --rank-gold: #FFD700;
          --rank-diamond: #B9F2FF;
        }


        /* üîò COMPONENTES UNIVERSALES */
        .universal-btn {
          width: var(--button-size);
          height: var(--button-size);
          background: var(--button-primary);
          color: var(--text-primary);
          border: none;
          border-radius: var(--button-radius);
          box-shadow: var(--shadow-soft);
          transition: all var(--transition-fast);
          cursor: pointer;
          font-weight: 600;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
          font-size: 14px;
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }

        .universal-btn:hover {
          background: var(--button-hover);
          transform: translateY(-2px);
          box-shadow: var(--shadow-strong);
        }

        .universal-btn:active {
          background: var(--button-active);
          transform: translateY(0);
          box-shadow: var(--shadow-soft);
        }

        .fade-in {
          animation: fadeIn var(--transition-smooth) ease;
        }

        .bounce-in {
          animation: bounceIn 0.5s var(--bounce-animation);
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes bounceIn {
          0% { transform: scale(0.3); opacity: 0; }
          50% { transform: scale(1.05); }
          70% { transform: scale(0.9); }
          100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }

        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-6px); }
        }
        /* üì± Estilos base m√≥vil-first */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
            padding: 0;
            box-sizing: border-box;
        }
        
        
        /* üèÜ CABECERA DEL JUEGO */
        #gameHeader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 15px 10px 15px;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(13, 71, 161, 0.4);
            z-index: 1000;
            border-bottom: 3px solid #0d47a1;
            backdrop-filter: blur(10px);
        }
        
        .fish-info-expanded {
            flex: 1;
            text-align: center;
            color: #fff;
            padding: 0 20px;
        }
        
        #fishAge {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        
        #fishName {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: linear-gradient(45deg, #26c6da, #4fc3f7);
            border: 3px solid #81d4fa;
            color: white;
            padding: 8px;
            border-radius: 50%;
            font-size: 18px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(38, 198, 218, 0.3);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(38, 198, 218, 0.4);
            border-color: #4fc3f7;
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .action-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéí MODAL DE INVENTARIO */
        #inventoryModal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 600px;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255,255,255,0.3);
        }
        
        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(255, 82, 82, 0.3);
        }
        
        .close-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(255, 82, 82, 0.4);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
        }
        
        .tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            padding: 15px 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 4px solid transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .tab-btn.active {
            color: white;
            border-bottom-color: white;
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-1px);
            border-radius: 8px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .item-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .item-card:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4fc3f7;
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .item-card.selected {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .item-preview {
            width: 80px;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin: 0 auto 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .item-name {
            color: #fff;
            font-size: 10px;
            font-weight: bold;
        }
        
        .item-cost {
            color: #4fc3f7;
            font-size: 9px;
            margin-top: 2px;
        }
        
        .coming-soon {
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-style: italic;
            padding: 40px 20px;
        }
        
        .locked-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        /* üé® MODALES BONITOS */
        @keyframes modalPop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes bubbleFloat {
            from {
                top: 100%;
                opacity: 0.8;
            }
            to {
                top: -10%;
                opacity: 0;
            }
        }
        
        /* üéÆ MODALES DE JUEGO MEJORADAS */
        .game-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-modal-overlay[style*="block"] {
            opacity: 1;
        }
        
        .game-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 650px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.4s ease-out;
            position: relative;
        }
        
        .games-modal {
            max-width: 700px;
        }
        
        .game-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .game-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 82, 82, 0.3);
        }
        
        .game-close-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 15px rgba(255, 82, 82, 0.5);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            padding: 16px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 4px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .game-tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-2px);
            border-radius: 8px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-tab-btn.active {
            color: white;
            border-bottom-color: #ffffff;
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .tab-text {
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-modal-body {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-tab-content {
            display: none;
        }
        
        .game-tab-content.active {
            display: block;
            animation: fadeInUp 0.3s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .game-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        
        .game-item-card {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-item-card:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-item-card.available {
            border-color: #4caf50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .game-item-card.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-item-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 12px;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }
        
        .game-item-info {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .game-item-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-reward {
            color: #4caf50;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-unlock {
            color: #ff9800;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-play-btn {
            width: 100%;
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 12px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .game-play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 18px rgba(76, 175, 80, 0.4);
            background: linear-gradient(45deg, #66bb6a, #4caf50);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-play-btn:active {
            transform: scale(0.98);
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* üéÆ ESTILOS ESPEC√çFICOS PARA JUEGO BURBUJAS */
        .bubble-btn.primary {
            background: linear-gradient(135deg, #FFD700, #FFA500) !important;
            border: 2px solid #FF8C00 !important;
            border-radius: 20px !important;
            padding: 10px 25px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: #8B4513 !important;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8) !important;
            box-shadow: 0 4px 10px rgba(255, 215, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.6) !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            width: 60% !important;
            max-width: 200px !important;
            margin: 0 auto !important;
            display: block !important;
        }
        
        .bubble-btn.primary:hover {
            transform: translateY(-3px) scale(1.08) !important;
            box-shadow: 0 12px 25px rgba(255, 215, 0, 0.7) !important;
            border-radius: 20px !important; /* Mantener esquinas redondeadas en hover */
        }
        
        /* üéØ √ÅREA DE JUEGO M√ÅS GRANDE */
        #bubbleStage {
            width: 100% !important;
            height: 300px !important;
            position: relative !important;
            overflow: hidden !important;
            background: linear-gradient(180deg, #4fc3f7 0%, #29b6f6 30%, #0288d1 70%, #0277bd 100%) !important;
            border-radius: 15px !important;
            border: 2px solid rgba(255, 255, 255, 0.3) !important;
        }
        
        .game-locked-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
        }
        
        .lock-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        .lock-text {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .coming-soon-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .coming-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .coming-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .coming-desc {
            font-size: 14px;
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* üì± MODALES M√ìVILES SIMPLES */
        .mobile-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .mobile-modal-overlay[style*="flex"] {
            opacity: 1;
        }
        
        .mobile-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 3px solid #ffffff;
            border-radius: 20px;
            width: 95%;
            max-width: 400px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }
        
        .mobile-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .inventory-grid-simple {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar {
            width: 8px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .mobile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mobile-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .mobile-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .mobile-close-btn:active {
            transform: scale(0.95);
        }
        
        .header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .mobile-help-btn {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid rgba(255, 193, 7, 0.5);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-help-btn:hover {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.1);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .mobile-help-btn:active {
            transform: scale(0.95);
        }
        
        /* üéÆ GRID DE JUEGOS 3x3 */
        .games-grid-3x3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-card-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .game-card-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
            border-radius: 10px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card-square:active {
            transform: scale(0.98);
        }
        
        .game-card-square.available {
            border-color: #4caf50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .game-card-square.available:hover {
            border-color: #66bb6a;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            border-radius: 10px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .game-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .game-card-square.locked .game-lock-overlay {
            opacity: 1;
        }
        
        .lock-icon-small {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .lock-stars {
            color: #ffa726;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* üéí INVENTARIO SIMPLE */
        .inventory-grid-simple {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .inventory-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .inventory-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .inventory-section-header h3 {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        .inventory-section-subtitle {
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
        }
        
        .inventory-section-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
        }
        
        .inventory-item-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .inventory-item-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-item-square:active {
            transform: scale(0.98);
        }
        
        .inventory-item-square.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .selected-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .inventory-item-square.available {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }
        
        .inventory-item-square.owned {
            border-color: #4CAF50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .inventory-square-price {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 500;
            margin-top: 2px;
        }
        
        .owned-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .inventory-item-square.available:hover {
            border-color: #42a5f5;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-item-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .inventory-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .inventory-square-preview {
            width: 60px;
            height: 45px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .inventory-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .inventory-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .inventory-item-square.locked .inventory-lock-overlay {
            opacity: 1;
        }
        
        /* üì± RESPONSIVE PARA MODALES M√ìVILES */
        @media (max-width: 480px) {
            .mobile-modal-content {
                width: 98%;
                max-width: 350px;
                border-radius: 16px;
            }
            
            .mobile-modal-header {
                padding: 14px 18px;
            }
            
            .mobile-modal-header h2 {
                font-size: 16px;
            }
            
            .mobile-close-btn {
                width: 36px;
                height: 36px;
                font-size: 20px;
            }
            
            .games-grid-3x3 {
                gap: 10px;
                padding: 16px;
            }
            
            .game-card-square {
                border-radius: 10px;
            }
            
            .game-square-icon {
                font-size: 28px;
                margin-bottom: 4px;
            }
            
            .game-square-name {
                font-size: 10px;
            }
            
            .lock-icon-small {
                font-size: 18px;
            }
            
            .lock-stars {
                font-size: 9px;
            }
        }
        
        @media (max-width: 360px) {
            .games-grid-3x3 {
                gap: 8px;
                padding: 14px;
            }
            
            .game-square-icon {
                font-size: 24px;
            }
            
            .game-square-name {
                font-size: 9px;
            }
        }
        
        /* üìä BARRAS DE NECESIDADES */
        .needs-bars {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .need-bar {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-icon {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        
        .bar-container {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .bar-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .bar-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .bar-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üìä BARRA DE NECESIDADES COMPACTA DEBAJO DE CABECERA */
        .needs-header-bar {
            background: linear-gradient(135deg, rgba(100, 150, 200, 0.8), rgba(130, 180, 230, 0.8)) !important;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 15px;
            display: none; /* OCULTA POR DEFECTO - SOLO VISIBLE CON PEZ */
            justify-content: center;
            align-items: center;
            gap: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 999;
            position: fixed;
            top: 100px;
            left: 0;
            right: 0;
            height: 0; /* ALTURA 0 CUANDO EST√Å OCULTA */
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        /* CUANDO SE MUESTRA, TIENE ALTURA */
        .needs-header-bar[style*="flex"] {
            height: 35px !important;
        }
        
        .need-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .need-emoji {
            font-size: 16px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }
        
        .need-bar-mini {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .need-fill-mini {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        
        .need-fill-mini.hunger {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE‚ÜíNARANJA‚ÜíROJO */
        }
        
        .need-fill-mini.dirt {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE‚ÜíNARANJA‚ÜíROJO (como hambre) */
        }
        
        .need-fill-mini.fun {
            background: linear-gradient(90deg, #f44336, #ff9800, #4caf50); /* ROJO‚ÜíNARANJA‚ÜíVERDE */
        }
        
        
        /* üìä BARRAS FLOTANTES COMPACTAS (OCULTAS) */
        .needs-overlay {
            display: none; /* OCULTAR las flotantes */
            position: absolute;
            top: 70px;
            right: 15px;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .need-mini {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-mini span {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .mini-bar {
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .mini-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .mini-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .mini-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .mini-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üì± RESPONSIVE PARA M√ìVILES */
        @media (max-width: 768px) {
            .game-modal-content {
                width: 98%;
                max-height: 95vh;
                border-radius: 20px;
            }
            
            .game-modal-header {
                padding: 16px 20px;
            }
            
            .game-modal-header h2 {
                font-size: 18px;
            }
            
            .game-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .game-tabs {
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .game-tabs::-webkit-scrollbar {
                display: none;
            }
            
            .game-tab-btn {
                padding: 12px 8px;
                min-width: 80px;
            }
            
            .tab-icon {
                font-size: 18px;
            }
            
            .tab-text {
                font-size: 11px;
            }
            
            .game-modal-body {
                padding: 16px;
                max-height: 400px;
            }
            
            .game-items-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .game-item-card {
                padding: 16px;
            }
            
            .game-item-icon {
                font-size: 40px;
            }
            
            .game-item-name {
                font-size: 16px;
            }
            
            .game-item-description {
                font-size: 13px;
            }
            
            .game-play-btn {
                padding: 10px 14px;
                font-size: 13px;
            }
            
            .coming-soon-card {
                padding: 30px 16px;
            }
            
            .coming-icon {
                font-size: 40px;
            }
            
            .coming-text {
                font-size: 16px;
            }
            
            .coming-desc {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .game-modal-content {
                border-radius: 16px;
            }
            
            .game-modal-header {
                padding: 12px 16px;
            }
            
            .game-modal-header h2 {
                font-size: 16px;
            }
            
            .game-modal-body {
                padding: 12px;
                max-height: 350px;
            }
            
            .game-item-card {
                padding: 12px;
            }
            
            .game-item-icon {
                font-size: 36px;
            }
            
            .tab-icon {
                font-size: 16px;
            }
            
            .tab-text {
                font-size: 10px;
            }
        }
        
        .custom-modal h2 {
            color: white;
            font-size: 18px;
            margin: 0 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .custom-modal p {
            color: white;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .custom-input {
            width: 100%;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 16px;
            text-align: center;
            margin: 10px 0;
            background: rgba(255,255,255,0.9);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .custom-input:focus {
            outline: none;
            border-color: #81d4fa;
            box-shadow: 0 0 10px rgba(129, 212, 250, 0.5);
        }
        
        .custom-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .custom-btn {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .confirm-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            color: white;
        }
        
        .cancel-btn {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
            color: white;
        }
        
        .custom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .custom-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéÆ TARJETAS DE JUEGOS */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .game-card {
            background: linear-gradient(135deg, #1e88e5 0%, #2196f3 50%, #42a5f5 100%);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        .game-card.available {
            cursor: pointer;
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: white;
            box-shadow: 0 8px 20px rgba(255,255,255,0.2);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card.locked {
            filter: grayscale(70%);
            opacity: 0.6;
        }
        
        .game-icon {
            font-size: 40px;
            margin-bottom: 15px;
        }
        
        .game-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .game-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-reward {
            color: #81d4fa;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .game-unlock {
            color: #ffab91;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .play-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(76, 175, 80, 0.4);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* üì∏ √ÅLBUM/DIARIO */
        .album-modal {
            max-width: 700px;
            max-height: 85%;
        }
        
        .album-header-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .album-action-btn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(79, 195, 247, 0.3);
        }
        
        .album-action-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(79, 195, 247, 0.4);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .album-content {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .album-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .stat-item span {
            display: block;
            font-size: 16px;
            color: #81d4fa;
            margin-top: 5px;
        }
        
        .album-timeline {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .album-entry {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .album-entry:hover {
            transform: translateY(-2px);
            border-color: white;
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .album-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .album-entry-title {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        .album-entry-date {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .album-entry-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .album-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: rgba(255,255,255,0.6);
        }
        
        .album-entry-age {
            background: rgba(129, 212, 250, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        #gameCanvas {
            position: fixed;
            top: 100px; /* Header (70px) + Barra necesidades (30px) */
            left: 0;
            right: 0;
            bottom: 60px; /* Espacio para barra inferior */
            touch-action: none;
            background: var(--bg-primary);
            z-index: 10;
        }
        
        
        /* üéÆ UI Overlay */
        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        /* üí∞ CONTADORES FLOTANTES */
        #currencyOverlay {
            position: absolute;
            top: 85px; /* M√°s cerca de la cabecera */
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px; /* M√°s compacto */
        }
        
        .currency-float {
            display: flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(38, 198, 218, 0.95), rgba(79, 195, 247, 0.95));
            border: 2px solid rgba(255,255,255,0.9);
            padding: 4px 6px;
            border-radius: 18px;
            box-shadow: 0 2px 6px rgba(38, 198, 218, 0.4);
            backdrop-filter: blur(6px);
            transition: all 0.3s ease;
            min-width: 55px;
        }
        
        .currency-float:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(38, 198, 218, 0.4);
            border-radius: 18px; /* Mantener esquinas redondeadas en hover */
        }
        
        .currency-float .currency-icon {
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .currency-float span:last-child {
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            min-width: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Animaci√≥n cuando cambia el valor */
        .currency-float.updated {
            animation: currencyPulse 0.5s ease-out;
        }
        
        @keyframes currencyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 8px 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }
        
        /* üí® Badge Turbo */
        #turboBadge {
            position: fixed;
            right: var(--mobile-padding);
            top: var(--mobile-padding);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: var(--blur-light);
            font-weight: 700;
            font-size: 14px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
        }
        
        #turboBadge.active {
            opacity: 1;
        }
        
        /* üéØ Loading Screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity var(--transition-smooth);
            color: white;
            text-align: center;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content h2 {
            margin: 20px 0 10px 0;
            font-size: 24px;
            font-weight: bold;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            animation: logoFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .loading-dots {
            font-size: 30px;
            animation: loadingPulse 1.5s infinite;
        }

        .loading-dots span {
            animation: dotBounce 1.4s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes dotBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-20px); }
        }

        /* üéÜ EFECTOS DE RECOMPENSA */
        .reward-bubble {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(100,200,255,0.6));
            border: 3px solid rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 2000;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(100,200,255,0.6);
            animation: rewardBubbleFloat 2s ease-out forwards;
        }

        @keyframes rewardBubbleFloat {
            0% {
                transform: scale(0.5) translateY(0);
                opacity: 0;
            }
            20% {
                transform: scale(1.2) translateY(-20px);
                opacity: 1;
            }
            50% {
                transform: scale(1) translateY(-60px);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-100px);
                opacity: 0;
            }
        }

        .reward-explosion {
            position: fixed;
            width: 70px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8), transparent);
            z-index: 99999;
            pointer-events: none;
            animation: rewardExplosion 0.8s ease-out forwards;
        }

        @keyframes rewardExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        @keyframes starExplosion {
            0% {
                transform: scale(0) translate(0, 0);
                opacity: 1;
            }
            50% {
                transform: scale(1) translate(var(--random-x, 0), var(--random-y, 0));
                opacity: 0.8;
            }
            100% {
                transform: scale(0.3) translate(calc(var(--random-x, 0) * 2), calc(var(--random-y, 0) * 2));
                opacity: 0;
            }
        }

        @keyframes floatUp {
            0% {
                transform: translateX(-50%) translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translateX(-50%) translateY(-20px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) translateY(-100px) scale(1);
                opacity: 0;
            }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(233, 246, 255, 0.3);
            border-top: 3px solid var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes floatBubble {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            25% {
                transform: translateY(-8px) scale(1.05);
            }
            50% {
                transform: translateY(-3px) scale(0.98);
            }
            75% {
                transform: translateY(-12px) scale(1.02);
            }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.8;
        }
        
        /* üö® Error Screen */
        #errorScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: var(--mobile-padding);
            text-align: center;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .error-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .error-message {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 24px;
        }
        
        .retry-button {
            padding: 12px 24px;
            border: none;
            border-radius: var(--button-radius);
            background: var(--button-primary);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        
        .retry-button:hover {
            background: var(--button-hover);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* üîß Barra de Debug (solo en desarrollo) */
        #debugBar {
            position: fixed;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15); /* BLANQUECINO CRISTAL */
            backdrop-filter: blur(10px); /* EFECTO CRISTAL */
            border-radius: 12px;
            padding: 6px 4px;
            display: none;
            flex-direction: column;
            gap: 3px;
            z-index: 1002;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* SOMBRA SUAVE */
            width: 80px; /* Ancho fijo m√°s peque√±o */
        }
        
        #debugInfo {
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 7px;
            text-align: center;
            margin-bottom: 4px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-btn {
            padding: 4px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            font-size: 16px; /* Solo emoji */
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .debug-btn.danger {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .debug-btn.primary {
            border-color: #4488ff;
            color: #4488ff;
        }
        
        .debug-btn.warning {
            border-color: #ffaa44;
            color: #ffaa44;
        }
        
        .debug-btn.success {
            border-color: #4caf50;
            color: #4caf50;
        }
        
        .debug-btn.info {
            border-color: #00bcd4;
            color: #00bcd4;
        }
        
        .debug-btn.purple {
            border-color: #9c27b0;
            color: #9c27b0;
        }
        
        /* üéÆ BARRA DE HERRAMIENTAS COMPACTA COMO CABECERA */
        .action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 90px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2); /* IGUAL QUE CABECERA */
            box-shadow: 0 -4px 20px rgba(13, 71, 161, 0.4); /* SOMBRA HACIA ARRIBA */
            border-top: 3px solid #0d47a1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10px;
            gap: 8px;
            backdrop-filter: blur(20px);
            border-radius: 0; /* SIN ESQUINAS REDONDEADAS */
            z-index: 40;
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: none; /* SIN BORDES */
        }
        
        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none; /* SIN BORDES OSCUROS */
            border-radius: 13px; /* RADIO PERSONALIZADO */
            padding: 2px; /* PADDING REDUCIDO */
            cursor: pointer;
            transition: all 0.2s ease; /* TRANSICI√ìN NORMAL Y SUAVE */
            width: 48px;
            height: 48px;
            overflow: hidden;
        }
        
        .menu-btn:hover:not(.disabled) {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px); /* EFECTO SUAVE NORMAL */
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4); /* SOMBRA SUAVE */
            border-radius: 13px; /* Mantener esquinas redondeadas en hover */
        }
        
        .menu-btn.disabled {
            background: linear-gradient(135deg, #bbb, #999);
            border: none; /* SIN BORDES EN DESHABILITADOS TAMBI√âN */
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .menu-btn.disabled:hover {
            transform: none;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        
        .menu-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .menu-btn:hover:not(.disabled) .menu-icon {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3)) brightness(1.1); /* EFECTO M√ÅS SUAVE */
        }
        
        .menu-btn.disabled .menu-icon {
            filter: grayscale(100%) drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        /* üé® LOGO DE LA WEB */
        .logo-container {
            display: flex;
            align-items: center;
        }
        
        .game-logo {
            height: 40px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .game-logo:hover {
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.4)) brightness(1.1);
            transform: scale(1.05);
        }
        
        /* üìù INFO EN DOS L√çNEAS */
        .fish-info-stacked {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            text-align: center;
        }
        
        .fish-info-stacked #fishAge {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .fish-info-stacked #fishName {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* üí∞ CONTADORES VERTICALES */
        .header-currency-vertical {
            display: flex;
            align-items: center;
        }
        
        .currency-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        
        
        .currency-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .currency-row .currency-icon {
            font-size: 12px;
        }
        
        .currency-row span {
            color: white;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* üéØ ICONOS DE NECESIDADES FLOTANTES (SOLO VISUALES) */
        .need-bubble-game {
            position: absolute;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* NO clickeables */
            animation: needPulse 2s infinite ease-in-out;
            z-index: 90;
            opacity: 0.4; /* M√ÅS TRANSPARENTE Y SUTIL */
        }
        
        .need-icon {
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
        }
        
        /* üé≠ TRANSICIONES SUAVES PARA MOVIMIENTO DE ICONOS */
        .need-bubble-game {
            transition: opacity 1.8s ease, transform 1.8s ease;
        }
        
        /* üçΩÔ∏è ICONO DE COMIDA CON EFECTO ROJO */
        .need-bubble-game.hunger .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 50, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 50, 50, 0.6))
                hue-rotate(-15deg) 
                saturate(1.5) 
                brightness(1.2);
        }
        
        /* üßΩ ICONO DE LIMPIEZA CON EFECTO AZUL */
        .need-bubble-game.dirty .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 150, 255, 0.8))
                drop-shadow(0 0 12px rgba(50, 150, 255, 0.6))
                hue-rotate(20deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üíä ICONO DE MEDICINA CON EFECTO VERDE */
        .need-bubble-game.medicine .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 255, 100, 0.8))
                drop-shadow(0 0 12px rgba(50, 255, 100, 0.6))
                hue-rotate(30deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üéÆ ICONO DE JUEGO CON EFECTO NARANJA */
        .need-bubble-game.play .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 150, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 150, 50, 0.6))
                hue-rotate(-30deg) 
                saturate(1.3) 
                brightness(1.1);
        }
        
        @keyframes needPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* üéâ Pantalla de bienvenida - ESTILO MARINO BONITO */
        #welcomeScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
            padding: var(--mobile-padding);
            overflow: hidden;
        }

        /* üåä EFECTOS MARINOS DE FONDO */
        #welcomeScreen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255,255,255,0.1) 2px, transparent 2px),
                radial-gradient(circle at 80% 30%, rgba(255,255,255,0.08) 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, rgba(255,255,255,0.06) 3px, transparent 3px),
                radial-gradient(circle at 90% 80%, rgba(255,255,255,0.1) 2px, transparent 2px);
            background-size: 100px 100px, 150px 150px, 200px 200px, 120px 120px;
            animation: float-bubbles 20s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes float-bubbles {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-20px, -30px) rotate(5deg); }
            50% { transform: translate(30px, -20px) rotate(-3deg); }
            75% { transform: translate(-10px, 40px) rotate(2deg); }
        }

        /* üì± Ocultar header durante bienvenida */
        #welcomeScreen:not([style*="display: none"]) + * #gameHeader,
        #welcomeScreen[style*="flex"] ~ #gameHeader {
            display: none !important;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.15);
            padding: 32px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .welcome-content h1 {
            font-size: 28px;
            margin-bottom: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .welcome-content p {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 24px;
        }
        
        /* üéì TUTORIAL STEPS */
        .welcome-tutorial {
            margin: 20px 0;
            text-align: left;
        }
        
        .tutorial-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 14px;
            opacity: 0.9;
            animation: tutorial-fade-in 0.6s ease-out forwards;
        }
        
        .tutorial-step:nth-child(1) { animation-delay: 0.2s; opacity: 0; }
        .tutorial-step:nth-child(2) { animation-delay: 0.4s; opacity: 0; }
        .tutorial-step:nth-child(3) { animation-delay: 0.6s; opacity: 0; }
        .tutorial-step:nth-child(4) { animation-delay: 0.8s; opacity: 0; }
        .tutorial-step:nth-child(5) { animation-delay: 1.0s; opacity: 0; }
        
        .tutorial-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }
        
        .tutorial-text {
            flex: 1;
            font-weight: 500;
        }
        
        @keyframes tutorial-fade-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 0.9; transform: translateX(0); }
        }
        
        /* ü•ö MENSAJE SIMPLE DEL HUEVITO */
        .welcome-info {
            margin: 20px 0;
        }
        
        .egg-message {
            font-size: 16px;
            opacity: 0.9;
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.1);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 12px;
        }
        
        .games-tip {
            font-size: 14px;
            opacity: 0.85;
            line-height: 1.4;
            background: rgba(76, 175, 80, 0.15); /* Verde suave */
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            animation: tip-glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes tip-glow {
            from { box-shadow: 0 0 5px rgba(76, 175, 80, 0.3); }
            to { box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
        }
        
        /* üíñ EFECTO PULSE PARA BARRA DE DIVERSI√ìN */
        @keyframes ping {
            0% { box-shadow: 0 0 0 0 rgba(155,231,255,.9) }
            100% { box-shadow: 0 0 0 14px rgba(155,231,255,0) }
        }
        .pulse { animation: ping 1.1s ease-out; }

        /* üéÆ MODAL DE JUEGOS HERMOSO */
        .games-modal-content {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .games-info {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .star-system {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .star-rule {
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            color: #ffd700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .user-stars-display {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
        }
        
        .stars-total {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 193, 7, 0.15) 100%);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 12px;
            padding: 12px 20px;
        }
        
        .stars-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(255, 215, 0, 0.6));
        }
        
        .stars-label {
            font-size: 14px;
            font-weight: 600;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .stars-count {
            font-size: 18px;
            font-weight: 800;
            color: #FFD700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* ‚ùì MODAL DE AYUDA */
        .help-modal-content {
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .help-content {
            padding: 20px;
        }
        
        .help-section {
            margin-bottom: 25px;
        }
        
        .help-section h3 {
            color: #FFD700;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .help-section p {
            color: #fff;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .star-rules {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .star-rule-help {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .star-icon {
            font-size: 24px;
            filter: drop-shadow(0 2px 4px rgba(255, 215, 0, 0.6));
        }
        
        .rule-text {
            color: #fff;
            line-height: 1.4;
        }
        
        .rule-text strong {
            color: #FFD700;
            font-size: 16px;
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .game-card {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 20px;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .game-card.available {
            border-color: rgba(76, 175, 80, 0.4);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.1),
                0 0 20px rgba(76, 175, 80, 0.1);
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(76, 175, 80, 0.6);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 0 30px rgba(76, 175, 80, 0.3);
        }
        
        .game-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .game-icon {
            font-size: 32px;
            margin-bottom: 10px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .game-description {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-stats {
            font-size: 11px;
            color: #ffd700;
            font-weight: 600;
        }
        
        .game-lock {
            font-size: 12px;
            color: #999;
            font-weight: 500;
        }
        
        /* üîä BOT√ìN DE VOLUMEN SIMPLE */
        .volume-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            margin-top: 8px;
            margin-left: 12px; /* Separaci√≥n de los contadores */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .volume-button:hover {
            transform: scale(1.1);
            border-radius: 13px; /* Mantener esquinas redondeadas en hover */
        }

        .volume-button:active {
            transform: scale(0.95);
        }

        #volumeIcon {
            width: 28px;
            height: 28px;
            opacity: 0.75; /* Transl√∫cido para que pegue con el resto */
            transition: all 0.3s ease;
        }
        
        .volume-button:hover #volumeIcon {
            opacity: 1; /* Completamente opaco al hover */
        }
        
        .volume-icon {
            pointer-events: none;
        }
        
        .start-button {
            padding: 16px 32px;
            border: 3px solid #01579b;
            border-radius: 25px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: white;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.6);
        }
        
        .start-button:hover {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.8);
            border-radius: 20px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* üîÑ BOT√ìN DE RESET BONITO */
        .reset-button {
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
            border-radius: 20px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* üé® LOGO ANIMADO */
        .logo-animated {
            margin-bottom: 20px;
        }
        
        .logo-bounce {
            width: 80px;
            height: 60px;
            animation: logoBounce 3s ease-in-out infinite;
            filter: drop-shadow(0 4px 15px rgba(79, 195, 247, 0.6));
        }
        
        @keyframes logoBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-10px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.02); }
            75% { transform: translateY(-15px) scale(1.08); }
        }
        
        /* üåä BURBUJAS ANIMADAS DE FONDO */
        .welcome-bubbles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .bubble {
            position: absolute;
            font-size: 20px;
            opacity: 0.7;
            animation: bubbleFloat 4s ease-in-out infinite;
        }
        
        .bubble-1 { left: 10%; animation-delay: 0s; }
        .bubble-2 { left: 20%; animation-delay: 1s; }
        .bubble-3 { left: 80%; animation-delay: 2s; }
        .bubble-4 { left: 90%; animation-delay: 0.5s; }
        .bubble-5 { left: 60%; animation-delay: 1.5s; }
        
        @keyframes bubbleFloat {
            0% { transform: translateY(100vh) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20px) scale(1.2); opacity: 0; }
        }
        
        /* üéÆ GRID DE JUEGOS COMPACTO MARINO */
        .games-grid-simple {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .game-card {
            background: linear-gradient(135deg, #29b6f6 0%, #42a5f5 50%, #64b5f6 100%);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #0066cc;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,150,255,0.2);
            backdrop-filter: blur(15px);
        }
        
        .game-card.locked {
            background: linear-gradient(135deg, rgba(200,200,200,0.6) 0%, rgba(180,180,180,0.5) 100%);
            border-color: rgba(150,150,150,0.6);
            color: #999;
            opacity: 0.8;
        }
        
        .game-card:hover:not(.locked) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(0,150,255,0.25);
            border-color: rgba(0,200,255,0.9);
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(230,248,255,0.9) 100%);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .game-name {
            font-weight: bold;
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1.1;
        }
        
        .game-requirement {
            font-size: 11px;
            opacity: 0.8;
        }
        
        /* üéì Pantalla de tutorial - ESTILO MARINO BONITO */
        #tutorialScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 998;
            padding: var(--mobile-padding);
        }
        
        .tutorial-content {
            text-align: center;
            max-width: 350px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 24px;
            border-radius: 16px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        .tutorial-content h2 {
            margin-bottom: 16px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .tutorial-hint {
            background: #f0f8ff;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-size: 14px;
        }
        
        /* Eliminado - Ya no hay bot√≥n saltar */
        
        /* üéÆ Responsive ajustes */
        @media (max-width: 480px) {
            #turboBadge {
                font-size: 12px;
                padding: 4px 8px;
            }
        }

        /* üåä Conecta 3 - Estilos del juego (basado en prototipo funcional) */
        .bloques-cell {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            font-weight: 900;
            color: #fff;
            user-select: none;
            -webkit-user-drag: none;
            touch-action: none;
            cursor: grab;
            transition: transform .18s ease, box-shadow .18s ease, filter .18s ease, opacity .18s ease;
            background: #2c3e50;
            box-shadow: inset 0 6px 10px rgba(255,255,255,.15), inset 0 -8px 14px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.2);
            border: 2px solid #34495e;
        }

        .bloques-cell span {
            font-size: 26px;
            line-height: 1;
            pointer-events: none;
        }

        .bloques-cell:active {
            cursor: grabbing;
        }

        .bloques-cell.ghost {
            opacity: 0.7;
            filter: brightness(1.15);
        }

        .bloques-cell.pop {
            animation: pop .25s ease;
        }

        @keyframes pop {
            from { transform: scale(.85); }
            to { transform: scale(1); }
        }

        .bloques-cell.pulse {
            animation: pulse .9s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 0 rgba(255,255,255,.15); }
            50% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 8px rgba(255,255,255,0); }
            100% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 0 rgba(255,255,255,0); }
        }

        /* Pistas sutiles por tipo (bordecito) */
        .bloques-cell.t0 { outline: 2px solid #4ac1ff66; }
        .bloques-cell.t1 { outline: 2px solid #7aff7a66; }
        .bloques-cell.t2 { outline: 2px solid #ffd84a66; }
        .bloques-cell.t3 { outline: 2px solid #ff7adf66; }
        .bloques-cell.t4 { outline: 2px solid #a88bff66; }
        .bloques-cell.t5 { outline: 2px solid #ff9a4a66; }

        /* üåä Conecta 3 - Estilos de la cabecera (igual que burbujas) */
        .bloques-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }

        .bloques-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bloques-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bloques-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }

        .bloques-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .bloques-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bloques-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .bloques-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }

        .bloques-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üß† Memoria - Estilos del contenedor */
        .memory-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }

        /* üß† Memoria - Estilos de la cabecera (igual que Conecta 3) */
        .memory-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }

        .memory-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .memory-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .memory-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .memory-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .memory-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .memory-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .memory-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .memory-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        .memory-btn {
            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
            border: 2px solid rgb(21, 101, 192) !important;
            border-radius: 20px !important;
            padding: 12px 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: white !important;
            cursor: pointer !important;
            transition: 0.3s !important;
            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            width: 80% !important;
            max-width: 250px !important;
            margin: 20px auto !important;
            display: block !important;
        }

        /* üéµ Sim√≥n - Estilos del contenedor */
        /* üéÆ CONTENEDOR UNIFICADO PARA TODOS LOS JUEGOS */
        .unified-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }
        
        .simon-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }

        /* üéµ Sim√≥n - Estilos de la cabecera (igual que Burbujas) */
        .simon-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .simon-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .simon-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .simon-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .simon-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .simon-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .simon-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .simon-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .simon-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        .simon-btn {
            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
            border: 2px solid rgb(21, 101, 192) !important;
            border-radius: 20px !important;
            padding: 12px 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: white !important;
            cursor: pointer !important;
            transition: 0.3s !important;
            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            width: 80% !important;
            max-width: 250px !important;
            margin: 20px auto !important;
            display: block !important;
        }

        /* üê¨ Carril - Estilos de la cabecera (igual que Burbujas) */
        .carril-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .carril-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .carril-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .carril-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .carril-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .carril-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .carril-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .carril-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .carril-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üêâ Drag√≥n - Estilos de la cabecera (igual que Burbujas) */
        .correr-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .correr-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .correr-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .correr-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .correr-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .correr-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .correr-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .correr-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .correr-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üéØ Caza - Estilos de la cabecera (igual que Burbujas) */
        .caza-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .caza-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .caza-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .caza-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .caza-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .caza-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .caza-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .caza-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .caza-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üåä Secuencia - Estilos de la cabecera (igual que Burbujas) */
        .secuencia-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .secuencia-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .secuencia-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .secuencia-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .secuencia-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .secuencia-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .secuencia-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .secuencia-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .secuencia-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üèñÔ∏è Toca-3 - Estilos de la cabecera (igual que Burbujas) */
        .toca3-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .toca3-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .toca3-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .toca3-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .toca3-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .toca3-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toca3-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .toca3-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .toca3-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* üåä Conecta 3 - Estilos del contenedor */
        .bloques-game-container {
            background: linear-gradient(135deg, 
                rgba(30, 60, 114, 0.95) 0%, 
                rgba(42, 82, 152, 0.9) 100%);
            border-radius: 20px;
            padding: 0;
            max-width: 90vw;
            max-height: calc(100vh - 80px);
            width: 400px;
            height: 600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 60px rgba(0,0,0,.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            position: relative;
            z-index: 1;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        /* ü´ß Burbujas - Estilos del contenedor */
        .bubble-game-container {
            background: linear-gradient(180deg, 
                rgba(129, 212, 250, 0.25) 0%,
                rgba(79, 195, 247, 0.2) 30%,
                rgba(41, 182, 246, 0.15) 70%,
                rgba(13, 71, 161, 0.2) 100%);
            backdrop-filter: blur(30px) saturate(200%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 28px;
            width: 95vw;
            max-width: 500px;
            max-height: calc(100vh - 80px);
            height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 60px rgba(0,0,0,.6);
            overflow: hidden;
            position: relative;
            z-index: 1;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        /* ü´ß Burbujas - Estilos de la cabecera (igual que Conecta 3) */
        .bubble-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }

        .bubble-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bubble-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bubble-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }

        .bubble-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .bubble-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bubble-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .bubble-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }

        .bubble-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <!-- üèÜ CABECERA CON LOGO -->
    <div id="gameHeader">
        <!-- üé® LOGO DE LA WEB -->
        <div class="logo-container">
            <img src="./images/ui/logo.png" alt="Mi Pececito" class="game-logo">
    </div>
    
        <!-- üìù INFO EN DOS L√çNEAS -->
        <div class="fish-info-stacked">
            <div id="fishAge">Huevo</div>
            <div id="fishName">Mi Pececito</div>
        </div>
        
        <!-- üí∞ CONTADORES VERTICALES -->
        <div class="header-currency-vertical">
            <div class="currency-stack">
                <div class="currency-row">
                    <span class="currency-icon">ü´ß</span>
                    <span id="bubblesCount">0</span>
                </div>
                <div class="currency-row">
                    <span class="currency-icon">‚≠ê</span>
                    <span id="starsCount">0</span>
                </div>
            </div>
            <!-- üîä BOT√ìN DE VOLUMEN BONITO -->
            <button id="volumeBtn" class="volume-button" title="Controlar sonido">
                <img id="volumeIcon" src="./images/ui/sonidoOn.png" alt="Sonido" class="volume-icon">
            </button>
        </div>
    </div>
    
    <!-- üìä BARRA DE NECESIDADES (SIEMPRE VISIBLE) -->
    <div id="needsHeaderBar" class="needs-header-bar">
        <div class="need-compact" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <img src="./images/ui/barra_comida.png" alt="Hambre" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini hunger" id="hungerBarHeader" style="width: 80%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Suciedad: M√ÅS ROJO = M√ÅS SUCIO">
            <img src="./images/ui/barra_limpieza.png" alt="Limpieza" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini dirt" id="dirtBarHeader" style="width: 65%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <img src="./images/ui/barra_diversion.png" alt="Diversi√≥n" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini fun" id="funBarHeader" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üéÆ BARRA DE MEN√ö LIMPIA SIN TEXTO -->
    <div class="action-bar">
        <button class="menu-btn disabled" id="feedBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_hunger.png" alt="Comida" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn disabled" id="cleanBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_dirty.png" alt="Limpiar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="playButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_play.png" alt="Jugar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="inventoryButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_inventario.png" alt="Inventario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="createUserButton" title="Crear Usuario">
            <div class="btn-icon">
                <img src="./images/ui/badge_config.png" alt="Crear Usuario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="resetButton" title="Cuidar otro pececito">
            <div class="btn-icon">
                <img src="./images/ui/badge_caravera.png" alt="Reset" class="menu-icon">
            </div>
        </button>
    </div>

    <!-- üë§ MODAL DE CREAR USUARIO -->
    <div id="createUserModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üë§ Crear Usuario</h2>
                <button class="mobile-close-btn" id="closeCreateUser">√ó</button>
            </div>
            <div class="mobile-modal-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <p style="color: var(--text-primary); font-size: 16px; line-height: 1.5;">
                        <strong>¬°No queremos perder a tu pececito!</strong><br>
                        Crea una cuenta para guardar tu progreso y nunca perder a tu compa√±ero acu√°tico.
                    </p>
                </div>
                
                <form id="createUserForm" style="display: flex; flex-direction: column; gap: 15px;">
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            üë§ Nombre completo
                        </label>
                        <input type="text" id="userFullName" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu nombre completo">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            üè∑Ô∏è Nombre de usuario
                        </label>
                        <input type="text" id="userNickname" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu nombre de usuario">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            üìß Correo electr√≥nico
                        </label>
                        <input type="email" id="userEmail" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="tu@email.com">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            üîí Contrase√±a
                        </label>
                        <input type="password" id="userPassword" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu contrase√±a segura">
                    </div>
                    
                    <button type="submit" 
                            style="background: linear-gradient(135deg, var(--button-primary), var(--button-hover)); 
                                   color: var(--text-primary); border: none; padding: 15px; 
                                   border-radius: 12px; font-size: 16px; font-weight: 600; 
                                   cursor: pointer; transition: all 0.3s ease; margin-top: 10px;">
                        ¬°Crear mi cuenta!
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- üéÆ Canvas principal del juego -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- üìä BARRAS DE NECESIDADES FLOTANTES -->
    <div class="needs-overlay">
        <div class="need-mini" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <span>üçé</span>
            <div class="mini-bar">
                <div class="mini-fill hunger" id="hungerBar" style="width: 80%"></div>
            </div>
        </div>
        <div class="need-mini" title="Suciedad: M√ÅS VERDE = M√ÅS SUCIO">
            <span>üßπ</span>
            <div class="mini-bar">
                <div class="mini-fill dirt" id="dirtBar" style="width: 65%"></div>
            </div>
        </div>
        <div class="need-mini" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <span>üéâ</span>
            <div class="mini-bar">
                <div class="mini-fill fun" id="funBar" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üê† CONTENEDOR LOTTIE PARA EL PEZ -->
    <div id="lottieContainer" style="
        position: absolute;
        width: 60px;
        height: 60px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        pointer-events: none;
        display: none;
        /* filter: brightness(1.3) contrast(1.1) saturate(1.2); */ /* DESHABILITADO - conflicto con JS din√°mico */
    "></div>
    
    <!-- üéØ UI Overlay -->
    <div class="ui-overlay">
        <!-- üí® Badge de turbo -->
        <div id="turboBadge">TURBO üí®</div>
        
        
        <!-- üéØ ICONOS DE NECESIDADES (SOLO VISUALES - NO CLICKEABLES) -->
        <!-- ICONOS FLOTANTES ELIMINADOS - ERAN MOLESTOS -->
    </div>
    
    <!-- üì± Pantalla de carga ELIMINADA -->
    
    <!-- üéâ Pantalla de bienvenida (primera vez) -->
    <div id="welcomeScreen" style="display: none;">
        <div class="welcome-content">
            <!-- üé® LOGO ANIMADO -->
            <div class="logo-animated">
                <img src="./images/ui/logo.png" alt="Mi Pececito" class="logo-bounce">
            </div>
            
            <h1>Mi Pececito</h1>
            <p>Tu mascota virtual</p>
            
            <!-- MENSAJE SIMPLE DEL HUEVITO -->
            <div class="welcome-info">
                <p class="egg-message">
                    Tu huevo nacer√° en <strong>5 minutos</strong><br>
                    Juega mientras esperas
                </p>
            </div>
            
            <!-- üåä BURBUJAS SUTILES (MENOS ICONOS) -->
            <div class="welcome-bubbles">
                <div class="bubble bubble-1">ü´ß</div>
                <div class="bubble bubble-2">ü´ß</div>
                <div class="bubble bubble-3">ü´ß</div>
            </div>
            
            <button id="startGameBtn" class="start-button">Empezar</button>
            
            <!-- Bot√≥n de reset eliminado - Solo aparece en men√∫ si ya tienes pez -->
        </div>
    </div>
    
    <!-- üéì Pantalla de tutorial -->
    <div id="tutorialScreen" style="display: none;">
        <div class="tutorial-content">
            <h2>ü•ö Tu Primer Huevo</h2>
            <p>Toca la pantalla para colocar tu huevo en el acuario</p>
            <div class="tutorial-hint">üí° El huevo tardar√° 24 horas en eclosionar</div>
        </div>
    </div>

    <!-- üéÆ MODAL DE JUEGOS MODERNO -->
    <div id="gamesModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content games-modal-content">
            <div class="mobile-modal-header">
                <h2>üéÆ Juegos</h2>
                <div class="header-buttons">
                    <button id="helpGames" class="mobile-help-btn" title="¬øC√≥mo ganar estrellas?">?</button>
                    <button id="closeGames" class="mobile-close-btn">√ó</button>
                </div>
            </div>
            
            <!-- üèÜ ESTRELLAS TOTALES DEL USUARIO -->
            <div class="games-info">
                <div class="user-stars-display">
                    <div class="stars-total">
                        <span class="stars-icon">‚≠ê</span>
                        <span class="stars-label">Tus estrellas:</span>
                        <span class="stars-count" id="modal-stars-count">0</span>
                    </div>
                </div>
            </div>
            
            <!-- üéØ GRID DE JUEGOS -->
            <div class="games-grid">
                <div class="game-card available" data-game="bubbles">
                    <div class="game-icon">ü´ß</div>
                    <div class="game-title">Atrapa Burbujas</div>
                    <div class="game-description">Revienta las burbujas buenas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bubbles-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="bubbles-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="bloques">
                    <div class="game-icon">üíé</div>
                    <div class="game-title">Conecta 3</div>
                    <div class="game-description">Conecta 3 gemas marinas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bloques-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="bloques-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="memoria">
                    <div class="game-icon">üß†</div>
                    <div class="game-title">PezFlip</div>
                    <div class="game-description">Encuentra las parejas</div>
                    <div class="game-stats">
                        <span class="best-score">Partidas: <span id="memoria-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="memoria-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="simon">
                    <div class="game-icon">üéµ</div>
                    <div class="game-title">Sim√≥n Marino</div>
                    <div class="game-description">Repite la secuencia</div>
                    <div class="game-stats">
                        <span class="best-score">R√©cord: <span id="simon-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="simon-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="carril">
                    <div class="game-icon">üê¨</div>
                    <div class="game-title">Carril del Delf√≠n</div>
                    <div class="game-description">Runner de 3 carriles</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="carril-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="carril-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="correr">
                    <div class="game-icon">üêâ</div>
                    <div class="game-title">Drag√≥n Marino</div>
                    <div class="game-description">Corre y salta obst√°culos</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="correr-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="correr-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="caza">
                    <div class="game-icon">üéØ</div>
                    <div class="game-title">Caza de Peces</div>
                    <div class="game-description">Toca el objetivo</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="caza-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="caza-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="secuencia">
                    <div class="game-icon">üåä</div>
                    <div class="game-title">Secuencia de Mareas</div>
                    <div class="game-description">Memoriza y repite</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="secuencia-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="secuencia-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="toca3">
                    <div class="game-icon">üèñÔ∏è</div>
                    <div class="game-title">Toca-3 Marino</div>
                    <div class="game-description">Pez en la arena</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="toca3-best">0</span></span>
                        <span class="level-reached">üèÜ Nivel: <span id="toca3-level">1</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ‚ùì MODAL DE AYUDA - ESTRELLAS -->
    <div id="helpModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content help-modal-content">
            <div class="mobile-modal-header">
                <h2>‚ùì ¬øC√≥mo ganar estrellas?</h2>
                <button id="closeHelp" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="help-content">
                <div class="help-section">
                    <h3>‚≠ê Sistema de Estrellas</h3>
                    <p>Las estrellas son la moneda principal para desbloquear nuevos juegos y contenido.</p>
                </div>
                
                <div class="help-section">
                    <h3>üéÆ C√≥mo ganar estrellas:</h3>
                    <div class="star-rules">
                        <div class="star-rule-help">
                            <span class="star-icon">‚≠ê</span>
                            <div class="rule-text">
                                <strong>1 estrella</strong><br>
                                Por jugar cualquier juego (ganes o pierdas)
                            </div>
                        </div>
                        <div class="star-rule-help">
                            <span class="star-icon">‚≠ê‚≠ê</span>
                            <div class="rule-text">
                                <strong>2 estrellas</strong><br>
                                Si superas tu r√©cord personal
                            </div>
                        </div>
                        <div class="star-rule-help">
                            <span class="star-icon">‚≠ê‚≠ê‚≠ê</span>
                            <div class="rule-text">
                                <strong>3 estrellas</strong><br>
                                Si superas el r√©cord global
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h3>üîì Desbloqueo de juegos:</h3>
                    <p>Algunos juegos requieren un n√∫mero m√≠nimo de estrellas para desbloquearse. ¬°Juega m√°s para acceder a todo el contenido!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- üéí MODAL DE INVENTARIO SIMPLE -->
    <div id="inventoryModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üéí Inventario</h2>
                <button id="closeInventory" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="mobile-modal-body">
                <div class="inventory-grid-simple">
                    <!-- Los fondos se cargar√°n din√°micamente -->
                </div>
            </div>
        </div>
    </div>


    <!-- üì∏ MODAL DE √ÅLBUM -->
    <div id="albumModal" style="display: none;">
        <div class="modal-content album-modal">
            <div class="modal-header">
                <h2>üì∏ √Ålbum de Mi Pececito</h2>
                <div class="album-header-buttons">
                    <button id="shareFromAlbum" class="album-action-btn" title="Compartir mi pez">üì±</button>
                    <button id="closeAlbum" class="close-btn">‚ùå</button>
                </div>
            </div>
            
            <div class="album-content">
                <div class="album-stats">
                    <div class="stat-item">üìÖ D√≠as juntos: <span id="albumDays">0</span></div>
                    <div class="stat-item">üì∏ Recuerdos: <span id="albumEvents">0</span></div>
                    <div class="stat-item">üéâ Hitos: <span id="albumMilestones">0</span></div>
                </div>
                
                <div class="album-timeline" id="albumTimeline">
                    <!-- Se llenar√° din√°micamente -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- üö® Pantalla de error -->
    <div id="errorScreen">
        <div class="error-icon">üò¢</div>
        <div class="error-title">¬°Oops! Algo sali√≥ mal</div>
        <div class="error-message">No se pudo cargar el juego. Verifica tu conexi√≥n.</div>
        <button class="retry-button" onclick="location.reload()">Reintentar</button>
    </div>
    
    <!-- üîß Barra de Debug (solo desarrollo) -->
    <div id="debugBar">
        <div id="debugInfo">
            --fps
        </div>
        <button class="debug-btn danger" id="debugResetBtn" title="Reset juego">üîÑ</button>
        <button class="debug-btn primary" id="forceHatchBtn" title="Forzar eclosi√≥n">üê£</button>
        <button class="debug-btn success" id="evolveToYoungBtn" title="Evolucionar a Joven">üå±</button>
        <button class="debug-btn info" id="evolveToAdultBtn" title="Evolucionar a Adulto">üëë</button>
        <button class="debug-btn warning" id="moveFishLeftBtn" title="Mover pez a la izquierda">‚¨ÖÔ∏è</button>
        <button class="debug-btn warning" id="moveFishRightBtn" title="Mover pez a la derecha">‚û°Ô∏è</button>
        <button class="debug-btn info" id="advanceTimeBtn" title="Avanzar tiempo 1 hora">‚è∞</button>
    </div>
    
    <!-- üé® Librer√≠a Lottie -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- üöÄ Script principal -->
    <!-- ü•ö MODAL ELIMINADA - YA NO SE NECESITA -->

    <script>
        // VERSI√ìN CON LOTTIE REAL
        // import { createGame } from './src/core/Game.js';
        
        // üéÆ Variables globales
        let game = null;
        let audioManager = null;
        
        // üöÄ Inicializar juego
        async function initializeGame() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const errorScreen = document.getElementById('errorScreen');
            
            try {
                console.log('üéÆ Iniciando Mi Pececito...');
                console.log('üîß Creando CompleteGame...');
                
                // Crear juego completo
                game = new CompleteGame();
                window.game = game; // Asignar inmediatamente para que est√© disponible
                console.log('‚úÖ CompleteGame creado correctamente');
                
                // Crear AudioManager
                console.log('üéµ Iniciando AudioManager...');
                audioManager = new AudioManager();
                window.audioManager = audioManager; // Hacer disponible globalmente
                console.log('‚úÖ AudioManager creado correctamente');
                
                // üìä FORZAR ACTUALIZACI√ìN DE BARRAS DE NECESIDADES
                setTimeout(() => {
                    if (game && game.updateNeedBars) {
                        game.updateNeedBars();
                        console.log('üìä Barras de necesidades actualizadas');
                    }
                }, 500);
                
                // Configurar eventos globales
                setupGlobalEvents();
                
                // Verificar si es primera vez (sin huevo colocado)
                const savedData = localStorage.getItem('miPececito_gameData');
                const hasPlayed = localStorage.getItem('miPececito_hasPlayed');
                const isFirstTime = !savedData || !hasPlayed;
                console.log('üîç DEBUG PRIMERA VEZ:');
                console.log('   savedData:', !!savedData);
                console.log('   hasPlayed:', hasPlayed);
                console.log('   isFirstTime:', isFirstTime);
                
                // IR DIRECTO (sin pantalla de carga)
                
                // L√ìGICA CORRECTA: Solo bienvenida si NO hay pez
                if (isFirstTime) {
                    // Primera vez: mostrar bienvenida
                    console.log('ü™ü Mostrando bienvenida (primera vez)...');
                    console.log('ü™ü welcomeScreen encontrado:', !!welcomeScreen);
                    if (welcomeScreen) {
                        welcomeScreen.style.display = 'flex';
                        welcomeScreen.style.visibility = 'visible';
                        welcomeScreen.style.opacity = '1';
                        welcomeScreen.style.zIndex = '9999';
                        console.log('ü™ü Modal forzada a visible');
                    }
                    setupWelcomeFlow();
                } else {
                    // Ya tiene pez: mostrar pantalla de carga personalizada
                    game.showLoadingWithFishName();
                    // A√±adir bot√≥n reset al men√∫
                    game.addResetButtonToMenu();
                }
                
                console.log('‚úÖ ¬°Juego listo!', isFirstTime ? '(Primera vez)' : '(Jugador veterano)');
                
                // üéÆ ACTUALIZAR UI DE JUEGOS
                updateGamesUI();
                
            } catch (error) {
                console.error('‚ùå Error inicializando juego:', error);
                
                // Mostrar pantalla de error
                errorScreen.style.display = 'flex';
            }
        }
        
        // üéÆ ACTUALIZAR UI DE JUEGOS
        function updateGamesUI() {
            // Obtener estrellas totales del juego principal
            let totalStars = 0;
            if (window.game && window.game.gameState) {
                totalStars = window.game.gameState.stars || 0;
            }
            
            // Fallback: cargar desde localStorage si no hay estrellas
            if (totalStars === 0) {
                const savedData = localStorage.getItem('miPececito_gameData');
                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        totalStars = parsed.stars || 0;
                        console.log(`üîç Fallback: Estrellas desde localStorage: ${totalStars}`);
                    } catch (e) {
                        console.log(`‚ùå Error parsing savedData: ${e}`);
                    }
                }
            }
            
            console.log(`üîç updateGamesUI: totalStars=${totalStars}, window.game=${!!window.game}`);
            
            // Actualizar juego de burbujas (solo nivel y mejor puntuaci√≥n)
            const bubblesBest = document.getElementById('bubbles-best');
            const bubblesLevel = document.getElementById('bubbles-level');
            
            if (bubblesBest) {
                bubblesBest.textContent = localStorage.getItem('bubbles_best') || '0';
            }
            if (bubblesLevel) {
                bubblesLevel.textContent = localStorage.getItem('bubbles_level') || '1';
            }
            
            // Actualizar otros juegos (solo sus estad√≠sticas espec√≠ficas)
            const otherGames = ['bloques', 'memoria', 'simon', 'carril', 'correr', 'caza', 'secuencia', 'toca3'];
            otherGames.forEach(gameName => {
                const bestEl = document.getElementById(`${gameName}-best`);
                if (bestEl) {
                    const bestScore = localStorage.getItem(`${gameName}_best`) || '0';
                    bestEl.textContent = bestScore;
                }
            });
        }
        
        // üéâ Configurar flujo de bienvenida
        function setupWelcomeFlow() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const tutorialScreen = document.getElementById('tutorialScreen');
            const startGameBtn = document.getElementById('startGameBtn');
            
            // Bot√≥n "Empezar Aventura"
            startGameBtn.addEventListener('click', () => {
                console.log('üöÄ Empezar aventura clickeado - OCULTANDO MODAL');
                welcomeScreen.style.display = 'none';
                
                // üéµ INICIAR M√öSICA DE FONDO INMEDIATAMENTE
                if (audioManager && !audioManager.isMuted) {
                    audioManager.startBackgroundMusic();
                    console.log('üéµ M√∫sica de fondo iniciada al empezar el juego');
                }
                
                // Marcar como jugado
                localStorage.setItem('miPececito_hasPlayed', 'true');
                
                // IR DIRECTO A COLOCAR HUEVO (sin modal intermedia)
                if (game && game.startEggPlacement) {
                    game.startEggPlacement();
                } else {
                    // Fallback si game no est√° listo
                    setTimeout(() => {
                        if (game && game.startEggPlacement) {
                            game.startEggPlacement();
                        }
                    }, 500);
                }
            });
            
            // ü•ö EVENT LISTENER ELIMINADO - YA NO SE NECESITA
            
            // Bot√≥n "Cuidar otro pececito" ELIMINADO - Solo aparece en men√∫ din√°micamente
            /*
            const resetGameBtn = document.getElementById('resetGameBtn');
            if (false) { // DESHABILITADO
                resetGameBtn.addEventListener('click', () => {
                    if (game) {
                        game.showCustomModal({
                            title: 'üåä Despedida de tu Pececito',
                            message: `üê†üí≠ "¬øDe verdad me vas a dejar libre?"\n\nüè† Volver√© al oc√©ano y ser√© feliz\nüíï Siempre recordar√© nuestros momentos\nüéÆ Podr√°s cuidar a un nuevo compa√±ero\n\n‚ö†Ô∏è Se perder√° todo el progreso actual`,
                            confirmText: 'üåä ¬°S√© libre y feliz!',
                            cancelText: 'üíï ¬°No, te quiero!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            },
                            onCancel: () => {
                                game.showCustomModal({
                                    title: 'üíï ¬°Qu√© alegr√≠a!',
                                    message: 'üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos jugando juntos! üéÆ',
                                    confirmText: 'ü•∞ ¬°Siempre!',
                                    onConfirm: () => {}
                                });
                            }
                        });
                    }
                });
            }
            */
        }
        
        // üéì Configurar handler del tutorial
        function setupTutorialHandler() {
            const tutorialScreen = document.getElementById('tutorialScreen');
            
            // Tutorial: Toque ANYWHERE para colocar huevo
            const tutorialHandler = (e) => {
                console.log('üëÜ Toque detectado en tutorial');
                
                // Cerrar tutorial inmediatamente
                tutorialScreen.style.display = 'none';
                
                // Colocar huevo en el centro (o donde toc√≥ si es en canvas)
                let x = window.innerWidth / 2;
                let y = window.innerHeight / 2;
                
                // Si toc√≥ en el canvas, usar esa posici√≥n
                if (e.target.id === 'gameCanvas') {
                    const rect = e.target.getBoundingClientRect();
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                if (game) {
                    game.placeFirstEgg(x, y);
                }
                
                // Remover listener del tutorial
                document.removeEventListener('click', tutorialHandler);
                
                console.log('ü•ö Primer huevo colocado - Tutorial cerrado');
            };
            
            // Escuchar toques en TODA la pantalla
            document.addEventListener('click', tutorialHandler);
        }
        
        // ‚öôÔ∏è Configurar eventos globales
        function setupGlobalEvents() {
            // Badge de turbo
            const turboBadge = document.getElementById('turboBadge');
            
            // Escuchar eventos del juego
            document.addEventListener('turboStart', () => {
                turboBadge.classList.add('active');
            });
            
            document.addEventListener('turboEnd', () => {
                turboBadge.classList.remove('active');
            });
            
            // Prevenir zoom en m√≥viles
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            
            // Debug info (solo en desarrollo)
            if (window.location.hostname === 'localhost') {
                setupDebugInfo();
            }
            
            // üîä BOT√ìN DE VOLUMEN
            const volumeBtn = document.getElementById('volumeBtn');
            if (volumeBtn && audioManager) {
                volumeBtn.addEventListener('click', () => {
                    audioManager.toggleMute();
                    console.log('üîä Bot√≥n de volumen clickeado');
                });
                
                // Inicializar estado del bot√≥n
                audioManager.updateVolumeButton();
                
                // üéµ M√öSICA SE INICIA AUTOM√ÅTICAMENTE AL HACER CLICK EN "¬°Cuidar mi huevo!"
                // (Ya no necesitamos listeners gen√©ricos)
            }
            
        // Event listeners de la cabecera
        setupHeaderEvents();
        }
        
        // üèÜ Configurar eventos de cabecera
        function setupHeaderEvents() {
            console.log('üîß Configurando eventos de cabecera...');
            
            // üè∑Ô∏è CLICK EN NOMBRE DEL PEZ PARA CAMBIARLO
            const fishNameElement = document.getElementById('fishName');
            if (fishNameElement) {
                fishNameElement.style.cursor = 'pointer';
                fishNameElement.title = 'Click para cambiar nombre';
                fishNameElement.addEventListener('click', () => {
                    if (game && game.gameState.stage !== 'egg' && game.gameState.stage !== 'waiting') {
                        game.showChangeNameModal();
                    }
                });
                console.log('üè∑Ô∏è Evento de cambio de nombre configurado');
            }
            
            // Verificar que el bot√≥n existe
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            
            console.log('üéÆ Bot√≥n de jugar encontrado:', !!playBtn);
            console.log('üéÆ Modal de juegos encontrada:', !!gamesModal);
            
            if (!playBtn) {
                console.error('‚ùå Bot√≥n playButton no encontrado!');
                return;
            }
            
            if (!gamesModal) {
                console.error('‚ùå Modal gamesModal no encontrada!');
                return;
            }
            
            // Bot√≥n de jugar
            playBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('üéÆ ¬°CLICK EN BOT√ìN JUGAR DETECTADO!');
                
                // Abrir modal directamente
                console.log('üéÆ Abriendo modal de juegos...');
                gamesModal.style.display = 'flex';
                
                // Forzar la animaci√≥n
                requestAnimationFrame(() => {
                    gamesModal.style.opacity = '1';
                });
                
                console.log('üéÆ Modal abierta, display:', gamesModal.style.display);
            });
            
            // Bot√≥n de inventario
            document.getElementById('inventoryButton').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de items
                if (window.game) {
                    window.game.updateInventoryAvailability?.();
                }
            });
            
            // Bot√≥n de crear usuario
            document.getElementById('createUserButton').addEventListener('click', () => {
                const modal = document.getElementById('createUserModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                console.log('üë§ Modal de crear usuario abierta');
            });
            
            
            // Cerrar inventario con animaci√≥n
            document.getElementById('closeInventory').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar modal de crear usuario
            document.getElementById('closeCreateUser').addEventListener('click', () => {
                const modal = document.getElementById('createUserModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Formulario de crear usuario
            document.getElementById('createUserForm').addEventListener('submit', (e) => {
                e.preventDefault();
                
                const fullName = document.getElementById('userFullName').value;
                const nickname = document.getElementById('userNickname').value;
                const email = document.getElementById('userEmail').value;
                const password = document.getElementById('userPassword').value;
                
                console.log('üë§ Datos del usuario:', { fullName, nickname, email, password: '***' });
                
                // Aqu√≠ ir√≠a la l√≥gica para crear el usuario
                // Por ahora solo mostramos un mensaje de √©xito
                alert('üê† ¬°Usuario creado exitosamente!\n\n' +
                      `Nombre: ${fullName}\n` +
                      `Usuario: ${nickname}\n` +
                      `Email: ${email}\n\n` +
                      '¬°Tu pececito est√° seguro!');
                
                // Cerrar modal
                const modal = document.getElementById('createUserModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar juegos con animaci√≥n
            document.getElementById('closeGames').addEventListener('click', () => {
                const modal = document.getElementById('gamesModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Bot√≥n de ayuda
            document.getElementById('helpGames').addEventListener('click', () => {
                const helpModal = document.getElementById('helpModal');
                helpModal.style.display = 'flex';
                setTimeout(() => helpModal.style.opacity = '1', 10);
            });
            
            // Cerrar ayuda
            document.getElementById('closeHelp').addEventListener('click', () => {
                const helpModal = document.getElementById('helpModal');
                helpModal.style.opacity = '0';
                setTimeout(() => helpModal.style.display = 'none', 300);
            });
            
            // Event listeners para las tarjetas de juegos cuadradas
            document.querySelectorAll('.game-card-square').forEach(card => {
                card.addEventListener('click', () => {
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('gamesModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            window.game.startGame(gameId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showGameLocked(starsNeeded);
                    }
                });
            });
            
            // Event listeners para las tarjetas de inventario cuadradas
            document.querySelectorAll('.inventory-item-square').forEach(card => {
                card.addEventListener('click', () => {
                    const itemId = card.dataset.item;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéí Usando item: ${itemId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('inventoryModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            // Aqu√≠ puedes a√±adir la l√≥gica para usar el item
                            window.game.useInventoryItem?.(itemId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Item bloqueado: ${itemId}`);
                        // Mostrar mensaje de item bloqueado
                        const bubblesNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showItemLocked?.(bubblesNeeded);
                    }
                });
            });
            

            // Bot√≥n de reset (calavera)
            document.getElementById('resetButton').addEventListener('click', () => {
                if (game) {
                    game.showResetModal();
                }
            });
            
            // üçé BOT√ìN DE ALIMENTACI√ìN (UNA BOLITA COMO EN ORIGINAL)
            document.getElementById('feedBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('‚ùå Bot√≥n de comida DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish) {
                    game.dropFood(); // UNA SOLA BOLITA
                    console.log('üçé Una bolita peque√±a soltada');
                }
            });
            
            // üßπ BOT√ìN DE LIMPIEZA
            document.getElementById('cleanBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('‚ùå Bot√≥n de limpieza DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish) {
                    game.startCleaning();
                    console.log('üßπ Limpiando la pecera...');
                }
            });
            
            // üíä BOT√ìN DE MEDICINA
            // üíä BOT√ìN DE MEDICINA - ELIMINADO (YA NO SE USA)
            
            // Bot√≥n de reset se a√±ade din√°micamente
            
            // Cerrar √°lbum
            document.getElementById('closeAlbum').addEventListener('click', () => {
                document.getElementById('albumModal').style.display = 'none';
            });
            
            // Compartir desde √°lbum
            document.getElementById('shareFromAlbum').addEventListener('click', () => {
                if (window.game) {
                    window.game.shareMyFish();
                } else {
                    console.warn('üö® Game no disponible para compartir');
                }
                console.log('üì± Compartir desde √°lbum clickeado');
            });
            
            // üéÆ MODAL DE JUEGOS
            document.getElementById('playButton').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'flex';
                console.log('üéÆ Modal de juegos abierta');
            });
            
            document.getElementById('closeGames').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'none';
                console.log('üéÆ Modal de juegos cerrada');
            });
            
            // ü´ß JUEGO DE BURBUJAS
            document.querySelector('[data-game="bubbles"]').addEventListener('click', () => {
                startBubbleGame();
            });
            
            // üíé JUEGO DE BLOQUES (MAR MATCH-3)
            document.querySelector('[data-game="bloques"]').addEventListener('click', () => {
                startBloquesGame();
            });
            
            // üß† JUEGO DE MEMORIA
            document.querySelector('[data-game="memoria"]').addEventListener('click', () => {
                startMemoriaGame();
            });
            
            // üéµ JUEGO DE SIM√ìN MARINO
            document.querySelector('[data-game="simon"]').addEventListener('click', () => {
                startSimonGame();
            });
            
            // üê¨ JUEGO DEL CARRIL DEL DELF√çN
            document.querySelector('[data-game="carril"]').addEventListener('click', () => {
                startCarrilGame();
            });
            
            // üêâ JUEGO DEL DRAG√ìN MARINO
            document.querySelector('[data-game="correr"]').addEventListener('click', () => {
                startCorrerGame();
            });
            
            // üéØ JUEGO DE CAZA DE PECES
            document.querySelector('[data-game="caza"]').addEventListener('click', () => {
                startCazaGame();
            });
            
            // üåä JUEGO DE SECUENCIA DE MAREAS
            document.querySelector('[data-game="secuencia"]').addEventListener('click', () => {
                startSecuenciaGame();
            });
            
            // üèñÔ∏è JUEGO DE TOCA-3 MARINO
            document.querySelector('[data-game="toca3"]').addEventListener('click', () => {
                startToca3Game();
            });
            
            // üîó CONECTORES ADICIONALES PARA NOMBRES ALTERNATIVOS
            const alternativeConnectors = [
                { selector: '[data-game="memory"]', handler: startMemoriaGame },
                { selector: '[data-game="snake"]', handler: startCarrilGame }, // Snake -> Carril
                { selector: '[data-game="puzzle"]', handler: startBloquesGame }, // Puzzle -> Bloques
                { selector: '[data-game="race"]', handler: startCorrerGame }, // Race -> Correr
                { selector: '[data-game="target"]', handler: startCazaGame }, // Target -> Caza
                { selector: '[data-game="adventure"]', handler: startSecuenciaGame }, // Adventure -> Secuencia
                { selector: '[data-game="tower"]', handler: startToca3Game }, // Tower -> Toca3
                { selector: '[data-game="boss"]', handler: startSimonGame } // Boss -> Simon
            ];
            
            alternativeConnectors.forEach(({selector, handler}) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.addEventListener('click', handler);
                    console.log(`üîó Conector alternativo a√±adido: ${selector}`);
                }
            });
            
            // Tabs del inventario y juegos (sistema unificado)
            document.querySelectorAll('.game-tab-btn, .tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    const modalContainer = btn.closest('.game-modal-content') || btn.closest('.modal-content');
                    
                    if (modalContainer) {
                        // Cambiar tab activo en el modal espec√≠fico
                        modalContainer.querySelectorAll('.game-tab-btn, .tab-btn').forEach(b => b.classList.remove('active'));
                        modalContainer.querySelectorAll('.game-tab-content, .tab-content').forEach(c => c.classList.remove('active'));
                    
                    btn.classList.add('active');
                        const targetTab = document.getElementById(tab + '-tab');
                        if (targetTab) {
                            targetTab.classList.add('active');
                        }
                    }
                });
            });
            
            // Botones de jugar en las modales mejoradas
            document.querySelectorAll('.game-play-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const gameId = btn.dataset.game;
                    if (gameId && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        window.game.startGame(gameId);
                    }
                });
            });
        }
        
        // üîß Configurar barra de debug
        function setupDebugInfo() {
            const debugBar = document.getElementById('debugBar');
            const debugInfo = document.getElementById('debugInfo');
            debugBar.style.display = 'flex';
            
            // Actualizar info cada segundo
            setInterval(() => {
                if (game) {
                    const info = game.getGameInfo();
                    const elapsed = info.eggTime || 0;
                    const hours = Math.floor(elapsed / (1000 * 60 * 60));
                    const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
                    
                    // Debug expandido con necesidades y edad
                    const hungerHours = Math.floor((Date.now() - game.gameState.lastFeed) / (1000 * 60 * 60));
                    const playHours = Math.floor((Date.now() - game.gameState.lastPlay) / (1000 * 60 * 60));
                    const cleanHours = Math.floor((Date.now() - game.gameState.lastClean) / (1000 * 60 * 60));
                    
                    debugInfo.innerHTML = `${Math.round(1 / (game.deltaTime || 0.016))}fps`;
                }
            }, 1000);
            
            // BOTONES DE DEBUG
            document.getElementById('debugResetBtn').addEventListener('click', () => {
                if (confirm('üîÑ ¬øResetear todo el juego?')) {
                    console.log('üîÑ Reseteando juego completo...');
                    
                    // Limpiar TODO el localStorage AGRESIVAMENTE
                    console.log('üßπ LIMPIEZA TOTAL del localStorage...');
                    localStorage.removeItem('miPececito_gameState');
                    localStorage.removeItem('miPececito_gameData');
                    localStorage.removeItem('miPececito_hasPlayed');
                    localStorage.removeItem('bubbleGame_personalRecord');
                    localStorage.removeItem('bubbleGame_globalRecord');
                    localStorage.clear(); // Por si hay m√°s
                    console.log('‚úÖ localStorage completamente limpio');
                    
                    // Recargar p√°gina para volver al inicio
                    setTimeout(() => {
                        location.reload();
                    }, 100);
                }
            });
            
            document.getElementById('forceHatchBtn').addEventListener('click', () => {
                if (game) {
                    game.setEggTimeToFinalSeconds(); // Ir a los √∫ltimos 5 segundos
                    console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
                }
            });
            
            // üå± BOT√ìN EVOLUCIONAR A JOVEN
            document.getElementById('evolveToYoungBtn').addEventListener('click', () => {
                if (game && game.gameState.stage === 'baby') {
                    console.log('üå± DEBUG: Forzando evoluci√≥n a joven...');
                    game.startEvolution('young');
                } else {
                    console.log('‚ùå Solo se puede evolucionar desde beb√© a joven');
                }
            });
            
            // üëë BOT√ìN EVOLUCIONAR A ADULTO  
            document.getElementById('evolveToAdultBtn').addEventListener('click', () => {
                if (game && game.gameState.stage === 'young') {
                    console.log('üëë DEBUG: Forzando evoluci√≥n a adulto...');
                    game.startEvolution('adult');
                } else {
                    console.log('‚ùå Solo se puede evolucionar desde joven a adulto');
                }
            });
            
            // ‚¨ÖÔ∏è BOT√ìN MOVER PEZ A LA IZQUIERDA
            document.getElementById('moveFishLeftBtn').addEventListener('click', () => {
                if (game && game.fish) {
                    const padLeft = 60;
                    game.fish.x = padLeft;
                    game.fish.vx = 0;
                    console.log(`‚¨ÖÔ∏è DEBUG: Pez movido a la izquierda (x: ${padLeft})`);
                } else {
                    console.log('‚ùå No hay pez para mover');
                }
            });
            
            // ‚û°Ô∏è BOT√ìN MOVER PEZ A LA DERECHA
            document.getElementById('moveFishRightBtn').addEventListener('click', () => {
                if (game && game.fish) {
                    const padRight = 30;
                    const W = game.canvas.width;
                    game.fish.x = W - padRight;
                    game.fish.vx = 0;
                    console.log(`‚û°Ô∏è DEBUG: Pez movido a la derecha (x: ${W - padRight})`);
                } else {
                    console.log('‚ùå No hay pez para mover');
                }
            });
            
            // ‚è∞ BOT√ìN AVANZAR TIEMPO
            document.getElementById('advanceTimeBtn').addEventListener('click', () => {
                if (game) {
                    game.advanceTime(1);
                    console.log('‚è∞ DEBUG: Tiempo avanzado 1 hora');
                } else {
                    console.log('‚ùå No hay juego para avanzar tiempo');
                }
            });
            
            
            
            
            
            
            
        }
        
        // üéØ Manejar errores globales
        window.addEventListener('error', (e) => {
            console.error('‚ùå Error global:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('‚ùå Promesa rechazada:', e.reason);
        });
        
        // üöÄ Iniciar cuando la p√°gina est√© lista
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // üéÆ SISTEMA COMPLETO DE JUEGO
        class CompleteGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // ü´ß CAPA OFFSCREEN PARA BURBUJAS (FIX DPR)
                this.bubLayer = null;
                this.bubCtx = null;
                
                this.setupCanvas();
                this.ensureBubLayer(); // INICIALIZAR CAPA OFFSCREEN
                
                // Estado del juego
                this.gameState = {
                    stage: 'waiting', // NUEVO: Esperando a colocar huevo
                    eggStartTime: null, // NO hay tiempo hasta colocar huevo
                    bubbles: 0,   // EMPEZAR SIN BURBUJAS
                    stars: 0,     // Sin estrellas al inicio
                    currentBackground: 'Mi casa',
                    bubblesCreated: false,
                    
                    // üìä SISTEMA DE NECESIDADES REALISTA (0-100)
                    needs: {
                        hunger: 80,  // Beb√© nace con hambre (normal)
                        dirt: 0,     // PANTALLA LIMPIA AL INICIAR 
                        fun: 95      // EMPIEZA FELIZ
                    },
                    
                    // üö® FLAGS DE CRISIS (75+ es crisis)
                    crisis: {
                        hunger: false,
                        dirt: false, 
                        bored: false
                    },
                    
                    // Sistema de edad
                    birthDate: null,
                    ageInDays: 0,
                    // Nombre del pez
                    fishName: null,
                    hasAskedForName: false,
                    // Sistema de √°lbum/diario
                    album: [],
                    lastEventTime: Date.now()
                };
                
                // üö´ VARIABLES DE CONTROL ELIMINADAS - YA NO SE NECESITAN
                
                // Sistema de huevo
                this.egg = {
                    x: 0, y: 0,
                    floatTime: 0,
                    bobSpeed: 2,
                    bobAmount: 8
                };
                
                // Im√°genes del huevo
                this.eggImages = {};
                this.bgImage = null;
                this.loadAssets();
                
                // Efectos
                this.bgBubbles = [];
                this.explosionBubbles = [];
                this.lightRays = [];
                this.explosionHappened = false;
                
                // üçé ARRAYS DEL SISTEMA REALISTA
                this.food = [];           // Comida que cae
                this.cleanBubbles = [];   // Burbujas de limpieza  
                this.tinyBubbles = [];    // Burbujas de respiraci√≥n
                this.flyers = [];         // Corazones voladores
                this.floatingMessages = []; // Mensajes sutiles del pez
                this.ripples = [];        // Ondas de click
                this.labels = [];         // Textos flotantes
                
                // üßπ ESTADO DE LIMPIEZA
                this.cleaningActive = false;
                this.cleanEmitT = 0;
                this.cleanDur = 2.6;
                this.dirtStart = 0;
                
                // ‚è∞ TIEMPO DEL JUEGO (para animaciones)
                this.gameTime = 0;
                
                // Burbujas de necesidades
                this.needBubbles = [];
                
                // Pez
                this.fish = null;
                this.lottieAnimation = null;
                
                this.setupBubbles();
                
                // NUNCA cargar datos en primera vez
                const isFirstTime = !localStorage.getItem('miPececito_hasPlayed');
                if (isFirstTime) {
                    console.log('üéâ Primera vez - Empezar completamente limpio');
                    // NO cargar nada, mantener estado inicial 'waiting'
                } else {
                    // Solo cargar si es veterano
                    if (!this.loadGame()) {
                        console.log('üÜï Veterano sin datos - empezar nuevo');
                    }
                }
                
                // Cargar fondos disponibles
                this.availableBackgrounds = [];
                this.loadAvailableBackgrounds();
                
                this.startLoop();
                this.startAutoSave();
                this.updateUI();
            }
            
            setupCanvas() {
                const resize = () => {
                    // VERSI√ìN SIMPLE QUE FUNCIONABA
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 130; // 70px header + 60px botones
                    
                    // CANVAS SIEMPRE DESDE EL HEADER (SIN ESPACIO AZUL)
                    this.canvas.style.top = '70px'; // SIEMPRE PEGADO AL HEADER
                    this.canvas.style.position = 'fixed';
                    this.canvas.style.left = '0';
                    this.canvas.style.right = '0';
                    this.canvas.style.bottom = '60px'; // Espacio para botones compactos
                    
                    // üß± CALCULAR Y GUARDAR L√çMITES DIN√ÅMICOS (con delay para asegurar que el canvas est√© listo)
                    setTimeout(() => {
                        this.calculateAndSaveBoundaries();
                    }, 100);
                };
                window.addEventListener('resize', resize);
                resize();
                
                // A√ëADIR EVENT LISTENER PARA CLICK EN CANVAS
                this.canvas.addEventListener('click', (event) => {
                    this.handleCanvasClick(event);
                });
                
                console.log('üëÜ Click en canvas habilitado - El pez vendr√° a tu dedo');
            }
            
            // üß± CALCULAR Y GUARDAR L√çMITES DIN√ÅMICOS DEL PEZ
            calculateAndSaveBoundaries() {
                console.log('üß± Calculando l√≠mites din√°micos del pez...');
                
                // Verificar que el canvas est√© disponible
                if (!this.canvas) {
                    console.warn('‚ö†Ô∏è Canvas no disponible, usando l√≠mites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Obtener dimensiones reales del canvas
                const canvasRect = this.canvas.getBoundingClientRect();
                const actualWidth = canvasRect.width || this.canvas.width || window.innerWidth;
                const actualHeight = canvasRect.height || this.canvas.height || window.innerHeight - 130;
                
                console.log('üß± Debug c√°lculo l√≠mites:');
                console.log(`  - canvasRect: ${canvasRect.width}x${canvasRect.height}`);
                console.log(`  - canvas.width/height: ${this.canvas.width}x${this.canvas.height}`);
                console.log(`  - window.inner: ${window.innerWidth}x${window.innerHeight}`);
                console.log(`  - actualWidth/Height: ${actualWidth}x${actualHeight}`);
                
                // Verificar dimensiones v√°lidas
                if (actualWidth <= 0 || actualHeight <= 0) {
                    console.warn('‚ö†Ô∏è Dimensiones de canvas inv√°lidas, usando l√≠mites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Calcular l√≠mites con m√°rgenes seguros
                const fishSize = 60; // Tama√±o aproximado del pez
                const safeMargin = 30; // Margen de seguridad
                
                // Calcular bottom de forma segura
                let bottomY;
                try {
                    bottomY = this.getFloorY ? this.getFloorY() : actualHeight - 60;
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error al calcular getFloorY, usando valor por defecto');
                    bottomY = actualHeight - 60;
                }
                
                // CORREGIR C√ÅLCULO DE L√çMITES - Asegurar que el pez est√© completamente visible
                const boundaries = {
                    left: fishSize / 2, // Mitad del pez desde el borde izquierdo
                    right: actualWidth - fishSize / 2, // Mitad del pez desde el borde derecho
                    top: 125, // Debajo del header
                    bottom: bottomY - 10, // Casi hasta el fondo para alcanzar la comida
                    width: actualWidth,
                    height: actualHeight,
                    timestamp: Date.now()
                };
                
                console.log('üß± L√≠mites calculados:');
                console.log(`  - left: ${boundaries.left}`);
                console.log(`  - right: ${boundaries.right} (ancho: ${actualWidth})`);
                console.log(`  - top: ${boundaries.top}`);
                console.log(`  - bottom: ${boundaries.bottom} (alto: ${actualHeight})`);
                
                // Verificar que los l√≠mites sean v√°lidos
                if (boundaries.right <= boundaries.left || boundaries.bottom <= boundaries.top) {
                    console.warn('‚ö†Ô∏è L√≠mites inv√°lidos calculados, usando l√≠mites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Guardar en el estado del juego
                if (this.gameState) {
                    this.gameState.boundaries = boundaries;
                }
                
                // Guardar en localStorage para persistencia
                try {
                    localStorage.setItem('miPececito_boundaries', JSON.stringify(boundaries));
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error al guardar l√≠mites en localStorage:', e);
                }
                
                console.log('üß± L√≠mites calculados:', boundaries);
                console.log(`üì± Canvas: ${actualWidth}x${actualHeight}px`);
                console.log(`üêü √Årea de movimiento: ${boundaries.right - boundaries.left}x${boundaries.bottom - boundaries.top}px`);
                
                return boundaries;
            }
            
            // üß± L√çMITES POR DEFECTO COMO FALLBACK
            getDefaultBoundaries() {
                const fishSize = 60;
                const defaultBoundaries = {
                    left: fishSize / 2, // Mitad del pez desde el borde izquierdo
                    right: window.innerWidth - fishSize / 2, // Mitad del pez desde el borde derecho
                    top: 125,
                    bottom: window.innerHeight - 130 - 10, // Casi hasta el fondo
                    width: window.innerWidth,
                    height: window.innerHeight - 130,
                    timestamp: Date.now()
                };
                
                console.log('üß± Usando l√≠mites por defecto:', defaultBoundaries);
                return defaultBoundaries;
            }
            
            // üß± RECALCULAR L√çMITES MANUALMENTE (para debug)
            recalculateBoundaries() {
                console.log('üß± Recalculando l√≠mites manualmente...');
                localStorage.removeItem('miPececito_boundaries'); // Forzar rec√°lculo
                return this.calculateAndSaveBoundaries();
            }
            
            // üß± OBTENER L√çMITES GUARDADOS O CALCULAR NUEVOS
            getBoundaries() {
                // Intentar cargar l√≠mites guardados
                try {
                    const saved = localStorage.getItem('miPececito_boundaries');
                    if (saved) {
                        const boundaries = JSON.parse(saved);
                        const age = Date.now() - (boundaries.timestamp || 0);
                        
                        // Verificar que los l√≠mites sean v√°lidos
                        if (boundaries && 
                            typeof boundaries.left === 'number' && 
                            typeof boundaries.right === 'number' &&
                            typeof boundaries.top === 'number' &&
                            typeof boundaries.bottom === 'number' &&
                            boundaries.right > boundaries.left &&
                            boundaries.bottom > boundaries.top) {
                            
                            // Si los l√≠mites son recientes (menos de 5 minutos), usarlos
                            if (age < 5 * 60 * 1000) {
                                console.log('üß± Usando l√≠mites guardados (edad:', Math.round(age/1000), 's)');
                                return boundaries;
                            }
                        } else {
                            console.warn('‚ö†Ô∏è L√≠mites guardados inv√°lidos, recalculando...');
                        }
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error al cargar l√≠mites guardados:', e);
                }
                
                // Si no hay l√≠mites v√°lidos, calcular nuevos
                console.log('üß± Calculando nuevos l√≠mites...');
                return this.calculateAndSaveBoundaries();
            }
            
            async loadAssets() {
                console.log('üìÅ Cargando assets...');
                
                // Cargar im√°genes del huevo
                const eggStages = ['00', '01', '02', '03', '04'];
                for (const stage of eggStages) {
                    try {
                        const img = new Image();
                        img.src = `./images/fish/egg_${stage}_clean.png`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                        });
                        this.eggImages[stage] = img;
                        console.log(`‚úÖ Cargado: egg_${stage}_clean.png`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar egg_${stage}_clean.png`);
                    }
                }
                
                // Cargar fondo
                try {
                    this.bgImage = new Image();
                    this.bgImage.src = './images/backgrounds/Mi casa.png';
                    await new Promise((resolve, reject) => {
                        this.bgImage.onload = resolve;
                        this.bgImage.onerror = reject;
                    });
                    console.log('‚úÖ Fondo cargado: Mi casa.png');
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo cargar Mi casa.png');
                }
            }
            
            setupBubbles() {
                // Burbujas de fondo
                for (let i = 0; i < 15; i++) {
                    this.bgBubbles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        r: 1 + Math.random() * 4,
                        speed: 20 + Math.random() * 30,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            startLoop() {
                let lastTime = 0;
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
            
            update(deltaTime) {
                this.gameTime += deltaTime; // Actualizar tiempo del juego
                
                // Posici√≥n del huevo (centro de la pantalla)
                this.egg.x = this.canvas.width / 2;
                this.egg.y = this.canvas.height * 0.6;
                this.egg.floatTime += deltaTime;
                
                // Burbujas de fondo
                for (const bubble of this.bgBubbles) {
                    bubble.y -= bubble.speed * deltaTime;
                    if (bubble.y < 0) {
                        bubble.y = this.canvas.height + 10;
                        bubble.x = Math.random() * this.canvas.width;
                    }
                }
                
                // Actualizar burbujas de explosi√≥n
                for (let i = this.explosionBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.explosionBubbles[i];
                    bubble.x += bubble.vx * deltaTime;
                    bubble.y += bubble.vy * deltaTime;
                    bubble.life -= deltaTime;
                    
                    if (bubble.life <= 0) {
                        this.explosionBubbles.splice(i, 1);
                    }
                }
                
                // Actualizar rayos de luz
                for (let i = this.lightRays.length - 1; i >= 0; i--) {
                    const ray = this.lightRays[i];
                    ray.length = Math.min(ray.length + 200 * deltaTime, ray.maxLength);
                    ray.life -= deltaTime;
                    
                    if (ray.life <= 0) {
                        this.lightRays.splice(i, 1);
                    }
                }
                
                // L√≥gica de eclosi√≥n (solo si hay huevo colocado)
                if (this.gameState.stage === 'egg' && this.gameState.eggStartTime) {
                    const elapsed = Date.now() - this.gameState.eggStartTime;
                    const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                    
                    if (elapsed >= total) {
                        this.startHatching();
                    }
                }
                
                // Movimiento del pez (todas las etapas)
                if (this.fish && (this.gameState.stage === 'baby' || this.gameState.stage === 'young' || this.gameState.stage === 'adult')) {
                    // üöÄ SISTEMA REALISTA COMPLETO
                    this.updateAutoNeeds(deltaTime);      // Necesidades autom√°ticas
                    this.updateCrisisFlags();             // Flags de crisis
                    this.updateFood(deltaTime);           // üçé COMIDA DEL DOCUMENTO
                    this.updateCleaning(deltaTime);       // üßπ LIMPIEZA ESPECTACULAR
                    this.updateFishMovement(deltaTime);    // Movimiento realista
                    this.updateTinyBubbles(deltaTime);     // Burbujas de respiraci√≥n
                    this.updateFlyers(deltaTime);          // Corazones voladores
                    this.updateLabels(deltaTime);          // üçé LABELS ("√ëam")
                    this.updateEatingParticles(deltaTime); // ‚ú® PART√çCULAS DE COMIDA
                    this.updateRewardParticles(deltaTime); // üéÜ PART√çCULAS DE RECOMPENSA
                    this.updateFloatingMessages(deltaTime); // üí¨ MENSAJES FLOTANTES
                    
                    // Actualizar UI cada pocos segundos
                    if (Math.random() < 0.05) { // M√ÅS FRECUENTE PARA DEBUG (era 0.01)
                        this.updateUI();
                        this.checkForAlbumEvents(); // Verificar eventos del √°lbum
                        this.checkEvolution(); // Verificar evoluci√≥n
                    }
                }
                
                // Actualizar burbujas de necesidades (DESACTIVADO - ICONOS SOBRAN)
                // for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                //     const bubble = this.needBubbles[i];
                //     bubble.life -= deltaTime;
                //     bubble.y += Math.sin(bubble.life * 3) * 10 * deltaTime;
                //     
                //     if (bubble.life <= 0) {
                //         this.needBubbles.splice(i, 1);
                //     }
                // }
            }
            
        render() {
            // üéØ VOLVER AL SISTEMA SIMPLE QUE FUNCIONABA
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.globalCompositeOperation = 'source-over';
                
                // Fondo (coordenadas f√≠sicas normales)
                if (this.bgImage && this.bgImage.complete) {
                    this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo degradado como fallback
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#0b1b2b');
                    gradient.addColorStop(1, '#133754');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // ‚ú® EFECTOS M√ÅGICOS: MUCHAS BURBUJITAS QUE TAPAN EL HUEVO
                if (this.gameState.stage === 'egg' && this.gameState.showMagicBubbles) {
                    this.ctx.save();
                    
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const time = Date.now() * 0.001;
                    const effectTime = time - (this.gameState.magicStartTime || time);
                    
                    // FASE 1: MUCH√çSIMAS burbujitas peque√±as que TAPAN todo (primeros 2 segundos)
                    if (effectTime < 2) {
                        const density = Math.max(0, 1 - effectTime / 2); // Se reduce con el tiempo
                        const numBubbles = Math.floor(800 * density); // 800 ‚Üí 0 burbujas (EXPLOSI√ìN MASIVA)
                        
                        // CAPA 1: Burbujas grandes de fondo
                        for (let i = 0; i < Math.floor(numBubbles * 0.3); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 140;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 15 + Math.random() * 10; // Grandes (15-25px)
                            
                            this.ctx.globalAlpha = 0.3 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${180 + Math.random() * 60}, 70%, ${70 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 12;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 2: Burbujas medianas
                        for (let i = 0; i < Math.floor(numBubbles * 0.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 100;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 8 + Math.random() * 8; // Medianas (8-16px)
                            
                            this.ctx.globalAlpha = 0.5 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${190 + Math.random() * 40}, 80%, ${65 + Math.random() * 25}%)`;
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 3: Burbujitas peque√±as (las que m√°s tapan)
                        for (let i = 0; i < Math.floor(numBubbles * 0.7); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 3 + Math.random() * 6; // Peque√±itas (3-9px)
                            
                            this.ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${60 + Math.random() * 30}%)`;
                            
                            // Muchas con brillo
                            if (Math.random() > 0.5) {
                                this.ctx.shadowBlur = 4;
                                this.ctx.shadowColor = this.ctx.fillStyle;
                            } else {
                                this.ctx.shadowBlur = 0;
                            }
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 4: Micro-burbujas como las del agua (MUCH√çSIMAS)
                        for (let i = 0; i < Math.floor(numBubbles * 1.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance + (Math.random() - 0.5) * 30;
                            const y = centerY + Math.sin(angle) * distance + (Math.random() - 0.5) * 30;
                            const size = 0.5 + Math.random() * 2; // Micro-burbujas (0.5-2.5px)
                            
                            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${75 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 1;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 5: Espuma densa (como burbujas de jab√≥n)
                        for (let i = 0; i < Math.floor(numBubbles * 2); i++) {
                            const x = centerX + (Math.random() - 0.5) * 160;
                            const y = centerY + (Math.random() - 0.5) * 160;
                            const size = 0.3 + Math.random() * 1.5; // S√∫per micro (0.3-1.8px)
                            
                            this.ctx.globalAlpha = 0.4 + Math.random() * 0.3;
                            this.ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#f0f8ff';
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    // FASE 2: Burbujas decorativas flotantes (despu√©s de 1.5s)
                    if (effectTime > 1.5) {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + time * 0.3;
                            const distance = 100 + Math.sin(time * 2 + i) * 40;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance + Math.sin(time * 1.5 + i) * 25;
                            const size = 8 + Math.sin(time * 4 + i) * 4;
                            
                            this.ctx.globalAlpha = 0.5 + Math.sin(time * 3 + i) * 0.3;
                            this.ctx.fillStyle = i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#add8e6' : '#b0e0e6';
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // ü´ß BURBUJITAS SUTILES DEL AGUA (AMBIENTE)
                this.drawAmbientBubbles();
                
                // üçé DIBUJAR COMIDA ANTES DEL PEZ (COMO DICE CHAT)
                this.drawFood();
                
                // Burbujas de fondo (sistema original - REACTIVADO)
                this.drawBackgroundBubbles();
                
                // Haces de luz ocasionales durante el juego
                this.drawOccasionalLightRays();
                
                // Efecto de suciedad en toda la pecera
                this.drawDirtyEffect();
                
                // Huevo (solo si est√° en stage 'egg')
                if (this.gameState.stage === 'egg') {
                    this.drawEgg();
                    this.drawEggTimer(); // Timer bonito en pantalla
                } else if (this.gameState.stage === 'waiting') {
                    // ESPERANDO: No hacer nada, solo esperar click del usuario
                }
                
                // Burbujas de explosi√≥n
                this.drawExplosionBubbles();
                
                // Pez (solo si no es Lottie)
                if (this.fish && !this.fish.isLottie) {
                    this.drawFish();
                }
                
                // Actualizar posici√≥n del Lottie
                if (this.fish && this.fish.isLottie) {
                    this.updateLottiePosition();
                }
                
                // Part√≠culas de comida (DESACTIVADO - CONFLICTO)
                // this.drawFoodParticles();
                
                // Comida cayendo (DESACTIVADO - CONFLICTO)  
                // this.drawFallingFood();
                
                // Burbujas de limpieza
                this.drawCleaningBubbles();
                
                // Burbujas de necesidades (DESACTIVADAS)
                // this.drawNeedBubbles();
                
                // Efectos de comer (DESACTIVADOS)
                // this.drawEatingEffects();
                
                // Textos flotantes (DESACTIVADOS)
                // this.drawFloatingTexts();
                
                // Burbujas de necesidades (DESACTIVADAS)  
                // this.drawNeedBubbles();
                
                // üßπ DIBUJAR BURBUJAS SIMPLE (REVERTIR A VERSI√ìN QUE FUNCIONABA)
                this.drawCleanBubbles();
                
                // üíñ DIBUJAR CORAZONES VOLADORES
                this.drawFlyers();
                
                // ‚ú® DIBUJAR PART√çCULAS DE COMIDA
                this.drawEatingParticles();
                
                // üéÜ DIBUJAR PART√çCULAS DE RECOMPENSA
                this.drawRewardParticles();
                
                // üí¨ DIBUJAR MENSAJES FLOTANTES
                this.drawFloatingMessages();
                
                // üçé DIBUJAR LABELS ("√ëam") ENCIMA DE TODO
                this.drawLabels();
                
                // üçé COMIDA YA SE DIBUJA ANTES DEL PEZ (L√çNEA 3743)
            }
            
            // üñåÔ∏è M√âTODOS DE RENDERIZADO
            
            drawBackgroundBubbles() {
                // SISTEMA SIMPLE Y FUNCIONAL
                this.ctx.save();
                
                for (let i = this.bgBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bgBubbles[i];
                    
                    // ü´ß TODAS LAS BURBUJAS (TEST + NUEVAS + EFECTOS)
                    if (bubble.isTestBubble || bubble.type) {
                        // Actualizar posici√≥n
                        bubble.x += bubble.vx * 0.016; // deltaTime aproximado
                        bubble.y += bubble.vy * 0.016;
                        
                        // Actualizar vida (compatible con ambos sistemas)
                        if (bubble.maxLife) {
                            bubble.life += 0.016; // Incrementar para nuevas burbujas
                        } else {
                            bubble.life--; // Decrementar para burbujas viejas
                        }
                        
                        // Eliminar si se acab√≥ la vida (compatible con ambos sistemas)
                        const shouldRemove = bubble.maxLife ? 
                            (bubble.life >= bubble.maxLife) : // Nuevas: life >= maxLife
                            (bubble.life <= 0); // Viejas: life <= 0
                            
                        if (shouldRemove) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar burbuja
                        this.ctx.save();
                        
                        if (bubble.sparkle) {
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = bubble.color;
                        }
                        
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 0.8;
                        this.ctx.fillStyle = bubble.color;
                        this.ctx.beginPath();
                        this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                        continue;
                    }
                    
                    // üéÜ SISTEMA VIEJO (APARICI√ìN)
                    if (bubble.isAppearanceEffect) {
                        bubble.x += bubble.vx;
                        bubble.y += bubble.vy;
                        bubble.life -= 16.67; // ~60fps
                        
                        // Eliminar si se acab√≥ la vida (EXCEPTO inmortales)
                        if (bubble.life <= 0 && !bubble.immortal) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Calcular alpha basado en vida restante
                        const maxLife = bubble.maxLife || 3000; // Fallback
                        const lifeRatio = bubble.life / maxLife;
                        bubble.opacity = (bubble.alpha || 1) * lifeRatio;
                    }
                    
                    this.ctx.save();
                    
                    // üéÜ EFECTO DE BRILLO PARA PART√çCULAS M√ÅGICAS
                    if (bubble.sparkle) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = bubble.color || '#ffd700';
                        
                        // Brillo pulsante
                        const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                        this.ctx.globalAlpha = (bubble.alpha || bubble.opacity || 1) * pulse;
                    } else {
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 1;
                    }
                    
                    this.ctx.fillStyle = bubble.color || '#87ceeb';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size || bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // DEBUG: Log de burbujas rojas de aparici√≥n (DESACTIVADO)
                    // if (bubble.isAppearanceEffect && bubble.color === '#ff0000') {
                    //     console.log(`üî¥ DIBUJANDO burbuja roja en (${bubble.x.toFixed(0)}, ${bubble.y.toFixed(0)}) tama√±o ${bubble.r}`);
                    // }
                    this.ctx.restore();
                }
                
                this.ctx.restore(); // CERRAR SAVE INICIAL
            }
            
            drawEgg() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 horas
                const progress = Math.min(elapsed / total, 1);
                
                // üéÜ ANIMACI√ìN SUAVE: SOLO FADE (SIN ESCALA BRUSCA)
                if (this.egg.appearing) {
                    // Solo fade in gradual (sin escala)
                    if (this.egg.alpha < this.egg.targetAlpha) {
                        this.egg.alpha += this.egg.fadeSpeed * 0.016; // Suave y controlado
                    }
                    
                    // Terminar animaci√≥n cuando est√© opaco
                    if (this.egg.alpha >= this.egg.targetAlpha) {
                        this.egg.appearing = false;
                        this.egg.alpha = 1;
                        console.log('‚ú® Animaci√≥n suave completada');
                    }
                }
                
                // Obtener imagen correcta del huevo CON TRANSICI√ìN
                const currentImage = this.getCurrentEggImage(progress);
                
                // üé≠ DETECTAR CAMBIO DE HUEVO Y HACER TRANSICI√ìN
                if (!this.egg.lastImage) this.egg.lastImage = currentImage;
                if (currentImage !== this.egg.lastImage) {
                    console.log('ü•ö ¬°Huevo evolucionando! Transici√≥n suave...');
                    this.egg.lastImage = currentImage;
                    this.createEggTransitionEffect();
                }
                
                if (currentImage) {
                    // Animaci√≥n de flotaci√≥n
                    const floatOffset = Math.sin(this.egg.floatTime * this.egg.bobSpeed) * this.egg.bobAmount;
                    const drawY = this.egg.y + floatOffset;
                    
                    // TEMBLOR cuando se acerca la eclosi√≥n
                    let shakeX = 0;
                    let shakeY = 0;
                    
                    if (progress > 0.85) { // √öltimos 15% = 3.6 horas
                        const shakeIntensity = (progress - 0.85) / 0.15; // 0 a 1
                        const maxShake = 6;
                        
                        shakeX = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        shakeY = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        
                        // Temblor INTENSO en los √∫ltimos segundos
                        if (progress > 0.98) { // √öltimos 2%
                            shakeX *= 2.5;
                            shakeY *= 2.5;
                        }
                    }
                    
                    // Dibujar huevo M√ÅS GRANDE - USAR CSS VARIABLE
                    const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                    const eggWidth = eggSize; // Usar variable CSS
                    const eggHeight = eggSize; // Cuadrado perfecto
                    
                    this.ctx.save();
                    
                    // üéÜ APLICAR ANIMACI√ìN DE APARICI√ìN
                    const scale = this.egg.scale || 1;
                    const alpha = this.egg.alpha || 1;
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.translate(this.egg.x + shakeX, drawY + shakeY);
                    this.ctx.scale(scale, scale);
                    
                    this.ctx.drawImage(
                        currentImage,
                        -eggWidth/2,
                        -eggHeight/2,
                        eggWidth,
                        eggHeight
                    );
                    
                    // ü´ß BURBUJITAS SUTILES DE GESTACI√ìN
                    this.drawEggGestationBubbles();
                    
                    // üéÜ CHISPORROTEO ALREDEDOR (COMO HIRVIENDO)
                    this.drawEggSizzleEffect();
                    
                    this.ctx.restore();
                } else {
                    // Fallback: huevo dibujado M√ÅS GRANDE
                    this.ctx.fillStyle = '#8ad7ff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(this.egg.x, this.egg.y, 50, 60, 0, 0, Math.PI * 2); // M√°s grande
                    this.ctx.fill();
                }
            }
            
            getCurrentEggImage(progress) {
                // ü•ö CADA MINUTO CAMBIA DE HUEVO (5 huevos en 5 minutos)
                if (progress < 0.2) return this.eggImages['00']; // Minuto 0-1
                if (progress < 0.4) return this.eggImages['01']; // Minuto 1-2  
                if (progress < 0.6) return this.eggImages['02']; // Minuto 2-3
                if (progress < 0.8) return this.eggImages['03']; // Minuto 3-4
                return this.eggImages['04']; // Minuto 4-5 (eclosi√≥n)
            }
            
            // ‚ú® EFECTOS SUAVES PARA APARICI√ìN DEL HUEVO
            createSoftEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // üåà PART√çCULAS DE COLORES SUAVES (como nacimiento del pez pero diferentes)
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (20 + Math.random() * 30),
                        vy: Math.sin(angle) * (20 + Math.random() * 30),
                        r: 3 + Math.random() * 4,
                        life: 0,
                        maxLife: 3 + Math.random() * 2,
                        opacity: 0.7 + Math.random() * 0.3,
                        color: i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#b0e0e6' : '#e0f6ff', // Azules suaves
                        type: 'soft-magic'
                    });
                }
                
                console.log('‚ú® 50 part√≠culas suaves creadas para el huevo');
            }
            
            // üé≠ EFECTO DE TRANSICI√ìN CUANDO CAMBIA EL HUEVO
            createEggTransitionEffect() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                // üåü PART√çCULAS DORADAS DE EVOLUCI√ìN (diferentes a las azules)
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (10 + Math.random() * 15),
                        vy: Math.sin(angle) * (10 + Math.random() * 15) - 20, // Hacia arriba
                        r: 2 + Math.random() * 3,
                        life: 0,
                        maxLife: 1.5 + Math.random() * 1,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: i % 2 === 0 ? '#ffd700' : '#ffec8b', // Dorado suave
                        type: 'egg-evolution'
                    });
                }
                
                console.log('üåü Efecto de evoluci√≥n del huevo creado');
            }
            
            // üéÜ EXPLOSI√ìN DE BURBUJAS PARA APARICI√ìN DEL HUEVO (COMO NACIMIENTO)
            createEggExplosionBubbles() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('‚ú® Creando efecto de aparici√≥n del huevo (estilo nacimiento)');
                
                // LIMPIAR explosionBubbles para el huevo
                this.explosionBubbles.length = 0;
                
                // EXPLOSI√ìN DE BURBUJAS - VERSI√ìN HUEVO (colores diferentes)
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 80; // Velocidad variada
                    const size = 3 + Math.random() * 8; // Tama√±os variados
                    const life = 3 + Math.random() * 2; // Duraderas
                    
                    // Colores DORADOS y BLANCOS (diferentes al nacimiento)
                    const colors = ['#FFFFFF', '#FFF8DC', '#FFEBCD', '#F0E68C', '#FFD700', '#FFA500', '#FFEC8B'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: size,
                        life: life, // VIDA INICIAL
                        maxLife: life,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: color,
                        type: 'egg-birth'
                    });
                }
                
                console.log('üéÜ 100 burbujas doradas creadas para aparici√≥n del huevo');
            }
            
            // üéÜ EFECTO CHISPORROTEO ALREDEDOR DEL HUEVO (COMO HIRVIENDO)
            drawEggSizzleEffect() {
                const time = Date.now() * 0.003; // Tiempo r√°pido para chispas
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                const radius = eggSize * 0.6; // Alrededor del huevo
                
                // üéá 8 CHISPAS ROTANDO ALREDEDOR
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time; // Rotaci√≥n
                    const sparkRadius = radius + Math.sin(time * 3 + i) * 8; // Vibraci√≥n
                    const x = Math.cos(angle) * sparkRadius;
                    const y = Math.sin(angle) * sparkRadius;
                    
                    // Chispa con transparencia variable
                    const opacity = 0.3 + Math.sin(time * 4 + i * 0.5) * 0.3;
                    const size = 2 + Math.sin(time * 5 + i) * 1;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = i % 2 === 0 ? '#ffeb3b' : '#ff9800'; // Amarillo/naranja
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // üî• PART√çCULAS ASCENDENTES (como vapor)
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const startRadius = radius * 0.8;
                    const x = Math.cos(angle) * startRadius;
                    const y = Math.sin(angle) * startRadius;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -20 - Math.random() * 15, // Hacia arriba
                        r: 1 + Math.random() * 2,
                        life: 0,
                        maxLife: 1 + Math.random() * 0.5,
                        opacity: 0.4 + Math.random() * 0.3,
                        color: '#fff8e1', // Vapor blanquecino
                        type: 'egg-sizzle'
                    });
                }
            }
            
            drawEggTimer() {
                if (this.gameState.stage !== 'egg' || !this.gameState.eggStartTime) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 HORAS
                const remaining = Math.max(0, total - elapsed);
                
                // DEBUG: Verificar que el tiempo avanza
                if (Math.random() < 0.02) { // Log m√°s frecuente para debug
                    console.log(`‚è∞ Timer Debug:`);
                    console.log(`   Current: ${new Date(currentTime).toLocaleTimeString()}`);
                    console.log(`   EggStart: ${new Date(this.gameState.eggStartTime).toLocaleTimeString()}`);
                    console.log(`   Elapsed: ${(elapsed/1000/60).toFixed(1)}min`);
                    console.log(`   Remaining: ${(remaining/1000/60).toFixed(1)}min`);
                }
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                // Progreso para efectos del cron√≥metro
                const timerProgress = elapsed / total;
                
                // CRON√ìMETRO BONITO EN PANTALLA
                const centerX = this.canvas.width / 2;
                const timerY = 80; // M√°s arriba y visible
                
                this.ctx.save();
                
                // CRON√ìMETRO SUTIL SIN FONDO NEGRO
                this.ctx.textAlign = 'center';
                
                // Sombra sutil para el texto
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 8;
                this.ctx.shadowOffsetY = 2;
                
                // T√≠tulo m√°s sutil SIN EMOJI
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 16px system-ui'; // Reducido para m√≥vil
                this.ctx.fillText('Nacer√° en:', centerX, timerY - 20);
                
                // Countdown principal
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 20px system-ui'; // Reducido para m√≥vil
                
                let timeText;
                if (hours > 0) {
                    timeText = `${hours}h ${minutes}m ${seconds}s`; // SIEMPRE mostrar segundos
                } else if (minutes > 0) {
                    timeText = `${minutes}m ${seconds}s`;
                } else {
                    // √öltimos segundos - MUY dram√°tico
                    this.ctx.fillStyle = remaining < 10000 ? '#ff6b6b' : '#ffeb3b';
                    timeText = `${seconds}s`;
                }
                
                this.ctx.fillText(timeText, centerX, timerY);
                
                this.ctx.restore();
            }
            
            drawLightRays() {
                for (const ray of this.lightRays) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height * 0.6;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.opacity * (ray.life / ray.maxLife);
                    this.ctx.strokeStyle = '#ffdd44';
                    this.ctx.lineWidth = ray.width;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffdd44';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(ray.angle) * ray.length,
                        centerY + Math.sin(ray.angle) * ray.length
                    );
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            // ‚ú® HACES DE LUZ OCASIONALES
            drawOccasionalLightRays() {
                // Inicializar timer de rayos si no existe
                if (!this.lightRayTimer) this.lightRayTimer = 0;
                if (!this.occasionalRays) this.occasionalRays = [];
                
                this.lightRayTimer += 1/60; // Asumiendo 60fps
                
                // Crear rayos ocasionalmente (cada 20-40 segundos)
                if (this.lightRayTimer > 20 + Math.random() * 20) {
                    this.createOccasionalLightRay();
                    this.lightRayTimer = 0;
                }
                
                // Dibujar y actualizar rayos existentes
                for (let i = this.occasionalRays.length - 1; i >= 0; i--) {
                    const ray = this.occasionalRays[i];
                    
                    // Actualizar rayo
                    ray.life -= 1/60;
                    ray.alpha = Math.max(0, ray.life / ray.maxLife);
                    
                    // Eliminar si expir√≥
                    if (ray.life <= 0) {
                        this.occasionalRays.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar REFLEJO SUTIL como luz real del sol
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.alpha * 0.08; // S√öPER sutil
                    this.ctx.globalCompositeOperation = 'lighter';
                    
                    const gradient = this.ctx.createLinearGradient(ray.x1, ray.y1, ray.x2, ray.y2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(0.2, 'rgba(255, 255, 240, 0.3)'); // Amarillo muy suave
                    gradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.4)'); // Azul casi transparente
                    gradient.addColorStop(0.8, 'rgba(255, 255, 240, 0.2)'); // Amarillo suave otra vez
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = ray.width * 0.8; // M√°s finos
                    this.ctx.shadowBlur = 1;
                    this.ctx.shadowColor = 'rgba(255, 255, 240, 0.2)';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(ray.x1, ray.y1);
                    this.ctx.lineTo(ray.x2, ray.y2);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
            }
            
            createOccasionalLightRay() {
                // Crear 2-4 REFLEJOS DEL SOL desde arriba
                const numRays = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numRays; i++) {
                    // Rayos vienen desde arriba con √°ngulos naturales
                    const startX = Math.random() * this.canvas.width;
                    const startY = -50; // Empiezan fuera de la pantalla arriba
                    
                    // √Ångulo hacia abajo con ligera inclinaci√≥n
                    const angle = Math.PI/2 + (Math.random() - 0.5) * 0.6; // 90¬∞ ¬± 30¬∞
                    const length = this.canvas.height + 100; // Atraviesan toda la pantalla
                    
                    const ray = {
                        x1: startX,
                        y1: startY,
                        x2: startX + Math.cos(angle) * length,
                        y2: startY + Math.sin(angle) * length,
                        width: 2 + Math.random() * 3,
                        life: 5 + Math.random() * 4, // M√°s duraderos
                        maxLife: 5 + Math.random() * 4,
                        alpha: 1
                    };
                    
                    this.occasionalRays.push(ray);
                }
                
                console.log(`‚òÄÔ∏è Reflejos del sol creados (${numRays} rayos desde arriba)`);
            }
            
            // ü¶† EFECTO DE SUCIEDAD UNIFICADO (BASADO EN BARRAS)
            drawDirtyEffect() {
                // USAR EL MISMO SISTEMA QUE LAS BARRAS
                const dirtValue = this.gameState.needs.dirt; // 0-100
                
                if (dirtValue > 15) { // Efecto visual m√°s temprano (era 30)
                    // Calcular nivel de suciedad (0 a 1)
                    const dirtLevel = Math.min((dirtValue - 15) / 85, 1); // Escala desde 15-100
                    
                    // Crear overlay de suciedad M√ÅS SUTIL
                    this.ctx.save();
                    this.ctx.globalAlpha = dirtLevel * 0.15; // M√°ximo 15% opacidad (m√°s sutil)
                    this.ctx.globalCompositeOperation = 'multiply';
                    
                    // Gradiente de suciedad
                    const gradient = this.ctx.createRadialGradient(
                        this.canvas.width / 2, this.canvas.height / 2, 0,
                        this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                    );
                    gradient.addColorStop(0, 'rgba(139, 115, 85, 0.2)'); // Marr√≥n claro centro
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)'); // Marr√≥n medio
                    gradient.addColorStop(1, 'rgba(62, 39, 35, 0.6)'); // Marr√≥n oscuro bordes
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Part√≠culas de suciedad flotando
                    if (!this.dirtParticles) this.dirtParticles = [];
                    
                    // Crear part√≠culas ocasionalmente
                    if (Math.random() < 0.02 * dirtLevel) {
                        this.dirtParticles.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            size: 1 + Math.random() * 3,
                            life: 5 + Math.random() * 5,
                            maxLife: 5 + Math.random() * 5,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10
                        });
                    }
                    
                    // Dibujar part√≠culas de suciedad
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = Math.min(0.9, dirtLevel * 2.0); // MUCHO M√ÅS OPACO
                    
                    for (let i = this.dirtParticles.length - 1; i >= 0; i--) {
                        const particle = this.dirtParticles[i];
                        
                        // Actualizar part√≠cula
                        particle.x += particle.vx * (1/60);
                        particle.y += particle.vy * (1/60);
                        particle.life -= 1/60;
                        
                        // Eliminar si expir√≥
                        if (particle.life <= 0) {
                            this.dirtParticles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar part√≠cula sucia
                        const alpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha = alpha * dirtLevel * 1.5; // MUCHO M√ÅS DENSA
                        this.ctx.fillStyle = '#8b7355';
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                    
                    // OVERLAY GENERAL DE SUCIEDAD (agua SUPER turbia como algas)
                    this.ctx.globalAlpha = Math.min(0.8, dirtLevel * 1.5); // MUCHO m√°s denso
                    
                    // Gradiente marr√≥n-verde como algas
                    const dirtGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    dirtGradient.addColorStop(0, 'rgba(139, 115, 85, 0.6)'); // Marr√≥n arriba
                    dirtGradient.addColorStop(0.5, 'rgba(101, 67, 33, 0.8)'); // Marr√≥n oscuro medio
                    dirtGradient.addColorStop(1, 'rgba(46, 125, 50, 0.7)'); // Verde algas abajo
                    
                    this.ctx.fillStyle = dirtGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.globalAlpha = 1;
                    
                    // Log ocasional
                    if (Math.random() < 0.005) {
                        console.log(`ü¶† Pecera sucia - Nivel: ${dirtValue.toFixed(1)}% (barra unificada)`);
                    }
                } else {
                    // Limpiar part√≠culas cuando no est√° sucio
                    if (this.dirtParticles) {
                        this.dirtParticles = [];
                    }
                }
            }
            
            drawExplosionBubbles() {
                for (const bubble of this.explosionBubbles) {
                    this.ctx.save();
                    
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha;
                    
                    if (bubble.isLight) {
                        // Part√≠culas de luz
                        this.ctx.fillStyle = '#ffeb3b';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#ffeb3b';
                    } else {
                        // Burbujas normales
                        this.ctx.fillStyle = `hsl(${200 + Math.random() * 60}, 70%, 80%)`;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(bubble.x - 1, bubble.y - 1, 2, 2);
                    }
                    
                    this.ctx.restore();
                }
            }
            
            drawFish() {
                if (!this.fish) return;
                
                const fish = this.fish;
                const size = fish.size;
                const colors = this.getFishColors();
                
                this.ctx.save();
                this.ctx.translate(fish.x, fish.y);
                this.ctx.rotate(-25 * Math.PI / 180); // Inclinaci√≥n del Lottie
                
                // ü´Å APLICAR RESPIRACI√ìN
                this.ctx.scale(fish.breatheScale, fish.breatheScale);
                
                // üêü COLA PRINCIPAL (forma exacta del Lottie)
                this.ctx.save();
                this.ctx.translate(-size * 0.8, 0);
                this.ctx.rotate(fish.finRotation); // Ondulaci√≥n -36¬∞ a +4¬∞
                
                this.ctx.fillStyle = colors.tail;
                this.ctx.beginPath();
                // Forma de cola del Lottie (m√°s org√°nica)
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.3, -size * 0.4, -size * 0.6, -size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.7, 0, -size * 0.6, size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.3, size * 0.4, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üê† CUERPO PRINCIPAL (forma org√°nica del Lottie)
                this.ctx.fillStyle = colors.body;
                this.ctx.beginPath();
                // Forma de pez m√°s realista basada en el JSON
                this.ctx.moveTo(size * 0.6, 0);
                this.ctx.quadraticCurveTo(size * 0.4, -size * 0.5, 0, -size * 0.4);
                this.ctx.quadraticCurveTo(-size * 0.6, -size * 0.3, -size * 0.7, 0);
                this.ctx.quadraticCurveTo(-size * 0.6, size * 0.3, 0, size * 0.4);
                this.ctx.quadraticCurveTo(size * 0.4, size * 0.5, size * 0.6, 0);
                this.ctx.fill();
                
                // üé® FRANJAS (patr√≥n del Lottie)
                this.ctx.fillStyle = colors.stripes;
                this.ctx.beginPath();
                // Franja superior
                this.ctx.moveTo(size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(0, -size * 0.25, -size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(-size * 0.2, -size * 0.05, size * 0.4, -size * 0.15);
                this.ctx.fill();
                
                // Franja inferior (solo para beb√©)
                if (this.gameState.stage === 'baby') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(0, size * 0.25, -size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(-size * 0.2, size * 0.05, size * 0.4, size * 0.15);
                    this.ctx.fill();
                }
                
                // üêü ALETA SUPERIOR (forma del Lottie)
                this.ctx.save();
                this.ctx.translate(size * 0.1, -size * 0.4);
                this.ctx.rotate(fish.finRotation * 0.6); // Ondulaci√≥n sutil
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                // Forma de aleta org√°nica
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.15, -size * 0.3, size * 0.05, -size * 0.35);
                this.ctx.quadraticCurveTo(size * 0.2, -size * 0.25, size * 0.15, -size * 0.1);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üêü ALETA INFERIOR
                this.ctx.save();
                this.ctx.translate(size * 0.2, size * 0.5);
                this.ctx.rotate(-fish.finRotation * 0.4);
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.1, size * 0.2, size * 0.05, size * 0.25);
                this.ctx.quadraticCurveTo(size * 0.15, size * 0.15, size * 0.1, size * 0.05);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üëÅÔ∏è OJO EXACTO DEL LOTTIE
                if (fish.eyeOpen > 0) {
                    // Ojo blanco (forma org√°nica del Lottie) - M√ÅS GRANDE PARA JOVEN
                    const whiteEyeScale = this.gameState.stage === 'baby' ? 1.0 : 1.6;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.3, -size * 0.05, size * 0.2 * whiteEyeScale, size * 0.15 * fish.eyeOpen * whiteEyeScale, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pupila negra
                    // üëÅÔ∏è OJO S√öPER GRANDE (especialmente para joven/adulto)
                    const eyeScale = this.gameState.stage === 'baby' ? 1.0 : 1.8; // MUCHO m√°s grande para joven/adulto
                    this.ctx.fillStyle = '#323232'; // Color exacto [0.1961,0.1961,0.1961]
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.32, -size * 0.05, size * 0.08 * eyeScale, size * 0.1 * fish.eyeOpen * eyeScale, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo en el ojo (m√°s grande tambi√©n)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.34, -size * 0.08, size * 0.03 * eyeScale, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // üëÑ BOCA PEQUE√ëA (del Lottie)
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.ellipse(size * 0.5, size * 0.05, size * 0.05, size * 0.03, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // üçº CHUPETE (solo para beb√©)
                if (this.gameState.stage === 'baby' && colors.pacifier) {
                    // Chupete principal
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.12, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Anillo del chupete
                    this.ctx.strokeStyle = colors.pacifier;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.16, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Mango del chupete
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.fillRect(size * 0.72, size * 0.08, size * 0.08, size * 0.04);
                }
                
                this.ctx.restore();
            }
            
            // üìè TAMA√ëO DEL PEZ SEG√öN ETAPA
            getFishSizeForStage(stage) {
                const sizes = {
                    'baby': 80,   // Tama√±o normal
                    'young': 95,  // 15% m√°s grande
                    'adult': 110  // 30% m√°s grande
                };
                return sizes[stage] || sizes['baby'];
            }
            
            // üé® COLORES EXACTOS DEL LOTTIE
            getFishColors() {
                const stage = this.gameState.stage;
                const ageInDays = this.gameState.ageInDays || 0;
                
                // Beb√© (0-2 d√≠as) - Colores Lottie + chupete
                if (stage === 'baby' || ageInDays < 3) {
                    return {
                        body: '#978bd8',      // Color exacto Lottie [0.5922,0.5451,0.8471]
                        stripes: '#9f8cb9',   // Franjas Lottie [0.6235,0.549,0.7255]
                        tail: '#d14444',      // Cola roja Lottie [0.8196,0.2667,0.2667]
                        fins: '#d78383',      // Aletas rosa Lottie [0.8431,0.5137,0.5137]
                        pacifier: '#ff9ecf'   // Chupete rosa para beb√©
                    };
                }
                
                // Joven (3-7 d√≠as) - Variaci√≥n m√°s intensa
                if (stage === 'young' || ageInDays < 8) {
                    return {
                        body: '#8a7bd8',      // Morado m√°s intenso
                        stripes: '#f4d03f',   // RAYA AMARILLENTA SUAVE
                        tail: '#c13434',      // Cola m√°s intensa
                        fins: '#c77373',      // Aletas m√°s fuertes
                        pacifier: null        // Sin chupete
                    };
                }
                
                // Adulto (8+ d√≠as) - Colores maduros
                return {
                    body: '#7d6bd8',        // Morado profundo
                    stripes: '#7f6cb9',     // Franjas sutiles
                    tail: '#b12424',        // Cola madura
                    fins: '#b76363',        // Aletas elegantes
                    pacifier: null          // Sin chupete
                };
            }
            
            // üìè ANCHO DE FRANJA POR EDAD
            getStripeWidth() {
                const ageInDays = this.gameState.ageInDays || 0;
                
                if (ageInDays < 3) return 0.25;      // Beb√©: franja ancha
                if (ageInDays < 8) return 0.18;      // Joven: franja media
                return 0.12;                          // Adulto: franja fina
            }
            
            // ü´ß CREAR BURBUJA DEL PEZ
            createFishBubble() {
                if (!this.fish) return;
                
                // Crear burbuja peque√±a que sale de la boca
                this.bgBubbles.push({
                    x: this.fish.x + this.fish.size * 0.5,
                    y: this.fish.y,
                    r: 2 + Math.random() * 3,
                    speed: 30 + Math.random() * 20,
                    opacity: 0.6 + Math.random() * 0.3,
                    life: 3 + Math.random() * 2,
                    maxLife: 3 + Math.random() * 2,
                    fromFish: true
                });
            }
            
            drawNeedBubbles() {
                for (const bubble of this.needBubbles) {
                    this.ctx.save();
                    this.ctx.globalAlpha = Math.min(bubble.life / 2, 1);
                    
                    // Burbuja de fondo
                    this.ctx.fillStyle = bubble.urgent ? '#ff6b6b' : '#4ecdc4';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Icono (emoji simple)
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px system-ui';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bubble.icon, bubble.x, bubble.y + 7);
                    
                    this.ctx.restore();
                }
            }
            
            // üê£ SISTEMA DE ECLOSI√ìN
            
            startHatching() {
                if (this.gameState.stage !== 'egg') return;
                
                console.log('üê£ ¬°ECLOSI√ìN SIMULT√ÅNEA!');
                
                // üîä SONIDO DE ECLOSI√ìN
                if (window.audioManager) {
                    window.audioManager.playSound('hatch');
                }
                
                // CREAR PEZ INMEDIATAMENTE (simult√°neo con burbujas)
                this.createFish();
                this.gameState.stage = 'baby';
                
                // Burbujas de eclosi√≥n al mismo tiempo
                this.createExplosionBubbles();
                
                console.log('ü•ö‚û°Ô∏èüêü Huevo desaparece y pez aparece AL MISMO TIEMPO');
            }
            
            createEggBubbles() {
                console.log('ü•ö Creando burbujitas blancas para el huevo');
                
                this.explosionBubbles.length = 0;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // BURBUJITAS BLANCAS SUAVES (COMO LAS DE NACIMIENTO PERO M√ÅS BLANCAS)
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 15 + Math.random() * 40; // M√°s suaves
                    const size = 2 + Math.random() * 8; // M√°s peque√±as
                    const life = 3 + Math.random() * 2;
                    
                    // COLORES M√ÅS BLANCOS
                    const colors = ['#FFFFFF', '#F8FCFF', '#F0F8FF', '#E8F4FF', '#E0F0FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 30,
                        y: centerY + (Math.random() - 0.5) * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20,
                        r: size,
                        life: life,
                        maxLife: life,
                        color: color,
                        alpha: 0.8
                    });
                }
                
                console.log('ü•ö 80 burbujitas blancas creadas para el huevo');
            }
            
            createExplosionBubbles() {
                if (this.explosionHappened) return;
                
                this.explosionBubbles.length = 0;
                this.lightRays.length = 0;
                this.explosionHappened = true;
                
                console.log('‚ú® Creando efecto suave de nacimiento');
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // EXPLOSI√ìN MASIVA DE BURBUJAS - LLENAR TODA LA PANTALLA
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 100; // Velocidad variada
                    const size = 3 + Math.random() * 12; // Tama√±os muy variados
                    const life = 4 + Math.random() * 3; // M√°s duraderas
                    
                    // Colores azules brillantes y blancos
                    const colors = ['#FFFFFF', '#E6F3FF', '#CCE7FF', '#99D6FF', '#66C7FF', '#33B8FF', '#00A9FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 30, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.3, // M√°s brillo
                        isLight: false
                    });
                }
                
                // ONDAS MASIVAS: 4 ondas consecutivas
                for (let wave = 0; wave < 4; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            const speed = 50 + Math.random() * 80;
                            const size = 2 + Math.random() * 8;
                            
                            this.explosionBubbles.push({
                                x: centerX + (Math.random() - 0.5) * 20,
                                y: centerY + (Math.random() - 0.5) * 20,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: size,
                                life: 3 + Math.random() * 2,
                                maxLife: 3 + Math.random() * 2,
                                sparkle: Math.random() < 0.4,
                                isLight: false
                            });
                        }
                    }, wave * 200);
                }
                
                console.log(`‚ú® Efecto suave creado: ${this.explosionBubbles.length} burbujas delicadas (sin rayos amarillos)`);
            }
            
            async createFish() {
                // Crear pez Lottie REAL
                await this.createLottieFish();
                
                // üîä SONIDO DE NACIMIENTO BONITO (solo eclosi√≥n)
                if (window.audioManager) {
                    setTimeout(() => {
                        window.audioManager.playSound('hatch'); // SOLO eclosi√≥n, sin bipbip
                    }, 200); // M√°s r√°pido para sincronizar mejor
                }
                
                // üß± POSICI√ìN INICIAL CON L√çMITES FIJOS
                const padLeft = 60;
                const padRight = 30;
                const W = this.canvas.width;
                const H = this.getFloorY();
                
                this.fish = {
                    x: W / 2, // Centro del canvas
                    y: H * 0.6, // 60% hacia abajo
                    size: this.getFishSizeForStage('baby'), // Tama√±o seg√∫n etapa
                    birthTime: Date.now(),
                    isLottie: true,
                    scale: 0.1, // Empezar muy peque√±o
                    targetScale: 1.0, // Crecer hasta tama√±o normal
                    growing: true,
                    
                    // üöÄ PROPIEDADES DEL SISTEMA REALISTA (EXACTAS DEL C√ìDIGO)
                    vx: 0, vy: 0, // Velocidades actuales
                    facing: 1, // Direcci√≥n (-1 izquierda, 1 derecha)
                    baseSpeed: 280, // Velocidad base EXACTA (duplicada)
                    maxSpeed: 600, // Velocidad m√°xima EXACTA (duplicada)
                    maxAccel: 2200, // Aceleraci√≥n m√°xima MEJORADA (duplicada)
                    wanderTimer: 0, // Timer para cambio de direcci√≥n
                    wanderDir: {x: 1, y: 0}, // Direcci√≥n de vagabundeo
                    swimPhase: 0, // Fase de nataci√≥n para ondulaci√≥n
                    desire: null, // Objetivo al que ir (click)
                    happyBurst: 0, // Tiempo de celebraci√≥n
                    spinKind: "eat", // Tipo de giro (eat/clean)
                    blinkT: 0, // Tiempo de parpadeo
                    nextBlink: 2 + Math.random() * 4, // Pr√≥ximo parpadeo
                    breathT: 2 + Math.random() * 3, // Pr√≥xima respiraci√≥n
                    eyeOpen: 1 // OJO ABIERTO AL NACER
                };
                
                // Establecer fecha de nacimiento
                this.gameState.birthDate = Date.now();
                this.gameState.ageInDays = 0;
                
                // üçé NACER CON HAMBRE (ES UN BEB√â)
                this.gameState.needs.hunger = 80; // Beb√© nace con hambre
                this.gameState.needs.dirt = 0;    // Limpio al nacer
                this.gameState.needs.fun = 95;    // Feliz al nacer
                this.updateCrisisFlags(); // Activar flags
                this.updateNeedBars(); // Actualizar barras
                
                console.log('üçé Beb√© naci√≥ con hambre - Crisis activada');
                
                // üìä MOSTRAR BARRAS DE NECESIDADES CUANDO NACE EL PEZ
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'flex';
                    this.setupCanvas(); // REAJUSTAR CANVAS CON BARRAS
                    console.log('üìä Barras de necesidades activadas + Canvas reajustado');
                }
                
                // Sin bonus de bienvenida - empezar desde cero
                // this.gameState.bubbles += 0; // Empezar sin burbujas
                // this.gameState.stars += 0;   // Empezar sin estrellas
                
                // üéÜ BURBUJAS ANTES DEL PEZ (INMEDIATAS)
                this.explosionHappened = false; // RESETEAR FLAG
                this.createExplosionBubbles(); // BURBUJAS PRIMERO
                
                console.log('üéÜ Burbujas de nacimiento creadas ANTES del pez');
                
                console.log('üê† ¬°PEZ LOTTIE NACIDO! +5 ü´ß +1 ‚≠ê de regalo');
                this.updateUI();
                
                // Forzar actualizaci√≥n inmediata de necesidades (beb√© nace con hambre)
                setTimeout(() => {
                    // this.updateAllNeedBubbles(); // DESHABILITADO - iconos eliminados
                    this.updateButtonStates();
                    console.log('üçΩÔ∏è Verificando necesidades del beb√© reci√©n nacido...');
                }, 1000); // Despu√©s de 1 segundo para asegurar que todo est√© inicializado
                
                // Pedir nombre despu√©s de 3 segundos
                setTimeout(() => {
                    this.askForFishName();
                }, 3000);
                
                // A√±adir evento de nacimiento al √°lbum
                this.addAlbumEvent('birth', 'üê£ ¬°He nacido!', 'Mi primer d√≠a en el mundo. Todo es nuevo y emocionante.');
            }
            
            async createLottieFish() {
                try {
                    // üéØ SELECCIONAR ARCHIVO SEG√öN ETAPA
                const lottieFiles = {
                    'baby': './ejemplos/bebe.json',
                    'young': './ejemplos/joven2.json', // ‚Üê USA TU NUEVO JOVEN2
                    'adult': './ejemplos/adulto.json'
                };
                    
                    const currentStage = this.gameState.stage;
                    const filePath = lottieFiles[currentStage] || lottieFiles['baby'];
                    
                    console.log(`üé® Cargando Lottie para etapa: ${currentStage} ‚Üí ${filePath}`);
                    
                    // Cargar JSON del pez seg√∫n etapa
                    const response = await fetch(filePath);
                    const animationData = await response.json();
                    
                    const container = document.getElementById('lottieContainer');
                    container.style.display = 'block';
                    
                    // Crear animaci√≥n Lottie
                    this.lottieAnimation = lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: animationData
                    });
                    
                    console.log('üé® Pez Lottie cargado correctamente');
                    
                    // Posicionar el contenedor
                    this.updateLottiePosition();
                    
                } catch (error) {
                    console.error('‚ùå Error cargando Lottie:', error);
                    // Fallback al pez Canvas
                    this.createCanvasFish();
                }
            }
            
            updateLottiePosition() {
                if (!this.fish || !this.lottieAnimation) return;
                
                const container = document.getElementById('lottieContainer');
                const rect = this.canvas.getBoundingClientRect();
                
                // CRECIMIENTO GRADUAL del pez reci√©n nacido
                if (this.fish.growing && this.fish.scale < this.fish.targetScale) {
                    this.fish.scale += 0.02; // Crecimiento visible
                    
                    if (this.fish.scale >= this.fish.targetScale) {
                        this.fish.scale = this.fish.targetScale;
                        this.fish.growing = false;
                        console.log('üê† Pez alcanz√≥ tama√±o completo');
                    }
                }
                
                // Posici√≥n relativa al canvas
                const x = this.fish.x;
                const y = this.fish.y;
                const currentScale = this.fish.scale || 1;
                const facing = this.fish.facing || 1;
                
                container.style.left = (rect.left + x - 30) + 'px'; // Centrar (60px/2 = 30)
                container.style.top = (rect.top + y - 30) + 'px';
                
                // üîÑ ORIENTACI√ìN CORREGIDA: Lottie mira IZQUIERDA por defecto
                // facing = 1 (derecha) ‚Üí scaleX(-1)
                // facing = -1 (izquierda) ‚Üí scaleX(1) 
                const scaleX = facing > 0 ? -1 : 1; // INVERTIDO para corregir orientaci√≥n
                
                // APLICAR INCLINACI√ìN Y EFECTOS DE ESTADO DE √ÅNIMO
                const tilt = this.fish.tilt || 0;
                const tiltDegrees = tilt * (180 / Math.PI); // Convertir a grados
                
                // üé® FILTROS POR ETAPA - JOVEN SOLO UN POQUITO M√ÅS CLARO
                const stageFilters = {
                    'baby': 'brightness(1.2) contrast(1.1) saturate(1.2)', // Color original beb√©
                    'young': 'brightness(1.3) contrast(1.1) saturate(1.2)', // Solo un poquito m√°s claro
                    'adult': 'brightness(1.2) contrast(1.1) saturate(1.2)' // Color original adulto
                };
                
                const currentFilter = stageFilters[this.gameState.stage] || stageFilters['baby'];
                
                container.style.transform = `translate(-50%, -50%) scaleX(${scaleX}) scale(${currentScale}) rotate(${tiltDegrees}deg)`;
                container.style.filter = currentFilter; // FILTRO SEG√öN ETAPA
                container.style.opacity = 1; // Siempre visible
                
                // Reducir felicidad gradualmente
                if (this.fish.happyTime > 0) {
                    this.fish.happyTime -= 1/60;
                    if (this.fish.happyTime <= 0) {
                        this.fish.excited = false;
                    }
                }
            }
            
            createCanvasFish() {
                // Fallback al pez Canvas original
                const W = this.canvas.width;
                const H = this.getFloorY();
                
                this.fish = {
                    x: W / 2, // Centro del canvas
                    y: H * 0.6, // 60% hacia abajo
                    size: 45,
                    birthTime: Date.now(),
                    isLottie: false
                };
                console.log('üê† Pez Canvas creado (fallback)');
            }
            
            
            // üê† L√ìGICA SIMPLE DE PEZ REAL
            updateNaturalFishMovement(deltaTime) {
                const fish = this.fish;
                const currentStage = this.gameState.stage;
                
                // Inicializar pez m√°s r√°pido y variado
                if (!fish.direction) fish.direction = 1; // 1 = derecha, -1 = izquierda
                if (!fish.baseSpeed) fish.baseSpeed = currentStage === 'baby' ? 120 : 90; // Velocidad base aumentada
                if (!fish.speed) fish.speed = fish.baseSpeed; // Velocidad actual
                if (!fish.swimPhase) fish.swimPhase = 0;
                if (!fish.facing) fish.facing = 1;
                if (!fish.changeTimer) fish.changeTimer = 0;
                if (!fish.verticalDirection) fish.verticalDirection = 0; // -1 arriba, 0 medio, 1 abajo
                if (!fish.verticalTimer) fish.verticalTimer = 0;
                // BEB√â NACE CON HAMBRE - Configurar tiempo anterior para que tenga hambre inmediatamente
                if (!fish.lastFeedTime) {
                    // Hacer que el beb√© nazca con hambre (4 horas + 1 minuto atr√°s)
                    const hungerTime = 4 * 60 * 60 * 1000 + 60 * 1000; // 4h 1min atr√°s
                    fish.lastFeedTime = Date.now() - hungerTime;
                    console.log('üçº ¬°Beb√© nace con HAMBRE! Necesita comer inmediatamente');
                }
                
                // INICIALIZAR SISTEMA DE BURBUJAS DE NECESIDADES
                if (!fish.needBubbleTimer) fish.needBubbleTimer = 0;
                if (!this.needBubbles) this.needBubbles = [];
                
                // Inicializar otros tiempos si no existen
                if (!this.gameState.lastClean) this.gameState.lastClean = Date.now();
                if (!this.gameState.lastMedicine) this.gameState.lastMedicine = Date.now();
                if (!this.gameState.lastPlay) this.gameState.lastPlay = Date.now();
                
                // Fase de nataci√≥n para ondulaci√≥n
                fish.swimPhase += deltaTime * (currentStage === 'baby' ? 2 : 1.2);
                fish.changeTimer += deltaTime;
                
                // CAMBIOS M√ÅS FRECUENTES para m√°s variedad
                // Beb√©: cada 4-8 segundos, Adulto: cada 6-10 segundos
                const changeInterval = currentStage === 'baby' ? 4 + Math.random() * 4 : 6 + Math.random() * 4;
                fish.verticalTimer += deltaTime;
                
                if (fish.changeTimer > changeInterval) {
                    // 50% chance de cambiar direcci√≥n horizontal
                    if (Math.random() < 0.5) {
                        fish.direction *= -1;
                        console.log(`üê† Cambio horizontal: ${fish.direction === 1 ? 'DERECHA ‚Üí' : 'IZQUIERDA ‚Üê'}`);
                    }
                    
                    // 60% chance de cambiar direcci√≥n vertical
                    if (Math.random() < 0.6) {
                        const options = [-1, 0, 1]; // arriba, medio, abajo
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                        const verticalNames = ['ARRIBA ‚Üë', 'MEDIO ‚Üí', 'ABAJO ‚Üì'];
                        console.log(`üê† Cambio vertical: ${verticalNames[fish.verticalDirection + 1]}`);
                    }
                    
                    fish.changeTimer = 0;
                }
                
                // Cambios verticales independientes (m√°s frecuentes)
                if (fish.verticalTimer > 3 + Math.random() * 3) {
                    if (Math.random() < 0.4) {
                        const options = [-1, 0, 1];
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                    }
                    fish.verticalTimer = 0;
                }
                
                // ‚úÖ SISTEMA ELIMINADO - SOLO USAMOS EL SISTEMA ORIGINAL DEL DOCUMENTO
                if (fish.isChasing) {
                    // 2. PRIORIDAD: Perseguir comida
                    // Durante persecuci√≥n, usar la velocidad ya calculada en makeFishChaseFood
                    // No sobreescribir fish.vx y fish.vy
                } else if (fish.isCleaning) {
                    // 3. PRIORIDAD: Movimiento de tirabuzones durante limpieza
                    fish.cleaningTime += deltaTime;
                    
                    // MOVIMIENTO EN TIRABUZONES (COSQUILLAS)
                    const spiralSpeed = fish.baseSpeed * 1.5;
                    const spiralRadius = 40 + Math.sin(fish.cleaningTime * 3) * 20;
                    const spiralAngle = fish.cleaningTime * 4; // 4 vueltas por segundo
                    
                    fish.vx = Math.cos(spiralAngle) * spiralRadius * 0.1 + Math.sin(fish.cleaningTime * 8) * spiralSpeed * 0.3;
                    fish.vy = Math.sin(spiralAngle) * spiralRadius * 0.1 + Math.cos(fish.cleaningTime * 6) * spiralSpeed * 0.2;
                    
                    // Movimiento err√°tico como si tuviera cosquillas
                    fish.vx += (Math.random() - 0.5) * spiralSpeed * 0.4;
                    fish.vy += (Math.random() - 0.5) * spiralSpeed * 0.3;
                    
                    console.log(`üåÄ Pez haciendo tirabuzones - tiempo: ${fish.cleaningTime.toFixed(1)}s`);
                } else if (fish.goingToCorner) {
                    // 4. PRIORIDAD: Pez triste va a esquina (SIN desire)
                    const dx = fish.cornerTargetX - fish.x;
                    const dy = fish.cornerTargetY - fish.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 15) {
                        // Movimiento LENTO hacia esquina
                        const slowSpeed = fish.baseSpeed * 0.5; // MUY lento
                        fish.vx = (dx / distance) * slowSpeed;
                        fish.vy = (dy / distance) * slowSpeed;
                        fish.direction = dx > 0 ? 1 : -1;
                    } else {
                        // Lleg√≥ a la esquina - quedarse quieto
                        fish.goingToCorner = false;
                        fish.vx = 0;
                        fish.vy = 0;
                        console.log('üò¢ Pez lleg√≥ a esquina - Se queda quieto');
                    }
                } else {
                    // 5. COMPORTAMIENTO NORMAL: Movimiento libre
                    fish.vx = fish.direction * fish.speed;
                    
                    // Movimiento vertical combinado
                    let baseVerticalMovement = Math.sin(fish.swimPhase) * (currentStage === 'baby' ? 12 : 8); // Ondulaci√≥n natural
                    let directionalVertical = fish.verticalDirection * (fish.speed * 0.4); // Movimiento direccional vertical
                    
                    fish.vy = baseVerticalMovement + directionalVertical;
                }
                
                // Aplicar movimiento
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;
                
                // GIRO SIMPLE: Solo cuando llega al borde
                this.handleSimpleFishBoundaries();
                
                // Orientaci√≥n simple
                this.updateFishOrientation();
                
                // SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
                this.updateNeedBubbles(deltaTime);
                
                // Sistema de necesidades - Solo botones (iconos flotantes eliminados)
                // this.updateAllNeedBubbles(); // DESHABILITADO - iconos molestos
                
                // Sistema de apat√≠a y tristeza
                this.updateFishMood();
                
                // Actualizar estado de botones
                this.updateButtonStates();
            }
            
            // üëÜ CLICK EN PANTALLA - PEZ VIENE AL DEDO (SISTEMA DEL DEMO)
            handleCanvasClick(event) {
                console.log('üëÜ CLICK DETECTADO - Pez:', !!this.fish, 'Stage:', this.gameState.stage);
                if (!this.fish || this.gameState.stage === 'egg' || this.fish.isDepressed) {
                    console.log('‚ùå Click ignorado - Sin pez o en huevo');
                    return;
                }
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // üö® GUARDACOSTAS: Solo ignorar si est√° MUY aburrido (no por hambre)
                if (this.gameState.crisis.bored) {
                    console.log('üòî Click ignorado - Pez muy aburrido (necesita jugar)');
                    return;
                }
                
                // üëÜ DEDO CON COORDENADAS CSS Y TURBO
                const padLeft = 60;
                const padRight = 30;
                const W = this.canvas.width;
                const H = this.getFloorY();
                this.fish.desire = {
                    x: this.clamp(x, padLeft, W - padRight),
                    y: this.clamp(y, 125, H - 5)
                };
                this.fish.fingerBoostT = 1.6;   // turbo temporal de dedo
                this.fish.returnToBottom = false; // apagar cualquier regreso al fondo
                this.fish.shouldLaunchHeart = true; // Marcar para lanzar coraz√≥n cuando llegue
                
                console.log(`üëÜ ¬°TURBO AL DEDO! (${x.toFixed(0)}, ${y.toFixed(0)}) - Boost: 1.6s`);
            }
            
            // üíñ LANZAR CORAZ√ìN QUE AUMENTA DIVERSI√ìN
            launchHeartToFun(x, y) {
                // Si no se pasan coordenadas, usar posici√≥n del pez
                const startX = x !== undefined ? x : this.fish.x;
                const startY = y !== undefined ? y : this.fish.y;
                
                // Crear coraz√≥n visual
                const heart = {
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 50, // Velocidad horizontal aleatoria
                    vy: -80, // Velocidad hacia arriba
                    life: 2.0, // 2 segundos de vida
                    maxLife: 2.0,
                    size: 20 + Math.random() * 10,
                    color: ['üíñ', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú'][Math.floor(Math.random() * 7)]
                };
                
                if (!this.flyers) this.flyers = [];
                this.flyers.push(heart);
                
                // üéâ AUMENTAR DIVERSI√ìN
                this.gameState.needs.fun = Math.max(0, this.gameState.needs.fun - 5); // -5 diversi√≥n (menos rojo = m√°s feliz)
                this.updateCrisisFlags();
                this.updateNeedBars();
                
                console.log(`üíñ Coraz√≥n lanzado! Diversi√≥n: ${this.gameState.needs.fun}`);
                
                // üì∏ EVENTO DE JUEGO OCASIONAL
                if (Math.random() < 0.08) { // 8% chance
                    const playMessages = [
                        '¬°Me encanta jugar contigo! Eres el mejor cuidador.',
                        'Cuando vienes a jugar conmigo me siento s√∫per feliz.',
                        '¬°Qu√© divertido! Me gusta mucho cuando interact√∫as conmigo.',
                        'Estos momentos de juego son mis favoritos del d√≠a.',
                        'Gracias por dedicarme tiempo para jugar. ¬°Eres genial!'
                    ];
                    const msg = playMessages[Math.floor(Math.random() * playMessages.length)];
                    this.addAlbumEvent('playing', 'üéÆ Momento de juego', msg);
                }
            }
            
            // YA NO NECESITAMOS CAMBIOS DE COMPORTAMIENTO
            // El pez simplemente NADA en una direcci√≥n hasta llegar al borde
            
            // üçΩÔ∏è SISTEMA DE HAMBRE
            updateHunger() {
                if (!this.fish || !this.fish.lastFeedTime) return;
                
                const currentTime = Date.now();
                const timeSinceLastFeed = currentTime - this.fish.lastFeedTime;
                // CONFIGURACI√ìN REAL: Beb√© tiene hambre cada 4 horas
                const currentStage = this.gameState.stage;
                let hungerThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000; // Default beb√©
                }
                
                const hungerBubble = document.getElementById('hungerBubble');
                if (!hungerBubble) return;
                
                if (timeSinceLastFeed > hungerThreshold) {
                    // Mostrar burbuja de hambre cerca del pez
                    this.showHungerBubble();
                } else {
                    // Ocultar burbuja
                    hungerBubble.style.display = 'none';
                }
            }
            
            showHungerBubble() {
                this.showNeedBubble('hungerBubble', 'hunger', 15, -45);
            }
            
            // üéØ MOSTRAR BURBUJA DE NECESIDAD GEN√âRICA
            showNeedBubble(bubbleId, needType, offsetX, offsetY) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Posicionar la burbuja cerca del pez
                bubble.style.display = 'block';
                bubble.style.left = (this.fish.x + offsetX) + 'px';
                bubble.style.top = (this.fish.y + offsetY) + 'px';
                
                const needNames = {
                    'hunger': 'COMIDA üçΩÔ∏è',
                    'dirty': 'LIMPIEZA üßΩ', 
                    'medicine': 'MEDICINA üíä',
                    'play': 'JUGAR üéÆ'
                };
                console.log(`üéØ Pez necesita: ${needNames[needType] || needType}`);
                
                // DEBUG: Verificar que se muestra el icono, no texto
                console.log(`üìç Burbuja ${bubbleId} posicionada en (${this.fish.x + offsetX}, ${this.fish.y + offsetY})`);
            }
            
            // üéØ MOSTRAR ICONO QUE SE MUEVE (APARECE/DESAPARECE/CAMBIA LUGAR)
            showFixedNeedIcon(bubbleId, needType) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Inicializar timer de movimiento si no existe
                if (!bubble.moveTimer) bubble.moveTimer = 0;
                if (!bubble.currentPosition) bubble.currentPosition = 0;
                
                bubble.moveTimer += 1/60;
                
                // Cambiar posici√≥n cada 8-15 segundos (M√ÅS LENTO)
                if (bubble.moveTimer > 8 + Math.random() * 7) {
                    bubble.currentPosition = (bubble.currentPosition + 1) % 4; // Rotar entre 4 posiciones
                    bubble.moveTimer = 0;
                    
                    // DESAPARECER MUY LENTAMENTE (1.5 segundos)
                    bubble.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
                    bubble.style.opacity = '0';
                    bubble.style.transform = 'scale(0.7)';
                    
                    setTimeout(() => {
                        // Cambiar posici√≥n mientras est√° invisible
                        this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                        
                        // APARECER MUY LENTAMENTE (2 segundos)
                        setTimeout(() => {
                            bubble.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
                            bubble.style.opacity = '1';
                            bubble.style.transform = 'scale(1)';
                        }, 200);
                        
                    }, 1500); // Esperar a que termine de desaparecer
                    
                    console.log(`üéØ Icono ${needType} se mueve SUAVEMENTE a nueva posici√≥n`);
                } else {
                    // Mantener posici√≥n actual
                    this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                }
                
                bubble.style.display = 'block';
            }
            
            updateIconPosition(bubble, bubbleId, positionIndex) {
                // 4 posiciones diferentes para cada icono
                const allPositions = [
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.25 }, // Superior izquierda
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.25 }, // Superior derecha
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.75 }, // Inferior derecha
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.75 }  // Inferior izquierda
                ];
                
                const pos = allPositions[positionIndex] || allPositions[0];
                
                bubble.style.left = pos.x + 'px';
                bubble.style.top = pos.y + 'px';
            }
            
            // üò¢ SISTEMA DE APAT√çA Y TRISTEZA
            updateFishMood() {
                if (!this.fish) return;
                console.log('üê† updateFishMood() ejecut√°ndose...');
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Calcular tiempo sin atender necesidades
                const timeSinceFood = this.fish.lastFeedTime ? currentTime - this.fish.lastFeedTime : 0;
                const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                const timeSinceClean = this.gameState.lastClean ? currentTime - this.gameState.lastClean : 0;
                
                // Umbrales de descuido (8 horas sin atender)
                const neglectThreshold = 8 * 60 * 60 * 1000; // 8 horas
                
                const isNeglected = timeSinceFood > neglectThreshold || 
                                  timeSincePlay > neglectThreshold || 
                                  timeSinceClean > neglectThreshold;
                
                // üê† COMPORTAMIENTO CUANDO TIENE NECESIDADES
                const hasNeeds = this.gameState.needs.hunger > 60 || 
                               this.gameState.needs.dirt > 50 || 
                               this.gameState.needs.fun < 30;
                
                if (hasNeeds) {
                    // Pez inquieto cuando tiene necesidades moderadas
                    this.fish.baseSpeed = (currentStage === 'baby' ? 120 : 90) * 1.5; // M√°s r√°pido
                    this.fish.isRestless = true;
                    
                    // Cambiar direcci√≥n m√°s frecuentemente
                    if (Math.random() < 0.02) { // 2% de probabilidad por frame
                        this.fish.direction *= -1;
                        console.log('üê† Pez inquieto cambia de direcci√≥n');
                    }
                } else {
                    this.fish.isRestless = false;
                }
                
                if (isNeglected) {
                    // PEZ TRISTE Y AP√ÅTICO - L√ìGICA MEJORADA
                    this.fish.baseSpeed = (currentStage === 'baby' ? 120 : 90) * 0.3; // MUY lento
                    this.fish.isDepressed = true;
                    this.fish.hideTimer = (this.fish.hideTimer || 0) + 1/60;
                    
                    // Se va a una esquina y se queda quieto M√ÅS TIEMPO
                    if (!this.fish.isInCorner && this.fish.hideTimer > 3) {
                        // Ir a una esquina aleatoria usando l√≠mites fijos
                        const padLeft = 60;
                        const padRight = 30;
                        const W = this.canvas.width;
                        const H = this.getFloorY();
                        const corners = [
                            { x: padLeft + 5, y: 125 }, // Esquina superior izquierda (5px dentro del l√≠mite)
                            { x: W - padRight, y: 125 }, // Superior derecha
                            { x: padLeft + 5, y: H - 5 }, // Inferior izquierda (5px dentro del l√≠mite)
                            { x: W - padRight, y: H - 5 } // Inferior derecha
                        ];
                        
                        const corner = corners[Math.floor(Math.random() * corners.length)];
                        this.fish.targetX = corner.x;
                        this.fish.targetY = corner.y;
                        // Pez triste va LENTO a esquina (SIN desire para evitar conflictos)
                        this.fish.cornerTargetX = corner.x;
                        this.fish.cornerTargetY = corner.y;
                        this.fish.goingToCorner = true;
                        this.fish.isInCorner = true;
                        this.fish.cornerTime = 8 + Math.random() * 12; // 8-20 segundos en esquina
                        console.log('üò¢ Pez triste va a esconderse en esquina...');
                    }
                    
                    // Quedarse quieto en la esquina
                    if (this.fish.isInCorner) {
                        this.fish.cornerTime -= 1/60;
                        
                        // Movimiento MUY reducido en la esquina
                        if (this.fish.cornerTime > 0) {
                            this.fish.vx *= 0.95; // Casi inm√≥vil
                            this.fish.vy *= 0.95;
                        } else {
                            this.fish.isInCorner = false;
                            this.fish.hideTimer = 0;
                            console.log('üê† Pez sale de la esquina');
                        }
                    }
                    
                    // No responde al dedo cuando est√° muy triste
                    if (this.fish.isGoingToTarget && !this.fish.isInCorner && Math.random() < 0.8) {
                        this.fish.isGoingToTarget = false;
                        this.fish.targetX = null;
                        this.fish.targetY = null;
                        console.log('üò¢ Pez demasiado triste para venir al dedo');
                    }
                    
                } else {
                    // PEZ NORMAL Y FELIZ
                    this.fish.baseSpeed = currentStage === 'baby' ? 120 : 90; // Velocidad normal
                    this.fish.isDepressed = false;
                    this.fish.isInCorner = false;
                    this.fish.hideTimer = 0;
                }
            }
            
            // üéÆ ACTUALIZAR TODAS LAS BURBUJAS DE NECESIDADES
            updateAllNeedBubbles() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales (mismos que en updateButtonStates)
                let hungerThreshold, cleanThreshold, medicineThreshold, playThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        playThreshold = 5 * 60 * 60 * 1000; // 5 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000;
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 14 * 60 * 60 * 1000;
                        playThreshold = 8 * 60 * 60 * 1000;
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000;
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 26 * 60 * 60 * 1000;
                        playThreshold = 10 * 60 * 60 * 1000;
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                        playThreshold = 5 * 60 * 60 * 1000;
                }
                
                // Verificar y mostrar/ocultar burbujas
                const needsFood = this.fish.lastFeedTime && (currentTime - this.fish.lastFeedTime) > hungerThreshold;
                const needsCleaning = this.gameState.lastClean && (currentTime - this.gameState.lastClean) > cleanThreshold;
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                const needsPlay = this.gameState.lastPlay && (currentTime - this.gameState.lastPlay) > playThreshold;
                
                // ICONOS APARECEN/DESAPARECEN en posiciones fijas
                if (needsFood) {
                    this.showFixedNeedIcon('hungerBubble', 'hunger');
                } else {
                    document.getElementById('hungerBubble').style.display = 'none';
                }
                
                if (needsCleaning) {
                    this.showFixedNeedIcon('dirtyBubble', 'dirty');
                } else {
                    document.getElementById('dirtyBubble').style.display = 'none';
                }
                
                if (needsMedicine) {
                    this.showFixedNeedIcon('medicineBubble', 'medicine');
                } else {
                    document.getElementById('medicineBubble').style.display = 'none';
                }
                
                if (needsPlay) {
                    this.showFixedNeedIcon('playBubble', 'play');
                } else {
                    document.getElementById('playBubble').style.display = 'none';
                }
            }
            
            // üìç ACTUALIZAR POSICIONES DE BURBUJAS QUE SIGUEN AL PEZ
            updateVisibleBubblesPositions() {
                if (!this.fish) return;
                
                const bubbles = [
                    { id: 'hungerBubble', offsetX: 15, offsetY: -45 },
                    { id: 'dirtyBubble', offsetX: -60, offsetY: -30 },
                    { id: 'medicineBubble', offsetX: 60, offsetY: -30 },
                    { id: 'playBubble', offsetX: 0, offsetY: -70 }
                ];
                
                bubbles.forEach(bubbleInfo => {
                    const bubble = document.getElementById(bubbleInfo.id);
                    if (bubble && bubble.style.display !== 'none') {
                        // Actualizar posici√≥n para que siga al pez
                        bubble.style.left = (this.fish.x + bubbleInfo.offsetX) + 'px';
                        bubble.style.top = (this.fish.y + bubbleInfo.offsetY) + 'px';
                    }
                });
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BOT√ìN (SISTEMA ANTIGUO - DESACTIVADO)
            startFeeding() {
                console.log('üçΩÔ∏è startFeeding() DESACTIVADO - Usar dropFood() en su lugar');
                return;
                
                // Crear 3 bolitas con MEJOR ESPACIADO
                setTimeout(() => {
                    this.createFallingFood(1); // Primera comida
                }, 0);
                
                setTimeout(() => {
                    this.createFallingFood(2); // Segunda comida
                }, 800); // Despu√©s de 800ms
                
                setTimeout(() => {
                    this.createFallingFood(3); // Tercera comida
                }, 1600); // Despu√©s de 1.6s
                
                // Activar modo persecuci√≥n del pez (velocidad m√°s suave)
                this.fish.isChasing = true;
                this.fish.chaseSpeed = this.fish.speed * 1.5; // Solo 50% m√°s r√°pido
                
                // Desactivar persecuci√≥n despu√©s de 15 segundos
                setTimeout(() => {
                    if (this.fish) {
                        this.fish.isChasing = false;
                        console.log('üê† Pez dej√≥ de perseguir comida - Volviendo a comportamiento normal');
                    }
                }, 15000);
                
                // Actualizar tiempo de alimentaci√≥n
                this.fish.lastFeedTime = Date.now();
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üèÉ ¬°Pez activado en modo persecuci√≥n! Velocidad x1.5 (m√°s natural)');
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BURBUJA (MODO ORIGINAL)
            feedFish() {
                if (!this.fish) return;
                
                // Actualizar tiempo de √∫ltima comida
                this.fish.lastFeedTime = Date.now();
                
                // Ocultar burbuja
                const hungerBubble = document.getElementById('hungerBubble');
                if (hungerBubble) {
                    hungerBubble.style.display = 'none';
                }
                
                // Efectos de alimentaci√≥n
                this.createFeedingEffects();
                
                // Aumentar felicidad
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üçΩÔ∏è Pez alimentado - Felicidad:', this.gameState.happiness);
            }
            
            createFeedingEffects() {
                // Crear part√≠culas de comida cayendo
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.createFoodParticle();
                    }, i * 100);
                }
            }
            
            createFoodParticle() {
                if (!this.fish) return;
                
                const particle = {
                    x: this.fish.x + (Math.random() - 0.5) * 40,
                    y: this.fish.y - 50,
                    vy: 30 + Math.random() * 20,
                    life: 2,
                    maxLife: 2,
                    size: 3 + Math.random() * 3
                };
                
                // A√±adir a array de part√≠culas (DESACTIVADO - SISTEMA ANTIGUO)
                // if (!this.foodParticles) this.foodParticles = [];
                // this.foodParticles.push(particle);
            }
            
            // üçñ CREAR COMIDA CON POSICIONES ESTRAT√âGICAS
            createFallingFood(foodNumber) {
                // SISTEMA ANTIGUO - DESACTIVADO
                return;
                
                let startX;
                if (this.fish) {
                    const fishX = this.fish.x;
                    const canvasWidth = this.canvas.width;
                    
                    // POSICIONES ESTRAT√âGICAS para cada comida
                    switch(foodNumber) {
                        case 1:
                            // Primera: A la izquierda del pez
                            startX = Math.max(80, fishX - 80 - Math.random() * 60);
                            break;
                        case 2:
                            // Segunda: A la derecha del pez
                            startX = Math.min(canvasWidth - 80, fishX + 80 + Math.random() * 60);
                            break;
                        case 3:
                            // Tercera: Cerca del pez (arriba o centro)
                            startX = fishX + (Math.random() - 0.5) * 100;
                            startX = Math.max(80, Math.min(canvasWidth - 80, startX));
                            break;
                        default:
                            startX = 100 + Math.random() * (canvasWidth - 200);
                    }
                } else {
                    // Si no hay pez, usar posici√≥n aleatoria
                    startX = 100 + Math.random() * (this.canvas.width - 200);
                }
                
                const food = {
                    x: startX,
                    y: this.canvas.height * 0.25, // Un poco m√°s abajo
                    vy: 18 + Math.random() * 8, // Velocidad m√°s lenta para dar tiempo
                    size: 9 + Math.random() * 3, // Tama√±o m√°s visible
                    life: 18, // M√°s tiempo para comer
                    maxLife: 18,
                    eaten: false,
                    type: Math.random() > 0.8 ? 'premium' : 'normal',
                    number: foodNumber
                };
                
                this.fallingFood.push(food);
                console.log(`üçñ Comida #${foodNumber} creada en x:${startX.toFixed(0)} (${foodNumber === 1 ? 'IZQUIERDA' : foodNumber === 2 ? 'DERECHA' : 'CENTRO'})`);
            }
            
            drawFoodParticles() {
                if (!this.foodParticles) return;
                
                // Actualizar y dibujar part√≠culas
                for (let i = this.foodParticles.length - 1; i >= 0; i--) {
                    const particle = this.foodParticles[i];
                    
                    // Actualizar posici√≥n
                    particle.y += particle.vy * (1/60); // Asumiendo 60fps
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.foodParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula de comida
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    // Color marr√≥n/dorado para la comida
                    this.ctx.fillStyle = '#D2691E';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Peque√±o brillo
                    this.ctx.fillStyle = '#F4A460';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x - 1, particle.y - 1, particle.size * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üçñ DIBUJAR Y ACTUALIZAR COMIDA CAYENDO
            drawFallingFood() {
                if (!this.fallingFood) return;
                
                // Actualizar y dibujar comida cayendo
                for (let i = this.fallingFood.length - 1; i >= 0; i--) {
                    const food = this.fallingFood[i];
                    
                    if (food.eaten) continue;
                    
                    // Actualizar posici√≥n
                    food.y += food.vy * (1/60);
                    food.life -= 1/60;
                    
                    // Eliminar si expir√≥ o sali√≥ de pantalla
                    if (food.life <= 0 || food.y > this.canvas.height + 50) {
                        this.fallingFood.splice(i, 1);
                        continue;
                    }
                    
                    // Verificar si el pez la alcanz√≥
                    if (this.fish && !food.eaten) {
                        const distance = Math.sqrt(
                            Math.pow(this.fish.x - food.x, 2) + 
                            Math.pow(this.fish.y - food.y, 2)
                        );
                        
                        if (distance < 30) { // Pez alcanz√≥ la comida (√°rea m√°s grande)
                            food.eaten = true;
                            this.createEatingEffect(food.x, food.y);
                            this.createBigEatingEffect(food.x, food.y, food.type);
                            console.log(`üçΩÔ∏è ¬°Pez comi√≥ comida ${food.type}! ¬°√ëAM √ëAM!`);
                            
                            // ACTUALIZAR TIEMPO DE COMIDA Y ESTADO
                            this.fish.lastFeedTime = Date.now();
                            this.fish.excited = true; // ¬°FELIZ AL COMER!
                            console.log('üòä ¬°Pez feliz despu√©s de comer!');
                            
                            // Quitar felicidad despu√©s de 3 segundos
                            setTimeout(() => {
                                this.fish.excited = false;
                            }, 3000);
                            
                            // Quitar comida despu√©s de un momento
                            setTimeout(() => {
                                const index = this.fallingFood.indexOf(food);
                                if (index > -1) this.fallingFood.splice(index, 1);
                            }, 100);
                            continue;
                        }
                        
                    }
                    
                    // Dibujar comida
                    this.ctx.save();
                    
                    // Color seg√∫n tipo
                    const color = food.type === 'premium' ? '#FFD700' : '#D2691E';
                    const highlightColor = food.type === 'premium' ? '#FFF8DC' : '#F4A460';
                    
                    // Sombra
                    this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetY = 2;
                    
                    // Comida principal
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo
                    this.ctx.fillStyle = highlightColor;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x - 2, food.y - 2, food.size * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Si el pez est√° persiguiendo, encontrar la comida m√°s cercana
                if (this.fish && this.fish.isChasing && this.fallingFood.length > 0) {
                    this.findAndChaseClosestFood();
                }
            }
            
            // üîç ENCONTRAR Y PERSEGUIR LA COMIDA M√ÅS CERCANA
            findAndChaseClosestFood() {
                if (!this.fallingFood || this.fallingFood.length === 0) return;
                
                const fish = this.fish;
                let closestFood = null;
                let closestDistance = Infinity;
                
                // Encontrar la comida m√°s cercana
                for (const food of this.fallingFood) {
                    if (food.eaten) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(fish.x - food.x, 2) + 
                        Math.pow(fish.y - food.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
                
                // Si encontramos comida, perseguirla
                if (closestFood) {
                    this.makeFishChaseFood(closestFood);
                }
            }
            
            // üèÉ HACER QUE EL PEZ PERSIGA LA COMIDA (SIN GIROS LOCOS)
            makeFishChaseFood(food) {
                const fish = this.fish;
                
                // Calcular direcci√≥n hacia la comida
                const dx = food.x - fish.x;
                const dy = food.y - fish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Velocidad de persecuci√≥n m√°s natural
                    const chaseSpeed = fish.chaseSpeed || (fish.speed * 1.5); // 50% m√°s r√°pido
                    
                    // Normalizar y aplicar velocidad
                    fish.vx = (dx / distance) * chaseSpeed;
                    fish.vy = (dy / distance) * chaseSpeed;
                    
                    // SOLO cambiar orientaci√≥n si hay un cambio SIGNIFICATIVO
                    const significantChange = Math.abs(dx) > 20; // Solo si est√° a m√°s de 20px
                    if (significantChange) {
                        const newDirection = dx > 0 ? 1 : -1;
                        // Solo cambiar si es realmente diferente
                        if (newDirection !== fish.direction) {
                            fish.direction = newDirection;
                            console.log(`üîÑ Pez cambi√≥ orientaci√≥n: ${fish.direction === 1 ? 'DERECHA' : 'IZQUIERDA'}`);
                        }
                    }
                    
                    // Log menos spam
                    if (Math.random() < 0.1) { // Solo 10% de las veces
                        console.log(`üèÉ Persiguiendo comida: ${distance.toFixed(0)}px`);
                    }
                }
            }
            
            // ‚ú® EFECTO AL COMER
            createEatingEffect(x, y) {
                // Peque√±as part√≠culas al comer
                for (let i = 0; i < 5; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 30,
                        vy: (Math.random() - 0.5) * 30,
                        life: 0.5,
                        maxLife: 0.5,
                        size: 2 + Math.random() * 2,
                        color: '#FFD700'
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
            }
            
            // üí• EFECTO GRANDE AL COMER
            createBigEatingEffect(x, y, type) {
                // Crear muchas part√≠culas espectaculares
                const particleCount = type === 'premium' ? 15 : 10;
                const colors = type === 'premium' 
                    ? ['#FFD700', '#FFF8DC', '#FFFF00', '#FFE55C'] 
                    : ['#D2691E', '#F4A460', '#DEB887', '#CD853F'];
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 40 + Math.random() * 30;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 3 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
                
                // Texto "√ëAM √ëAM" flotante
                this.createFloatingText(x, y, type === 'premium' ? '¬°√ëAM √ëAM!' : '√±am √±am', 
                                       type === 'premium' ? '#FFD700' : '#D2691E');
            }
            
            // üìù TEXTO FLOTANTE
            createFloatingText(x, y, text, color) {
                const textEffect = {
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 2,
                    maxLife: 2,
                    vy: -30 // Flota hacia arriba
                };
                
                if (!this.floatingTexts) this.floatingTexts = [];
                this.floatingTexts.push(textEffect);
            }
            
            // üé® DIBUJAR EFECTOS DE COMER
            drawEatingEffects() {
                if (!this.eatingEffects) return;
                
                for (let i = this.eatingEffects.length - 1; i >= 0; i--) {
                    const particle = this.eatingEffects[i];
                    
                    // Actualizar part√≠cula
                    particle.x += particle.vx * (1/60);
                    particle.y += particle.vy * (1/60);
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.eatingEffects.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üìù DIBUJAR TEXTOS FLOTANTES
            drawFloatingTexts() {
                if (!this.floatingTexts) return;
                
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    // Actualizar texto
                    text.y += text.vy * (1/60);
                    text.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar texto
                    const alpha = text.life / text.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.fillStyle = text.color;
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.textAlign = 'center';
                    
                    // Contorno blanco
                    this.ctx.strokeText(text.text, text.x, text.y);
                    // Texto principal
                    this.ctx.fillText(text.text, text.x, text.y);
                    
                    this.ctx.restore();
                }
            }
            
            // ‚è∞ AVANZAR TIEMPO DEL JUEGO (WRAPPER)
            advanceTime(hours) {
                this.advanceGameTime(hours);
            }
            
            // ‚è∞ AVANZAR TIEMPO DEL JUEGO (DEBUG)
            advanceGameTime(hours) {
                if (!this.fish) return;
                
                const timeAdvance = hours * 60 * 60 * 1000; // Convertir horas a milisegundos
                
                // Avanzar TODOS los tiempos del juego
                if (this.fish.lastFeedTime) {
                    this.fish.lastFeedTime -= timeAdvance; // Retroceder = como si hubiera pasado tiempo
                }
                
                if (this.gameState.lastPlay) {
                    this.gameState.lastPlay -= timeAdvance;
                }
                
                if (this.gameState.lastClean) {
                    this.gameState.lastClean -= timeAdvance;
                }
                
                if (this.gameState.birthDate) {
                    this.gameState.birthDate -= timeAdvance; // Hacer m√°s viejo
                }
                
                // Actualizar edad
                this.updateAgeDisplay();
                
                // Forzar actualizaci√≥n de necesidades - simular tiempo transcurrido
                const cfg = this.getStageCfg(this.gameState);
                const hoursPassed = hours;
                
                // Aumentar hambre, suciedad y disminuir diversi√≥n
                const hungerIncrease = (100 / cfg.hungerHours) * hoursPassed;
                const dirtIncrease = (100 / cfg.dirtHours) * hoursPassed;
                const funDecrease = (100 / cfg.funHours) * hoursPassed;
                
                this.gameState.needs.hunger = Math.min(100, this.gameState.needs.hunger + hungerIncrease);
                this.gameState.needs.dirt = Math.min(100, this.gameState.needs.dirt + dirtIncrease);
                this.gameState.needs.fun = Math.max(0, this.gameState.needs.fun - funDecrease);
                
                this.updateCrisisFlags();
                this.updateNeedBars();
                this.updateButtonStates();
                
                console.log(`‚è∞ Tiempo del juego avanzado +${hours} hora(s)`);
                console.log(`üçΩÔ∏è √öltima comida: hace ${Math.round((Date.now() - this.fish.lastFeedTime) / (60*60*1000))} horas`);
                console.log(`üìä Necesidades actualizadas: Hambre: ${this.gameState.needs.hunger.toFixed(1)}%, Suciedad: ${this.gameState.needs.dirt.toFixed(1)}%, Diversi√≥n: ${this.gameState.needs.fun.toFixed(1)}%`);
            }
            
            // üéÆ ACTUALIZAR ESTADO DE BOTONES
            updateButtonStates() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales seg√∫n la edad
                let hungerThreshold, cleanThreshold, medicineThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas descuido
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000; // 2 d√≠as
                        medicineThreshold = 14 * 60 * 60 * 1000; // 14 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000; // 3 d√≠as
                        medicineThreshold = 26 * 60 * 60 * 1000; // 26 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                }
                
                // Verificar necesidades BASADAS EN LOS VALORES REALES
                const needsFood = this.gameState.needs.hunger > 20; // Si hambre > 20%, activar bot√≥n (AJUSTADO)
                const needsCleaning = true; // LIMPIEZA SIEMPRE DISPONIBLE
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                
                // Actualizar botones (MEDICINA ELIMINADA) - M√ÅS DEBUG
                console.log('üîò BOTONES DEBUG:', 
                    'Hambre:', this.gameState.needs.hunger.toFixed(1) + '% ‚Üí needsFood:', needsFood,
                    'Suciedad:', this.gameState.needs.dirt.toFixed(1) + '% ‚Üí needsCleaning:', needsCleaning,
                    'Umbral limpieza: >10%');
                    
                // DEBUG EXTRA para limpieza
                if (this.gameState.needs.dirt > 50) {
                    console.log('üßπ LIMPIEZA DEBUG EXTRA:', 
                        'dirt:', this.gameState.needs.dirt,
                        'needsCleaning:', needsCleaning,
                        'cleanBtn existe:', !!document.getElementById('cleanBtn'));
                }
                this.toggleButton('feedBtn', needsFood);
                this.toggleButton('cleanBtn', needsCleaning);
                // this.toggleButton('medicineBtn', needsMedicine); // ELIMINADO
            }
            
            // üîò HABILITAR/DESHABILITAR BOT√ìN
            toggleButton(buttonId, enabled) {
                const button = document.getElementById(buttonId);
                if (!button) {
                    console.log(`‚ùå toggleButton: Bot√≥n ${buttonId} NO ENCONTRADO`);
                    return;
                }
                
                console.log(`üîò toggleButton: ${buttonId} ‚Üí ${enabled ? 'HABILITADO' : 'DESHABILITADO'}`);
                
                if (enabled) {
                    button.classList.remove('disabled');
                    console.log(`‚úÖ ${buttonId}: Clase 'disabled' REMOVIDA`);
                    button.onclick = () => {
                        switch(buttonId) {
                            case 'feedBtn': this.dropFood(); break; // USAR SISTEMA NUEVO
                            case 'cleanBtn': this.startCleaning(); break;
                            // case 'medicineBtn': this.giveMedicine(); break; // ELIMINADO
                        }
                    };
                } else {
                    button.classList.add('disabled');
                    console.log(`‚ùå ${buttonId}: Clase 'disabled' A√ëADIDA`);
                    button.onclick = () => {
                        console.log(`‚ùå ${buttonId}: El pez no necesita esto ahora`);
                    };
                }
            }
            
            // üßΩ FUNCI√ìN DUPLICADA ELIMINADA - SE USA LA DEL EFECTO ESPECTACULAR
            
            // ü´ß SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
            updateNeedBubbles(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;
                
                const fish = this.fish;
                fish.needBubbleTimer += deltaTime;
                
                // Crear burbuja cada 3-5 segundos si tiene necesidades
                if (fish.needBubbleTimer > 3 + Math.random() * 2) {
                    fish.needBubbleTimer = 0;
                    
                    const currentTime = Date.now();
                    const currentStage = this.gameState.stage;
                    
                    // Verificar necesidades
                    const timeSinceFood = fish.lastFeedTime ? currentTime - fish.lastFeedTime : 0;
                    const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                    const timeSinceMedicine = this.gameState.lastMedicine ? currentTime - this.gameState.lastMedicine : 0;
                    
                    // Umbrales
                    const hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                    const playThreshold = 5 * 60 * 60 * 1000;   // 5 horas
                    const medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                    
                    // Crear burbujas seg√∫n necesidades (en orden de prioridad)
                    if (timeSinceFood > hungerThreshold) {
                        this.createNeedBubble('./images/ui/badge_hunger.png', '#ff5555');
                        console.log('ü´ß Burbuja de HAMBRE creada');
                    }
                    
                    if (timeSinceMedicine > medicineThreshold) {
                        this.createNeedBubble('./images/ui/badge_medicine.png', '#55ff55');
                        console.log('ü´ß Burbuja de MEDICINA creada');
                    }
                    
                    if (timeSincePlay > playThreshold) {
                        this.createNeedBubble('./images/ui/badge_play.png', '#ffaa55');
                        console.log('ü´ß Burbuja de JUEGO creada');
                    }
                }
                
                // Actualizar burbujas existentes
                this.updateExistingNeedBubbles(deltaTime);
            }
            
            createNeedBubble(icon, color) {
                if (!this.fish) return;
                
                // Posici√≥n desde la boca del pez
                const fish = this.fish;
                const direction = fish.direction || 1;
                const mouthX = fish.x + (direction > 0 ? 30 : -30); // Boca del pez
                const mouthY = fish.y;
                
                this.needBubbles.push({
                    x: mouthX,
                    y: mouthY,
                    vx: (Math.random() - 0.5) * 3, // MUY lento horizontal
                    vy: -8 - Math.random() * 5, // MUY lento hacia arriba
                    size: 22, // Tama√±o para ver bien el icono
                    life: 5 + Math.random() * 2, // Duran m√°s tiempo
                    maxLife: 5 + Math.random() * 2,
                    iconPath: icon, // Ruta de la imagen PNG
                    color: color,
                    alpha: 1,
                    iconImage: null // Se cargar√° din√°micamente
                });
            }
            
            updateExistingNeedBubbles(deltaTime) {
                if (!this.needBubbles) return;
                
                for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.needBubbles[i];
                    
                    // Actualizar posici√≥n (COMO BURBUJAS NORMALES)
                    bubble.x += bubble.vx; // Sin deltaTime - movimiento frame por frame
                    bubble.y += bubble.vy;
                    bubble.life -= deltaTime;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.needBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Actualizar alpha
                    bubble.alpha = bubble.life / bubble.maxLife;
                }
            }
            
            drawNeedBubbles() {
                if (!this.needBubbles || this.needBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (const bubble of this.needBubbles) {
                    this.ctx.globalAlpha = bubble.alpha * 0.7; // M√ÅS TRANSL√öCIDA
                    
                    // Dibujar burbuja base (m√°s transl√∫cida)
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.strokeStyle = bubble.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = bubble.color;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Cargar y dibujar icono PNG
                    if (!bubble.iconImage) {
                        bubble.iconImage = new Image();
                        bubble.iconImage.src = bubble.iconPath;
                    }
                    
                    if (bubble.iconImage && bubble.iconImage.complete) {
                        this.ctx.globalAlpha = bubble.alpha;
                        const iconSize = bubble.size * 0.7;
                        this.ctx.drawImage(
                            bubble.iconImage,
                            bubble.x - iconSize/2,
                            bubble.y - iconSize/2,
                            iconSize,
                            iconSize
                        );
                    }
                    
                    this.ctx.shadowBlur = 0; // Limpiar sombra
                }
                
                this.ctx.restore();
            }
            
            // ‚ú® DIBUJAR BURBUJAS DE LIMPIEZA
            drawCleaningBubbles() {
                if (!this.cleaningBubbles || this.cleaningBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (let i = this.cleaningBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cleaningBubbles[i];
                    
                    // Actualizar burbuja
                    bubble.x += bubble.vx * (1/60);
                    bubble.y += bubble.vy * (1/60);
                    bubble.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.cleaningBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar burbuja de limpieza
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha * 0.8;
                    
                    // Color azul brillante para limpieza
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#ffffff'; // Burbujas brillantes
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00bfff';
                    } else {
                        this.ctx.fillStyle = '#87ceeb'; // Burbujas normales azul cielo
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#4169e1';
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo interno
                    this.ctx.globalAlpha = alpha * 0.4;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // üéÆ FUNCIONES DE JUEGOS
            playBubbleGame() {
                this.showCustomModal({
                    title: 'ü´ß Juego de Burbujas',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüéÆ ¬°Ser√° s√∫per divertido!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            playMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüß† ¬°Ser√° s√∫per desafiante!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            showGameLocked(starsNeeded) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesitamos m√°s estrellas para este juego!"\n\n‚≠ê Tienes: ${this.gameState.stars || 0} estrellas\n‚≠ê Necesitas: ${starsNeeded} estrellas\n\nüéÆ ¬°Juega otros juegos para ganar estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            showItemLocked(bubblesNeeded) {
                this.showCustomModal({
                    title: 'üîí Item Bloqueado',
                    message: `üê†üí≠ "¬°Necesitamos m√°s burbujas para este item!"\n\nü´ß Tienes: ${this.gameState.bubbles || 0} burbujas\nü´ß Necesitas: ${bubblesNeeded} burbujas\n\nüéÆ ¬°Juega para ganar burbujas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // üéí USAR ITEM DEL INVENTARIO
            useInventoryItem(itemId) {
                console.log(`üéí Usando item del inventario: ${itemId}`);
                
                // Si es un fondo, manejar compra o selecci√≥n
                if (itemId.startsWith('bg-')) {
                    const bgName = itemId.replace('bg-', '');
                    const item = document.querySelector(`[data-item="${itemId}"]`);
                    const isOwned = item?.dataset.owned === 'true';
                    const cost = parseInt(item?.dataset.cost || '0');
                    
                    if (isOwned) {
                        // Ya lo tiene, solo cambiar fondo
                        console.log(`üé® Cambiando fondo a: ${bgName}`);
                        const bg = this.availableBackgrounds.find(b => b.name === bgName);
                        if (bg) {
                            this.gameState.currentBackground = bgName;
                            this.bgImage = bg.image;
                            console.log(`üé® Fondo cambiado: ${bgName}, imagen: ${bg.image ? 'cargada' : 'no cargada'}`);
                        }
                        this.updateInventoryAvailability(); // Actualizar selecci√≥n
                        this.saveGame();
                        
                        // Mostrar mensaje de cambio
                        this.showCustomModal({
                            title: 'üé® ¬°Fondo cambiado!',
                            message: `üê†üí≠ "¬°Me encanta mi nuevo hogar!"\n\n‚ú® Fondo aplicado: ${bgName}`,
                            confirmText: 'üéÆ ¬°Genial!',
                            onConfirm: () => {}
                        });
                    } else if (this.gameState.bubbles >= cost) {
                        // Mostrar modal de confirmaci√≥n de compra
                        this.showCustomModal({
                            title: 'üõí ¬øComprar Fondo?',
                            message: `üê†üí≠ "¬øQuieres comprarme este hermoso fondo?"\n\nü´ß Costo: ${cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\nü´ß Quedar√°n: ${this.gameState.bubbles - cost} burbujas\n\n‚ú® ¬°El fondo se aplicar√° inmediatamente!`,
                            confirmText: 'üõí ¬°Comprar!',
                            cancelText: '‚ùå Cancelar',
                            onConfirm: () => {
                                // Comprar fondo
                                this.gameState.bubbles -= cost;
                                
                                // Marcar como desbloqueado y aplicar fondo
                                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                                if (bg) {
                                    bg.unlocked = true;
                                    this.gameState.currentBackground = bgName;
                                    this.bgImage = bg.image;
                                    console.log(`üé® Fondo comprado y aplicado: ${bgName}`);
                                }
                                
                                // Actualizar UI
                                this.updateUI();
                                this.updateInventoryAvailability();
                                this.saveGame();
                                
                                // Efecto visual de compra
                                this.createBubbleEffect(0); // Sin burbujas voladoras, solo actualizar contador
                                
                                // Mostrar confirmaci√≥n de compra exitosa
                                this.showCustomModal({
                                    title: 'üéâ ¬°Fondo Comprado!',
                                    message: `üê†üí≠ "¬°Gracias por comprarme este hermoso fondo!"\n\nü´ß Costo: ${cost} burbujas\nü´ß Restantes: ${this.gameState.bubbles} burbujas\n\n‚ú® ¬°El fondo est√° ahora aplicado!`,
                                    confirmText: 'üéÆ ¬°Genial!',
                                    onConfirm: () => {}
                                });
                            },
                            onCancel: () => {
                                console.log('‚ùå Compra cancelada por el usuario');
                            }
                        });
                    } else {
                        // No tiene suficientes burbujas
                        this.showItemLocked(`${cost}ü´ß`);
                    }
                    return;
                }
                
                // Otros items (decoraciones, etc.)
                const itemCosts = {
                    'food-special': 30,
                    'decoration': 40
                };
                
                const cost = itemCosts[itemId];
                if (cost && this.gameState.bubbles >= cost) {
                    // Desbloquear item
                    this.gameState.bubbles -= cost;
                    this.updateUI();
                    this.saveGame();
                    
                    this.showCustomModal({
                        title: 'üéâ ¬°Item Desbloqueado!',
                        message: `üê†üí≠ "¬°Gracias por comprarme este item!"\n\nü´ß Costo: ${cost} burbujas\nü´ß Restantes: ${this.gameState.bubbles} burbujas\n\n‚ú® ¬°El item est√° ahora disponible!`,
                        confirmText: 'üéÆ ¬°Genial!',
                        onConfirm: () => {}
                    });
                } else {
                    this.showItemLocked(`${cost}ü´ß`);
                }
            }
            
            startGame(gameId) {
                // Cerrar modal de juegos
                document.getElementById('gamesModal').style.display = 'none';
                
                // üîä SONIDO DE INICIO DE JUEGO
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                switch(gameId) {
                    case 'bubbles':
                        this.startBubbleGame();
                        break;
                    case 'memory':
                        this.startMemoryGame();
                        break;
                    default:
                        this.showCustomModal({
                            title: 'üöß En Desarrollo',
                            message: `üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\n‚ú® Pr√≥ximamente disponible...`,
                            confirmText: 'üëç ¬°Esperar√©!',
                            onConfirm: () => {}
                        });
                }
            }

            showGameLocked(starsRequired) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesito m√°s estrellas para jugar!"\n\n‚≠ê Necesitas: ${starsRequired} estrellas\n‚≠ê Tienes: ${this.gameState.stars}\n\nüéÆ ¬°Juega m√°s para conseguir estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // üåä MODAL DE RESET EMOTIVO
            showResetModal() {
                const fishName = this.gameState.fishName || 'tu pececito';
                
                this.showCustomModal({
                    title: 'Despedida de tu Pececito',
                    message: `üê† "${fishName === 'tu pececito' ? 'Hola' : 'Soy ' + fishName}... ¬øde verdad me vas a dejar libre?"

Volver√© al oc√©ano infinito y ser√© feliz
Siempre recordar√© nuestros momentos juntos
Podr√°s cuidar a un nuevo compa√±ero
Nuestros recuerdos quedar√°n en mi coraz√≥n

‚ö†Ô∏è **Se perder√° todo el progreso actual**
ü´ß Burbujas: ${this.gameState.bubbles || 0}
‚≠ê Estrellas: ${this.gameState.stars || 0}
üìÖ D√≠as juntos: ${this.gameState.ageInDays || 0}`,
                    confirmText: '¬°S√© libre y feliz!',
                    cancelText: '¬°No, te quiero!',
                    onConfirm: () => {
                        this.showCustomModal({
                            title: '¬°Hasta siempre!',
                            message: `üê† "¬°Gracias por todo! ¬°Fui muy feliz contigo!"\n\n*Nada hacia el oc√©ano infinito*\n\nTu nueva aventura comenzar√° en un momento...`,
                            confirmText: '¬°Adi√≥s!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            }
                        });
                    },
                    onCancel: () => {
                        this.showCustomModal({
                            title: 'üíï ¬°Qu√© alegr√≠a!',
                            message: `üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos siendo los mejores amigos! üéÆ\n\nüí™ ¬°Vamos a vivir m√°s aventuras juntos!`,
                            confirmText: 'ü•∞ ¬°Siempre juntos!',
                            onConfirm: () => {}
                        });
                    }
                });
            }

            // üéÆ Pantalla de carga ELIMINADA (ya no se usa)
            showLoadingWithFishName() {
                console.log('üéÆ showLoadingWithFishName() ELIMINADO - Ya no hay pantalla de carga');
                // M√©todo eliminado - ir directo al juego
            }

            // üíÄ A√±adir bot√≥n reset al men√∫ solo si ya tienes pez
            addResetButtonToMenu() {
                const actionBar = document.querySelector('.action-bar');
                if (!document.getElementById('resetButton')) {
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'menu-btn';
                    resetBtn.id = 'resetButton';
                    resetBtn.title = 'Cuidar otro pececito';
                    resetBtn.innerHTML = '<div class="btn-icon">üíÄ</div>';
                    
                    resetBtn.addEventListener('click', () => {
                        this.showResetModal();
                    });
                    
                    actionBar.appendChild(resetBtn);
                    console.log('üíÄ Bot√≥n reset a√±adido al men√∫');
                }
            }
            
            // ü´ß JUEGO DE BURBUJAS - DIRECTO
            startBubbleGame() {
                console.log('ü´ß Iniciando juego de burbujas...');
                // Ir directo al juego sin modal previo
                this.runBubbleGame();
            }
            
            runBubbleGame() {
                // Crear overlay del juego completo
                const gameOverlay = document.createElement('div');
                gameOverlay.id = 'bubbleGameOverlay';
                gameOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                    z-index: 2000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    padding: 20px;
                    font-family: 'Comic Sans MS', cursive;
                    overflow: hidden;
                `;

                // UI del juego
                const gameUI = document.createElement('div');
                gameUI.style.cssText = `
                    color: white;
                    text-align: center;
                    margin-bottom: 15px;
                    font-size: 20px;
                    font-weight: bold;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                    background: rgba(255,255,255,0.1);
                    padding: 10px 20px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.3);
                `;
                gameUI.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                        <div>‚è±Ô∏è Tiempo: <span id="bubbleTimer">20</span>s</div>
                        <div>ü´ß Puntos: <span id="bubbleScore">0</span></div>
                        <button id="exitGameBtn" style="
                            background: rgba(255,255,255,0.2);
                            border: 2px solid rgba(255,255,255,0.5);
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            color: white;
                            font-size: 18px;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">‚ùå</button>
                    </div>
                    <div style="
                        color: rgba(255,255,255,0.8);
                        font-size: 12px;
                        text-align: center;
                        margin-top: 8px;
                        line-height: 1.3;
                    ">
                        üîµ Toca burbujas azules (+3 pts +tiempo) üî¥ Evita rojas (-2 pts)<br>
                        ‚≠ê 1 estrella por jugar ‚Ä¢ 2 por r√©cord personal ‚Ä¢ 3 por r√©cord global
                    </div>
                `;

                const gameArea = document.createElement('div');
                gameArea.id = 'bubbleGameArea';
                gameArea.style.cssText = `
                    position: relative;
                    width: 100%;
                    max-width: 350px;
                    height: 450px;
                    border-radius: 20px;
                    overflow: hidden;
                    cursor: pointer;
                    background: rgba(255,255,255,0.05);
                    border: 3px solid rgba(255,255,255,0.2);
                `;

                gameOverlay.appendChild(gameUI);
                gameOverlay.appendChild(gameArea);
                document.body.appendChild(gameOverlay);

                // Bot√≥n de salir
                document.getElementById('exitGameBtn').addEventListener('click', () => {
                    gameActive = false;
                    clearInterval(gameTimer);
                    clearInterval(bubbleSpawner);
                    document.body.removeChild(gameOverlay);
                    if (document.head.contains(style)) {
                        document.head.removeChild(style);
                    }
                });

                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                let baseSpawnRate = 800; // Velocidad base de aparici√≥n
                let currentSpawnRate = baseSpawnRate;
                let gameStartTime = Date.now();
                
                // Sistema de r√©cords
                const personalRecord = parseInt(localStorage.getItem('bubbleGame_personalRecord') || '0');
                const globalRecord = parseInt(localStorage.getItem('bubbleGame_globalRecord') || '50'); // R√©cord global inicial

                // Actualizar UI
                const updateUI = () => {
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    document.getElementById('bubbleScore').textContent = score;
                };

                // Crear burbuja
                const createBubble = () => {
                    if (!gameActive) return;

                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35; // 65% buenas, 35% malas
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        border-radius: 50%;
                        background: ${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid ${isGood ? '#ffffff' : '#ffdddd'};
                        box-shadow: 0 0 12px ${isGood ? 'rgba(135,206,235,0.8)' : 'rgba(255,107,107,0.8)'};
                        cursor: pointer;
                        animation: bubbleFloat 3.5s linear;
                        top: 100%;
                        left: ${Math.random() * (350 - size)}px;
                        z-index: 1001;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${size * 0.4}px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                    `;

                    bubble.innerHTML = isGood ? 'üîµ' : 'üî¥';
                    bubble.dataset.good = isGood;
                    
                    bubble.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!gameActive) return;

                        if (isGood) {
                            score += 3;
                            // ‚è∞ A√ëADIR TIEMPO POR BURBUJA BUENA
                            timeLeft += 1; // +1 segundo por burbuja buena
                            bubble.style.background = 'radial-gradient(circle, #00ff88, #32cd32)';
                            bubble.innerHTML = '+3 +1s';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                            
                            // üöÄ AUMENTAR DIFICULTAD PROGRESIVAMENTE
                            if (score > 0 && score % 15 === 0) { // Cada 15 puntos
                                currentSpawnRate = Math.max(300, currentSpawnRate - 50); // M√°s r√°pido, m√≠nimo 300ms
                                console.log(`üöÄ Dificultad aumentada: ${currentSpawnRate}ms`);
                            }
                        } else {
                            score = Math.max(0, score - 2);
                            bubble.style.background = 'radial-gradient(circle, #ff4444, #dc143c)';
                            bubble.innerHTML = '-2';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                        }
                        
                        updateUI();
                        
                        setTimeout(() => {
                            if (bubble.parentNode) bubble.remove();
                        }, 600);
                    });

                    gameArea.appendChild(bubble);
                    bubbles.push(bubble);

                    // Remover burbuja despu√©s de la animaci√≥n
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                        const index = bubbles.indexOf(bubble);
                        if (index > -1) bubbles.splice(index, 1);
                    }, 3500);
                };

                // A√±adir CSS de animaci√≥n
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes bubbleFloat {
                        0% { 
                            transform: translateY(0) rotate(0deg) scale(0.8);
                            opacity: 0.7;
                        }
                        10% { 
                            opacity: 1;
                            transform: translateY(-40px) rotate(20deg) scale(1);
                        }
                        100% { 
                            transform: translateY(-500px) rotate(360deg) scale(0.9);
                            opacity: 0.8;
                        }
                    }
                `;
                document.head.appendChild(style);

                // Timer del juego
                const gameTimer = setInterval(() => {
                    timeLeft--;
                    updateUI();

                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        clearInterval(bubbleSpawner);
                        
                        // Finalizar juego
                        setTimeout(() => {
                            document.body.removeChild(gameOverlay);
                            document.head.removeChild(style);
                            
                            // Actualizar burbujas del jugador
                            const finalScore = Math.max(0, score);
                            this.gameState.bubbles += finalScore;
                            
                            // ‚≠ê SISTEMA DE ESTRELLAS SEG√öN RENDIMIENTO
                            let starsEarned = 1; // 1 estrella por jugar
                            let achievement = 'Partida completada';
                            
                            if (finalScore > personalRecord) {
                                starsEarned = 2; // 2 estrellas por r√©cord personal
                                achievement = '¬°Nuevo r√©cord personal!';
                                localStorage.setItem('bubbleGame_personalRecord', finalScore.toString());
                            }
                            
                            if (finalScore > globalRecord) {
                                starsEarned = 3; // 3 estrellas por r√©cord global
                                achievement = '¬°R√âCORD GLOBAL! ¬°Eres incre√≠ble!';
                                localStorage.setItem('bubbleGame_globalRecord', finalScore.toString());
                            }
                            
                            this.gameState.stars += starsEarned;
                            
                            // üéÜ EFECTOS VISUALES DE RECOMPENSA
                            if (finalScore > 0) {
                                this.showRewardEffect('bubbles', finalScore);
                                setTimeout(() => {
                                    this.showRewardEffect('stars', starsEarned);
                                }, 800);
                            }
                            
                            this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                            this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                            this.saveGame();

                            // Mostrar resultado
                            this.showCustomModal({
                                title: starsEarned === 3 ? 'üèÜ ¬°R√âCORD GLOBAL!' : starsEarned === 2 ? 'üéâ ¬°Nuevo R√©cord!' : 'üéÆ ¬°Bien Jugado!',
                                message: `üê†üí≠ "${achievement}"\n\nü´ß Puntos: ${finalScore}\n‚≠ê Estrellas ganadas: ${starsEarned}\nüìä R√©cord personal: ${Math.max(personalRecord, finalScore)}\nüèÜ R√©cord global: ${Math.max(globalRecord, finalScore)}\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                                confirmText: 'üéÆ ¬°Genial!'
                            });
                        }, 1000);
                    }
                }, 1000);

                // Spawner de burbujas din√°mico
                const bubbleSpawner = setInterval(() => {
                    if (gameActive) {
                        createBubble();
                    }
                }, currentSpawnRate);

                // Actualizar spawner din√°micamente
                const updateSpawner = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(updateSpawner);
                        return;
                    }
                    clearInterval(bubbleSpawner);
                    const newSpawner = setInterval(() => {
                        if (gameActive) createBubble();
                    }, currentSpawnRate);
                }, 1000);

                // Crear burbujas iniciales
                setTimeout(() => createBubble(), 300);
                setTimeout(() => createBubble(), 800);
                setTimeout(() => createBubble(), 1200);
            }
            
            // üß† JUEGO DE MEMORIA
            startMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: `üê†üí≠ "¬°A ejercitar la mente!"\n\nüéØ **Objetivo:**\nEncuentra todas las parejas de cartas\nRecuerda d√≥nde est√°n las im√°genes\n\nüèÜ **Recompensas:**\n+3 burbujas por pareja encontrada\nBonus de velocidad\n\nüÉè Cartas: 8 parejas (16 cartas)`,
                    confirmText: 'üß† ¬°Empezar!',
                    cancelText: '‚ùå Cancelar',
                    onConfirm: () => {
                        this.runMemoryGame();
                    }
                });
            }
            
            runMemoryGame() {
                // Implementaci√≥n del juego de memoria
                this.showCustomModal({
                    title: 'üß† ¬°Jugando Memoria!',
                    message: `üéÆ **DEMO DEL JUEGO**\n\nüÉè Parejas encontradas: 6/8\nüëÅÔ∏è Cartas volteadas: 18\n‚è±Ô∏è Tiempo: 45s\n\nüèÜ Puntuaci√≥n actual: +18 burbujas`,
                    confirmText: '‚úÖ Terminar',
                    onConfirm: () => {
                        // Dar recompensa
                        this.gameState.bubbles += 18;
                        this.gameState.stars += 3;
                        this.updateUI();
                        
                        this.showCustomModal({
                            title: 'üèÜ ¬°Excelente Memoria!',
                            message: `üê†üí≠ "¬°Tienes una memoria incre√≠ble!"\n\nüéâ **Recompensas obtenidas:**\nü´ß +18 burbujas\n‚≠ê +3 estrellas\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                            confirmText: 'ü•∞ ¬°Gracias!',
                            onConfirm: () => {}
                        });
                    }
                });
            }
            
            // üíä DAR MEDICINA (PLACEHOLDER)
            giveMedicine() {
                console.log('üíä Dando medicina al pez...');
                this.gameState.lastMedicine = Date.now();
                this.gameState.health = Math.min(100, this.gameState.health + 40);
                console.log('üè• Pez curado - Salud:', this.gameState.health);
            }

            // üí∞ SISTEMA DE COSTOS PROGRESIVOS
            getBackgroundCost(bgName) {
                const costs = {
                    'cartoon': 15,   // Primer fondo - f√°cil de conseguir
                    'coral': 25,     // Segundo fondo
                    'mario': 40,     // M√°s caro
                    'minecraft': 60  // El m√°s caro
                };
                return costs[bgName] || 30; // Costo por defecto
            }

            // üéÜ EFECTOS DE RECOMPENSA
            showRewardEffect(type, amount, sourceElement = null) {
                const emoji = type === 'bubbles' ? 'ü´ß' : '‚≠ê';
                const color = type === 'bubbles' ? 'rgba(100,200,255,0.6)' : 'rgba(255,215,0,0.6)';
                
                // Posici√≥n de origen (elemento fuente o centro de pantalla)
                let startX, startY;
                if (sourceElement) {
                    const rect = sourceElement.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                } else {
                    startX = window.innerWidth / 2;
                    startY = window.innerHeight / 2;
                }

                // Crear m√∫ltiples burbujas seg√∫n la cantidad
                const bubbleCount = Math.min(amount, 5); // M√°ximo 5 burbujas
                for (let i = 0; i < bubbleCount; i++) {
                    setTimeout(() => {
                        this.createRewardBubble(emoji, color, startX, startY, i);
                    }, i * 150); // Delay escalonado
                }

                // Explosi√≥n dorada al final
                setTimeout(() => {
                    this.createRewardExplosion(startX, startY);
                }, bubbleCount * 150 + 500);
            }

            createRewardBubble(emoji, color, startX, startY, index) {
                const bubble = document.createElement('div');
                bubble.className = 'reward-bubble';
                bubble.textContent = emoji;
                bubble.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), ${color})`;
                bubble.style.boxShadow = `0 0 20px ${color}`;
                
                // Posici√≥n inicial con variaci√≥n
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 50;
                bubble.style.left = (startX + offsetX - 30) + 'px';
                bubble.style.top = (startY + offsetY - 30) + 'px';
                
                document.body.appendChild(bubble);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                }, 2000);
            }

            createRewardExplosion(x, y) {
                const explosion = document.createElement('div');
                explosion.className = 'reward-explosion';
                explosion.style.left = (x - 50) + 'px';
                explosion.style.top = (y - 50) + 'px';
                
                document.body.appendChild(explosion);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.remove();
                    }
                }, 800);
            }

            // üéì MODAL DE TUTORIAL BONITO
            showTutorialModal() {
                this.showCustomModal({
                    title: 'Tu Primera Aventura Marina',
                    message: `"¬°Hola! Soy tu nuevo compa√±ero virtual."\n\nü•ö Primero aparecer√© como un huevito\n‚è∞ En 24 horas eclosionar√© y nadar√© contigo\nüéÆ Mientras tanto, puedes jugar minijuegos\n\n¬°Clica aqu√≠ y aparecer√° tu huevito de pez!`,
                    confirmText: '¬°Colocar mi huevo!',
                    onConfirm: () => {
                        // CERRAR MODAL PRIMERO para ver el efecto
                        const customModal = document.querySelector('.custom-modal');
                        if (customModal) {
                            customModal.remove();
                        }
                        
                        // Peque√±o delay para que se vea el cierre
                        setTimeout(() => {
                            this.startEggPlacement();
                        }, 300);
                    }
                });
            }

            // ü•ö INICIAR COLOCACI√ìN DEL HUEVO
            startEggPlacement() {
                console.log('‚ú® INICIANDO MAGIA DEL HUEVO...');
                
                // CERRAR MODAL INMEDIATAMENTE para que no se vea el huevo
                const modals = document.querySelectorAll('.custom-modal, .modal-overlay, .game-modal-overlay');
                modals.forEach(modal => {
                    modal.remove();
                    console.log('üö™ Modal eliminada');
                });
                
                // Tambi√©n ocultar cualquier modal por CSS
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 100);
                
                // üéµ INICIAR M√öSICA DE FONDO AL APARECER EL HUEVO (si no est√° ya sonando)
                if (window.audioManager && !window.audioManager.isMuted && !window.audioManager.backgroundMusic?.played?.length) {
                    window.audioManager.startBackgroundMusic();
                    console.log('üéµ M√∫sica de fondo iniciada con el huevo');
                }
                
                // ASEGURAR que NO hay huevo todav√≠a
                this.gameState.stage = 'waiting';
                this.gameState.eggStartTime = null;
                
                // üè∑Ô∏è RESETEAR NOMBRE PARA NUEVO PEZ
                this.gameState.hasAskedForName = false;
                this.gameState.fishName = null;
                console.log('üè∑Ô∏è Estado de nombre reseteado para nuevo pez');
                
                // üßº RESETEAR SOLO PANTALLA Y BURBUJAS AL INICIAR HUEVO
                this.gameState.needs.dirt = 0;     // Pantalla limpia
                this.gameState.bubbles = 0;        // Sin burbujas
                console.log('üßº Pantalla reseteada: limpia, sin burbujas');
                
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                // PASO 1: USAR EL MISMO EFECTO QUE EL NACIMIENTO DEL PEZ
                console.log('üöÄ LLAMANDO createEggExplosionBubbles()...');
                this.createEggExplosionBubbles();
                console.log('üöÄ createEggExplosionBubbles() EJECUTADO');
                    
                console.log('‚ú® Burbujas de aparici√≥n del huevo (como nacimiento)...');
                
                // PASO 2: Colocar huevo y EMPEZAR CRON√ìMETRO (2.2s)
                    setTimeout(() => {
                    const now = Date.now();
                    
                    // Colocar huevo Y empezar cron√≥metro AL MISMO TIEMPO
                    this.gameState.stage = 'egg';
                    this.gameState.eggStartTime = now;
                    this.egg.x = centerX;
                    this.egg.y = centerY;
                    
                    // Iniciar animaci√≥n de aparici√≥n del huevo
                    this.startEggAppearanceAnimation();
                    
                    console.log('ü•ö ¬°Huevo + cron√≥metro iniciados!');
                }, 800); // MUCHO M√ÅS R√ÅPIDO (era 2200ms)
                
                // PASO 3: Desactivar efectos gradualmente (6s total)
                setTimeout(() => {
                    this.gameState.showMagicBubbles = false;
                    console.log('‚ú® Magia completada');
                }, 6000);
            }

            // ü´ß BURBUJAS COPIADAS DEL TEST QUE FUNCIONA
            createSimpleBubbles() {
                console.log('‚ú® COPIANDO SISTEMA DEL TEST...');
                
                // LIMPIAR COMPLETAMENTE
                this.bgBubbles = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // EXACTAMENTE como en el test que funciona
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 150;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const burbuja = {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        r: 8 + Math.random() * 12,
                        alpha: 0.6 + Math.random() * 0.4,
                        color: `hsl(${190 + Math.random() * 40}, 70%, 70%)`,
                        life: 120, // 2 segundos a 60fps
                        sparkle: Math.random() > 0.5,
                        isTestBubble: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(burbuja);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas TEST creadas`);
            }

            // üå´Ô∏è EFECTOS ANTES DEL HUEVO - SISTEMA PERSISTENTE (VIEJO)
            createPreEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('‚ú® TEST BURBUJAS INMORTALES...');
                
                // LIMPIAR burbujas existentes
                this.bgBubbles = [];
                
                // TEST: 10 burbujas INMORTALES que NUNCA se eliminen
                for (let i = 0; i < 10; i++) {
                    const x = 50 + i * 35;
                    const y = 150;
                    
                    const bubble = {
                        x: x,
                        y: y,
                        vx: 0, // SIN MOVIMIENTO
                        vy: 0, // EST√ÅTICAS
                        r: 25, // GRANDES
                        alpha: 1, // OPACAS
                        color: '#ff0000', // ROJO BRILLANTE
                        life: 999999, // VIDA INFINITA
                        maxLife: 999999,
                        sparkle: false,
                        isAppearanceEffect: true,
                        immortal: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(bubble);
                    console.log(`üî¥ Burbuja INMORTAL ${i+1} en (${x}, ${y})`);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas INMORTALES creadas`);
            }

            // üí¨ MENSAJE TEMPORAL EN PANTALLA
            showTemporaryMessage(text, duration) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 40%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 50, 100, 0.8);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 12px;
                    font-size: 14px;
                    font-weight: bold;
                    text-align: center;
                    z-index: 1500;
                    border: 2px solid rgba(255,255,255,0.4);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    animation: messageFloat 0.5s ease-out;
                `;
                messageDiv.textContent = text;
                
                // A√±adir CSS de animaci√≥n si no existe
                if (!document.getElementById('messageFloatStyle')) {
                    const style = document.createElement('style');
                    style.id = 'messageFloatStyle';
                    style.textContent = `
                        @keyframes messageFloat {
                            from { 
                                transform: translate(-50%, -50%) scale(0.8);
                                opacity: 0;
                            }
                            to { 
                                transform: translate(-50%, -50%) scale(1);
                                opacity: 1;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageDiv);
                
                // Remover despu√©s del tiempo especificado
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, duration);
            }
            
            // üéÆ MOSTRAR JUEGOS - MODAL SIMPLE Y FUNCIONAL
            showGames() {
                console.log('üéÆ Abriendo modal de juegos simple...');
                
                // Usar la nueva modal simple
                const modal = document.getElementById('gamesModal');
                modal.style.display = 'flex';
                
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar estrellas en el modal
                const modalStarsCount = document.getElementById('modal-stars-count');
                if (modalStarsCount) {
                    modalStarsCount.textContent = this.gameState.stars || 0;
                }
                
                // Actualizar disponibilidad de juegos din√°micamente
                this.updateGameAvailabilitySquare();
            }
            
            // üéØ ACTUALIZAR DISPONIBILIDAD DE JUEGOS CUADRADOS
            updateGameAvailabilitySquare() {
                const stars = this.gameState.stars || 0;
                
                const gameRequirements = {
                    'bubbles': 0,
                    'memory': 10,
                    'snake': 25,
                    'puzzle': 50,
                    'race': 75,
                    'target': 100,
                    'adventure': 150,
                    'tower': 200,
                    'boss': 300
                };
                
                // Actualizar cada juego seg√∫n las estrellas disponibles
                Object.entries(gameRequirements).forEach(([gameId, requiredStars]) => {
                    const card = document.querySelector(`[data-game="${gameId}"]`);
                    if (card) {
                        if (stars >= requiredStars) {
                            card.classList.remove('locked');
                            card.classList.add('available');
                        } else {
                            card.classList.add('locked');
                            card.classList.remove('available');
                        }
                    }
                });
                
                console.log(`üéÆ Juegos cuadrados actualizados. Estrellas: ${stars}`);
            }
            
            // Funci√≥n temporal para mantener compatibilidad
            populateGamesGrid() {
                // Esta funci√≥n ya no es necesaria con el nuevo dise√±o
                console.log('üéÆ populateGamesGrid() - Ya no es necesaria con el nuevo dise√±o');

                const buttonsHTML = gameButtons.map(game => {
                    if (game.available) {
                        return `<button onclick="game.startGame('${game.id}')" style="
                            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
                            border: 2px solid #0277bd;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: white;
                            font-size: 16px;
                            cursor: pointer;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                        </button>`;
                    } else {
                        return `<button style="
                            background: linear-gradient(135deg, #bbb, #999);
                            border: 2px solid #666;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: #666;
                            font-size: 16px;
                            cursor: not-allowed;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                            opacity: 0.6;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                            <div style="font-size: 10px;">‚≠ê ${game.stars}</div>
                        </button>`;
                    }
                }).join('');

                this.showCustomModal({
                    title: 'üéÆ Minijuegos',
                    message: `üê†üí≠ "¬°Elige un juego para divertirnos!"\n\n<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 5px;">${buttonsHTML}</div>`,
                    confirmText: '‚ùå Cerrar',
                    onConfirm: () => {}
                });
            }
            
            populateGamesGrid() {
                const gamesGrid = document.getElementById('gamesGrid');
                if (!gamesGrid) return;
                
                const games = [
                    { id: 'bubbles', icon: 'ü´ß', name: 'Burbujas', available: true, stars: 0 },
                    { id: 'memory', icon: 'üß†', name: 'Memoria', available: this.gameState.stars >= 10, stars: 10 },
                    { id: 'target', icon: 'üéØ', name: 'Punter√≠a', available: false, stars: 25 },
                    { id: 'race', icon: 'üèÉ', name: 'Carrera', available: false, stars: 50 },
                    { id: 'puzzle', icon: 'üß©', name: 'Puzzle', available: false, stars: 75 },
                    { id: 'adventure', icon: 'üó∫Ô∏è', name: 'Aventura', available: false, stars: 100 }
                ];
                
                gamesGrid.innerHTML = games.map(game => {
                    const isAvailable = game.available;
                    
                    return `
                        <div class="game-card ${isAvailable ? 'available' : 'locked'}" 
                             data-game-id="${game.id}" 
                             data-available="${isAvailable}"
                             data-stars="${game.stars}">
                            <div class="game-icon">${game.icon}</div>
                            <div class="game-name">${game.name}</div>
                            ${!isAvailable ? `<div class="game-requirement">‚≠ê ${game.stars}</div>` : ''}
                        </div>
                    `;
                }).join('');

                // A√±adir event listeners a las cartas de juego
                setTimeout(() => {
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.addEventListener('click', (e) => {
                            const gameId = card.dataset.gameId;
                            const isAvailable = card.dataset.available === 'true';
                            const stars = parseInt(card.dataset.stars);

                            console.log(`üéÆ Click en juego: ${gameId}, disponible: ${isAvailable}`);

                            if (isAvailable) {
                                console.log(`üöÄ Iniciando juego: ${gameId}`);
                                // CERRAR MODAL ANTES DE INICIAR JUEGO
                                const customModal = document.querySelector('.custom-modal');
                                if (customModal) {
                                    customModal.remove();
                                }
                                this.startGame(gameId);
                            } else {
                                console.log(`üîí Juego bloqueado: ${gameId}, necesita ${stars} estrellas`);
                                this.showGameLocked(stars);
                            }
                        });
                    });
                }, 100);
            }
            
            // üéí MOSTRAR INVENTARIO (PLACEHOLDER)
            showInventory() {
                console.log('üéí Abriendo inventario...');
                
                this.showCustomModal({
                    title: 'üéí Mi Inventario',
                    message: `üê†üí≠ "¬°Mira todas mis cosas!"

üí∞ Tienes: ü´ß ${this.gameState.bubbles || 0} burbujas | ‚≠ê ${this.gameState.stars || 0} estrellas

üåä **Fondos de Pecera** - DISPONIBLE
Cambia el fondo de tu acuario
üñºÔ∏è ${this.availableBackgrounds ? this.availableBackgrounds.length : 23} fondos disponibles

üé® **Decoraciones** - PR√ìXIMAMENTE
Rocas, plantas, castillos...
üöß En desarrollo

üçΩÔ∏è **Comida Especial** - PR√ìXIMAMENTE  
Comida premium y de cumplea√±os
üöß En desarrollo`,
                    confirmText: 'üåä Ver Fondos',
                    cancelText: '‚ùå Cerrar',
                    onConfirm: () => {
                        // Abrir selector de fondos (funci√≥n existente)
                        document.getElementById('inventoryModal').style.display = 'flex';
                    },
                    onCancel: () => {
                        console.log('üéí Inventario cerrado');
                    }
                });
            }
            
            // üéí ACTUALIZAR DISPONIBILIDAD DEL INVENTARIO
            updateInventoryAvailability() {
                console.log('üéí Actualizando disponibilidad del inventario...');
                
                if (!this.availableBackgrounds) {
                    console.warn('‚ö†Ô∏è availableBackgrounds no est√° disponible');
                    return;
                }
                
                const grid = document.querySelector('.inventory-grid-simple');
                if (!grid) {
                    console.warn('‚ö†Ô∏è Grid de inventario no encontrado');
                    return;
                }
                
                // Limpiar grid actual
                grid.innerHTML = '';
                
                // üé® BLOQUE DE FONDOS
                const backgroundsSection = document.createElement('div');
                backgroundsSection.className = 'inventory-section';
                backgroundsSection.innerHTML = `
                    <div class="inventory-section-header">
                        <h3>üåä Fondos de Pecera</h3>
                        <span class="inventory-section-subtitle">ü´ß Tienes: ${this.gameState.bubbles || 0} burbujas</span>
                    </div>
                    <div class="inventory-section-grid"></div>
                `;
                grid.appendChild(backgroundsSection);
                
                const backgroundsGrid = backgroundsSection.querySelector('.inventory-section-grid');
                
                // Crear items din√°micamente basados en fondos reales
                this.availableBackgrounds.forEach((bg, index) => {
                    const item = document.createElement('div');
                    const isUnlocked = bg.unlocked !== false; // Por defecto desbloqueado
                    const isSelected = this.gameState.currentBackground === bg.name;
                    const cost = bg.cost || 0;
                    const canAfford = this.gameState.bubbles >= cost;
                    const isOwned = bg.unlocked === true || bg.name === 'Mi casa'; // Mi casa es gratis
                    
                    item.className = `inventory-item-square ${isOwned ? 'owned' : (canAfford ? 'available' : 'locked')}`;
                    if (isSelected) item.classList.add('selected');
                    
                    item.dataset.item = `bg-${bg.name}`;
                    item.dataset.cost = cost;
                    item.dataset.owned = isOwned;
                    
                    // Icono basado en el nombre del fondo
                    let icon = 'üåä';
                    switch(bg.name) {
                        case 'basic': icon = 'üåä'; break;
                        case 'cartoon': icon = 'üé®'; break;
                        case 'coral': icon = 'ü™∏'; break;
                        case 'mario': icon = 'üçÑ'; break;
                        case 'minecraft': icon = 'üß±'; break;
                        default: icon = 'üåä';
                    }
                    
                    item.innerHTML = `
                        <div class="inventory-square-preview" style="background-image: url('./images/backgrounds/${bg.file}')${!isOwned && !canAfford ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="inventory-square-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="inventory-square-price">${cost === 0 ? 'Gratis' : cost + 'ü´ß'}</div>
                        ${!isOwned && !canAfford ? `
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">üîí</div>
                                <div class="lock-stars">${cost}ü´ß</div>
                            </div>
                        ` : ''}
                        ${isSelected ? '<div class="selected-indicator">‚úì</div>' : ''}
                        ${isOwned && !isSelected ? '<div class="owned-indicator">‚úì</div>' : ''}
                    `;
                    
                    backgroundsGrid.appendChild(item);
                });
                
                // üé® BLOQUE DE DECORACIONES (PR√ìXIMAMENTE)
                const decorationsSection = document.createElement('div');
                decorationsSection.className = 'inventory-section';
                decorationsSection.innerHTML = `
                    <div class="inventory-section-header">
                        <h3>üé® Decoraciones</h3>
                        <span class="inventory-section-subtitle">üöß Pr√≥ximamente</span>
                    </div>
                    <div class="inventory-section-grid">
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">üè∞</div>
                            <div class="inventory-square-name">Castillo</div>
                            <div class="inventory-square-price">50ü´ß</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">üöß</div>
                                <div class="lock-stars">Pr√≥ximamente</div>
                            </div>
                        </div>
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">üåø</div>
                            <div class="inventory-square-name">Plantas</div>
                            <div class="inventory-square-price">30ü´ß</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">üöß</div>
                                <div class="lock-stars">Pr√≥ximamente</div>
                            </div>
                        </div>
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">ü™®</div>
                            <div class="inventory-square-name">Rocas</div>
                            <div class="inventory-square-price">20ü´ß</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">üöß</div>
                                <div class="lock-stars">Pr√≥ximamente</div>
                            </div>
                        </div>
                    </div>
                `;
                grid.appendChild(decorationsSection);
                
                // A√±adir event listeners a los elementos del inventario
                const inventoryItems = document.querySelectorAll('.inventory-item-square');
                inventoryItems.forEach(card => {
                    const itemId = card.dataset.item;
                    if (!itemId) return;
                    
                    card.addEventListener('click', () => {
                        const isLocked = card.classList.contains('locked');
                        
                        if (!isLocked && window.game) {
                            console.log(`üéí Usando item: ${itemId}`);
                            // Cerrar modal primero
                            const modal = document.getElementById('inventoryModal');
                            modal.style.opacity = '0';
                            setTimeout(() => {
                                modal.style.display = 'none';
                                // Llamar a la funci√≥n de usar item
                                window.game.useInventoryItem?.(itemId);
                            }, 300);
                        } else if (isLocked) {
                            console.log(`üîí Item bloqueado: ${itemId}`);
                            // Mostrar mensaje de item bloqueado
                            const bubblesNeeded = card.querySelector('.lock-stars')?.textContent || '';
                            window.game?.showItemLocked?.(bubblesNeeded);
                        }
                    });
                });
                
                console.log(`üéí Inventario actualizado con ${this.availableBackgrounds.length} fondos`);
            }
            
            // üì∏ FUNCI√ìN PLACEHOLDER ELIMINADA - USAR LA FUNCI√ìN REAL M√ÅS ABAJO
            
            // üîÑ DETECCI√ìN MUY TEMPRANA DE BORDES
            handleSimpleFishBoundaries() {
                const fish = this.fish;
                const fishSize = 60; // Tama√±o aproximado del pez Lottie
                const padding = fishSize + 40; // MARGEN MUY GRANDE (100px total)
                
                // DETECCI√ìN TEMPRANA: Antes de que se salga del borde
                
                // BORDE IZQUIERDO
                if (fish.x <= padding && fish.direction === -1) {
                    fish.direction = 1; // Girar a la derecha
                    fish.x = padding + 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana IZQUIERDO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la DERECHA`);
                }
                
                // BORDE DERECHO  
                if (fish.x >= this.canvas.width - padding && fish.direction === 1) {
                    fish.direction = -1; // Girar a la izquierda
                    fish.x = this.canvas.width - padding - 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana DERECHO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la IZQUIERDA`);
                }
                
                // BORDE SUPERIOR - M√°s margen
                if (fish.y <= this.canvas.height * 0.2 && fish.verticalDirection === -1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : 1;
                    fish.y = this.canvas.height * 0.2 + 10;
                    console.log(`üê† Detecci√≥n MUY temprana SUPERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ABAJO ‚Üì'}`);
                }
                
                // BORDE INFERIOR - M√°s margen
                if (fish.y >= this.canvas.height * 0.8 && fish.verticalDirection === 1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : -1;
                    fish.y = this.canvas.height * 0.8 - 10;
                    console.log(`üê† Detecci√≥n MUY temprana INFERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ARRIBA ‚Üë'}`);
                }
                
                // SEGURIDAD SILENCIOSA: Solo reposicionar sin spam de logs
                const safetyMargin = 80;
                if (fish.x < safetyMargin) {
                    fish.x = safetyMargin;
                    fish.direction = 1; // Forzar direcci√≥n hacia la derecha
                }
                if (fish.x > this.canvas.width - safetyMargin) {
                    fish.x = this.canvas.width - safetyMargin;
                    fish.direction = -1; // Forzar direcci√≥n hacia la izquierda
                }
                if (fish.y < safetyMargin) {
                    fish.y = safetyMargin;
                    fish.verticalDirection = 1; // Forzar hacia abajo
                }
                if (fish.y > this.canvas.height - safetyMargin) {
                    fish.y = this.canvas.height - safetyMargin;
                    fish.verticalDirection = -1; // Forzar hacia arriba
                }
            }
            
            // üîÑ ORIENTACI√ìN CORREGIDA
            updateFishOrientation() {
                const fish = this.fish;
                const container = document.getElementById('lottieContainer');
                if (!container) return;
                
                // EL PEZ LOTTIE MIRA HACIA LA IZQUIERDA POR DEFECTO
                // Para que vaya a la DERECHA necesitamos invertirlo
                // direction = 1 (derecha) ‚Üí scaleX(-1) invertido
                // direction = -1 (izquierda) ‚Üí scaleX(1) normal
                
                const scaleX = fish.direction === 1 ? -1 : 1;
                
                // Solo cambiar si es diferente
                if (fish.facing !== scaleX) {
                    fish.facing = scaleX;
                    container.style.transform = `translate(-50%, -50%) scaleX(${scaleX})`;
                    
                    console.log(`üîÑ Pez orientado: ${fish.direction === 1 ? 'DERECHA ‚Üí (scaleX -1)' : 'IZQUIERDA ‚Üê (scaleX 1)'}`);
                }
            }
            
            updateCanvasFishAnimations(deltaTime) {
                const fish = this.fish;
                
                // Actualizar timers de animaci√≥n
                if (!fish.breatheTime) fish.breatheTime = 0;
                if (!fish.blinkTime) fish.blinkTime = 0;
                if (!fish.finTime) fish.finTime = 0;
                if (!fish.bubbleTime) fish.bubbleTime = 0;
                if (!fish.floatTime) fish.floatTime = 0;
                if (!fish.baseY) fish.baseY = this.canvas.height * 0.6;
                
                fish.breatheTime += deltaTime * 1.5;
                fish.blinkTime += deltaTime;
                fish.finTime += deltaTime * 2;
                fish.bubbleTime += deltaTime;
                fish.floatTime += deltaTime * 0.8;
                
                // Animaciones Canvas
                const breatheCycle = fish.breatheTime % (2.5 * Math.PI);
                fish.breatheScale = 1 + Math.sin(breatheCycle) * 0.06;
                
                // PARPADEO DESHABILITADO - Se maneja en updateFishMovement()
                // if (fish.blinkTime > 4 + Math.random() * 3) {
                //     fish.eyeOpen = 0;
                //     setTimeout(() => {
                //         if (this.fish) this.fish.eyeOpen = 1;
                //     }, 200);
                //     fish.blinkTime = 0;
                // }
                
                const finCycle = (fish.finTime % (2.5 * Math.PI)) / (2.5 * Math.PI);
                const minRotation = -36 * Math.PI / 180;
                const maxRotation = 4 * Math.PI / 180;
                fish.finRotation = minRotation + (maxRotation - minRotation) * (Math.sin(finCycle * Math.PI * 2) * 0.5 + 0.5);
                
                const floatCycle = fish.floatTime % (2.5 * Math.PI);
                const floatAmount = 10;
                fish.y = fish.baseY + Math.sin(floatCycle) * floatAmount;
                
                if (fish.bubbleTime > 4 + Math.random() * 6) {
                    this.createFishBubble();
                    fish.bubbleTime = 0;
                }
            }
            
            // üîÑ EVOLUCI√ìN AUTOM√ÅTICA CON EFECTOS ESPECTACULARES
            checkEvolution() {
                if (!this.fish || this.evolutionInProgress) return;
                
                const ageInDays = this.gameState.ageInDays || 0;
                const currentStage = this.gameState.stage;
                
                // Beb√© ‚Üí Joven (3 d√≠as)
                if (currentStage === 'baby' && ageInDays >= 3 && !this.gameState.hasEvolvedToYoung) {
                    this.startEvolution('young');
                    this.gameState.hasEvolvedToYoung = true;
                }
                
                // Joven ‚Üí Adulto (8 d√≠as)
                if (currentStage === 'young' && ageInDays >= 8 && !this.gameState.hasEvolvedToAdult) {
                    this.startEvolution('adult');
                    this.gameState.hasEvolvedToAdult = true;
                }
            }
            
            // üé≠ INICIAR EVOLUCI√ìN ESPECTACULAR
            startEvolution(newStage) {
                console.log(`üé≠ ¬°EVOLUCI√ìN INICIADA! ${this.gameState.stage} ‚Üí ${newStage}`);
                
                this.evolutionInProgress = true;
                this.evolutionStartTime = Date.now();
                this.evolutionTargetStage = newStage;
                
                // ü´ß CREAR EXPLOSI√ìN DE BURBUJAS (como el huevo)
                this.createEvolutionBubbles();
                
                // üîä SONIDO DE EVOLUCI√ìN
                if (window.audioManager) {
                    window.audioManager.playSound('evolution'); // Sonido m√°gico espec√≠fico
                }
                
                // üéâ EFECTO EN EL PEZ
                if (this.fish) {
                    this.fish.happyBurst = 4.0; // Giro m√°s largo
                    this.fish.spinKind = "evolution";
                }
                
                // ‚è∞ PROGRAMAR CAMBIO DE ETAPA DESPU√âS DE 2 SEGUNDOS
                setTimeout(() => {
                    this.completeEvolution(newStage);
                }, 2000);
            }
            
            // üéÜ CREAR BURBUJAS DE EVOLUCI√ìN (COMO LAS DEL HUEVO)
            createEvolutionBubbles() {
                console.log('üéÜ Creando explosi√≥n de evoluci√≥n...');
                
                // Limpiar burbujas anteriores
                this.explosionBubbles = this.explosionBubbles || [];
                this.explosionBubbles.length = 0;
                
                // Crear explosi√≥n desde el pez
                const fishX = this.fish ? this.fish.x : this.canvas.width / 2;
                const fishY = this.fish ? this.fish.y : this.canvas.height / 2;
                
                // üéÜ EXPLOSI√ìN MASIVA DE EVOLUCI√ìN (como el huevo pero dorada)
                for (let i = 0; i < 120; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 40 + Math.random() * 120; // Velocidad variada
                    const size = 4 + Math.random() * 10; // Tama√±os variados
                    const life = 3 + Math.random() * 2; // Duraderas
                    
                    // Colores DORADOS Y AMARILLOS brillantes
                    const colors = ['#FFD700', '#FFA500', '#FFEB3B', '#FFF176', '#FFCC02', '#FFB300', '#FF8F00'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: fishX + (Math.random() - 0.5) * 60,
                        y: fishY + (Math.random() - 0.5) * 60,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.4, // M√°s brillo
                        color: color,
                        opacity: 0.9
                    });
                }
                
                console.log(`üéÜ Burbujas de evoluci√≥n doradas creadas: ${this.explosionBubbles.length}`);
            }
            
            // ‚úÖ COMPLETAR EVOLUCI√ìN CON MODAL BONITO
            completeEvolution(newStage) {
                // Cambiar etapa
                this.gameState.stage = newStage;
                this.evolutionInProgress = false;
                
                // üìè ACTUALIZAR TAMA√ëO DEL PEZ (LOTTIE Y CANVAS)
                if (this.fish) {
                    this.fish.size = this.getFishSizeForStage(newStage);
                    
                    // ESCALAR LOTTIE SEG√öN ETAPA - M√ÅS GRANDES
                    const scaleByStage = {
                        'baby': 1.0,
                        'young': 1.5, // 50% m√°s grande (antes 20%)
                        'adult': 1.8  // 80% m√°s grande (antes 40%)
                    };
                    
                    this.fish.targetScale = scaleByStage[newStage] || 1.0;
                    this.fish.scale = this.fish.targetScale; // Cambio inmediato
                    
                    console.log(`üìè Tama√±o actualizado para ${newStage}: size=${this.fish.size}px, scale=${this.fish.scale}`);
                }
                
                // üé® RECARGAR LOTTIE CON NUEVA ETAPA (MANTENER DISE√ëOS BONITOS)
                this.reloadLottieForStage(newStage);
                
                // A√±adir al √°lbum
                const messages = {
                    'young': {
                        title: 'üå± ¬°He crecido!',
                        desc: 'Ya no soy un beb√©. ¬°Ahora soy un pez joven y m√°s fuerte!'
                    },
                    'adult': {
                        title: 'üëë ¬°Soy adulto!',
                        desc: 'He crecido completamente. ¬°Ahora soy un pez adulto y sabio!'
                    }
                };
                
                const msg = messages[newStage];
                if (msg) {
                    this.addAlbumEvent('evolution', msg.title, msg.desc);
                    
                    // üéâ MOSTRAR MODAL BONITO
                    this.showCustomModal({
                        title: msg.title,
                        message: `${msg.desc}\n\n‚ú® ¬°Mis necesidades han cambiado!\nüçé Tendr√© hambre m√°s lentamente\nüßπ Me ensuciar√© menos\nüéÆ Me aburrir√© menos`,
                        confirmText: 'üéâ ¬°Qu√© emocionante!',
                        onConfirm: () => {
                            console.log(`‚úÖ Evoluci√≥n a ${newStage} completada`);
                            this.saveGame(); // Guardar inmediatamente
                        }
                    });
                }
                
                console.log(`üé≠ EVOLUCI√ìN COMPLETADA: ${newStage}`);
            }
            
            // üé® RECARGAR LOTTIE PARA NUEVA ETAPA (PRESERVANDO ESCALA)
            async reloadLottieForStage(newStage) {
                try {
                    // Guardar escala antes de destruir
                    const savedScale = this.fish ? this.fish.scale : 1.0;
                    const savedPosition = this.fish ? {x: this.fish.x, y: this.fish.y} : null;
                    
                    // Destruir animaci√≥n actual
                    if (this.lottieAnimation) {
                        this.lottieAnimation.destroy();
                        this.lottieAnimation = null;
                    }
                    
                    // Cargar nueva animaci√≥n
                    await this.createLottieFish();
                    
                    // RESTAURAR ESCALA Y POSICI√ìN
                    if (this.fish) {
                        this.fish.scale = savedScale;
                        this.fish.targetScale = savedScale;
                        this.fish.growing = false; // No volver a crecer
                        
                        if (savedPosition) {
                            this.fish.x = savedPosition.x;
                            this.fish.y = savedPosition.y;
                        }
                    }
                    
                    console.log(`üé® Lottie recargado para etapa: ${newStage} con escala: ${savedScale}`);
                    
                } catch (error) {
                    console.error('‚ùå Error recargando Lottie:', error);
                }
            }
            
            // üçé SISTEMA DE NECESIDADES
            
            // FUNCI√ìN VIEJA DESHABILITADA - Usamos updateAllNeedBubbles ahora
            // updateNeeds(deltaTime) {
            //     // Esta funci√≥n vieja estaba mostrando texto en lugar de iconos
            //     // Ahora usamos updateAllNeedBubbles() que muestra los iconos correctamente
            // }
            
            // FUNCI√ìN VIEJA DESHABILITADA - Mostraba texto en lugar de iconos
            // showNeedBubble(icon, urgent = false) {
            //     // Esta funci√≥n vieja est√° comentada porque mostraba texto
            //     // Usamos la nueva showNeedBubble(bubbleId, needType, offsetX, offsetY)
            // }
            
            // üé® SISTEMA DE FONDOS
            
            async loadAvailableBackgrounds() {
                // Lista de todos los fondos disponibles
                const knownBackgrounds = [
                    'Mi casa.png',           // Renombrado de basic
                    'Azulito.png',
                    'Bajo el mar.png',
                    'Bolas de dragon.png',
                    'Cuadrados corales.png',
                    'Cuadrados de noche.png',
                    'Cuadrados en el mar.png',
                    'El cielo.png',
                    'Entre corales.png',
                    'Guardianes.png',
                    'Hielo.png',
                    'Magico.png',
                    'Mi paraiso.png',
                    'Oscuro.png',
                    'Peppa Fish.png',
                    'Perretes.png',
                    'Piratas.png',
                    'Plastelina Isla.png',
                    'Plastelina.png',
                    'Playa.png',
                    'Slayer.png',
                    'Tuberias.png',
                    'Villa Volcan.png'
                ];
                
                for (const bgFile of knownBackgrounds) {
                    const bgName = bgFile.replace('.png', ''); // Usar nombre completo sin extensi√≥n
                    try {
                        const img = new Image();
                        img.src = `./images/backgrounds/${bgFile}`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            setTimeout(reject, 2000); // Timeout de 2s
                        });
                        
                        this.availableBackgrounds.push({
                            name: bgName,
                            file: bgFile,
                            image: img,
                            cost: bgName === 'Mi casa' ? 0 : this.getBackgroundCost(bgName), // Mi casa es gratis
                            unlocked: bgName === 'Mi casa' // Solo Mi casa desbloqueado
                        });
                        
                        console.log(`‚úÖ Fondo cargado: ${bgName}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar: ${bgFile}`);
                    }
                }
                
                console.log(`üé® ${this.availableBackgrounds.length} fondos disponibles`);
                this.populateBackgroundsGrid();
            }
            
            populateBackgroundsGrid() {
                const grid = document.getElementById('backgroundsGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                for (const bg of this.availableBackgrounds) {
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    if (this.gameState.currentBackground === bg.name) {
                        card.classList.add('selected');
                    }
                    
                    const isLocked = bg.cost > 0 && this.gameState.bubbles < bg.cost;
                    
                    card.innerHTML = `
                        <div class="item-preview" style="background-image: url('./images/backgrounds/${bg.file}')${isLocked ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="item-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="item-cost">${bg.cost === 0 ? 'Gratis' : bg.cost + ' ü´ß'}</div>
                        ${isLocked ? '<div class="locked-overlay">üîí</div>' : ''}
                    `;
                    
                    card.addEventListener('click', () => {
                        this.useInventoryItem(`bg-${bg.name}`);
                    });
                    
                    grid.appendChild(card);
                }
            }
            
            selectBackground(bgName) {
                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                if (!bg) return;
                
                // Si ya est√° seleccionado, no hacer nada
                if (this.gameState.currentBackground === bgName) {
                    console.log('üé® Ya tienes este fondo seleccionado');
                    return;
                }
                
                // Si cuesta burbujas, pedir confirmaci√≥n
                if (bg.cost > 0) {
                    // Verificar si tiene suficientes burbujas
                    if (this.gameState.bubbles < bg.cost) {
                        const needed = bg.cost - this.gameState.bubbles;
                        this.showCustomModal({
                            title: 'üê†üí≠ ¬°Me encanta este fondo!',
                            message: `Pero necesitamos m√°s burbujas...\n\nü´ß Necesitas: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n‚ùå Te faltan: ${needed} burbujas\n\nüéÆ ¬°Juega minijuegos para ganar m√°s burbujas!`,
                            confirmText: 'üéÆ ¬°Vamos a jugar!',
                            onConfirm: () => {}
                        });
                        return;
                    }
                    
                    // Mensajes personalizados por fondo
                    const bgDisplayName = bg.name.charAt(0).toUpperCase() + bg.name.slice(1);
                    const fishMessages = {
                        'cartoon': 'üê†üí≠ "¬°Wow! Este lugar parece s√∫per divertido!"',
                        'coral': 'üê†üí≠ "¬°Me encanta nadar entre corales!"',
                        'mario': 'üê†üí≠ "¬°Como en los videojuegos! ¬°Genial!"',
                        'minecraft': 'üê†üí≠ "¬°Un mundo de bloques para explorar!"'
                    };
                    
                    const fishMessage = fishMessages[bg.name] || 'üê†üí≠ "¬°Este lugar se ve genial para nadar!"';
                    
                    this.showCustomModal({
                        title: 'üè† ¬°Tu pececito quiere un nuevo hogar!',
                        message: `üé® Fondo: ${bgDisplayName}\nü´ß Cuesta: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n\n${fishMessage}`,
                        confirmText: '‚ú® ¬°Desbloquear fondo!',
                        cancelText: 'üö´ Mejor no',
                        onConfirm: () => {
                            // Proceder con la compra
                            this.completePurchase(bg);
                        },
                        onCancel: () => {
                            console.log('üö´ Compra cancelada');
                        }
                    });
                    return; // Salir aqu√≠, la compra se completa en completePurchase
                }
                
                // Si es gratis, comprar directamente
                this.completePurchase(bg);
            }
            
            completePurchase(bg) {
                // Cobrar
                if (bg.cost > 0) {
                    this.gameState.bubbles -= bg.cost;
                    console.log(`üí≥ Pagado: ${bg.cost} burbujas`);
                }
                
                // Cambiar fondo
                this.gameState.currentBackground = bg.name;
                this.bgImage = bg.image;
                
                console.log(`üé® Fondo cambiado a: ${bg.name}, imagen: ${bg.image ? 'cargada' : 'no cargada'}`);
                
                // Mensaje de √©xito
                if (bg.cost > 0) {
                    const successMessages = {
                        'cartoon': 'üéâ ¬°Tu pececito est√° s√∫per feliz en su nuevo hogar cartoon!',
                        'coral': 'üéâ ¬°Tu pececito nada feliz entre los corales!',
                        'mario': 'üéâ ¬°Tu pececito se siente como en un videojuego!',
                        'minecraft': 'üéâ ¬°Tu pececito explora su mundo de bloques!'
                    };
                    
                    const successMsg = successMessages[bg.name] || 'üéâ ¬°Tu pececito ama su nuevo hogar!';
                    
                    // Mostrar mensaje de √©xito con modal bonito
                    this.showCustomModal({
                        title: 'üéâ ¬°Fondo desbloqueado!',
                        message: `${successMsg}\n\nüê†üí≠ "¬°Gracias! ¬°Me encanta!"`,
                        confirmText: 'ü•∞ ¬°De nada!',
                        onConfirm: () => {}
                    });
                }
                
                // A√±adir evento al √°lbum
                const purchaseMsg = bg.cost > 0 ? 
                    `He comprado un nuevo fondo ${bg.name} por ${bg.cost} burbujas. ¬°Me encanta mi nuevo hogar!` :
                    `He cambiado mi acuario por uno ${bg.name}. ¬°Me encanta mi nuevo hogar!`;
                this.addAlbumEvent('background', `üé® Nuevo hogar: ${bg.name}`, purchaseMsg);
                
                console.log(`üé® Fondo cambiado a: ${bg.name}`);
                this.populateBackgroundsGrid(); // Actualizar selecci√≥n
                this.updateUI();
                this.saveGame();
            }
            
            // üñ•Ô∏è ACTUALIZACI√ìN DE UI
            
            updateUI() {
                // Actualizar contadores con animaci√≥n
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                
                // Actualizar edad y nombre
                this.updateAgeDisplay();
                
                // Actualizar UI de todos los juegos con las estrellas totales
                if (typeof updateGamesUI === 'function') {
                    updateGamesUI();
                }
            }
            
            updateCurrencyDisplay(elementId, newValue) {
                const element = document.getElementById(elementId);
                const currentValue = parseInt(element.textContent) || 0;
                
                if (newValue !== currentValue) {
                    element.textContent = newValue;
                    
                    // A√±adir animaci√≥n
                    const floatContainer = element.closest('.currency-float');
                    if (floatContainer) {
                        floatContainer.classList.add('updated');
                        setTimeout(() => {
                            floatContainer.classList.remove('updated');
                        }, 500);
                    }
                }
            }
            
            updateAgeDisplay() {
                const fishAge = document.getElementById('fishAge');
                const fishName = document.getElementById('fishName');
                
                if (this.gameState.stage === 'waiting') {
                    fishAge.textContent = 'Esperando...';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.gameState.stage === 'egg') {
                    fishAge.textContent = 'Huevo';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.fish && this.gameState.birthDate) {
                    // Calcular edad en d√≠as
                    const now = Date.now();
                    const ageInMs = now - this.gameState.birthDate;
                    const ageInDays = Math.floor(ageInMs / (24 * 60 * 60 * 1000));
                    this.gameState.ageInDays = ageInDays;
                    
                    // Mostrar etapa y edad
                    const stageEmojis = {
                        'baby': 'üçº',
                        'young': 'üå±', 
                        'adult': 'üëë'
                    };
                    
                    const stageNames = {
                        'baby': 'Beb√©',
                        'young': 'Joven',
                        'adult': 'Adulto'
                    };
                    
                    const stageName = stageNames[this.gameState.stage] || 'Pez';
                    
                    fishAge.textContent = `${stageName} - ${ageInDays} d√≠a${ageInDays !== 1 ? 's' : ''}`;
                    
                    // Nombre del juego con el nombre del pez
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                } else {
                    fishAge.textContent = 'üçº Beb√©';
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                }
            }
            
            // üè∑Ô∏è MODAL PARA CAMBIAR NOMBRE DEL PEZ
            showChangeNameModal() {
                const currentName = this.gameState.fishName || 'Sin nombre';
                
                this.showCustomModal({
                    title: 'üè∑Ô∏è Cambiar nombre',
                    message: `Nombre actual: "${currentName}"\n\n¬øC√≥mo quieres llamar a tu pez?`,
                    confirmText: '‚úÖ Cambiar',
                    cancelText: '‚ùå Cancelar',
                    input: true, // ACTIVAR CAMPO DE INPUT
                    inputPlaceholder: 'Nuevo nombre...',
                    inputValue: currentName === 'Sin nombre' ? '' : currentName,
                    onConfirm: (newName) => {
                        if (newName && newName.trim()) {
                            const oldName = this.gameState.fishName;
                            this.gameState.fishName = newName.trim();
                            this.updateUI();
                            this.saveGame();
                            
                            // A√±adir evento al √°lbum
                            this.addAlbumEvent('rename', 'üè∑Ô∏è Nuevo nombre', 
                                oldName ? `Cambi√© mi nombre de "${oldName}" a "${newName.trim()}"` : 
                                `¬°Ahora me llamo "${newName.trim()}"!`);
                            
                            console.log(`üè∑Ô∏è Nombre cambiado a: ${newName.trim()}`);
                        }
                    }
                });
            }
            
            // üê† SISTEMA DE NOMBRE
            
            askForFishName() {
                console.log('üè∑Ô∏è DEBUG NOMBRE:', {
                    hasAskedForName: this.gameState.hasAskedForName,
                    fishName: this.gameState.fishName,
                    shouldAsk: !this.gameState.hasAskedForName && !this.gameState.fishName
                });
                
                if (this.gameState.hasAskedForName || this.gameState.fishName) {
                    console.log('‚ùå No preguntar nombre - Ya preguntado o ya tiene nombre');
                    return;
                }
                
                this.gameState.hasAskedForName = true;
                console.log('üè∑Ô∏è Preguntando nombre del pez...');
                
                // Mostrar burbuja de nombre
                this.showNameBubble();
            }
            
            showNameBubble() {
                if (!this.fish) return;
                
                // Crear modal bonito para el nombre
                this.showCustomModal({
                    title: 'Hola! Soy tu nuevo pececito',
                    message: 'Como quieres llamarme?\n\nSi no escribes nada, elegir√© un nombre bonito para mi',
                    input: true,
                    inputPlaceholder: 'Mi nombre...',
                    confirmText: 'Confirmar',
                    onConfirm: (name) => {
                        if (name && name.trim()) {
                            this.gameState.fishName = name.trim();
                            console.log(`üè∑Ô∏è Pez nombrado: ${this.gameState.fishName}`);
                            
                            // Mostrar mensaje de bienvenida con consejos
                            this.showCustomModal({
                                title: '¬°Perfecto!',
                                message: `üê† "¬°Me encanta mi nombre ${this.gameState.fishName}!"\n\n¬°Gracias por elegirme!\n\nüí° Consejos para cuidarme:\nü´ß Alimenta cuando tenga hambre ‚Üí +2 burbujas\nüßπ L√≠mpiame cuando est√© sucio ‚Üí +3 burbujas\nüéÆ Juega conmigo ‚Üí +burbujas y estrellas\n\n¬°Con burbujas podr√°s comprarme fondos bonitos!`,
                                confirmText: '¬°Empecemos juntos!',
                                onConfirm: () => {}
                            });
                        } else {
                            this.setRandomName();
                            console.log(`üè∑Ô∏è Nombre aleatorio elegido: ${this.gameState.fishName}`);
                        }
                        this.updateUI();
                        this.saveGame();
                    }
                });
            }
            
            setRandomName() {
                const randomNames = ['Burbuj√≠n', 'Nadador', 'Azulito', 'Brillante', 'Saltar√≠n', 'Coralito'];
                this.gameState.fishName = randomNames[Math.floor(Math.random() * randomNames.length)];
                
                this.showCustomModal({
                    title: '¬°Sorpresa!',
                    message: `üê† "¬°Me llamar√© ${this.gameState.fishName}!"\n\n¬°Espero que te guste mi nombre!\n\nüí° Consejos para cuidarme:\nü´ß Alimenta cuando tenga hambre ‚Üí +2 burbujas\nüßπ L√≠mpiame cuando est√© sucio ‚Üí +3 burbujas\nüéÆ Juega conmigo ‚Üí +burbujas y estrellas\n\n¬°Con burbujas podr√°s comprarme fondos bonitos!`,
                    confirmText: '¬°Empecemos juntos!',
                    onConfirm: () => {}
                });
            }
            
            // üé® MODAL PERSONALIZADO BONITO
            showCustomModal(options) {
                // Crear modal din√°micamente
                const modal = document.createElement('div');
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <div class="custom-modal-content">
                        <div class="custom-modal-header">
                            <h2>${options.title}</h2>
                        </div>
                        <div class="custom-modal-body">
                            <p>${options.message.replace(/\n/g, '<br>')}</p>
                            ${options.input ? `<input type="text" class="custom-input" placeholder="${options.inputPlaceholder}" maxlength="15">` : ''}
                        </div>
                        <div class="custom-modal-buttons">
                            <button class="custom-btn confirm-btn">${options.confirmText}</button>
                            ${options.cancelText ? `<button class="custom-btn cancel-btn">${options.cancelText}</button>` : ''}
                        </div>
                    </div>
                `;
                
                // A√±adir estilos inline para que funcione inmediatamente
                modal.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const content = modal.querySelector('.custom-modal-content');
                content.style.cssText = `
                    background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
                    border: 4px solid #ffffff;
                    border-radius: 25px;
                    padding: 25px;
                    max-width: 350px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    animation: modalPop 0.3s ease-out;
                `;
                
                // Event listeners
                const confirmBtn = modal.querySelector('.confirm-btn');
                const cancelBtn = modal.querySelector('.cancel-btn');
                const input = modal.querySelector('.custom-input');
                
                confirmBtn.addEventListener('click', () => {
                    const value = input ? input.value : null;
                    document.body.removeChild(modal);
                    options.onConfirm(value);
                });
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        options.onCancel();
                    });
                }
                
                // Focus en input si existe
                document.body.appendChild(modal);
                if (input) {
                    // Asignar valor inicial si se proporcion√≥
                    if (options.inputValue) {
                        input.value = options.inputValue;
                    }
                    input.focus();
                    input.select(); // Seleccionar todo el texto
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmBtn.click();
                        }
                    });
                }
            }
            
            // üì∏ MOSTRAR √ÅLBUM
            
            showAlbum() {
                this.populateAlbum();
                document.getElementById('albumModal').style.display = 'flex';
            }
            
            populateAlbum() {
                const albumTimeline = document.getElementById('albumTimeline');
                const albumDays = document.getElementById('albumDays');
                const albumEvents = document.getElementById('albumEvents');
                const albumMilestones = document.getElementById('albumMilestones');
                
                // Estad√≠sticas
                const daysSinceBirth = this.gameState.birthDate ? 
                    Math.floor((Date.now() - this.gameState.birthDate) / (24 * 60 * 60 * 1000)) : 0;
                const totalEvents = this.gameState.album?.length || 0;
                const milestones = this.gameState.album?.filter(e => 
                    ['birth', 'naming', 'background'].includes(e.type)).length || 0;
                
                albumDays.textContent = daysSinceBirth;
                albumEvents.textContent = totalEvents;
                albumMilestones.textContent = milestones;
                
                // Timeline
                albumTimeline.innerHTML = '';
                
                if (!this.gameState.album || this.gameState.album.length === 0) {
                    albumTimeline.innerHTML = `
                        <div class="album-entry">
                            <div class="album-entry-title">üìù Diario vac√≠o</div>
                            <div class="album-entry-description">¬°Los recuerdos aparecer√°n aqu√≠ mientras juegas!</div>
                        </div>
                    `;
                    return;
                }
                
                // Mostrar eventos m√°s recientes primero
                const sortedEvents = [...this.gameState.album].reverse();
                
                sortedEvents.forEach(event => {
                    const entry = document.createElement('div');
                    entry.className = 'album-entry';
                    entry.innerHTML = `
                        <div class="album-entry-header">
                            <div class="album-entry-title">${event.title}</div>
                            <div class="album-entry-date">${event.date} ${event.time}</div>
                        </div>
                        <div class="album-entry-description">${event.description}</div>
                        <div class="album-entry-meta">
                            <div class="album-entry-age">D√≠a ${event.fishAge}</div>
                            <div>${event.fishName}</div>
                        </div>
                    `;
                    albumTimeline.appendChild(entry);
                });
            }
            
            // üì∏ SISTEMA DE √ÅLBUM/DIARIO
            
            addAlbumEvent(type, title, description, photo = null) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type, // 'birth', 'naming', 'feeding', 'playing', 'background', 'milestone'
                    title: title,
                    description: description,
                    photo: photo, // URL de la foto o null
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                
                // Mantener solo los √∫ltimos 50 eventos para no saturar
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                
                console.log(`üì∏ Evento a√±adido al √°lbum: ${title}`);
                this.saveGame();
                
                // Verificar logros despu√©s de a√±adir evento
                this.checkAchievements();
            }
            
            // ü´ß EFECTO VISUAL DE BURBUJAS AL CONTADOR
            createBubbleEffect(amount) {
                console.log(`ü´ß Creando efecto de ${amount} burbujas al contador`);
                
                // Obtener posici√≥n del contador de burbujas
                const bubbleCounter = document.getElementById('bubblesCount');
                if (!bubbleCounter) return;
                
                const counterRect = bubbleCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Obtener posici√≥n del pez (convertir coordenadas del canvas a coordenadas de pantalla)
                const canvasRect = this.canvas.getBoundingClientRect();
                const startX = canvasRect.left + (this.fish ? this.fish.x : this.canvas.width/2);
                const startY = canvasRect.top + (this.fish ? this.fish.y : this.canvas.height/2);
                
                // Calcular distancia y duraci√≥n de animaci√≥n
                const distance = Math.sqrt((targetX - startX) ** 2 + (targetY - startY) ** 2);
                const duration = Math.max(800, Math.min(2000, distance * 2)); // 800ms m√≠nimo, 2000ms m√°ximo
                
                console.log(`ü´ß Animaci√≥n: ${distance.toFixed(0)}px en ${duration}ms`);
                
                // Crear burbujas que vuelan desde el pez al contador
                for (let i = 0; i < amount; i++) {
                    const bubble = document.createElement('div');
                    bubble.innerHTML = 'ü´ß';
                    bubble.style.cssText = `
                        position: fixed;
                        left: ${startX}px;
                        top: ${startY}px;
                        font-size: 20px;
                        pointer-events: none;
                        z-index: 10000;
                        transition: all ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        transform: translate(0, 0) scale(1);
                        opacity: 1;
                    `;
                    
                    document.body.appendChild(bubble);
                    
                    // Animar hacia el contador
                    setTimeout(() => {
                        bubble.style.left = `${targetX}px`;
                        bubble.style.top = `${targetY}px`;
                        bubble.style.transform = 'translate(-50%, -50%) scale(0.3)';
                        bubble.style.opacity = '0';
                    }, 50 + (i * 100)); // Delay escalonado con offset m√≠nimo
                    
                    // Remover despu√©s de la animaci√≥n
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, duration + 50 + (i * 100) + 200);
                }
                
                // Actualizar contador con animaci√≥n
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
            }
            
            // üéÜ ANIMACIONES DIN√ÅMICAS PARA RECOMPENSAS EXTRA
            createRewardAnimation(stars, bubbles, sourceElement = null) {
                if (stars >= 2 || bubbles >= 10) {
                    console.log(`üéÜ ¬°RECOMPENSA EXTRA! ${stars} estrellas, ${bubbles} burbujas`);
                    
                    // Crear explosi√≥n de part√≠culas doradas
                    if (!this.rewardParticles) this.rewardParticles = [];
                    
                    const centerX = sourceElement ? sourceElement.offsetLeft + sourceElement.offsetWidth/2 : this.canvas.width/2;
                    const centerY = sourceElement ? sourceElement.offsetTop + sourceElement.offsetHeight/2 : this.canvas.height/2;
                    
                    // Crear part√≠culas especiales basadas en las recompensas
                    const particleCount = Math.min(stars * 15 + Math.floor(bubbles/2), 50);
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = 100 + Math.random() * 150;
                        const life = 2 + Math.random() * 1.5;
                        
                        // Colores especiales para diferentes recompensas
                        let color = '#FFD700'; // Dorado por defecto
                        if (stars >= 3) color = '#FF6B9D'; // Rosa para 3+ estrellas
                        else if (stars >= 2) color = '#4ECDC4'; // Cyan para 2+ estrellas
                        else if (bubbles >= 20) color = '#45B7D1'; // Azul para muchas burbujas
                        
                        this.rewardParticles.push({
                            x: centerX + (Math.random() - 0.5) * 40,
                            y: centerY + (Math.random() - 0.5) * 40,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed - 30,
                            r: 3 + Math.random() * 5,
                            life: life,
                            maxLife: life,
                            color: color,
                            sparkle: Math.random() < 0.6,
                            type: stars >= 2 ? 'star' : 'bubble'
                        });
                    }
                    
                    // Sonido especial para recompensas extra
                    if (window.audioManager && stars >= 2) {
                        window.audioManager.playSound('achievement');
                    }
                    
                    // Mensaje flotante - CENTRADO EN EL JUEGO DE BURBUJAS
                    const gameModal = document.querySelector('.bubble-game-container');
                    if (gameModal) {
                        const gameRect = gameModal.getBoundingClientRect();
                        const gameCenterX = gameRect.left + gameRect.width / 2;
                        const gameCenterY = gameRect.top + gameRect.height / 2;
                        // Solo mostrar efecto de estrellas, sin mensaje
                    }
                }
            }
            
            // üí´ ACTUALIZAR PART√çCULAS DE RECOMPENSA
            updateRewardParticles(deltaTime) {
                if (!this.rewardParticles) return;
                
                for (let i = this.rewardParticles.length - 1; i >= 0; i--) {
                    const p = this.rewardParticles[i];
                    p.life -= deltaTime;
                    
                    // F√≠sica de part√≠culas
                    p.vy += 150 * deltaTime; // Gravedad
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    
                    // Eliminar part√≠culas muertas
                    if (p.life <= 0 || p.y > this.canvas.height + 50) {
                        this.rewardParticles.splice(i, 1);
                    }
                }
            }
            
            // ‚ú® DIBUJAR PART√çCULAS DE RECOMPENSA
            drawRewardParticles() {
                if (!this.rewardParticles || this.rewardParticles.length === 0) return;
                
                this.ctx.save();
                for (const p of this.rewardParticles) {
                    const alpha = Math.max(0, p.life / p.maxLife);
                    this.ctx.globalAlpha = alpha;
                    
                    if (p.type === 'star') {
                        // Dibujar estrella
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        const spikes = 5;
                        const outerRadius = p.r * 1.5;
                        const innerRadius = p.r * 0.7;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = p.x + Math.cos(angle) * radius;
                            const y = p.y + Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    } else {
                        // Dibujar burbuja
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (p.sparkle) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.beginPath();
                            this.ctx.arc(p.x - p.r * 0.3, p.y - p.r * 0.3, p.r * 0.2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                this.ctx.restore();
            }
            
            // üí¨ MOSTRAR MENSAJE FLOTANTE
            showFloatingMessage(text, x, y) {
                if (!this.floatingMessages) this.floatingMessages = [];
                
                this.floatingMessages.push({
                    text: text,
                    x: x,
                    y: y,
                    life: 2.5,
                    maxLife: 2.5,
                    vy: -60 // Velocidad hacia arriba
                });
            }
            
            // üê† MENSAJES SUTILES DEL PEZ
            showFishMessage(message, color = '#FFD700') {
                if (!this.fish) return;
                
                // Mensajes m√°s peque√±os y sutiles
                if (!this.floatingMessages) this.floatingMessages = [];
                
                    this.floatingMessages.push({
                        text: message,
                        x: this.fish.x,
                        y: this.fish.y - 20,
                        life: 3.0,
                        maxLife: 3.0,
                        vy: -40, // M√°s lento
                        color: '#FFFFFF', // Texto blanco
                        size: 18 // M√°s peque√±o
                    });
            }
            
            // üìù ACTUALIZAR MENSAJES FLOTANTES
            updateFloatingMessages(deltaTime) {
                if (!this.floatingMessages) return;
                
                for (let i = this.floatingMessages.length - 1; i >= 0; i--) {
                    const msg = this.floatingMessages[i];
                    msg.life -= deltaTime;
                    msg.y += msg.vy * deltaTime;
                    
                    if (msg.life <= 0) {
                        this.floatingMessages.splice(i, 1);
                    }
                }
            }
            
            // ‚ú® DIBUJAR MENSAJES FLOTANTES
            drawFloatingMessages() {
                if (!this.floatingMessages || this.floatingMessages.length === 0) return;
                
                this.ctx.save();
                for (const msg of this.floatingMessages) {
                    const alpha = Math.max(0, msg.life / msg.maxLife);
                    this.ctx.globalAlpha = alpha;
                    
                    // Tama√±o y color personalizables
                    const fontSize = msg.size || 24;
                    const color = msg.color || '#FFD700';
                    
                    this.ctx.font = `bold ${fontSize}px Arial`;
                    this.ctx.fillStyle = color;
                    this.ctx.textAlign = 'center';
                    
                    // Solo texto sin borde negro
                    this.ctx.fillText(msg.text, msg.x, msg.y);
                }
                this.ctx.restore();
            }
            
            // üèÜ SISTEMA DE LOGROS INTEGRADO
            checkAchievements() {
                if (!this.gameState.achievements) {
                    this.gameState.achievements = [];
                }
                
                const achievements = [
                    {
                        id: 'first_birth',
                        title: 'üê£ Primera Vida',
                        desc: 'Tu primer pececito ha nacido',
                        condition: () => this.gameState.stage !== 'egg',
                        reward: { bubbles: 5, stars: 1 }
                    },
                    {
                        id: 'first_evolution',
                        title: 'üå± Crecimiento',
                        desc: 'Tu pez ha evolucionado por primera vez',
                        condition: () => this.gameState.hasEvolvedToYoung,
                        reward: { bubbles: 10, stars: 2 }
                    },
                    {
                        id: 'adult_fish',
                        title: 'üëë Madurez',
                        desc: 'Tu pez ha alcanzado la edad adulta',
                        condition: () => this.gameState.hasEvolvedToAdult,
                        reward: { bubbles: 20, stars: 3 }
                    },
                    {
                        id: 'bubble_collector',
                        title: 'ü´ß Coleccionista',
                        desc: 'Has reunido 100 burbujas',
                        condition: () => this.gameState.bubbles >= 100,
                        reward: { bubbles: 25, stars: 2 }
                    },
                    {
                        id: 'star_hunter',
                        title: '‚≠ê Cazador de Estrellas',
                        desc: 'Has reunido 50 estrellas',
                        condition: () => this.gameState.stars >= 50,
                        reward: { bubbles: 30, stars: 5 }
                    },
                    {
                        id: 'caring_owner',
                        title: 'üíñ Cuidador Ejemplar',
                        desc: 'Has alimentado a tu pez 20 veces',
                        condition: () => {
                            const feedEvents = this.gameState.album.filter(e => 
                                e.type === 'feeding' || e.description.includes('comido')
                            ).length;
                            return feedEvents >= 20;
                        },
                        reward: { bubbles: 15, stars: 3 }
                    },
                    {
                        id: 'week_survivor',
                        title: 'üìÖ Una Semana Juntos',
                        desc: 'Tu pez ha vivido 7 d√≠as',
                        condition: () => (this.gameState.ageInDays || 0) >= 7,
                        reward: { bubbles: 35, stars: 5 }
                    }
                ];
                
                achievements.forEach(achievement => {
                    // Verificar si ya se obtuvo este logro
                    const alreadyEarned = this.gameState.achievements.includes(achievement.id);
                    
                    if (!alreadyEarned && achievement.condition()) {
                        // ¬°Logro desbloqueado!
                        this.gameState.achievements.push(achievement.id);
                        
                        // Dar recompensas
                        this.gameState.bubbles += achievement.reward.bubbles;
                        this.gameState.stars += achievement.reward.stars;
                        
                        // A√±adir al √°lbum como evento especial
                        this.addAlbumEventDirect('achievement', achievement.title, achievement.desc);
                        
                        // Mostrar notificaci√≥n
                        this.showAchievementNotification(achievement);
                        
                        console.log(`üèÜ ¬°LOGRO DESBLOQUEADO! ${achievement.title}`);
                        this.updateUI(); // Actualizar burbujas/estrellas
                    }
                });
            }
            
            // üì∏ A√ëADIR EVENTO SIN RECURSI√ìN
            addAlbumEventDirect(type, title, description) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type,
                    title: title,
                    description: description,
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                this.saveGame();
            }
            
            // üéâ NOTIFICACI√ìN DE LOGRO
            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="achievement-content">
                        <div class="achievement-icon">üèÜ</div>
                        <div class="achievement-text">
                            <div class="achievement-title">${achievement.title}</div>
                            <div class="achievement-desc">${achievement.desc}</div>
                            <div class="achievement-reward">+${achievement.reward.bubbles}ü´ß +${achievement.reward.stars}‚≠ê</div>
                        </div>
                    </div>
                `;
                
                notification.style.cssText = `
                    position: fixed; top: 80px; right: 20px;
                    background: linear-gradient(135deg, #1bb37a, #2e7d32);
                    color: white; border: 2px solid #4caf50; border-radius: 15px; padding: 15px;
                    box-shadow: 0 8px 25px rgba(27, 179, 122, 0.4); z-index: 10000;
                    animation: slideInRight 0.5s ease; max-width: 300px;
                `;
                
                // A√±adir animaciones CSS si no existen
                if (!document.querySelector('#achievement-animations')) {
                    const style = document.createElement('style');
                    style.id = 'achievement-animations';
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        @keyframes bounce {
                            0%, 20%, 53%, 80%, 100% { transform: scale(1); }
                            40%, 43% { transform: scale(1.1); }
                            70% { transform: scale(1.05); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                const content = notification.querySelector('.achievement-content');
                content.style.cssText = `display: flex; align-items: center; gap: 12px;`;
                
                const icon = notification.querySelector('.achievement-icon');
                icon.style.cssText = `font-size: 32px; animation: bounce 0.6s ease;`;
                
                const title = notification.querySelector('.achievement-title');
                title.style.cssText = `font-weight: bold; font-size: 16px; margin-bottom: 4px;`;
                
                const desc = notification.querySelector('.achievement-desc');
                desc.style.cssText = `font-size: 12px; opacity: 0.9; margin-bottom: 4px;`;
                
                const reward = notification.querySelector('.achievement-reward');
                reward.style.cssText = `font-size: 12px; font-weight: bold; color: #ffeb3b;`;
                
                document.body.appendChild(notification);
                
                // Remover despu√©s de 4 segundos
                setTimeout(() => {
                    notification.style.animation = 'slideInRight 0.5s ease reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
                
                // Sonido de logro
                if (window.audioManager) {
                    window.audioManager.playSound('achievement');
                }
            }
            
            // üì± SISTEMA DE COMPARTIR PEZ
            shareMyFish() {
                console.log('üì± Iniciando sistema de compartir...');
                
                // Crear imagen bonita para compartir
                this.generateShareImage().then(shareData => {
                    // Mostrar modal de compartir
                    this.showShareModal(shareData);
                }).catch(error => {
                    console.error('Error generando imagen:', error);
                    this.showSimpleShare();
                });
            }
            
            async generateShareImage() {
                // Crear canvas temporal para captura
                const shareCanvas = document.createElement('canvas');
                shareCanvas.width = 400;
                shareCanvas.height = 300;
                const ctx = shareCanvas.getContext('2d');
                
                // Fondo bonito
                const gradient = ctx.createLinearGradient(0, 0, 400, 300);
                gradient.addColorStop(0, '#4fc3f7');
                gradient.addColorStop(0.5, '#29b6f6');
                gradient.addColorStop(1, '#0288d1');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 300);
                
                // T√≠tulo
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üê† Mi Pececito', 200, 40);
                
                // Info del pez
                const fishName = this.gameState.fishName || 'Sin nombre';
                const stage = this.gameState.stage;
                const age = this.gameState.ageInDays || 0;
                const bubbles = this.gameState.bubbles || 0;
                const stars = this.gameState.stars || 0;
                
                ctx.font = '18px Arial';
                ctx.fillText(`Nombre: ${fishName}`, 200, 80);
                ctx.fillText(`Etapa: ${stage === 'baby' ? 'Beb√©' : stage === 'young' ? 'Joven' : 'Adulto'}`, 200, 110);
                ctx.fillText(`Edad: ${age} d√≠as`, 200, 140);
                ctx.fillText(`ü´ß ${bubbles} burbujas  ‚≠ê ${stars} estrellas`, 200, 170);
                
                // Mensaje
                ctx.font = '16px Arial';
                ctx.fillStyle = '#e3f2fd';
                ctx.fillText('¬°Ven a cuidar tu propio pececito!', 200, 220);
                ctx.fillText('üåä Mi Pececito - Mascota Virtual üåä', 200, 250);
                
                // Convertir a blob
                return new Promise(resolve => {
                    shareCanvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        resolve({
                            image: url,
                            text: `üê† ¬°Mira mi pececito ${fishName}! Es un ${stage === 'baby' ? 'beb√©' : stage === 'young' ? 'joven' : 'adulto'} de ${age} d√≠as. ¬°√önete a Mi Pececito! üåä`,
                            url: window.location.href
                        });
                    }, 'image/png');
                });
            }
            
            showShareModal(shareData) {
                this.showCustomModal({
                    title: 'üì± Compartir mi pez',
                    message: `¬øC√≥mo quieres compartir a ${this.gameState.fishName || 'tu pececito'}?`,
                    confirmText: 'üìã Copiar texto',
                    cancelText: '‚ùå Cancelar',
                    onConfirm: () => {
                        // Copiar al portapapeles
                        navigator.clipboard.writeText(shareData.text).then(() => {
                            alert('üìã ¬°Texto copiado! P√©galo en WhatsApp, Telegram, etc.');
                        }).catch(() => {
                            // Fallback para navegadores sin clipboard API
                            this.showTextToCopy(shareData.text);
                        });
                    },
                    extraButtons: [
                        {
                            text: 'üì∏ Descargar imagen',
                            onclick: () => {
                                const link = document.createElement('a');
                                link.download = `mi-pececito-${this.gameState.fishName || 'mascota'}.png`;
                                link.href = shareData.image;
                                link.click();
                                URL.revokeObjectURL(shareData.image);
                            }
                        },
                        {
                            text: 'üåê Compartir web',
                            onclick: () => {
                                if (navigator.share) {
                                    navigator.share({
                                        title: 'Mi Pececito',
                                        text: shareData.text,
                                        url: shareData.url
                                    });
                                } else {
                                    this.showTextToCopy(shareData.url);
                                }
                            }
                        }
                    ]
                });
            }
            
            showSimpleShare() {
                const fishName = this.gameState.fishName || 'mi pececito';
                const stage = this.gameState.stage;
                const age = this.gameState.ageInDays || 0;
                const text = `üê† ¬°Mira mi pececito ${fishName}! Es un ${stage === 'baby' ? 'beb√©' : stage === 'young' ? 'joven' : 'adulto'} de ${age} d√≠as. ¬°√önete a Mi Pececito! üåä`;
                
                this.showTextToCopy(text);
            }
            
            showTextToCopy(text) {
                this.showCustomModal({
                    title: 'üìã Copiar para compartir',
                    message: 'Copia este texto y comp√°rtelo:',
                    confirmText: '‚úÖ Entendido',
                    input: true,
                    inputValue: text,
                    inputReadonly: true,
                    onConfirm: () => {
                        console.log('üì± Texto para compartir mostrado');
                    }
                });
            }
            
            // ‚ú® EFECTOS DE PART√çCULAS AL COMER
            createEatingParticles(x, y) {
                if (!this.eatingParticles) this.eatingParticles = [];
                
                // Crear 8-12 part√≠culas brillantes
                const particleCount = 8 + Math.floor(Math.random() * 5);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                    const speed = 60 + Math.random() * 40;
                    const size = 3 + Math.random() * 4;
                    const life = 1.2 + Math.random() * 0.8;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20, // Hacia arriba
                        size: size,
                        life: life,
                        maxLife: life,
                        color: ['#ffeb3b', '#ffc107', '#ff9800', '#4caf50', '#2196f3'][Math.floor(Math.random() * 5)],
                        sparkle: Math.random() < 0.5
                    };
                    
                    this.eatingParticles.push(particle);
                }
                
                console.log(`‚ú® ${particleCount} part√≠culas de comida creadas en (${x.toFixed(1)}, ${y.toFixed(1)})`);
            }
            
            // ‚ú® ACTUALIZAR PART√çCULAS DE COMIDA
            updateEatingParticles(deltaTime) {
                if (!this.eatingParticles) return;
                
                for (let i = this.eatingParticles.length - 1; i >= 0; i--) {
                    const p = this.eatingParticles[i];
                    
                    // F√≠sica
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.vy += 80 * deltaTime; // Gravedad suave
                    p.vx *= 0.98; // Fricci√≥n
                    
                    // Vida
                    p.life -= deltaTime;
                    
                    // Remover si muri√≥
                    if (p.life <= 0) {
                        this.eatingParticles.splice(i, 1);
                    }
                }
            }
            
            // ‚ú® DIBUJAR PART√çCULAS DE COMIDA
            drawEatingParticles() {
                if (!this.eatingParticles || this.eatingParticles.length === 0) return;
                
                this.ctx.save();
                
                for (const p of this.eatingParticles) {
                    const alpha = p.life / p.maxLife;
                    const size = p.size * (0.5 + alpha * 0.5);
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = p.color;
                    
                    // Part√≠cula brillante
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo extra para algunas part√≠culas
                    if (p.sparkle) {
                        this.ctx.globalAlpha = alpha * 0.6;
                        this.ctx.fillStyle = 'white';
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, size * 0.5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.restore();
            }
            
            checkForAlbumEvents() {
                const now = Date.now();
                const hoursSinceLastEvent = (now - this.gameState.lastEventTime) / (1000 * 60 * 60);
                
                // Solo generar eventos cada 1+ horas para m√°s actividad
                if (hoursSinceLastEvent < 1) return;
                
                // Eventos aleatorios basados en el estado del pez
                if (this.fish && Math.random() < 0.15) { // 15% chance cada check
                    const stage = this.gameState.stage;
                    const age = this.gameState.ageInDays || 0;
                    const bubbles = this.gameState.bubbles || 0;
                    const stars = this.gameState.stars || 0;
                    
                    const randomEvents = [
                        // Eventos b√°sicos
                        { type: 'swimming', title: 'üèä Nadando feliz', desc: 'Hoy he nadado mucho y me siento muy activo.' },
                        { type: 'exploring', title: 'üîç Explorando', desc: 'He descubierto un rinc√≥n nuevo de mi acuario.' },
                        { type: 'playing', title: 'üéà Jugando', desc: 'He estado jugando con las burbujas. ¬°Qu√© divertido!' },
                        { type: 'resting', title: 'üò¥ Descansando', desc: 'He encontrado un lugar c√≥modo para relajarme.' },
                        
                        // Eventos por etapa
                        ...(stage === 'baby' ? [
                            { type: 'curious', title: 'üëÄ Curiosidad', desc: 'Todo me parece nuevo y emocionante. ¬°Quiero explorarlo todo!' },
                            { type: 'learning', title: 'üß† Aprendiendo', desc: 'Estoy aprendiendo a nadar mejor cada d√≠a.' },
                            { type: 'growing', title: 'üìè Creciendo', desc: 'Siento que cada d√≠a soy un poquito m√°s grande.' }
                        ] : []),
                        
                        ...(stage === 'young' ? [
                            { type: 'energetic', title: '‚ö° Lleno de energ√≠a', desc: 'Me siento s√∫per activo y lleno de vida.' },
                            { type: 'social', title: 'üëã Sociable', desc: 'Me encanta cuando vienes a visitarme.' },
                            { type: 'adventurous', title: 'üó∫Ô∏è Aventurero', desc: 'Tengo ganas de explorar m√°s all√° de mi pecera.' }
                        ] : []),
                        
                        ...(stage === 'adult' ? [
                            { type: 'wise', title: 'üßô Sabidur√≠a', desc: 'Con la experiencia he aprendido muchas cosas.' },
                            { type: 'peaceful', title: '‚òÆÔ∏è Tranquilo', desc: 'Disfruto de la paz y tranquilidad de mi hogar.' },
                            { type: 'mentor', title: 'üë®‚Äçüè´ Mentor', desc: 'Me gustar√≠a ense√±ar a otros peces j√≥venes.' }
                        ] : []),
                        
                        // Eventos por logros
                        ...(bubbles >= 50 ? [
                            { type: 'wealthy', title: 'üí∞ Pr√≥spero', desc: 'He acumulado muchas burbujas. ¬°Soy rico!' }
                        ] : []),
                        
                        ...(stars >= 20 ? [
                            { type: 'skilled', title: 'üåü Habilidoso', desc: 'Mis habilidades en los juegos han mejorado mucho.' }
                        ] : []),
                        
                        // Eventos por edad
                        ...(age >= 3 ? [
                            { type: 'memories', title: 'üí≠ Recuerdos', desc: 'Recuerdo cuando era solo un huevito. ¬°Qu√© tiempos!' }
                        ] : []),
                        
                        ...(age >= 7 ? [
                            { type: 'milestone', title: 'üéÇ Una semana especial', desc: 'Ya llevo una semana contigo. ¬°Qu√© feliz soy!' }
                        ] : []),
                        
                        // Eventos especiales por hora del d√≠a
                        ...(new Date().getHours() < 12 ? [
                            { type: 'morning', title: 'üåÖ Buenos d√≠as', desc: 'La ma√±ana es perfecta para nadar y jugar.' }
                        ] : new Date().getHours() < 18 ? [
                            { type: 'afternoon', title: '‚òÄÔ∏è Tarde soleada', desc: 'Los rayos de sol hacen brillar el agua.' }
                        ] : [
                            { type: 'evening', title: 'üåô Noche tranquila', desc: 'La noche es perfecta para relajarse.' }
                        ])
                    ];
                    
                    const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                    this.addAlbumEvent(event.type, event.title, event.desc);
                    this.gameState.lastEventTime = now;
                }
            }
            
            // üíæ SISTEMA DE GUARDADO
            
            saveGame() {
                const saveData = {
                    version: '1.0.0',
                    
                    // üë§ DATOS DEL USUARIO
                    userId: this.gameState.userId || null,
                    username: this.gameState.username || null,
                    
                    // üê† DATOS DEL PEZ
                    fishName: this.gameState.fishName,
                    fishStage: this.gameState.stage,
                    fishAge: this.gameState.ageInDays || 0,
                    fishBirthTime: this.gameState.birthTime,
                    fishEvolutionTimes: {
                        toYoung: this.gameState.hasEvolvedToYoung ? this.gameState.evolutionToYoungTime : null,
                        toAdult: this.gameState.hasEvolvedToAdult ? this.gameState.evolutionToAdultTime : null
                    },
                    
                    // üé® FONDO ACTUAL Y DESBLOQUEADOS
                    currentBackground: this.gameState.currentBackground,
                    unlockedBackgrounds: this.availableBackgrounds?.filter(bg => bg.unlocked).map(bg => bg.name) || [],
                    
                    // üí∞ CURRENCY
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars,
                    
                    // üìä NECESIDADES
                    needs: this.gameState.needs,
                    
                    // üèÜ LOGROS Y PROGRESO
                    achievements: this.gameState.achievements || [],
                    album: this.gameState.album || [],
                    
                    // üéÆ PROGRESO DE JUEGOS
                    gameProgress: {
                        bubbleGame: {
                            bestScore: this.gameState.bubbleGame?.bestScore || 0,
                            totalGames: this.gameState.bubbleGame?.totalGames || 0,
                            starsEarned: this.gameState.bubbleGame?.starsEarned || 0
                        },
                        memoryGame: {
                            bestScore: this.gameState.memoryGame?.bestScore || 0,
                            totalGames: this.gameState.memoryGame?.totalGames || 0,
                            starsEarned: this.gameState.memoryGame?.starsEarned || 0
                        },
                        simonGame: {
                            bestScore: this.gameState.simonGame?.bestScore || 0,
                            totalGames: this.gameState.simonGame?.totalGames || 0,
                            starsEarned: this.gameState.simonGame?.starsEarned || 0
                        },
                        carrilGame: {
                            bestScore: this.gameState.carrilGame?.bestScore || 0,
                            totalGames: this.gameState.carrilGame?.totalGames || 0,
                            starsEarned: this.gameState.carrilGame?.starsEarned || 0
                        },
                        correrGame: {
                            bestScore: this.gameState.correrGame?.bestScore || 0,
                            totalGames: this.gameState.correrGame?.totalGames || 0,
                            starsEarned: this.gameState.correrGame?.starsEarned || 0
                        },
                        cazaGame: {
                            bestScore: this.gameState.cazaGame?.bestScore || 0,
                            totalGames: this.gameState.cazaGame?.totalGames || 0,
                            starsEarned: this.gameState.cazaGame?.starsEarned || 0
                        },
                        secuenciaGame: {
                            bestScore: this.gameState.secuenciaGame?.bestScore || 0,
                            totalGames: this.gameState.secuenciaGame?.totalGames || 0,
                            starsEarned: this.gameState.secuenciaGame?.starsEarned || 0
                        },
                        toca3Game: {
                            bestScore: this.gameState.toca3Game?.bestScore || 0,
                            totalGames: this.gameState.toca3Game?.totalGames || 0,
                            starsEarned: this.gameState.toca3Game?.starsEarned || 0
                        },
                        bloquesGame: {
                            bestScore: this.gameState.bloquesGame?.bestScore || 0,
                            totalGames: this.gameState.bloquesGame?.totalGames || 0,
                            starsEarned: this.gameState.bloquesGame?.starsEarned || 0
                        }
                    },
                    
                    // ü•ö ESTADO DEL HUEVO
                    egg: this.egg,
                    eggStartTime: this.gameState.eggStartTime,
                    explosionHappened: this.explosionHappened,
                    
                    // üê† DATOS DEL PEZ (para compatibilidad)
                    fish: this.fish,
                    
                    // ‚è∞ METADATOS
                    lastPlayed: Date.now(),
                    totalPlayTime: this.gameState.totalPlayTime || 0,
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('miPececito_gameData', JSON.stringify(saveData));
                    console.log('üíæ Juego guardado correctamente');
                    console.log('üìä Guardado completo:', {
                        usuario: this.gameState.username || 'An√≥nimo',
                        pez: this.gameState.fishName || 'Sin nombre',
                        etapa: this.gameState.stage,
                        edad: this.gameState.ageInDays || 0,
                        fondo: this.gameState.currentBackground,
                        fondosDesbloqueados: this.availableBackgrounds?.filter(bg => bg.unlocked).length || 0,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        logros: this.gameState.achievements?.length || 0,
                        album: this.gameState.album?.length || 0,
                        juegosJugados: Object.values(saveData.gameProgress).reduce((total, game) => total + (game.totalGames || 0), 0)
                    });
                } catch (error) {
                    console.error('‚ùå Error guardando:', error);
                }
            }
            
            loadGame() {
                try {
                    const savedData = localStorage.getItem('miPececito_gameData');
                    if (!savedData) return false;
                    
                    const data = JSON.parse(savedData);
                    
                    // Restaurar estado del juego
                    if (data.gameState) {
                        this.gameState = { ...this.gameState, ...data.gameState };
                    }
                    
                    // Restaurar huevo y pez
                    if (data.egg) {
                        this.egg = { ...this.egg, ...data.egg };
                    }
                    
                    if (data.fish) {
                        this.fish = { ...this.fish, ...data.fish };
                    }
                    
                    // Restaurar explosi√≥n
                    this.explosionHappened = data.explosionHappened || false;
                    
                    // Restaurar fondos desbloqueados
                    if (data.availableBackgrounds && this.availableBackgrounds) {
                        data.availableBackgrounds.forEach(savedBg => {
                            const bg = this.availableBackgrounds.find(b => b.name === savedBg.name);
                            if (bg) {
                                bg.unlocked = savedBg.unlocked;
                            }
                        });
                    }
                    
                    console.log('üìÅ Juego cargado correctamente');
                    console.log('üìä Cargado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Error cargando:', error);
                    return false;
                }
            }
            
            // Auto-guardado cada 30 segundos
            startAutoSave() {
                setInterval(() => {
                    this.saveGame();
                }, 30000);
            }
            
            // üîß M√âTODOS DE DEBUG
            
            placeFirstEgg(x, y) {
                const now = Date.now();
                
                // CAMBIAR STAGE A 'EGG' Y INICIAR TIEMPO
                this.gameState.stage = 'egg';
                this.gameState.eggStartTime = now;
                
                // üìä OCULTAR BARRAS DE NECESIDADES CON HUEVO
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'none';
                    this.setupCanvas(); // REAJUSTAR CANVAS SIN BARRAS
                    console.log('üìä Barras ocultas con huevo + Canvas reajustado');
                }
                
                // üéÜ BURBUJITAS BLANCAS PRIMERO, LUEGO HUEVO
                this.createEggBubbles();
                
                // ESPERAR 1 SEGUNDO PARA QUE SE VEAN LAS BURBUJAS PRIMERO
                setTimeout(() => {
                    this.egg.x = x || this.canvas.width / 2;
                    this.egg.y = y || this.canvas.height * 0.6;
                    this.startEggAppearanceAnimation();
                    console.log('ü•ö Huevo aparece DESPU√âS de las burbujas');
                }, 1000);
                
                this.saveGame(); // Guardar al colocar huevo
                console.log(`ü•ö Huevo colocado - Stage cambiado a 'egg'`);
                console.log(`ü•ö Tiempo inicio: ${new Date(now).toLocaleTimeString()}`);
                console.log(`‚è∞ EggStartTime configurado: ${this.gameState.eggStartTime}`);
            }

            // üéÜ ANIMACI√ìN DE APARICI√ìN DEL HUEVO (SOLO APARICI√ìN)
            startEggAppearanceAnimation() {
                // EFECTO SUAVE: Solo fade, sin escala brusca
                this.egg.appearing = true;
                this.egg.scale = 1; // TAMA√ëO NORMAL DESDE EL INICIO
                this.egg.targetScale = 1;
                this.egg.alpha = 0; // EMPEZAR TRANSPARENTE
                this.egg.targetAlpha = 1; // IR A OPACO
                this.egg.fadeSpeed = 0.8; // VELOCIDAD SUAVE
                
                console.log('ü•ö Iniciando aparici√≥n SUAVE del huevo (fade)...');
            }

            // üå´Ô∏è BURBUJAS DE APARICI√ìN - TEST VISUAL DIRECTO
            createEggAppearanceBubbles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`üå´Ô∏è Creando burbujas de aparici√≥n en (${centerX}, ${centerY})`);
                console.log(`üîç bgBubbles array actual: ${this.bgBubbles.length} burbujas`);
                
                // LIMPIAR burbujas existentes para evitar conflictos
                this.bgBubbles = [];
                
                // Crear 10 burbujas GRANDES y VISIBLES para test
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = 50 + i * 20; // Distancias variadas
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const testBubble = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2 - 3, // Hacia arriba
                        r: 20, // TAMA√ëO FIJO GRANDE
                        size: 20,
                        opacity: 1,
                        alpha: 1,
                        life: 5000, // 5 segundos fijos
                        maxLife: 5000,
                        color: i % 2 === 0 ? '#ff0000' : '#00ff00', // ROJO/VERDE ALTERNADO para ver
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(testBubble);
                    console.log(`üî¥üü¢ Burbuja TEST ${i+1}/10 creada: ${testBubble.color} en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
                
                console.log(`üéØ TEST: ${this.bgBubbles.length} burbujas grandes creadas`);
            }

            // ‚ú® PART√çCULAS M√ÅGICAS - TEST VISUAL
            createMagicParticles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`‚ú® Creando part√≠culas m√°gicas en (${centerX}, ${centerY})`);
                
                // Crear 5 part√≠culas ENORMES y DORADAS para test
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 80 + i * 15;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const magicParticle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1 - 2,
                        r: 25, // ENORMES para test
                        size: 25,
                        opacity: 1,
                        alpha: 1,
                        life: 6000, // 6 segundos
                        maxLife: 6000,
                        color: '#ffff00', // AMARILLO PURO
                        sparkle: true,
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(magicParticle);
                    console.log(`‚≠ê Part√≠cula TEST ${i+1}/5 creada: AMARILLA 25px en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
            }
            
            setEggTimeToFinalSeconds() {
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                this.gameState.eggStartTime = Date.now() - (total - 5000);
                console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
            }
            
            addTime(ms) {
                this.gameState.eggStartTime -= ms;
                console.log(`‚è∞ +${ms/1000/60/60}h a√±adidas`);
            }
            
            toggleBackground() {
                // Por ahora solo tenemos basic
                console.log('üñºÔ∏è Fondo cambiado (solo basic disponible)');
            }
            
            addCurrency(type, amount) {
                if (type === 'bubbles') {
                    this.gameState.bubbles += amount;
                } else if (type === 'stars') {
                    this.gameState.stars += amount;
                }
                console.log(`üí∞ +${amount} ${type} a√±adidas`);
                this.updateUI(); // ACTUALIZAR UI INMEDIATAMENTE
            }
            
            getGameInfo() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                return {
                    stage: this.gameState.stage,
                    eggTime: elapsed,
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars
                };
            }
            
            // üîß FUNCIONES HELPER COPIADAS DEL C√ìDIGO REALISTA
            clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }
            
            dist(x1, y1, x2, y2) {
                return Math.hypot(x2 - x1, y2 - y1);
            }
            
            // === Helpers de canvas/DPR (CSS px coherentes) ===
            getDPR() { 
                return window.devicePixelRatio || 1; 
            }
            
            viewW() { 
                return this.canvas.width / this.getDPR(); // ancho en CSS px
            }
            
            viewH() { 
                return this.canvas.height / this.getDPR(); // alto en CSS px
            }
            
            // ‚Äî‚Äî‚Äî SUELO √öNICO COHERENTE CON LA BARRA INFERIOR ‚Äî‚Äî‚Äî
            getFloorY() {
                // Si quieres medir la barra real:
                // const bar = document.querySelector('.bottom-bar');
                // const uiBottom = bar ? bar.getBoundingClientRect().height : 100;

                const uiBottom = 100;  // ‚Üê ajusta si tu barra real es otra
                const safeGap  = 12;   // margen para no pisar la UI
                return this.viewH() - (uiBottom + safeGap);
            }
            
            // Llamar al principio de cada render()
            beginFrame() {
                const ctx = this.ctx;
                // limpiar en p√≠xeles f√≠sicos
                ctx.setTransform(1,0,0,1,0,0);
                ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
                // reescalar a CSS px
                const r = this.getDPR();
                ctx.setTransform(r,0,0,r,0,0);
            }
            
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            vary(val, amt, min, max) {
                const v = val + (Math.random() * 2 - 1) * amt;
                return this.clamp(v, min, max);
            }
            
            // üçé SISTEMA DE COMIDA SEG√öN CHAT
            pelletColors() {
                const PELLET_FAMILIES = [
                    {h:38,s:85,l:62},{h:30,s:80,l:58},{h:46,s:68,l:70},
                    {h:28,s:60,l:55},{h:60,s:35,l:65},{h:22,s:55,l:54}
                ];
                const b = PELLET_FAMILIES[Math.floor(Math.random() * PELLET_FAMILIES.length)];
                const h = this.vary(b.h, 5, 10, 70);
                const s = this.vary(b.s, 10, 20, 95);
                const l = this.vary(b.l, 8, 35, 85);
                const strokeL = Math.max(10, l - 22);
                const strokeS = Math.max(25, Math.round(s * 0.85));
                return { 
                    fill: `hsl(${Math.round(h)} ${Math.round(s)}% ${Math.round(l)}%)`, 
                    stroke: `hsl(${Math.round(h)} ${Math.round(strokeS)}% ${Math.round(strokeL)}%)` 
                };
            }
            
            dropFood() {
                console.log('üçé dropFood() llamado - Array food existe:', !!this.food);
                
                // ZONA ACCESIBLE PARA EL PEZ (evitar extremos)
                const fishSize = 80;
                const fishHalfSize = fishSize / 2;
                const leftLimit = fishHalfSize + 15; // 55px
                const rightLimit = this.canvas.width - fishHalfSize - 15; // W-55px
                const accessibleWidth = rightLimit - leftLimit;
                
                const x = leftLimit + Math.random() * accessibleWidth; // Solo en zona accesible
                const col = this.pelletColors();
                const r = 2.6 + Math.random() * 1.2;
                
                const pellet = {
                    x: x,
                    y: 120, // M√ÅS ABAJO para que est√© cerca del pez
                    vx: 0,
                    vy: 4 + Math.random() * 4, // CA√çDA M√ÅS LENTA
                    bottomT: 0,
                    colorFill: col.fill,
                    colorStroke: col.stroke,
                    r: r
                };
                
                this.food.push(pellet);
                console.log('üçé Pellet a√±adido en ZONA SEGURA:', 
                    `x=${x.toFixed(1)} (rango: ${leftLimit}-${rightLimit})`,
                    'Total food:', this.food.length);
            }
            
            // üßπ LIMPIEZA CON M√ÅQUINA DE ESTADOS SINCRONIZADA
            startCleaning() {
                console.log('üßπ ¬°INICIANDO LIMPIEZA SINCRONIZADA!');
                
                // ü´ß DAR BURBUJAS SI ESTABA SUCIO
                const wasReallyDirty = this.gameState.needs.dirt > 15; // Solo si estaba realmente sucio
                if (wasReallyDirty) {
                    this.gameState.bubbles += 3;
                    console.log(`ü´ß +3 burbujas por limpiar cuando estaba sucio (suciedad previa: ${this.gameState.needs.dirt.toFixed(1)}%)`);
                    
                    // üéÜ EFECTO VISUAL DE BURBUJAS AL CONTADOR
                    this.createBubbleEffect(3);
                }
                
                // üéØ INICIALIZAR ESTADO DE LIMPIEZA
                this.cleaningState = 'burst'; // burst -> fade -> settle
                this.cleaningTimer = 0;
                this._time = this._time || 0;
                this.cleanBubbles = this.cleanBubbles || [];

                // üêü EFECTO EN EL PEZ
                if (this.fish) { 
                    this.fish.happyBurst = 3.2; 
                    this.fish.spinKind = "clean"; 
                }
                
                // ü´ß CREAR BURBUJAS INMEDIATAMENTE (R√ÅFAGA INICIAL)
                this.emitCleanBubblesBurst();
                console.log(`ü´ß R√ÅFAGA INICIAL: ${this.cleanBubbles.length} burbujas creadas`);
                
                // üîä SONIDO SINCRONIZADO
                if (window.audioManager) {
                    window.audioManager.playSound('clean');
                }
                
                // üßπ CONFIGURAR LIMPIEZA
                this.dirtStart = this.gameState.needs.dirt;
            }
            
            // ü´ß R√ÅFAGA INTENSA DE BURBUJAS PARA SINCRONIZACI√ìN
            emitCleanBubblesBurst() {
                const W = this.viewW();
                const H = this.viewH();
                
                // üéØ CREAR MUCHAS BURBUJAS DE UNA VEZ (R√ÅFAGA)
                for (let wave = 0; wave < 3; wave++) {
                    for (let i = 0; i < 25; i++) {
                        const b = {
                            x0: 30 + Math.random() * (W - 60),
                            y0: H * 0.8 + Math.random() * (H * 0.15),
                            t: wave * 0.1, // Escalonar ligeramente las ondas
                            dur: 2.0 + Math.random() * 0.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 2,
                            wobAmp: 8 + Math.random() * 12,
                            r: 4 + Math.random() * 6
                        };
                        b.x = b.x0;
                        b.y = b.y0;
                        this.cleanBubbles.push(b);
                    }
                }
                
                console.log(`ü´ß R√°faga creada: ${this.cleanBubbles.length} burbujas totales`);
            }
            
            emitCleanBubbles() {
                const W = this.viewW();   // CSS px
                const H = this.viewH();   // CSS px
                const vents = Math.max(16, Math.floor(W / 24));
                const perVent = 2;

                for (let i = 0; i < vents; i++) {
                    const baseX = (i + 0.5) * (W / vents) + (Math.random() - 0.5) * 8;

                    for (let k = 0; k < perVent; k++) {
                        const vy  = 260 + Math.random() * 120;     // velocidad vertical (CSS px/s)
                        const y0  = H - 1 + Math.random() * 0.5;   // nacen pegadas al fondo
                        const dur = (H + 24) / vy;                 // tiempo exacto hasta salir por arriba
                        const x0  = this.clamp(baseX + (Math.random() - 0.5) * 6, 2, W - 2);

                        this.cleanBubbles.push({
                            // guardo origen (x0,y0) y movimiento param√©trico por tiempo
                            x: x0, y: y0,
                            x0, y0, dur, t: 0,
                            r: 1.5 + Math.random() * 2.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 1.2,
                            wobAmp: 6 + Math.random() * 10,
                            from: 'clean'
                        });
                    }
                }

                // L√≠mite de memoria
                if (this.cleanBubbles.length > 1400) {
                    this.cleanBubbles.splice(0, this.cleanBubbles.length - 1400);
                }
            }
            
            updateCleaning(deltaTime) {
                this._time = (this._time || 0) + deltaTime;

                // üéØ M√ÅQUINA DE ESTADOS DE LIMPIEZA
                if (this.cleaningState) {
                    this.cleaningTimer += deltaTime;
                    
                    switch (this.cleaningState) {
                        case 'burst':
                            // FASE 1: R√°faga inicial (0.5s)
                            if (this.cleaningTimer >= 0.5) {
                                this.cleaningState = 'fade';
                                this.cleaningTimer = 0;
                                console.log('üßπ FASE: burst ‚Üí fade');
                            }
                            break;
                            
                        case 'fade':
                            // FASE 2: Reducir suciedad gradualmente (2s)
                            const progress = Math.min(this.cleaningTimer / 2.0, 1.0);
                    this.gameState.needs.dirt = this.clamp((1 - progress) * this.dirtStart, 0, 100);
                    this.updateNeedBars();

                            if (this.cleaningTimer >= 2.0) {
                                this.cleaningState = 'settle';
                                this.cleaningTimer = 0;
                                console.log('üßπ FASE: fade ‚Üí settle');
                            }
                            break;
                            
                        case 'settle':
                            // FASE 3: Finalizar cuando no queden burbujas
                            if (this.cleanBubbles.length === 0 || this.cleaningTimer >= 3.0) {
                                this.gameState.needs.dirt = 0;
                                this.updateNeedBars();
                                this.cleaningState = null;
                                console.log('üßπ LIMPIEZA COMPLETADA');
                                
                                // üì∏ EVENTO DE LIMPIEZA OCASIONAL
                                if (Math.random() < 0.15) { // 15% chance
                                    const cleaningMessages = [
                                        '¬°Ahh! ¬°Qu√© limpia est√° mi pecera! Me siento renovado.',
                                        'Gracias por limpiar mi hogar. Ahora puedo nadar mejor.',
                                        '¬°Qu√© bien! El agua cristalina me hace muy feliz.',
                                        'Una pecera limpia es un pez feliz. ¬°Gracias!',
                                        'Me encanta cuando mi hogar est√° as√≠ de limpio y brillante.'
                                    ];
                                    const msg = cleaningMessages[Math.floor(Math.random() * cleaningMessages.length)];
                                    this.addAlbumEvent('cleaning', 'üßπ Pecera limpia', msg);
                                }
                            }
                            break;
                    }
                }

                // ü´ß ACTUALIZAR MOVIMIENTO DE BURBUJAS
                const H = this.viewH();
                for (const b of this.cleanBubbles) {
                    b.t += deltaTime;
                    const p = Math.min(1, b.t / (b.dur || 1));
                    b.y = b.y0 - p * (H + 24);
                    b.x = b.x0 + Math.sin(this._time * b.wobSpd + b.wobble) * b.wobAmp;
                }

                // üóëÔ∏è ELIMINAR BURBUJAS QUE SALIERON DE PANTALLA
                for (let i = this.cleanBubbles.length - 1; i >= 0; i--) {
                    const b = this.cleanBubbles[i];
                    if (b.t >= (b.dur || 1) || b.y < -12) {
                        this.cleanBubbles.splice(i, 1);
                    }
                }
            }
            
            drawCleanBubbles() {
                if (!this.cleanBubbles || this.cleanBubbles.length === 0) {
                    return;
                }
                const ctx = this.ctx;
                
                // üéØ ESCALAR CONTEXTO SOLO PARA BURBUJAS (sistema h√≠brido)
                ctx.save();
                const r = this.getDPR();
                ctx.setTransform(r, 0, 0, r, 0, 0);
                ctx.globalCompositeOperation = 'source-over';

                for (const b of this.cleanBubbles) {
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#dff7ff';
                    ctx.fill();
                    ctx.lineWidth = 0.9;
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                    ctx.stroke();
                }
                
                // üîÑ RESTAURAR CONTEXTO NORMAL
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.restore();
            }
            
            updateFood(deltaTime) {
                if (!this.food) {
                    console.log('üçé updateFood: Array food no existe');
                    return;
                }
                
                // üêü PERSECUCI√ìN DE COMIDA MANEJADA EN updateFishMovement()
                
                const h = this.canvas.height;
                const drag = 0.99;
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 254-256
                for (const f of this.food) {
                    if (f.bottomT > 0) {
                        f.bottomT += deltaTime;
                    } else {
                        f.vy = Math.min(f.vy + 50 * deltaTime, 60);
                        f.y += f.vy * deltaTime;
                        f.x += f.vx * deltaTime;
                        f.vx *= drag;
                // USAR SUELO UNIFICADO
                const floorY = this.getFloorY();
                        if (f.y > floorY) {
                            f.y = floorY;
                            f.vy = 0;
                            f.vx = 0;
                            f.bottomT = Math.max(0.001, f.bottomT || 0.001);
                        }
                    }
                }
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 258-269
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const f = this.food[i];
                    const distance = this.fish ? this.dist(this.fish.x, this.fish.y, f.x, f.y) : 999;
                    
                    // üçé COLISI√ìN CON EL PEZ (radio de colisi√≥n m√°s amplio)
                    if (this.fish && distance < 28) { // Aumentado de 22 a 28 para mejor detecci√≥n
                        console.log(`üçé COLISI√ìN: Pez en (${this.fish.x.toFixed(1)}, ${this.fish.y.toFixed(1)}) come pellet en (${f.x.toFixed(1)}, ${f.y.toFixed(1)}) - Distancia: ${distance.toFixed(1)}`);
                        this.food.splice(i, 1);
                        
                        // üçé COMER CON CONFIG POR ETAPA
                        const cfg = this.getStageCfg(this.gameState);
                        const hadRealHunger = this.gameState.needs.hunger > 20; // Solo si ten√≠a hambre significativa
                        this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger - cfg.eatReduce, 0, 100);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerPellet, 0, 100);
                        
                        // üê† SALIR DEL ESTADO DEPRIMIDO SI COME
                        if (this.fish.isDepressed && this.gameState.needs.hunger < 70) {
                            this.fish.isDepressed = false;
                            this.fish.isInCorner = false;
                            this.fish.hideTimer = 0;
                            console.log('üê† ¬°Pez sale del estado deprimido al comer!');
                        }
                        
                        // ü´ß DAR BURBUJAS SI TEN√çA HAMBRE REAL
                        if (hadRealHunger) {
                            this.gameState.bubbles += 2;
                            console.log(`ü´ß +2 burbujas por comer con hambre real (hambre previa: ${this.gameState.needs.hunger + cfg.eatReduce}%)`);
                            
                            // üéÜ EFECTO VISUAL DE BURBUJAS AL CONTADOR
                            this.createBubbleEffect(2);
                        }
                        
                        console.log(`üçé ¬°PEZ COME! Etapa: ${this.gameState.stage} - Reduce hambre: ${cfg.eatReduce} - A√±ade suciedad: ${cfg.dirtPerPellet}`);
                        
                        // üîä SONIDO SIEMPRE
                        if (window.audioManager) {
                            window.audioManager.playSound('eat');
                        }
                        
                        // üé¨ √ëAM SIEMPRE
                            this.labels.push({
                                x: this.fish.x,
                                y: this.fish.y - 12,
                                text: "√ëam",
                                a: 1,
                                vy: 40,
                                life: 1.4
                            });
                            
                            this.fish.happyBurst = Math.max(this.fish.happyBurst, 1.2);
                            this.fish.spinKind = "eat";
                            
                        // üìä ACTUALIZAR BARRAS SIEMPRE
                        this.updateCrisisFlags();
                        this.updateNeedBars();
                        
                        console.log(`üçé ¬°√ëam completo! Nueva hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                        
                        // ‚ú® EFECTOS DE PART√çCULAS AL COMER
                        this.createEatingParticles(f.x, f.y);
                        
                        // üì∏ EVENTO DE ALIMENTACI√ìN OCASIONAL
                        if (Math.random() < 0.1) { // 10% chance
                            const feedingMessages = [
                                'Mmm, ¬°qu√© rico! Esta comida est√° deliciosa.',
                                '¬°√ëam √±am! Me encanta cuando me das de comer.',
                                'Gracias por cuidarme tan bien. Esta comida me da mucha energ√≠a.',
                                '¬°Qu√© sabroso! Ahora me siento mucho mejor.',
                                'Esta comida me recuerda a cuando era peque√±o.'
                            ];
                            const msg = feedingMessages[Math.floor(Math.random() * feedingMessages.length)];
                            this.addAlbumEvent('feeding', 'üçΩÔ∏è Hora de comer', msg);
                        }
                        
                        // ‚ö†Ô∏è ELIMINADO: No limitar hambre en crisis para que siga persiguiendo
                        // if (this.gameState.crisis.hunger) {
                        //     this.gameState.needs.hunger = Math.min(this.gameState.needs.hunger, 60);
                        // }
                        
                        this.updateCrisisFlags();
                        this.updateNeedBars();
                        continue; // Importante: saltar al siguiente pellet
                    } 
                    
                    // üóëÔ∏è PUDRIR COMIDA VIEJA (despu√©s de 8 segundos en el fondo)
                    if (f.bottomT > 0 && f.bottomT > 8) {
                        console.log(`üóëÔ∏è Pellet podrido despu√©s de ${f.bottomT.toFixed(1)}s en el fondo`);
                        const cfg = this.getStageCfg(this.gameState);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerRotten, 0, 100);
                        console.log(`ü¶† Suciedad por pudrici√≥n: +${cfg.dirtPerRotten} (total: ${this.gameState.needs.dirt.toFixed(1)}%)`);
                        this.updateNeedBars();
                        this.food.splice(i, 1);
                    }
                }
                
                // üìä LOG PERI√ìDICO PARA DEBUG
                // Log reducido: solo cada 5 segundos o cuando cambia significativamente
                this.lastFoodLogTime = this.lastFoodLogTime || 0;
                if (Date.now() - this.lastFoodLogTime > 5000) {
                    console.log(`üçé Estado: ${this.food.length} pellets - Hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                    this.lastFoodLogTime = Date.now();
                }
            }
            
            drawFood() {
                if (!this.food || this.food.length === 0) {
                    // console.log('üçé drawFood: No hay comida que dibujar');
                    return;
                }
                
                // Solo log cuando hay cambios importantes
                if (this.food.length > (this.lastFoodCount || 0)) {
                    console.log('üçé Comida a√±adida:', this.food.length, 'pellets');
                    this.lastFoodCount = this.food.length;
                }
                
                this.ctx.save();
                for (let i = 0; i < this.food.length; i++) {
                    const f = this.food[i];
                    // console.log(`üçé Dibujando pellet ${i}:`, f.x, f.y, f.r); // Log deshabilitado para performance
                    
                    this.ctx.beginPath();
                    this.ctx.arc(f.x, f.y, f.r || 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = f.colorFill || '#ffd166';
                    this.ctx.fill();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = f.colorStroke || '#cc8400';
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }
            
            // üçé FUNCIONES DE COMIDA
            nearestFood() {
                let best = null, bestD = 1e9;
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                return best || null;
            }
            
            // ‚ù§Ô∏è CORAZ√ìN VOLADOR (cuando tocas el pez)
            launchHeartToFun() {
                // VERSI√ìN CHATGPT: Convertir coords DOM de la barra a coords canvas
                const barF = document.getElementById('funBarHeader'); // Barra de diversi√≥n del header
                if (!barF) {
                    console.log('‚ùå No se encontr√≥ barra de diversi√≥n');
                    return;
                }
                
                const crect = this.canvas.getBoundingClientRect();
                const frect = barF.getBoundingClientRect();
                
                const sx = this.fish.x, sy = this.fish.y; // origen coraz√≥n (pez)
                const ex = frect.left + frect.width * 0.9 - crect.left; // destino barra
                const ey = frect.top + frect.height * 0.5 - crect.top;
                
                // control point para Bezier (curvita agradable)
                const cx = (sx + ex) / 2;
                const cy = Math.min(sy, ey) - 100;
                
                this.flyers.push({ 
                    t: 0, dur: 1.8, sx, sy, cx, cy, ex, ey, given: false 
                });
                
                console.log('‚ù§Ô∏è Coraz√≥n lanzado hacia barra de diversi√≥n (coords DOM)');
            }
            
            // ü´ß BURBUJAS DE RESPIRACI√ìN (desde la boca)
            emitMouthBubbles(n = 4, x0, y0) {
                const fish = this.fish;
                if (!fish) return;
                
                // Posici√≥n de la boca del pez
                const bodyW = fish.size * 0.4;
                const bodyH = fish.size * 0.24;
                const mx = fish.x + (fish.facing > 0 ? 1 : -1) * (bodyW * 0.42);
                const my = fish.y - bodyH * 0.12;
                
                for (let i = 0; i < n; i++) {
                    this.tinyBubbles.push({
                        x: mx + (Math.random() * 6 - 3),
                        y: my + (Math.random() * 6 - 3),
                        r: 0.9 + Math.random() * 1.3,
                        vy: 50 + Math.random() * 40,
                        wob: Math.random() * Math.PI * 2,
                        wobSpd: 1.2 + Math.random() * 0.8,
                        wobAmp: 3 + Math.random() * 4,
                        a: 1,
                        life: 1.2
                    });
                }
            }
            
            // ü´ß BURBUJITAS SUTILES DE AMBIENTE (REALMENTE SUTILES)
            drawAmbientBubbles() {
                const time = this.gameTime || Date.now() * 0.001;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                this.ctx.save();
                
                // 8 burbujitas REALMENTE peque√±as y sutiles
                for (let i = 0; i < 8; i++) {
                    // Posici√≥n que se mueve muy lentamente
                    const baseX = (i * 97 + (time * 15) % W) % W;
                    const baseY = H - ((time * 25 + i * 80) % H);
                    
                    // Peque√±o wobble muy sutil
                    const x = baseX + Math.sin(time * 1.5 + i) * 4;
                    const y = baseY + Math.cos(time * 1.2 + i) * 3;
                    
                    // Tama√±o muy peque√±o (1-3px)
                    const size = 1 + (i % 2) + Math.sin(time * 2 + i) * 0.3;
                    
                    // MUY transparente
                    this.ctx.globalAlpha = 0.15 + Math.sin(time * 1.8 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    this.ctx.shadowBlur = 0; // Sin sombra
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // ü´ß BURBUJITAS SUTILES DURANTE GESTACI√ìN DEL HUEVO
            drawEggGestationBubbles() {
                const time = (Date.now() * 0.001) % 1000; // Tiempo lento
                const eggX = 0; // Relativo al huevo (ya transformado)
                const eggY = 0;
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                
                // 6 burbujitas muy sutiles alrededor del huevo
                for (let i = 0; i < 6; i++) {
                    const angle = (time * 0.3 + i * Math.PI / 3) % (Math.PI * 2);
                    const radius = eggSize * 0.35 + Math.sin(time * 2 + i) * 10;
                    
                    const x = eggX + Math.cos(angle) * radius;
                    const y = eggY + Math.sin(angle) * radius * 0.6; // M√°s ovalado
                    
                    // Tama√±o muy peque√±o (2-4px)
                    const size = 2 + Math.sin(time * 3 + i) * 1;
                    
                    // MUY transparente y suave
                    this.ctx.globalAlpha = 0.1 + Math.sin(time * 1.5 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 3 burbujitas m√°s grandes que suben lentamente
                for (let i = 0; i < 3; i++) {
                    const yOffset = ((time * 20 + i * 40) % 120) - 60; // Suben lentamente
                    const x = eggX + (i - 1) * 25 + Math.sin(time * 2 + i) * 8;
                    const y = eggY - eggSize * 0.4 - yOffset;
                    
                    const size = 3 + i * 0.5;
                    this.ctx.globalAlpha = 0.15 - (yOffset / 120) * 0.1; // Se desvanecen al subir
                    this.ctx.fillStyle = '#b3e5fc'; // Azul claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // üçé ACTUALIZAR Y DIBUJAR LABELS ("√ëam", etc.)
            updateLabels(deltaTime) {
                for (let i = this.labels.length - 1; i >= 0; i--) {
                    const label = this.labels[i];
                    label.life -= deltaTime;
                    label.y -= label.vy * deltaTime;
                    label.a = Math.max(0, label.life / 1.4); // Fade out
                    
                    if (label.life <= 0) {
                        this.labels.splice(i, 1);
                    }
                }
            }
            
            drawLabels() {
                this.ctx.save();
                this.ctx.font = 'bold 18px system-ui';
                this.ctx.textAlign = 'center';
                
                for (const label of this.labels) {
                    this.ctx.globalAlpha = label.a;
                    this.ctx.fillStyle = '#ff6b35';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.strokeText(label.text, label.x, label.y);
                    this.ctx.fillText(label.text, label.x, label.y);
                }
                
                this.ctx.restore();
            }
            
            // üéØ VIEW HELPERS - COORDENADAS SIMPLES 
        // üåç TAMA√ëO CANVAS SIMPLE (VERSI√ìN QUE FUNCIONABA)
        viewW() { return this.canvas.width; }
        viewH() { return this.canvas.height; }
        
        // ü´ß GESTI√ìN CAPA OFFSCREEN
        ensureBubLayer() {
            if (!this.bubLayer) {
                this.bubLayer = document.createElement('canvas');
                this.bubCtx = this.bubLayer.getContext('2d');
            }
            this.resizeBubLayer();
        }
        
        resizeBubLayer() {
            if (!this.bubLayer) return;
            const dpr = window.devicePixelRatio || 1;
            const w = this.viewW(), h = this.viewH();
            this.bubLayer.width = Math.max(1, Math.floor(w * dpr));
            this.bubLayer.height = Math.max(1, Math.floor(h * dpr));
            this.bubLayer.style.width = w + 'px';
            this.bubLayer.style.height = h + 'px';
        }
        
        // ü´ß DIBUJAR BURBUJAS EN CAPA OFFSCREEN
        drawBubblesLayer() {
            this.ensureBubLayer();
            const dpr = window.devicePixelRatio || 1;
            
            // Limpiar offscreen en device px y fijar su DPR
            this.bubCtx.setTransform(1, 0, 0, 1, 0, 0);
            this.bubCtx.clearRect(0, 0, this.bubLayer.width, this.bubLayer.height);
            this.bubCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Tiny bubbles (respiraci√≥n)
            for (const b of this.tinyBubbles) {
                this.bubCtx.globalAlpha = Math.max(0.2, b.a || 0.8);
                this.bubCtx.beginPath(); 
                this.bubCtx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                this.bubCtx.fillStyle = '#e8fbff'; 
                this.bubCtx.fill();
                this.bubCtx.lineWidth = 0.7; 
                this.bubCtx.strokeStyle = 'rgba(255,255,255,0.8)'; 
                this.bubCtx.stroke();
            }
        }
            
            // üêü MOVIMIENTO FLUIDO CON F√çSICA AVANZADA (DESDE movimiento_pez_final.html)
            updateFishMovement(deltaTime) {
                if (!this.fish) return;
                console.log('üêü updateFishMovement() ejecut√°ndose...');
                const fish = this.fish;

                // Inicializar propiedades de f√≠sica si no existen
                if (!fish.maxSpeed) fish.maxSpeed = 600; // Duplicado
                if (!fish.maxAccel) fish.maxAccel = 1800; // Duplicado
                if (!fish.baseSpeed) fish.baseSpeed = 280; // Duplicado
                if (!fish.facing) fish.facing = 1;
                if (!fish.wanderTimer) fish.wanderTimer = 0;
                if (!fish.wanderDir) fish.wanderDir = {x: 1, y: 0};
                if (fish.desire === undefined) fish.desire = null;

                // üëÅÔ∏è PARPADEO SIMPLIFICADO (OJO SIEMPRE VISIBLE)
                fish.eyeOpen = 1; // OJO SIEMPRE ABIERTO (sin parpadeo por ahora)
                
                // Sistema de parpadeo deshabilitado temporalmente para debug
                // fish.blinkT = Math.max(0, (fish.blinkT || 0) - deltaTime);
                // fish.nextBlink = (fish.nextBlink || 2) - deltaTime;
                // if (fish.nextBlink <= 0 && fish.blinkT <= 0) {
                //     fish.blinkT = 0.12;
                //     fish.eyeOpen = 0;
                //     fish.nextBlink = 2 + Math.random() * 4;
                // } else if (fish.blinkT <= 0) {
                //     fish.eyeOpen = 1;
                // }

                // Burbujas de respiraci√≥n
                fish.breathT = (fish.breathT || 2) - deltaTime;
                if (fish.breathT <= 0 && !this.cleaningState) {
                    this.emitMouthBubbles(3 + Math.floor(Math.random() * 3));
                    fish.breathT = 2 + Math.random() * 3;
                }

                fish.swimPhase = (fish.swimPhase || 0) + deltaTime * 3.2;
                let targetV = {vx: 0, vy: 0};
                let speedMul = 1.0;

                // üö® NECESIDADES EXTREMAS - Va a esquina
                const hasExtremeNeeds = this.gameState.needs.hunger > 70 || 
                                      this.gameState.needs.dirt > 80 || 
                                      this.gameState.needs.fun < 20;
                
                // Debug de necesidades extremas
                if (this.gameState.needs.hunger > 70 || this.gameState.needs.dirt > 80 || this.gameState.needs.fun < 20) {
                    console.log(`üö® NECESIDADES EXTREMAS: Hambre: ${this.gameState.needs.hunger.toFixed(1)}%, Suciedad: ${this.gameState.needs.dirt.toFixed(1)}%, Diversi√≥n: ${this.gameState.needs.fun.toFixed(1)}%`);
                }
                
                if (hasExtremeNeeds) {
                    console.log('üö® ACTIVANDO COMPORTAMIENTO DE NECESIDADES EXTREMAS');
                    // Pez con necesidades extremas - va a esquina
                    const currentStage = this.gameState.stage;
                    fish.baseSpeed = (currentStage === 'baby' ? 120 : 90) * 0.3; // MUY lento
                    fish.isDepressed = true;
                    fish.hideTimer = (fish.hideTimer || 0) + 1/60;
                    
                    // Se va a la esquina inferior izquierda y se queda quieto
                    if (!fish.isInCorner && fish.hideTimer > 2) {
                        // Ir SIEMPRE a la esquina inferior izquierda
                        const padLeft = 60;
                        const H = this.getFloorY();
                        const corner = { x: padLeft + 5, y: H - 5 }; // Esquina inferior izquierda (5px dentro del l√≠mite)
                        
                        fish.targetX = corner.x;
                        fish.targetY = corner.y;
                        // Pez con necesidades extremas va LENTO a esquina
                        fish.cornerTargetX = corner.x;
                        fish.cornerTargetY = corner.y;
                        fish.goingToCorner = true;
                        fish.isInCorner = true;
                        fish.cornerTime = 5 + Math.random() * 8; // 5-13 segundos en esquina
                        console.log(`üò¢ Pez con hambre >70% va a esconderse en esquina inferior izquierda... (${corner.x}, ${corner.y})`);
                    }
                    
                    // Quedarse quieto en la esquina
                    if (fish.isInCorner) {
                        fish.cornerTime -= 1/60;
                        
                        // Movimiento MUY reducido en la esquina
                        if (fish.cornerTime > 0) {
                            fish.vx *= 0.95; // Casi inm√≥vil
                            fish.vy *= 0.95;
                        } else {
                            fish.isInCorner = false;
                            fish.hideTimer = 0;
                            console.log('üê† Pez sale de la esquina');
                        }
                    }
                    
                    // üçé PERMITIR B√öSQUEDA DE COMIDA INCLUSO CUANDO EST√Å EN ESQUINA
                    const nearestFood = this.nearestFood();
                    if (nearestFood && this.dist(fish.x, fish.y, nearestFood.x, nearestFood.y) < 80) {
                        console.log('üçé Pez hambriento detecta comida cerca, va a comer!');
                        fish.desire = 'food';
                        fish.targetX = nearestFood.x;
                        fish.targetY = nearestFood.y;
                        fish.isGoingToTarget = true;
                        fish.isInCorner = false; // Salir de la esquina para comer
                        fish.cornerTime = 0;
                    }
                    
                    // NO salir temprano - permitir que contin√∫e con la l√≥gica de movimiento
                }

                // üî• TURBO DE DEDO (decaimiento)
                fish.fingerBoostT = Math.max(0, (fish.fingerBoostT || 0) - deltaTime);

                // üåÄ EFECTO GIRATORIO (happyBurst)
                if (fish.happyBurst && fish.happyBurst > 0) {
                    const w = (fish.spinKind === "clean") ? 13.0 : 6.0;
                    const R = (fish.spinKind === "clean") ? 140 : 55;
                    const a = (this._time || 0) * w;
                    targetV = {vx: Math.cos(a) * R * 0.65, vy: Math.sin(a) * R * 0.65};
                    speedMul = (fish.spinKind === "clean") ? 1.8 : 1.25;
                    fish.happyBurst = Math.max(0, fish.happyBurst - (fish.spinKind === "clean" ? 0.6 : 1.6) * deltaTime);
                }
                // üëÜ SEGUIR DEDO (PRIORIDAD M√ÅXIMA) - USANDO fish.desire COMO EL EJEMPLO
                else if (fish.desire) {
                    const s = this.seek(fish.x, fish.y, fish.desire.x, fish.desire.y, fish.maxSpeed * 0.9);
                    const t = this.clamp(s.dist / 120, 0.25, 1);
                    targetV = {vx: s.vx * t, vy: s.vy * t};
                    speedMul = 1.5;
                    
                    if (s.dist < 40) {
                        // üíñ PEZ LLEG√ì AL DEDO - LANZAR CORAZ√ìN CON SONIDO
                        fish.desire = null;
                        targetV = {vx: 0, vy: 0};
                        this.launchHeartToFun(fish.x, fish.y);
                        
                        // üîä SONIDO DE CORAZ√ìN/BURBUJA
                        if (window.audioManager) {
                            window.audioManager.playSound('heart');
                        }
                        
                        console.log('üíñ ¬°Pez lleg√≥ al dedo! Coraz√≥n lanzado con sonido');
                    }
                }
                // üçé PERSEGUIR COMIDA SIEMPRE (los peces SIEMPRE comen)
                else if (this.food.length > 0) {
                    const closest = this.nearestFood();
                    if (closest) {
                        const d = this.dist(fish.x, fish.y, closest.x, closest.y);
                        const s = this.seek(fish.x, fish.y, closest.x, closest.y, fish.maxSpeed * 0.9);
                        const t = this.clamp(d / 200, 0.35, 1); // Rango ampliado a 200px
                        targetV = {vx: s.vx * t, vy: s.vy * t};
                        speedMul = 1.3;
                        fish.isChasing = true;
                    }
                }
                // üéØ MOVIMIENTO ALEATORIO FLUIDO (cuando no hay objetivos)
                else {
                    fish.wanderTimer -= deltaTime;
                    if (fish.wanderTimer <= 0) {
                        const angle = Math.random() * Math.PI * 2;
                        fish.wanderDir.x = Math.cos(angle);
                        fish.wanderDir.y = Math.sin(angle) * 0.33; // Menos movimiento vertical
                        fish.wanderTimer = 0.8 + Math.random() * 1.1;
                    }
                    const cruise = fish.baseSpeed * 1.1;
                    targetV = {
                        vx: fish.wanderDir.x * cruise + Math.cos(fish.swimPhase) * 16,
                        vy: fish.wanderDir.y * cruise + Math.sin(fish.swimPhase * 1.8) * 16
                    };
                    speedMul = 0.8;
                }

                // üèä F√çSICA AVANZADA: ACELERACI√ìN GRADUAL
                const maxSpeed = fish.maxSpeed * speedMul;
                const maxAccel = fish.maxAccel * speedMul;
                
                fish.vx = fish.vx || 0;
                fish.vy = fish.vy || 0;
                
                const ax = this.clamp(targetV.vx - fish.vx, -maxAccel, maxAccel);
                const ay = this.clamp(targetV.vy - fish.vy, -maxAccel, maxAccel);
                
                fish.vx += ax * deltaTime;
                fish.vy += ay * deltaTime;

                // üöÄ MOVER PEZ
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;

                // üß± L√çMITES FIJOS QUE FUNCIONAN (SISTEMA ORIGINAL)
                const padLeft = 60; // Margen izquierdo para no salir de pantalla
                const padRight = 30; // Margen derecho m√°s peque√±o para llegar al borde
                const padBottom = 5; // Margen inferior MUY PEQUE√ëO para que pueda bajar m√°s
                const W = this.canvas.width;
                const H = this.getFloorY();
                
                // Debug: mostrar l√≠mites cada 3 segundos
                if (!this.lastBoundaryDebug || Date.now() - this.lastBoundaryDebug > 3000) {
                    console.log('üß± L√≠mites fijos:');
                    console.log(`  - left: ${padLeft}, right: ${W - padRight}`);
                    console.log(`  - top: 125, bottom: ${H - padBottom}`);
                    console.log(`üêü Posici√≥n pez: (${fish.x.toFixed(1)}, ${fish.y.toFixed(1)})`);
                    console.log(`üì± Canvas: ${W}x${H}`);
                    this.lastBoundaryDebug = Date.now();
                }
                
                // Aplicar l√≠mites con rebote suave
                if (fish.x < padLeft) { 
                    console.log(`‚ö†Ô∏è Pez sali√≥ por izquierda: ${fish.x.toFixed(1)} < ${padLeft}`);
                    fish.x = padLeft; 
                    if (fish.vx < 0) fish.vx *= -0.5; 
                }
                if (fish.x > W - padRight) { 
                    console.log(`‚ö†Ô∏è Pez sali√≥ por derecha: ${fish.x.toFixed(1)} > ${W - padRight}`);
                    fish.x = W - padRight; 
                    if (fish.vx > 0) fish.vx *= -0.5; 
                }
                if (fish.y < 125) { 
                    fish.y = 125; 
                    if (fish.vy < 0) fish.vy *= -0.5; 
                }
                if (fish.y > H - padBottom) { 
                    fish.y = H - padBottom; 
                    if (fish.vy > 0) fish.vy *= -0.5; 
                }

                // üêü ORIENTACI√ìN FLUIDA (mirar hacia donde nada)
                if (Math.abs(fish.vx) > 2) {
                    fish.facing = fish.vx > 0 ? 1 : -1;
                    fish.facingRight = fish.vx > 0; // Para compatibilidad
                }
            }
            
            // üéØ FUNCI√ìN SEEK PARA MOVIMIENTO FLUIDO (DESDE movimiento_pez_final.html)
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            // üçé ENCONTRAR COMIDA M√ÅS CERCANA
            nearestFood() {
                if (!this.food || this.food.length === 0) return null;
                
                let best = null;
                let bestD = Infinity;
                
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                
                return best;
            }
            
            // ‚Äî‚Äî‚Äî CONFIG POR ETAPA ‚Äî‚Äî‚Äî
        getStageCfg(state) {
            var STAGE_RATES = {
                baby:  { hungerHours: 2, dirtHours: 4, funHours: 3, eatReduce: 30, dirtPerPellet: 3, dirtPerRotten: 6 },
                young: { hungerHours: 6, dirtHours: 8, funHours: 4, eatReduce: 25, dirtPerPellet: 2, dirtPerRotten: 5 },
                adult: { hungerHours: 8, dirtHours:10, funHours: 5, eatReduce: 20, dirtPerPellet: 1, dirtPerRotten: 4 },
            };
            var st = (state && state.stage) || 'baby';
            return STAGE_RATES[st] || STAGE_RATES.baby;
        }
        
        // üîß FUNCIONES QUE FALTAN PARA EL SISTEMA REALISTA
        updateAutoNeeds(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;

                const cfg = this.getStageCfg(this.gameState);
                const hungerInc = (100 / (cfg.hungerHours * 3600)) * deltaTime;
                const dirtInc   = (100 / (cfg.dirtHours   * 3600)) * deltaTime;
                const funDec    = (100 / (cfg.funHours    * 3600)) * deltaTime;

                this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger + hungerInc, 0, 100);
                this.gameState.needs.dirt   = this.clamp(this.gameState.needs.dirt   + dirtInc,   0, 100);
                this.gameState.needs.fun    = this.clamp(this.gameState.needs.fun    - funDec,    0, 100);
                
                // üê† MENSAJES SUTILES DEL PEZ (solo ocasionalmente)
                if (Math.random() < 0.01) { // 1% de probabilidad por frame
                    if (this.gameState.needs.hunger > 60) {
                        const messages = ["Tengo hambre...", "¬øAlgo de comer?", "Mi barriga ruge"];
                        this.showFishMessage(messages[Math.floor(Math.random() * messages.length)], '#FF6B6B');
                    } else if (this.gameState.needs.dirt > 50) {
                        const messages = ["Me siento sucio", "Necesito un ba√±o", "¬°Qu√© asco!"];
                        this.showFishMessage(messages[Math.floor(Math.random() * messages.length)], '#8B4513');
                    } else if (this.gameState.needs.fun < 30) {
                        const messages = ["Me aburro...", "¬øJugamos?", "Estoy solo"];
                        this.showFishMessage(messages[Math.floor(Math.random() * messages.length)], '#9370DB');
                    }
                }
                
                // Actualizar barras visuales
                this.updateNeedBars();
            }
            
            resetForEgg() {
                this.food = [];
                this.cleanBubbles = [];
                this.labels = [];
                this.flyers = [];
                if (this.fish) this.fish.desire = null; // Limpiar desire del pez
                this.cleaning = null;

                this.gameState.needs = { hunger: 15, dirt: 0, fun: 95 };
                this.updateNeedBars?.();
                this.gameState.stage = 'egg';

                // Si tienes contadores de monedas/estrellas, pon sus valores de inicio acordados
                // this.gameState.coins = 0;
                // this.gameState.stars = 0;
                
                console.log('ü•ö Reset completo para huevo - Todo limpio');
            }
            
            updateNeedBars() {
                // Actualizar las barras visuales (FLOTANTES - OCULTAS)
                const hungerBar = document.getElementById('hungerBar');
                const dirtBar = document.getElementById('dirtBar');
                const funBar = document.getElementById('funBar');
                
                if (hungerBar) hungerBar.style.width = this.gameState.needs.hunger + '%';
                if (dirtBar) dirtBar.style.width = this.gameState.needs.dirt + '%';
                if (funBar) funBar.style.width = this.gameState.needs.fun + '%';
                
                // üìä ACTUALIZAR BARRAS DEL HEADER (NUEVAS)
                const hungerBarHeader = document.getElementById('hungerBarHeader');
                const dirtBarHeader = document.getElementById('dirtBarHeader');
                const funBarHeader = document.getElementById('funBarHeader');
                
                if (hungerBarHeader) hungerBarHeader.style.width = this.gameState.needs.hunger + '%';
                if (dirtBarHeader) dirtBarHeader.style.width = this.gameState.needs.dirt + '%';
                if (funBarHeader) {
                    funBarHeader.style.width = this.gameState.needs.fun + '%';
                    // BORDE ROJO cuando diversi√≥n est√° baja (aburrido)
                    if (this.gameState.needs.fun <= 25) {
                        funBarHeader.style.border = '2px solid #ff4444';
                        funBarHeader.style.boxShadow = '0 0 8px rgba(255, 68, 68, 0.6)';
                    } else {
                        funBarHeader.style.border = 'none';
                        funBarHeader.style.boxShadow = 'none';
                    }
                }
            }
            
            updateCrisisFlags() {
                const CRISIS_LVL = 75;
                this.gameState.crisis.hunger = this.gameState.needs.hunger >= CRISIS_LVL;
                this.gameState.crisis.dirt = this.gameState.needs.dirt >= CRISIS_LVL;
                this.gameState.crisis.bored = this.gameState.needs.fun <= 25; // Aburrido cuando diversi√≥n < 25%
            }
            
            updateTinyBubbles(deltaTime) {
                // Actualizar burbujas de respiraci√≥n
                for (const b of this.tinyBubbles) {
                    b.y -= b.vy * deltaTime;
                    b.x += Math.sin((this.state?.time || Date.now() * 0.001) * b.wobSpd + b.wob) * b.wobAmp * deltaTime;
                    b.life -= deltaTime;
                    b.a = Math.max(0, b.life / 1.2);
                }
                
                // Eliminar burbujas muertas
                for (let i = this.tinyBubbles.length - 1; i >= 0; i--) {
                    const b = this.tinyBubbles[i];
                    if (b.life <= 0 || b.y < -12) {
                        this.tinyBubbles.splice(i, 1);
                    }
                }
            }
            
            updateFlyers(deltaTime) {
                if (!this.flyers) this.flyers = [];
                
                // VERSI√ìN CHATGPT: Actualizar progreso de corazones
                for (const f of this.flyers) {
                    f.t += deltaTime / f.dur;
                }
                
                // Purgar completados y dar diversi√≥n
                for (let i = this.flyers.length - 1; i >= 0; i--) {
                    const f = this.flyers[i];
                    if (f.t >= 1) {
                        if (!f.given) {
                            // SUMAR DIVERSI√ìN +0.25
                            this.gameState.needs.fun = this.clamp(this.gameState.needs.fun + 25, 0, 100); // +25 = +0.25 en escala 0-100
                            this.updateNeedBars();
                            
                            // Efecto visual en la barra
                            const barF = document.getElementById('funBarHeader');
                            if (barF) {
                                barF.classList.remove('pulse'); 
                                void barF.offsetWidth; 
                                barF.classList.add('pulse');
                            }
                            
                            f.given = true;
                            console.log('üíñ +25 diversi√≥n por tocar al pez');
                        }
                        this.flyers.splice(i, 1);
                    }
                }
            }
            
            // üíñ DIBUJAR CORAZONES VOLADORES
            drawFlyers() {
                if (!this.flyers) return;
                
                // VERSI√ìN CHATGPT: Curva de Bezier
                for (const f of this.flyers) {
                    const t = Math.min(1, f.t), u = 1 - t;
                    // curva de Bezier 2 puntos
                    const x = u*u*f.sx + 2*u*t*f.cx + t*t*f.ex;
                    const y = u*u*f.sy + 2*u*t*f.cy + t*t*f.ey;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.font = 'bold 18px system-ui, Segoe UI, Arial';
                    this.ctx.fillStyle = 'rgba(255,120,160,1)';
                    this.ctx.fillText('‚ù§', x - 6, y);
                    this.ctx.restore();
                }
            }
        }
        
        // üåê game ya est√° expuesto globalmente arriba
        
        // üö® SISTEMA DE EMERGENCIA PARA MODALES
        setTimeout(() => {
            console.log('üö® Activando sistema de emergencia para modales...');
            
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            const invBtn = document.getElementById('inventoryButton');
            const invModal = document.getElementById('inventoryModal');
            
            // Funci√≥n para abrir modal de juegos
            window.openGamesModal = function() {
                console.log('üéÆ Abriendo modal de juegos (funci√≥n de emergencia)');
                if (gamesModal) {
                    gamesModal.style.display = 'flex';
                    gamesModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n para abrir modal de inventario
            window.openInventoryModal = function() {
                console.log('üéí Abriendo modal de inventario (funci√≥n de emergencia)');
                if (invModal) {
                    invModal.style.display = 'flex';
                    invModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n S√öPER SIMPLE para juego de burbujas
            window.startBubbleGameDirect = function() {
                console.log('ü´ß Iniciando juego SIMPLE');
                
                // üîä SONIDO DE INICIO DE JUEGO
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                // Si window.game existe, usar su m√©todo
                if (window.game && window.game.runBubbleGame) {
                    window.game.runBubbleGame();
                    return;
                }
                
                // Pantalla simple
                document.body.innerHTML += `
                    <div id="bubbleGameOverlay" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                        z-index: 10000;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding: 20px;
                        font-family: Comic Sans MS, cursive;
                    ">
                        <div style="
                            color: white;
                            text-align: center;
                            margin-bottom: 15px;
                            font-size: 20px;
                            font-weight: bold;
                            background: rgba(255,255,255,0.1);
                            padding: 10px 20px;
                            border-radius: 15px;
                            border: 2px solid rgba(255,255,255,0.3);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                                <div>‚è±Ô∏è <span id="bubbleTimer">20</span>s</div>
                                <div>ü´ß <span id="bubbleScore">0</span></div>
                                <button onclick="document.getElementById('bubbleGameOverlay').remove()" style="
                                    background: rgba(255,255,255,0.2);
                                    border: 2px solid rgba(255,255,255,0.5);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    color: white;
                                    font-size: 18px;
                                    cursor: pointer;
                                ">‚ùå</button>
                            </div>
                        </div>
                        
                        <div id="bubbleGameArea" style="
                            position: relative;
                            width: 100%;
                            max-width: 350px;
                            height: 450px;
                            border-radius: 20px;
                            overflow: hidden;
                            cursor: pointer;
                            background: rgba(255,255,255,0.05);
                            border: 3px solid rgba(255,255,255,0.2);
                        "></div>
                    </div>
                `;
                
                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                
                const gameArea = document.getElementById('bubbleGameArea');
                
                // Funci√≥n simple para crear burbujas
                function createBubble() {
                    if (!gameActive) return;
                    
                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35;
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: \${size}px;
                        height: \${size}px;
                        border-radius: 50%;
                        background: \${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid white;
                        cursor: pointer;
                        top: 450px;
                        left: \${Math.random() * (300)}px;
                        transition: top 3s linear;
                    `;
                    
                    bubble.onclick = function() {
                        if (isGood) {
                            score += 3;
                            timeLeft += 1;
                        } else {
                            score = Math.max(0, score - 2);
                        }
                        document.getElementById('bubbleScore').textContent = score;
                        bubble.remove();
                    };
                    
                    gameArea.appendChild(bubble);
                    
                    // Animar hacia arriba
                    setTimeout(() => bubble.style.top = '-50px', 10);
                    
                    // Remover autom√°ticamente
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, 3000);
                }
                
                // Timer simple
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(timer);
                        clearInterval(spawner);
                        
                        gameArea.innerHTML = `
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                text-align: center;
                                color: white;
                                font-size: 24px;
                                font-weight: bold;
                                background: rgba(255,255,255,0.1);
                                padding: 20px;
                                border-radius: 15px;
                            ">
                                üéâ ¬°Terminado!<br>
                                ü´ß \${score} puntos<br>
                                ‚≠ê 1 estrella
                            </div>
                        `;
                    }
                }, 1000);
                
                // Spawner simple
                const spawner = setInterval(() => {
                    if (gameActive) createBubble();
                }, 800);
                
                // Burbujas iniciales
                setTimeout(() => createBubble(), 500);
                setTimeout(() => createBubble(), 1000);
            };
            
            // Event listeners de emergencia - ELIMINADO (YA EXISTE ARRIBA)
            
            if (invBtn) {
                invBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('üö® CLICK DETECTADO - Abriendo inventario');
                    window.openInventoryModal();
                };
            }
            
            // Botones de cierre
            const closeGames = document.getElementById('closeGames');
            const closeInventory = document.getElementById('closeInventory');
            
            if (closeGames) {
                closeGames.onclick = function() {
                    gamesModal.style.display = 'none';
                };
            }
            
            if (closeInventory) {
                closeInventory.onclick = function() {
                    invModal.style.display = 'none';
                };
            }
            
            // Event listeners para las tarjetas de juegos cuadradas
            const gameCards = document.querySelectorAll('.game-card-square');
            gameCards.forEach(card => {
                card.onclick = function(e) {
                    e.preventDefault();
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    console.log(`üéÆ Click en juego: ${gameId}, bloqueado: ${isLocked}`);
                    
                    if (!isLocked) {
                        console.log(`üöÄ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        gamesModal.style.display = 'none';
                        
                        // Iniciar juego usando window.game o funci√≥n de emergencia
                        if (window.game && window.game.startGame) {
                            window.game.startGame(gameId);
                        } else if (gameId === 'bubbles') {
                            console.log('üö® Usando funci√≥n de emergencia para burbujas');
                            window.startBubbleGameDirect();
                        } else {
                            console.error('‚ùå window.game no disponible y no hay funci√≥n de emergencia para:', gameId);
                            alert(`üöß Juego ${gameId} no disponible temporalmente`);
                        }
                    } else {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        alert(`üîí Juego bloqueado. Necesitas m√°s estrellas.`);
                    }
                };
            });
            
            console.log('‚úÖ Sistema de emergencia activado');
        }, 1000);

        // üéµ SISTEMA DE AUDIO COMPLETO
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.backgroundMusic = null;
                this.isMuted = localStorage.getItem('miPececito_muted') === 'true' || false;
                this.volume = parseFloat(localStorage.getItem('miPececito_volume')) || 0.7;
                this.musicVolume = 0.55; // M√∫sica de fondo bien audible
                this.effectsVolume = 0.4; // Efectos a volumen medio
                
                this.initAudioContext();
                this.loadSounds();
                this.createGeneratedSounds();
            }
            
            async initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('üéµ AudioContext creado correctamente');
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo crear AudioContext:', error);
                }
            }
            
            async loadSounds() {
                const soundFiles = {
                    background: './sound/fondo.mp3',
                    eat: './sound/comer.mp3',
                    hatch: './sound/eclosionar.mp3',
                    clean: './sound/limpiar.mp3',
                    fail: './sound/fallo.mp3',
                    levelComplete: './sound/nivelcompletado.mp3',
                    jugar: './sound/jugar.mp3',
                    acierto: './sound/comer.mp3'
                };
                
                for (const [name, url] of Object.entries(soundFiles)) {
                    try {
                        const audio = new Audio(url);
                        audio.preload = 'auto';
                        this.sounds[name] = audio;
                        console.log(`üéµ Sonido cargado: ${name}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Error cargando ${name}:`, error);
                    }
                }
                
                // Configurar m√∫sica de fondo
                if (this.sounds.background) {
                    this.sounds.background.loop = true;
                    this.sounds.background.volume = this.musicVolume * this.volume;
                    this.backgroundMusic = this.sounds.background;
                }
            }
            
            createGeneratedSounds() {
                // Sonidos que crearemos con Web Audio API si no existen
                this.createHeartSound();
                this.createBirthSound();
                this.createClickSound();
                this.createAchievementSound();
                this.createEvolutionSound();
                this.createGameWinSound();
            }
            
            createHeartSound() {
                // Sonido de campanita suave para el coraz√≥n
                this.sounds.heart = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createBirthSound() {
                // Fanfarria suave para el nacimiento
                this.sounds.birth = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const notes = [523, 659, 784, 1047]; // Do, Mi, Sol, Do alto
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.2, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                            
                            oscillator.type = 'triangle';
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, i * 100);
                    });
                };
            }
            
            createClickSound() {
                // Sonido sutil de click/burbuja
                this.sounds.click = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.1, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }
            
            // üîä SONIDOS ADICIONALES PARA NUEVAS FUNCIONALIDADES
            createAchievementSound() {
                // Sonido √©pico para logros
                this.sounds.achievement = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    // Acorde triunfal
                    const frequencies = [523, 659, 784]; // Do, Mi, Sol
                    frequencies.forEach((freq, i) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        oscillator.type = 'triangle';
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.2, this.audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.0);
                        
                        oscillator.start(this.audioContext.currentTime + i * 0.1);
                        oscillator.stop(this.audioContext.currentTime + 1.0);
                    });
                };
            }
            
            createEvolutionSound() {
                // Sonido m√°gico para evoluci√≥n
                this.sounds.evolution = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Subida m√°gica de frecuencia
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 1.0);
                    
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.4, this.audioContext.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 1.2);
                };
            }
            
            createGameWinSound() {
                // Sonido de victoria para juegos
                this.sounds.gamewin = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    // Melod√≠a ascendente alegre
                    const notes = [523, 587, 659, 784]; // Do, Re, Mi, Sol
                    notes.forEach((freq, i) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        oscillator.type = 'square';
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.15, this.audioContext.currentTime + i * 0.1 + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + i * 0.1 + 0.3);
                        
                        oscillator.start(this.audioContext.currentTime + i * 0.1);
                        oscillator.stop(this.audioContext.currentTime + i * 0.1 + 0.3);
                    });
                };
            }
            
            playSound(soundName) {
                if (this.isMuted) return;
                
                const sound = this.sounds[soundName];
                if (!sound) {
                    console.warn(`‚ö†Ô∏è Sonido no encontrado: ${soundName}`);
                    return;
                }
                
                try {
                    if (typeof sound === 'function') {
                        // Sonido generado
                        sound();
                    } else {
                        // Archivo de audio
                        sound.currentTime = 0;
                        sound.volume = this.effectsVolume * this.volume;
                        sound.play();
                    }
                    console.log(`üîä Reproduciendo: ${soundName}`);
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error reproduciendo ${soundName}:`, error);
                }
            }
            
            startBackgroundMusic() {
                if (this.isMuted || !this.backgroundMusic) return;
                
                this.backgroundMusic.volume = this.musicVolume * this.volume;
                
                const playPromise = this.backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('üéµ M√∫sica de fondo iniciada correctamente');
                        })
                        .catch(error => {
                            console.warn('‚ö†Ô∏è Autoplay bloqueado por el navegador:', error);
                            console.log('üéµ La m√∫sica se iniciar√° tras la primera interacci√≥n del usuario');
                        });
                } else {
                    console.log('üéµ M√∫sica de fondo iniciada (navegador antiguo)');
                }
            }
            
            stopBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                    this.backgroundMusic.currentTime = 0;
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('miPececito_muted', this.isMuted.toString());
                
                if (this.isMuted) {
                    this.stopBackgroundMusic();
                } else {
                    this.startBackgroundMusic();
                }
                
                this.updateVolumeButton();
                console.log(`üîä Audio ${this.isMuted ? 'silenciado' : 'activado'}`);
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                localStorage.setItem('miPececito_volume', this.volume.toString());
                
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume * this.volume;
                }
            }
            
            updateVolumeButton() {
                const volumeBtn = document.getElementById('volumeBtn');
                const volumeIcon = document.getElementById('volumeIcon');
                
                if (volumeBtn && volumeIcon) {
                    volumeIcon.src = this.isMuted ? './images/ui/sonidoOff.png' : './images/ui/sonidoOn.png';
                    volumeBtn.title = this.isMuted ? 'Activar sonido' : 'Silenciar sonido';
                    volumeBtn.classList.toggle('muted', this.isMuted);
                }
            }
        }
        
        // üé® DISE√ëO PERFECTO UNIFICADO PARA TODOS LOS JUEGOS (BASADO EN BURBUJAS)
        function applyPerfectUnifiedDesign(gameOverlay, gameName) {
            // Estilos del overlay principal - EXACTAMENTE IGUAL QUE BURBUJAS
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                backdrop-filter: blur(10px) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            // Contenedor principal - EXACTAMENTE IGUAL QUE BURBUJAS
            const container = gameOverlay.querySelector(`.${gameName}-game-container`);
            if (container) {
                container.style.cssText = `
                    background: linear-gradient(180deg, 
                        rgba(129, 212, 250, 0.25) 0%,
                        rgba(79, 195, 247, 0.2) 30%,
                        rgba(41, 182, 246, 0.15) 70%,
                        rgba(13, 71, 161, 0.2) 100%);
                    backdrop-filter: blur(30px) saturate(200%);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    border-radius: 28px;
                    width: 95vw;
                    height: 95vh;
                    max-width: 420px;
                    max-height: 800px;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    box-shadow: 
                        0 30px 100px rgba(79, 195, 247, 0.3),
                        0 0 60px rgba(129, 212, 250, 0.2),
                        inset 0 2px 0 rgba(255, 255, 255, 0.4);
                `;
            }
            
            // Header del juego - EXACTAMENTE IGUAL QUE BURBUJAS
            const header = gameOverlay.querySelector(`.${gameName}-game-header`);
            if (header) {
                header.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.3) 0%, 
                        rgba(129, 212, 250, 0.2) 100%);
                    padding: 15px 20px;
                    display: flex;
                    flex-direction: column;
                    border-bottom: 2px solid rgba(255, 255, 255, 0.25);
                    gap: 8px;
                `;
            }
        }

        // üéÆ JUEGO DE BURBUJAS INTEGRADO HERMOSO
        function startBubbleGame() {
            console.log('ü´ß Iniciando juego de burbujas integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear modal del juego con dise√±o hermoso
            const gameModal = document.createElement('div');
            gameModal.className = 'bubble-game-modal';
            gameModal.innerHTML = `
                <div class="bubble-game-container">
                    <!-- üèÜ HEADER CON DOS L√çNEAS COMO NOS GUSTABA -->
                    <div class="bubble-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">ü´ß Atrapa Burbujas</div>
                            <div class="header-controls">
                                <button id="bubble-sound-toggle" class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="bubble-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        
                        <!-- SEGUNDA L√çNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL 1</span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="bubble-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="bubble-best-display">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- üìñ LEYENDA LADO A LADO -->
                    <div class="bubble-legend">
                        <div class="legend-item good">üêü üê† üêö ü™∏ ‚≠ê</div>
                        <div class="legend-item bad">üíÄ ü¶à ‚ö†Ô∏è üß® ü™ù</div>
                    </div>
                    
                    <!-- üéØ √ÅREA DE JUEGO M√ÅS LARGA -->
                    <div class="bubble-stage-container">
                        <div id="bubbleStage" class="bubble-stage"></div>
                    </div>
                    
                    <!-- üéÆ BOT√ìN JUGAR JUSTO DEBAJO -->
                    <div class="bubble-controls">
                         <button id="bubbleStartBtn" class="bubble-btn primary big-yellow">JUGAR</button>
                    </div>
                </div>
                
                <!-- üèÜ MODAL DE RESULTADOS -->
                <div class="bubble-results-modal" style="display: none;">
                    <div class="results-content">
                        <!-- Bot√≥n X arriba - COMPACTO -->
                        <button class="bubble-close-results-btn" style="
                            position: absolute;
                            top: 10px;
                            right: 10px;
                            width: 25px;
                            height: 25px;
                            font-size: 16px;
                            font-weight: 800;
                            color: #fff;
                            background: rgba(255, 255, 255, 0.2);
                            border: 2px solid rgba(255, 255, 255, 0.5);
                            border-radius: 50%;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.3s ease;
                            z-index: 1000;
                        ">‚úï</button>
                        
                        <h2 id="results-title">¬°Fin de partida!</h2>
                        <div class="results-stats">
                            <div class="result-item">
                                <span class="result-label">üèÜ Nivel Alcanzado</span>
                                <span class="result-value" id="final-level">1</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">üíé Perlas</span>
                                <span class="result-value" id="final-score">0</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">‚≠ê Ganadas</span>
                                <span class="result-value" id="final-stars">1</span>
                            </div>
                        </div>
                        <div class="reward-reasons" id="reward-reasons" style="
                            background: rgba(33, 150, 243, 0.1);
                            border: 2px solid rgba(33, 150, 243, 0.3);
                            border-radius: 12px;
                            padding: 10px;
                            margin: 10px 0;
                            font-size: 12px;
                            color: #fff;
                            white-space: pre-line;
                            text-align: center;
                            font-weight: 500;
                        "></div>
                        <div class="results-buttons">
                            <button id="bubble-again-btn" class="bubble-btn primary">JUGAR</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(gameModal);
            
            
            // üé® APLICAR ESTILOS Y INICIALIZAR JUEGO
            // Aplicar dise√±o perfecto unificado (el hermoso de Burbujas para todos)
            applyPerfectBubbleDesign(gameModal, 'bubble');
            
            // üéØ ARREGLAR ESPEC√çFICAMENTE EL JUEGO DE BURBUJAS
            fixBubbleGameSpecifics(gameModal);
        }
        
        // üéØ FUNCI√ìN ESPEC√çFICA PARA ARREGLAR EL JUEGO DE BURBUJAS
        function fixBubbleGameSpecifics(gameModal) {
            // üü¢ ARREGLAR LEYENDA DE BUENAS (VERDE CON BORDE Y FONDO)
            const goodLegend = gameModal.querySelector('.legend-item.good');
            if (goodLegend) {
                goodLegend.style.cssText = `
                    background: rgba(76, 175, 80, 0.3) !important;
                    border: 3px solid #4CAF50 !important;
                    border-radius: 12px !important;
                    padding: 8px 16px !important;
                    font-size: 16px !important;
                    font-weight: bold !important;
                    color: #2E7D32 !important;
                    box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4) !important;
                    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8) !important;
                `;
            }
            
            // üî¥ ARREGLAR LEYENDA DE MALAS (ROJO CON BORDE Y FONDO)
            const badLegend = gameModal.querySelector('.legend-item.bad');
            if (badLegend) {
                badLegend.style.cssText = `
                    background: rgba(244, 67, 54, 0.3) !important;
                    border: 3px solid #F44336 !important;
                    border-radius: 12px !important;
                    padding: 8px 16px !important;
                    font-size: 16px !important;
                    font-weight: bold !important;
                    color: #C62828 !important;
                    box-shadow: 0 4px 8px rgba(244, 67, 54, 0.4) !important;
                    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8) !important;
                `;
            }
            
            // üìè HACER LA CAJITA DEL JUEGO M√ÅS ALTA PERO DEJAR ESPACIO PARA EL BOT√ìN
            const stageContainer = gameModal.querySelector('.bubble-stage-container');
            if (stageContainer) {
                stageContainer.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.1) 0%, 
                        rgba(41, 182, 246, 0.05) 100%) !important;
                    border: 2px solid rgba(255, 255, 255, 0.2) !important;
                    border-radius: 15px !important;
                    margin: 15px 20px !important;
                    padding: 20px !important;
                    flex: 1 !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    min-height: 500px !important;
                    max-height: 600px !important;
                    box-sizing: border-box !important;
                `;
            }
            
            // üéØ ARREGLAR EL GRID DEL JUEGO PARA QUE COINCIDA CON SU CONTENEDOR
            const bubbleStage = gameModal.querySelector('#bubbleStage');
            if (bubbleStage) {
                bubbleStage.style.cssText = `
                    width: 100% !important;
                    height: 100% !important;
                    min-height: 400px !important;
                    display: grid !important;
                    grid-template-columns: repeat(4, 1fr) !important;
                    grid-template-rows: repeat(6, 1fr) !important;
                    gap: 8px !important;
                    padding: 10px !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                    border-radius: 10px !important;
                    box-sizing: border-box !important;
                `;
            }
            
            // üìê ARREGLAR LEYENDA EN UNA SOLA L√çNEA - TODOS LOS ICONOS JUNTOS
            const legend = gameModal.querySelector('.bubble-legend');
            if (legend) {
                // Cambiar el HTML para poner todos los iconos en una sola l√≠nea
                legend.innerHTML = `
                    <div class="legend-item good">üêü üê† üêö ü™∏ ‚≠ê</div>
                    <div class="legend-item bad">üíÄ ü¶à ‚ö†Ô∏è üß® ü™ù</div>
                `;
                
                legend.style.cssText = `
                    display: flex !important;
                    justify-content: center !important;
                    align-items: center !important;
                    gap: 15px !important;
                    margin: 10px 0 !important;
                    padding: 0 20px !important;
                    flex-wrap: nowrap !important;
                    white-space: nowrap !important;
                `;
                
                // Re-aplicar estilos a los elementos reci√©n creados
                const goodLegend = legend.querySelector('.legend-item.good');
                const badLegend = legend.querySelector('.legend-item.bad');
                
                if (goodLegend) {
                    goodLegend.style.cssText = `
                        background: rgba(76, 175, 80, 0.3) !important;
                        border: 3px solid #4CAF50 !important;
                        border-radius: 12px !important;
                        padding: 6px 12px !important;
                        font-size: 14px !important;
                        font-weight: bold !important;
                        color: #2E7D32 !important;
                        box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4) !important;
                        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8) !important;
                        white-space: nowrap !important;
                        display: inline-block !important;
                    `;
                }
                
                if (badLegend) {
                    badLegend.style.cssText = `
                        background: rgba(244, 67, 54, 0.3) !important;
                        border: 3px solid #F44336 !important;
                        border-radius: 12px !important;
                        padding: 6px 12px !important;
                        font-size: 14px !important;
                        font-weight: bold !important;
                        color: #C62828 !important;
                        box-shadow: 0 4px 8px rgba(244, 67, 54, 0.4) !important;
                        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8) !important;
                        white-space: nowrap !important;
                        display: inline-block !important;
                    `;
                }
            }
            
            // üéÆ FORZAR VISIBILIDAD DEL BOT√ìN JUGAR
            const playBtn = gameModal.querySelector('#bubbleStartBtn');
            if (playBtn) {
                // Resetear completamente los estilos
                playBtn.removeAttribute('style');
                playBtn.className = 'bubble-btn primary big-yellow';
                
                // Aplicar estilos b√°sicos para que se vea
                playBtn.style.cssText = `
                    background: linear-gradient(135deg, #2196F3, #1976D2) !important;
                    border: 2px solid #1565C0 !important;
                    border-radius: 20px !important;
                    padding: 12px 30px !important;
                    font-size: 18px !important;
                    font-weight: bold !important;
                    color: white !important;
                    cursor: pointer !important;
                    transition: all 0.3s ease !important;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
                    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4) !important;
                    text-transform: uppercase !important;
                    letter-spacing: 1px !important;
                    width: 80% !important;
                    max-width: 250px !important;
                    margin: 20px auto !important;
                    display: block !important;
                    position: relative !important;
                    z-index: 1000 !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    height: auto !important;
                    min-height: 50px !important;
                    overflow: visible !important;
                    clip: auto !important;
                    clip-path: none !important;
                `;
                
                // Asegurar que el texto sea "JUGAR"
                playBtn.textContent = 'JUGAR';
                
                console.log('üéÆ Bot√≥n JUGAR configurado:', playBtn);
            } else {
                console.error('‚ùå No se encontr√≥ el bot√≥n #bubbleStartBtn');
            }
            
            // üìç ASEGURAR QUE EL CONTENEDOR DE CONTROLES EST√â BIEN POSICIONADO
            const controlsContainer = gameModal.querySelector('.bubble-controls');
            if (controlsContainer) {
                controlsContainer.style.cssText = `
                    padding: 20px !important;
                    display: flex !important;
                    justify-content: center !important;
                    align-items: center !important;
                    margin-top: auto !important;
                    position: relative !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                    border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
                    min-height: 80px !important;
                    width: 100% !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    overflow: visible !important;
                    z-index: 100 !important;
                `;
                
                console.log('üéÆ Contenedor de controles configurado:', controlsContainer);
            } else {
                console.error('‚ùå No se encontr√≥ el contenedor .bubble-controls');
            }
        }
        
        // üé® DISE√ëO PERFECTO UNIFICADO PARA TODOS LOS JUEGOS (BASADO EN BURBUJAS)
        function applyPerfectGameStyles(gameOverlay, gameName) {
            // Estilos del overlay - EXACTAMENTE IGUAL QUE BURBUJAS
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                backdrop-filter: blur(10px) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            // Contenedor principal - EXACTAMENTE IGUAL QUE BURBUJAS
            const container = gameOverlay.querySelector(`.${gameName}-game-container`);
            if (container) {
                container.style.cssText = `
                    background: linear-gradient(180deg, 
                        rgba(129, 212, 250, 0.25) 0%,
                        rgba(79, 195, 247, 0.2) 30%,
                        rgba(41, 182, 246, 0.15) 70%,
                        rgba(13, 71, 161, 0.2) 100%);
                    backdrop-filter: blur(30px) saturate(200%);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    border-radius: 28px;
                    width: 95vw;
                    height: 95vh;
                    max-width: 420px;
                    max-height: 800px;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    box-shadow: 
                        0 30px 100px rgba(79, 195, 247, 0.3),
                        0 0 60px rgba(129, 212, 250, 0.2),
                        inset 0 2px 0 rgba(255, 255, 255, 0.4);
                `;
            }
            
            // Header del juego - EXACTAMENTE IGUAL QUE BURBUJAS
            const header = gameOverlay.querySelector(`.${gameName}-game-header, .${gameName}-header`);
            if (header) {
                header.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.3) 0%, 
                        rgba(129, 212, 250, 0.2) 100%);
                    padding: 15px 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-bottom: 2px solid rgba(255, 255, 255, 0.25);
                    gap: 15px;
                `;
            }
        }

        // üé® DISE√ëO ORIGINAL PERFECTO DE BURBUJAS (EL QUE NOS GUSTABA)
        function applyBubbleGameStyles(gameModal) {
            // Modal principal - Fondo azul marino hermoso
            gameModal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: linear-gradient(135deg, #072334 0%, #1d4b6b 100%);
                display: flex; align-items: center; justify-content: center;
                z-index: 9999; animation: fadeIn 0.3s ease;
            `;
            
            // Contenedor principal - Dise√±o tipo acuario colorido
            const container = gameModal.querySelector('.bubble-game-container');
            container.style.cssText = `
                background: linear-gradient(180deg, 
                    rgba(129, 212, 250, 0.25) 0%,
                    rgba(79, 195, 247, 0.2) 30%,
                    rgba(41, 182, 246, 0.15) 70%,
                    rgba(13, 71, 161, 0.2) 100%);
                backdrop-filter: blur(30px) saturate(200%);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 28px;
                width: 95vw;
                height: 95vh;
                max-width: 420px;
                max-height: 800px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                box-shadow: 
                    0 30px 100px rgba(79, 195, 247, 0.3),
                    0 0 60px rgba(129, 212, 250, 0.2),
                    inset 0 2px 0 rgba(255, 255, 255, 0.4);
            `;
            
            // Header del juego - DOS L√çNEAS COMO NOS GUSTABA
            const header = gameModal.querySelector('.bubble-game-header');
            header.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.3) 0%, 
                    rgba(129, 212, 250, 0.2) 100%);
                padding: 15px 20px;
                display: flex;
                flex-direction: column;
                border-bottom: 2px solid rgba(255, 255, 255, 0.25);
                gap: 8px;
            `;
            
            // Primera l√≠nea: T√≠tulo + Altavoz + X
            const headerTop = gameModal.querySelector('.header-top');
            headerTop.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            
            // Controles de la cabecera (altavoz y cerrar)
            const headerControls = gameModal.querySelector('.header-controls');
            if (headerControls) {
                headerControls.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
            }
            
            // Segunda l√≠nea: Nivel + Perlas
            const headerBottom = gameModal.querySelector('.header-bottom');
            headerBottom.style.cssText = `
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            // Stats centrados
            const gameStats = gameModal.querySelector('.game-stats');
            gameStats.style.cssText = `
                display: flex;
                align-items: center;
                gap: 15px;
                color: white;
                font-size: 16px;
                font-weight: bold;
            `;
            
            // T√≠tulo centrado y bonito
            const title = gameModal.querySelector('.game-title');
            title.style.cssText = `
                color: white;
                font-size: 20px;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                margin: 0;
            `;
            
            // Stats centrados
            const statsSimple = gameModal.querySelector('.game-stats-simple');
            if (statsSimple) {
                statsSimple.style.cssText = `
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    text-align: center;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                `;
            }
            
            // Estilos para los nuevos elementos de la cabecera (igual que Conecta 3)
            const level = gameModal.querySelector('.level');
            if (level) {
                level.style.cssText = `
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                `;
            }
            
            const score = gameModal.querySelector('.score');
            if (score) {
                score.style.cssText = `
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                `;
            }
            
            const bestScoreDisplay = gameModal.querySelector('.best-score-display');
            if (bestScoreDisplay) {
                bestScoreDisplay.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 8px;
                    padding: 4px 8px;
                    font-size: 12px;
                    color: #fff;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                `;
            }
            
            const bestLabel = gameModal.querySelector('.best-label');
            if (bestLabel) {
                bestLabel.style.cssText = `
                    opacity: 0.8;
                    font-size: 11px;
                `;
            }
            
            const bestValue = gameModal.querySelector('.best-value');
            if (bestValue) {
                bestValue.style.cssText = `
                    font-weight: bold;
                    color: #FFD700;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                `;
            }
            
            // Bot√≥n de cerrar bonito
            const closeBtn = gameModal.querySelector('.game-close-btn');
            closeBtn.style.cssText = `
                font-size: 22px;
                font-weight: 800;
                color: #fff;
                text-shadow: 
                    0 2px 8px rgba(79, 195, 247, 0.8),
                    0 0 20px rgba(129, 212, 250, 0.6);
                letter-spacing: 0.5px;
            `;
            
            // Stats ya configurados arriba, no necesitamos esto
            
            
            // Leyenda con bordes de colores
            const legend = gameModal.querySelector('.bubble-legend');
            legend.style.cssText = `
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 20px;
                padding: 8px 15px;
                background: rgba(0, 0, 0, 0.01);
                border-radius: 8px;
                margin: 8px 20px;
                font-size: 16px;
                white-space: nowrap;
            `;
            
            // Burbujas buenas (verde con fondo transparente)
            const goodLegend = legend.querySelector('.legend-item.good');
            goodLegend.style.cssText = `
                background: rgba(76, 175, 80, 0.2);
                border: 2px solid #4CAF50;
                border-radius: 8px;
                padding: 4px 12px;
                font-size: 14px;
                font-weight: bold;
                color: #2E7D32;
                text-shadow: none;
                box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
            `;
            
            // Burbujas malas (rojo con fondo transparente)
            const badLegend = legend.querySelector('.legend-item.bad');
            badLegend.style.cssText = `
                background: rgba(244, 67, 54, 0.2);
                border: 2px solid #F44336;
                border-radius: 8px;
                padding: 4px 12px;
                font-size: 14px;
                font-weight: bold;
                color: #C62828;
                text-shadow: none;
                box-shadow: 0 2px 4px rgba(244, 67, 54, 0.3);
            `;
            
            // √Årea de juego M√ÅS LARGA (casi el doble)
            const stageContainer = gameModal.querySelector('.bubble-stage-container');
            stageContainer.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.1) 0%, 
                    rgba(41, 182, 246, 0.05) 100%);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                margin: 10px 20px;
                padding: 15px;
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 400px; /* CASI EL DOBLE */
            `;
            
            // Stage del juego M√ÅS LARGO
            const stage = gameModal.querySelector('#bubbleStage');
            stage.style.cssText = `
                width: 100%;
                height: 100%;
                position: relative;
                background: linear-gradient(180deg, #4fc3f7 0%, #29b6f6 30%, #0288d1 70%, #0277bd 100%);
                border-radius: 12px;
                overflow: hidden;
                border: 2px solid rgba(255, 255, 255, 0.3);
                min-height: 350px; /* CASI EL DOBLE */
            `;
            
            // Items de leyenda ya configurados arriba con bordes de colores
            
            // √Årea de juego ya configurada arriba
            const instructions = gameModal.querySelector('.game-instructions');
            instructions.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 35px;
                background: linear-gradient(135deg, rgba(79, 195, 247, 0.4), rgba(129, 212, 250, 0.3));
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                color: white;
                font-weight: 700;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                border-top: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            // Controles centrados y bonitos
            const controls = gameModal.querySelector('.bubble-controls');
            controls.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(129, 212, 250, 0.15) 100%);
                padding: 20px;
                display: flex;
                justify-content: center;
                align-items: center;
                border-top: 2px solid rgba(255, 255, 255, 0.25);
            `;
            
            // Bot√≥n JUGAR estilo gamer
            const playBtn = gameModal.querySelector('#bubbleStartBtn');
            playBtn.style.cssText = `
                background: linear-gradient(135deg, #FFD700, #FFA500);
                border: 4px solid #FF8C00;
                border-radius: 30px;
                padding: 20px 60px;
                font-size: 28px;
                font-weight: bold;
                color: #8B4513;
                text-shadow: 0 2px 4px rgba(255, 255, 255, 0.8);
                box-shadow: 
                    0 8px 20px rgba(255, 215, 0, 0.5),
                    inset 0 3px 0 rgba(255, 255, 255, 0.6);
                cursor: pointer;
                transition: all 0.3s ease;
                text-transform: uppercase;
                letter-spacing: 2px;
                width: 80%;
                max-width: 300px;
                margin: 0 auto;
                display: block;
            `;
            
            // Efecto hover para el bot√≥n
            playBtn.addEventListener('mouseenter', () => {
                playBtn.style.transform = 'translateY(-3px) scale(1.08)';
                playBtn.style.boxShadow = '0 12px 25px rgba(255, 215, 0, 0.7)';
            });
            
            playBtn.addEventListener('mouseleave', () => {
                playBtn.style.transform = 'translateY(0) scale(1)';
                playBtn.style.boxShadow = '0 8px 20px rgba(255, 215, 0, 0.5)';
            });
            
            // Bot√≥n JUGAR ya configurado arriba con estilo amarillo
            
            // Bot√≥n SALIR - M√°s sutil pero elegante
            const backBtn = gameModal.querySelector('.bubble-btn.secondary');
            backBtn.style.cssText = `
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 12px;
                font-weight: 600;
                color: white;
                cursor: pointer;
                transition: all 0.3s ease;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                box-shadow: 
                    0 6px 20px rgba(255, 255, 255, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            `;
            
            backBtn.addEventListener('mouseenter', () => {
                backBtn.style.transform = 'translateY(-2px)';
                backBtn.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2))';
                backBtn.style.boxShadow = '0 8px 25px rgba(255, 255, 255, 0.2)';
            });
            
            backBtn.addEventListener('mouseleave', () => {
                backBtn.style.transform = 'translateY(0)';
                backBtn.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1))';
                backBtn.style.boxShadow = '0 6px 20px rgba(255, 255, 255, 0.1)';
            });
            
            // A√±adir animaci√≥n de acuario
            const style = document.createElement('style');
            style.textContent = `
                @keyframes aquarium-glow {
                    from { 
                        filter: brightness(1) saturate(100%);
                        box-shadow: 
                            inset 0 0 80px rgba(255, 255, 255, 0.1),
                            0 10px 40px rgba(79, 195, 247, 0.3);
                    }
                    to { 
                        filter: brightness(1.1) saturate(120%);
                        box-shadow: 
                            inset 0 0 100px rgba(255, 255, 255, 0.15),
                            0 15px 50px rgba(129, 212, 250, 0.4);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // üé® FUNCI√ìN UNIFICADA SIMPLE PARA TODOS LOS JUEGOS
        function applyPerfectBubbleDesign(gameOverlay, gameName) {
            // Estilos del overlay principal - AZUL M√ÅS CLARO Y SEMI-TRANSPARENTE
            gameOverlay.style.cssText = `
                position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                backdrop-filter: blur(10px) !important;
                display: flex !important; align-items: center !important; justify-content: center !important;
                z-index: 99999 !important; visibility: visible !important; opacity: 1 !important;
            `;
            
            // Contenedor principal - SIMPLE Y FUNCIONAL
            const container = gameOverlay.querySelector(`.${gameName}-game-container, .${gameName}-container`);
            console.log(`üé® Buscando contenedor para ${gameName}:`, container);
            if (container) {
                container.style.cssText = `
                    background: rgba(255, 255, 255, 0.1);
                    backdrop-filter: blur(20px);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 20px;
                    width: 90vw;
                    height: 95vh;
                    max-width: 500px;
                    max-height: 800px;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                `;
            }
            
            // üèÜ CREAR HEADER UNIFICADO PARA TODOS LOS JUEGOS (excepto Conecta 3, Burbujas y Sim√≥n)
            if (gameName !== 'bloques' && gameName !== 'bubble' && gameName !== 'simon') {
                const existingHeader = gameOverlay.querySelector(`.${gameName}-header, .${gameName}-game-header`);
                if (existingHeader) {
                    existingHeader.remove();
                }
            }
            
            // Crear header unificado (solo para juegos que no sean Conecta 3, Burbujas ni Sim√≥n)
            if (gameName !== 'bloques' && gameName !== 'bubble' && gameName !== 'simon') {
                const unifiedHeader = document.createElement('div');
                unifiedHeader.className = `${gameName}-unified-header`;
                unifiedHeader.innerHTML = `
                    <!-- PRIMERA L√çNEA: NOMBRE + ALTAVOZ + X -->
                    <div class="header-top">
                        <div class="game-title">${getGameTitle(gameName)}</div>
                        <div class="header-controls">
                            <button class="sound-btn">üîä</button>
                            <button class="close-btn">‚úï</button>
                        </div>
                    </div>
                    
                        <!-- SEGUNDA L√çNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL 1</span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="bubble-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="bubble-best-display">0</span>
                                </span>
                            </div>
                        </div>
                `;
                
                // Insertar header al principio del contenedor
                if (container) {
                    container.insertBefore(unifiedHeader, container.firstChild);
                }
            }
            
            // Estilos del header unificado (solo para juegos que no sean Conecta 3 ni Sim√≥n)
            if (gameName !== 'bloques' && gameName !== 'simon' && typeof unifiedHeader !== 'undefined') {
                unifiedHeader.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.3) 0%, 
                        rgba(129, 212, 250, 0.2) 100%);
                    padding: 15px 20px;
                    display: flex;
                    flex-direction: column;
                    border-bottom: 2px solid rgba(255, 255, 255, 0.25);
                    gap: 8px;
                `;
            }
            
            // Estilos del header unificado (solo para juegos que no sean Conecta 3 ni Sim√≥n)
            if (gameName !== 'bloques' && gameName !== 'simon' && typeof unifiedHeader !== 'undefined') {
                // Primera l√≠nea: T√≠tulo + Altavoz + X
                const headerTop = unifiedHeader.querySelector('.header-top');
                if (headerTop) {
                    headerTop.style.cssText = `
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;
                }
                
                // Segunda l√≠nea: Nivel + Perlas
                const headerBottom = unifiedHeader.querySelector('.header-bottom');
                if (headerBottom) {
                    headerBottom.style.cssText = `
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    `;
                }
                
                // Stats centrados
                const gameStats = unifiedHeader.querySelector('.game-stats');
                if (gameStats) {
                    gameStats.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 15px;
                        color: white;
                        font-size: 16px;
                        font-weight: bold;
                    `;
                }
                
                // T√≠tulo
                const title = unifiedHeader.querySelector('.game-title');
                if (title) {
                    title.style.cssText = `
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        margin: 0;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                    `;
                }
                
                // Controles del header
                const headerControls = unifiedHeader.querySelector('.header-controls');
                if (headerControls) {
                    headerControls.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    `;
                }
            }
            
            // Funci√≥n para obtener el t√≠tulo del juego
            function getGameTitle(gameName) {
                const titles = {
                    'bubble': 'ü´ß Atrapa Burbujas',
                    'bloques': 'üíé Conecta 3',
                    'carril': 'üê¨ Carril del Delf√≠n',
                    'correr': 'üêâ Drag√≥n Marino',
                    'caza': 'üéØ Caza de Peces',
                    'secuencia': 'üåä Secuencia de Mareas',
                    'toca3': 'üèñÔ∏è Toca-3 Marino',
                    'simon': 'üéµ Sim√≥n Marino',
                    'memoria': 'üß† Memoflip'
                };
                return titles[gameName] || 'üéÆ Juego';
            }
            
            // üéØ CONFIGURAR BOTONES DEL HEADER UNIFICADO (solo para juegos que no sean Conecta 3)
            if (gameName !== 'bloques' && typeof unifiedHeader !== 'undefined') {
                const soundBtn = unifiedHeader.querySelector('.sound-btn');
                const closeBtn = unifiedHeader.querySelector('.close-btn');
            
                // Estilo para el indicador de mejor puntuaci√≥n
                const bestScoreDisplay = unifiedHeader.querySelector('.best-score-display');
                if (bestScoreDisplay) {
                    bestScoreDisplay.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 4px;
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        border-radius: 8px;
                        padding: 4px 8px;
                        font-size: 12px;
                        color: #fff;
                        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                    `;
                    
                    const bestLabel = bestScoreDisplay.querySelector('.best-label');
                    if (bestLabel) {
                        bestLabel.style.cssText = `
                            opacity: 0.8;
                            font-size: 11px;
                        `;
                    }
                    
                    const bestValue = bestScoreDisplay.querySelector('.best-value');
                    if (bestValue) {
                        bestValue.style.cssText = `
                            font-weight: bold;
                            color: #FFD700;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                        `;
                    }
                }
            
                // Bot√≥n de sonido - SINCRONIZADO CON EL PRINCIPAL
                if (soundBtn) {
                // Usar las mismas im√°genes que el bot√≥n principal
                const isMuted = window.audioManager ? window.audioManager.isMuted : false;
                soundBtn.innerHTML = isMuted ? 
                    '<img src="images/ui/sonidoOff.png" style="width: 20px; height: 20px;">' : 
                    '<img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">';
                
                soundBtn.style.cssText = `
                    width: 30px;
                    height: 30px;
                    color: #fff;
                    background: rgba(255, 255, 255, 0.2);
                    border: 2px solid rgba(255, 255, 255, 0.5);
                    border-radius: 50%;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.3s ease;
                `;
                
                soundBtn.addEventListener('mouseenter', () => {
                    soundBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    soundBtn.style.transform = 'scale(1.1)';
                });
                
                soundBtn.addEventListener('mouseleave', () => {
                    soundBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    soundBtn.style.transform = 'scale(1)';
                });
                
                // Sincronizar con el AudioManager
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        window.audioManager.toggleMute();
                        // Actualizar imagen seg√∫n el estado
                        const isMuted = window.audioManager.isMuted;
                        soundBtn.innerHTML = isMuted ? 
                            '<img src="images/ui/sonidoOff.png" style="width: 20px; height: 20px;">' : 
                            '<img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">';
                    }
                });
            }
            
                // Bot√≥n de cerrar
                if (closeBtn) {
                closeBtn.style.cssText = `
                    width: 30px;
                    height: 30px;
                    font-size: 18px;
                    font-weight: 800;
                    color: #fff;
                    background: rgba(255, 255, 255, 0.2);
                    border: 2px solid rgba(255, 255, 255, 0.5);
                    border-radius: 50%;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.3s ease;
                `;
                
                closeBtn.addEventListener('mouseenter', () => {
                    closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    closeBtn.style.transform = 'scale(1.1)';
                });
                
                closeBtn.addEventListener('mouseleave', () => {
                    closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    closeBtn.style.transform = 'scale(1)';
                });
                
                // Event listener para cerrar
                    closeBtn.addEventListener('click', () => {
                        gameOverlay.remove();
                        // Volver a la ventana de juegos, no a la pecera
                        document.getElementById('gamesModal').style.display = 'flex';
                    });
                }
            }
            
            // üéÆ BUSCAR Y UNIFICAR BOTONES DE JUGAR - M√âTODO SIMPLE
            // EXCLUIR JUEGO DE BURBUJAS (tiene su propia funci√≥n espec√≠fica)
            if (gameName !== 'bubble') {
                const allButtons = gameOverlay.querySelectorAll('button');
                allButtons.forEach(btn => {
                    const text = btn.textContent.toLowerCase().trim();
                    const isCloseBtn = text === '‚úï' || text === '√ó' || text === 'x' || btn.classList.contains('close-btn');
                    const isSoundBtn = text === 'üîä' || btn.classList.contains('sound-btn');
                    
                    // Solo procesar botones que NO sean cerrar ni sonido
                    if (!isCloseBtn && !isSoundBtn) {
                        // Cambiar texto a "JUGAR" si parece un bot√≥n de juego
                        if (text.includes('jugar') || text.includes('empezar') || text.includes('‚ñ∂Ô∏è') || text.includes('reiniciar') || text.includes('üîÑ') || text.includes('start') || text.includes('play')) {
                            btn.textContent = 'JUGAR';
                        }
                        
                        // Aplicar estilos unificados
                        btn.style.cssText = `
                            background: linear-gradient(135deg, #ff6b35, #ff8e53);
                            border: 2px solid #FF8C00;
                            border-radius: 20px;
                            padding: 12px 30px;
                            font-size: 18px;
                            font-weight: bold;
                            color: white;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
                            text-transform: uppercase;
                            letter-spacing: 1px;
                            width: 80%;
                            max-width: 250px;
                            margin: 15px auto;
                            display: block;
                        `;
                        
                        // Efecto hover unificado
                        btn.addEventListener('mouseenter', () => {
                            btn.style.transform = 'translateY(-3px) scale(1.08)';
                            btn.style.boxShadow = '0 12px 25px rgba(255, 107, 53, 0.7)';
                        });
                        
                        btn.addEventListener('mouseleave', () => {
                            btn.style.transform = 'translateY(0) scale(1)';
                            btn.style.boxShadow = '0 6px 20px rgba(255, 107, 53, 0.4)';
                        });
                    }
                });
            }
            
            // üìç ASEGURAR QUE EL FOOTER EST√â ABAJO DEL TODO
            const footerSelectors = [
                `.${gameName}-footer`,
                `.${gameName}-controls`,
                `.${gameName}-game-container > div:last-child`
            ];
            
            footerSelectors.forEach(selector => {
                const footer = gameOverlay.querySelector(selector);
                if (footer) {
                    footer.style.cssText = `
                        padding: 20px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        margin-top: auto;
                        position: relative;
                    `;
                }
            });
            
            // üéÆ INICIALIZAR L√ìGICA DEL JUEGO DESPU√âS DE CREAR EL HEADER
            if (gameName === 'bubble') {
                initBubbleGameLogic(gameOverlay);
            }
        }
        
        // üéÆ L√ìGICA DEL JUEGO DE BURBUJAS
        function initBubbleGameLogic(gameModal) {
            const GOOD_EMOJIS = ["üêü","üê†","üêö","ü™∏","‚≠ê"];
            const BAD_EMOJIS = ["üíÄ","ü¶à","‚ö†Ô∏è","üß®","ü™ù"];
            
            let gameState = {
                running: false,
                score: 0,
                level: 1,
                lastSpawn: 0,
                spawnEvery: 800,
                bubbles: [],
                rafId: null,
                startTime: 0
            };
            
            const elements = {
                stage: gameModal.querySelector('#bubbleStage'),
                scoreEl: gameModal.querySelector('#bubble-score'),
                bestEl: gameModal.querySelector('#bubble-best-display'),
                starsEl: { textContent: '' }, // No existe en el HTML, usar temporal
                startBtn: gameModal.querySelector('#bubbleStartBtn'),
                backBtn: gameModal.querySelector('.bubble-back-btn'),
                resultsModal: gameModal.querySelector('.bubble-results-modal')
            };
            
            // Debug: verificar que los elementos est√©n correctos
            console.log('üîç Elementos encontrados:');
            console.log('  scoreEl:', elements.scoreEl);
            console.log('  bestEl:', elements.bestEl);
            console.log('  starsEl:', elements.starsEl);
            
            // Persistencia
            const getBest = () => Number(localStorage.getItem('bubbles_best') || 0);
            const setBest = (v) => localStorage.setItem('bubbles_best', String(v));
            const getStars = () => Number(localStorage.getItem('bubbles_stars') || 0);
            const addStars = (n) => {
                const total = getStars() + n;
                localStorage.setItem('bubbles_stars', String(total));
                return total;
            };
            const getLevel = () => Number(localStorage.getItem('bubbles_level') || 1);
            const setLevel = (v) => localStorage.setItem('bubbles_level', String(v));
            
            // UI inicial
            if (elements.bestEl) {
                elements.bestEl.textContent = getBest();
            }
            if (elements.starsEl) {
                elements.starsEl.textContent = getStars();
            }
            
            // ü´ß CREAR BURBUJA
            function createBubble(now) {
                if (now - gameState.lastSpawn < gameState.spawnEvery) return;
                gameState.lastSpawn = now;
                
                const isGood = Math.random() < 0.7;
                const size = 35 + Math.random() * 25; // 35-60px
                const stageRect = elements.stage.getBoundingClientRect();
                console.log('ü´ß Creando burbuja - Stage rect:', stageRect);
                const x = size + Math.random() * (stageRect.width - size * 2);
                const y = stageRect.height + size;
                const speed = 80 + Math.random() * 60 + gameState.score * 0.8;
                const drift = (Math.random() - 0.5) * 40;
                
                const bubbleEl = document.createElement('div');
                bubbleEl.className = 'game-bubble ' + (isGood ? 'good' : 'bad');
                bubbleEl.innerHTML = `<div class="bubble-emoji">${isGood ? 
                    GOOD_EMOJIS[Math.floor(Math.random() * GOOD_EMOJIS.length)] : 
                    BAD_EMOJIS[Math.floor(Math.random() * BAD_EMOJIS.length)]
                }</div>`;
                
                // Estilo de la burbuja
                bubbleEl.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size}px;
                    border-radius: 50%;
                    background: radial-gradient(120% 100% at 30% 25%, 
                        rgba(255,255,255,0.25), 
                        rgba(255,255,255,0.08) 55%, 
                        rgba(255,255,255,0.03) 70%);
                    border: 2px solid ${isGood ? 'rgba(76, 175, 80, 0.4)' : 'rgba(244, 67, 54, 0.4)'};
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 2px 0 rgba(255, 255, 255, 0.3);
                    cursor: pointer;
                    user-select: none;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transform: translate(${x - size/2}px, ${y - size/2}px);
                    transition: transform 0.1s ease;
                `;
                
                bubbleEl.querySelector('.bubble-emoji').style.cssText = `
                    font-size: ${size * 0.5}px;
                    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
                `;
                
                elements.stage.appendChild(bubbleEl);
                
                const bubble = { el: bubbleEl, x, y, size, vy: -speed, vx: drift, isGood };
                gameState.bubbles.push(bubble);
                
                // Click en burbuja
                bubbleEl.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!gameState.running) return;
                    
                    if (bubble.isGood) {
                        gameState.score++;
                        elements.scoreEl.textContent = gameState.score;
                        
                        // üèÜ EFECTO VISUAL SI SUPERAS TU MEJOR PUNTUACI√ìN
                        const currentBest = getBest();
                        if (gameState.score > currentBest) {
                            const bestDisplay = gameModal.querySelector('#bubble-best-display');
                            if (bestDisplay) {
                                bestDisplay.style.color = '#00FF00'; // Verde cuando superas
                                bestDisplay.style.animation = 'pulse 0.5s ease';
                                setTimeout(() => {
                                    bestDisplay.style.color = '#FFD700';
                                    bestDisplay.style.animation = '';
                                }, 500);
                            }
                        }
                        
                        // üèÜ SISTEMA DE NIVELES - Subir de nivel cada 20 perlas
                        const newLevel = Math.floor(gameState.score / 20) + 1;
                        if (newLevel > gameState.level) {
                            gameState.level = newLevel;
                            // Actualizar el nivel en la UI
                            const levelEl = gameModal.querySelector('.level');
                            if (levelEl) {
                                levelEl.textContent = `NIVEL ${gameState.level}`;
                            }
                            
                            // üîä SONIDO DE NIVEL COMPLETADO
                            if (window.audioManager) {
                                window.audioManager.playSound('levelComplete');
                            }
                            
                            // Aumentar dificultad (m√°s r√°pido)
                            gameState.spawnEvery = Math.max(400, gameState.spawnEvery - 50);
                        }
                        
                        removeBubble(bubble, true);
                        bubbleEl.style.transform += ' scale(1.2)';
                        bubbleEl.style.opacity = '0';
                        setTimeout(() => bubbleEl.remove(), 200);
                        
                        // üîä SONIDO DE ACIERTO
                        if (window.audioManager) {
                            window.audioManager.playSound('eat');
                        }
                    } else {
                        // üîä SONIDO DE FALLO (m√°s dram√°tico)
                        console.log('üîä Intentando reproducir sonido de fallo...');
                        if (window.audioManager) {
                            console.log('üîä AudioManager encontrado, reproduciendo fail...');
                            window.audioManager.playSound('fail'); // Sonido de fallo m√°s dram√°tico
                        } else {
                            console.log('‚ùå AudioManager no encontrado');
                        }
                        endGame(false, "¬°Tocaste una mala!");
                    }
                });
                
                gameState.spawnEvery = Math.max(300, 800 - gameState.score * 10);
            }
            
            // üóëÔ∏è REMOVER BURBUJA
            function removeBubble(bubble, silent = false) {
                const index = gameState.bubbles.indexOf(bubble);
                if (index >= 0) {
                    gameState.bubbles.splice(index, 1);
                    if (!silent) {
                        bubble.el.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                        bubble.el.style.opacity = '0';
                        bubble.el.style.transform += ' scale(0.8)';
                        setTimeout(() => bubble.el.remove(), 200);
                    } else {
                        bubble.el.remove();
                    }
                }
            }
            
            // üéÆ LOOP DEL JUEGO
            function gameLoop(now) {
                if (!gameState.running) return;
                
                if (!gameState.startTime) gameState.startTime = now;
                const deltaTime = (now - gameState.startTime) / 1000;
                gameState.startTime = now;
                
                createBubble(now);
                
                // Mover burbujas
                for (let i = gameState.bubbles.length - 1; i >= 0; i--) {
                    const bubble = gameState.bubbles[i];
                    bubble.y += bubble.vy * deltaTime;
                    bubble.x += bubble.vx * deltaTime;
                    bubble.vx += Math.sin(now / 400 + i) * 50 * deltaTime;
                    
                    const stageRect = elements.stage.getBoundingClientRect();
                    if (bubble.x - bubble.size/2 < 0 || bubble.x + bubble.size/2 > stageRect.width) {
                        bubble.vx *= -0.9;
                    }
                    
                    bubble.el.style.transform = `translate(${bubble.x - bubble.size/2}px, ${bubble.y - bubble.size/2}px)`;
                    
                    if (bubble.y + bubble.size/2 < 0) {
                        if (bubble.isGood) {
                            // üîä SONIDO DE FALLO cuando se escapa una burbuja buena
                            console.log('üîä Burbuja buena escapada - reproduciendo sonido de fallo...');
                            if (window.audioManager) {
                                window.audioManager.playSound('fail');
                            }
                            endGame(false, "¬°Dejaste escapar una buena!");
                            return;
            } else {
                            removeBubble(bubble, true);
                        }
                    }
                }
                
                gameState.rafId = requestAnimationFrame(gameLoop);
            }
            
            // üèÜ TERMINAR JUEGO
            function endGame(won, reason) {
                gameState.running = false;
                if (gameState.rafId) cancelAnimationFrame(gameState.rafId);
                
                gameState.bubbles.forEach(bubble => bubble.el.remove());
                gameState.bubbles = [];
                
                const finalScore = gameState.score;
                const bestPrev = getBest();
                let starsWon = 0;
                let rewardReasons = [];
                
                // ‚≠ê SISTEMA DE ESTRELLAS CORRECTO
                // 1 estrella por jugar (siempre)
                starsWon += 1;
                rewardReasons.push("üéÆ Por jugar");
                
                // +1 estrella si superas tu r√©cord personal
                if (finalScore > bestPrev) {
                    starsWon += 1;
                    rewardReasons.push("üèÜ ¬°Nuevo r√©cord personal!");
                    setBest(finalScore);
                    
                    // Actualizar mejor puntuaci√≥n en el header
                    const bestDisplay = gameModal.querySelector('#bubble-best-display');
                    if (bestDisplay) {
                        bestDisplay.textContent = finalScore;
                    }
                }
                
                // +1 estrella si superas el r√©cord global (simulado)
                const globalRecord = 1000; // Simulamos un r√©cord global
                if (finalScore > globalRecord) {
                    starsWon += 1;
                    rewardReasons.push("üåç ¬°R√âCORD GLOBAL!");
                }
                
                // No usar sistema local de estrellas, solo el principal
                elements.bestEl.textContent = getBest();
                // elements.starsEl.textContent se actualizar√° desde el sistema principal
                
                // Guardar nivel alcanzado
                if (gameState.level > getLevel()) {
                    setLevel(gameState.level);
                }
                
                // Actualizar UI de juegos en pantalla principal
                if (typeof updateGamesUI === 'function') {
                    updateGamesUI();
                }
                
                // üéÜ INTEGRAR CON SISTEMA PRINCIPAL
                console.log(`üîç DEBUG ESTRELLAS: starsWon=${starsWon}, window.game=${!!window.game}`);
                if (window.game) {
                    console.log(`üîç DEBUG: Estrellas antes: ${window.game.gameState.stars}`);
                }
                
                if (window.game && starsWon > 0) {
                    window.game.gameState.stars += starsWon;
                    window.game.saveGame();
                    
                    // Actualizar UI inmediatamente
                    window.game.updateUI();
                    
                    console.log(`üîç DEBUG: Estrellas despu√©s: ${window.game.gameState.stars}`);
                    
                    // üéÜ ANIMACI√ìN DE ESTRELLAS INMEDIATAMENTE (ANTES DEL MODAL)
                    if (starsWon > 0) {
                        // Crear animaci√≥n directamente en el modal del juego
                        const gameModal = document.querySelector('.bubble-game-container');
                        if (gameModal) {
                            const gameRect = gameModal.getBoundingClientRect();
                            const centerX = gameRect.left + gameRect.width / 2;
                            const centerY = gameRect.top + gameRect.height / 2;
                            
                            // Crear part√≠culas de estrellas
                            for (let i = 0; i < starsWon * 10; i++) {
                                const particle = document.createElement('div');
                                const randomX = (Math.random() - 0.5) * 200;
                                const randomY = (Math.random() - 0.5) * 200;
                                
                                particle.style.cssText = `
                                    position: fixed;
                                    width: 8px;
                                    height: 8px;
                                    background: #FFD700;
                                    border-radius: 50%;
                                    z-index: 99999;
                                    pointer-events: none;
                                    left: ${centerX}px;
                                    top: ${centerY}px;
                                    --random-x: ${randomX}px;
                                    --random-y: ${randomY}px;
                                    animation: starExplosion 1.5s ease-out forwards;
                                `;
                                document.body.appendChild(particle);
                                
                                // Eliminar part√≠cula despu√©s de la animaci√≥n
                                setTimeout(() => particle.remove(), 1500);
                            }
                            
                            // Mensaje flotante
                            const message = document.createElement('div');
                            message.style.cssText = `
                                position: fixed;
                                left: ${centerX}px;
                                top: ${centerY - 50}px;
                                transform: translateX(-50%);
                                font-size: 24px;
                                font-weight: bold;
                                color: #FFD700;
                                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                                z-index: 99999;
                                pointer-events: none;
                                animation: floatUp 2s ease-out forwards;
                            `;
                            // Solo efecto de part√≠culas, sin mensaje flotante
                        }
                    }
                    
                    console.log(`üèÜ Burbujas: +${starsWon} estrellas ganadas`);
                } else {
                    console.log(`‚ùå ERROR: No se pudieron a√±adir estrellas - window.game=${!!window.game}, starsWon=${starsWon}`);
                }
                
                // Mostrar resultados con razones
                console.log(`üîç Mostrando resultados: ${finalScore} puntos, ${starsWon} estrellas`);
                
                // Verificar que los elementos existan antes de actualizarlos
                const resultsTitle = gameModal.querySelector('#results-title');
                const finalLevel = gameModal.querySelector('#final-level');
                const finalScoreEl = gameModal.querySelector('#final-score');
                const finalBest = gameModal.querySelector('#final-best');
                const finalStars = gameModal.querySelector('#final-stars');
                
                if (resultsTitle) resultsTitle.textContent = won ? "¬°Perfecto!" : "Fin de partida";
                if (finalLevel) finalLevel.textContent = gameState.level;
                if (finalScoreEl) finalScoreEl.textContent = finalScore;
                if (finalBest) finalBest.textContent = getBest();
                if (finalStars) finalStars.textContent = starsWon;
                
                console.log(`üîç Modal actualizado: estrellas=${starsWon}`);
                
                // Mostrar razones de recompensas
                const reasonsText = rewardReasons.join('\n');
                const reasonsEl = gameModal.querySelector('#reward-reasons');
                if (reasonsEl) {
                    reasonsEl.textContent = reasonsText;
                }
                
                // üé® MODAL DE FIN DE PARTIDA HERMOSO CON DISE√ëO AZUL - FONDO M√ÅS OSCURO
                elements.resultsModal.style.display = 'flex';
                elements.resultsModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                // Estilo del contenido de resultados con tonos azules - M√ÅS ANCHO
                const resultsContent = gameModal.querySelector('.results-content');
                resultsContent.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(33, 150, 243, 0.2) 0%, 
                        rgba(25, 118, 210, 0.15) 50%,
                        rgba(21, 101, 192, 0.2) 100%);
                    backdrop-filter: blur(30px);
                    border: 2px solid rgba(33, 150, 243, 0.4);
                    border-radius: 20px;
                    padding: 25px;
                    text-align: center;
                    color: #fff;
                    max-width: 400px;
                    width: 70%;
                    box-shadow: 
                        0 20px 60px rgba(33, 150, 243, 0.4),
                        0 0 40px rgba(25, 118, 210, 0.3),
                        inset 0 2px 0 rgba(255, 255, 255, 0.2);
                    animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                    position: relative;
                `;
                
                // T√≠tulo de resultados - COMPACTO
                if (resultsTitle) {
                    resultsTitle.style.cssText = `
                        font-size: 20px;
                        font-weight: 800;
                        margin-bottom: 15px;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                        color: #fff;
                    `;
                }
                
                // Stats de resultados - COMPACTO
                const resultsStats = gameModal.querySelector('.results-stats');
                resultsStats.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    margin-bottom: 15px;
                `;
                
                gameModal.querySelectorAll('.result-item').forEach(item => {
                    item.style.cssText = `
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        background: rgba(33, 150, 243, 0.2);
                        border-radius: 12px;
                        padding: 8px 12px;
                        border: 2px solid rgba(33, 150, 243, 0.3);
                        font-weight: 600;
                        color: #fff;
                        font-size: 14px;
                    `;
                });
                
                // Botones de resultados
                const resultsButtons = gameModal.querySelector('.results-buttons');
                resultsButtons.style.cssText = `
                    display: flex;
                    gap: 15px;
                    justify-content: center;
                `;
                
                gameModal.querySelectorAll('#bubble-again-btn, #bubble-finish-btn').forEach(btn => {
                    const isAgain = btn.id === 'bubble-again-btn';
                    btn.style.cssText = `
                        background: linear-gradient(135deg, 
                            ${isAgain ? '#4caf50, #66bb6a' : 'rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1)'});
                        border: 2px solid ${isAgain ? 'rgba(76, 175, 80, 0.6)' : 'rgba(255, 255, 255, 0.3)'};
                        border-radius: 20px;
                        padding: 12px 25px;
                        font-size: 14px;
                        font-weight: 700;
                        color: white;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                        box-shadow: 0 6px 20px ${isAgain ? 'rgba(76, 175, 80, 0.4)' : 'rgba(255, 255, 255, 0.2)'};
                    `;
                });
                
                console.log(`üèÜ Juego terminado: ${finalScore} puntos, ${starsWon} estrellas`);
                
                // Agregar estrellas al pez
                if (window.game && window.game.gameState) {
                    window.game.gameState.stars = (window.game.gameState.stars || 0) + starsWon;
                    window.game.saveGame();
                }
            }
            
            // üöÄ INICIAR JUEGO
            function startGame() {
                console.log('üöÄ STARTGAME LLAMADO');
                gameState.running = true;
                gameState.score = 0;
                gameState.level = 1;
                gameState.lastSpawn = 0;
                gameState.spawnEvery = 800;
                gameState.startTime = 0;
                
                elements.scoreEl.textContent = '0';
                elements.resultsModal.style.display = 'none';
                
                // Actualizar nivel en la UI
                const levelEl = gameModal.querySelector('.level');
                if (levelEl) {
                    levelEl.textContent = 'NIVEL 1';
                }
                
                // Actualizar mejor puntuaci√≥n en el header
                const bestDisplay = gameModal.querySelector('#bubble-best-display');
                if (bestDisplay) {
                    bestDisplay.textContent = getBest();
                }
                
                gameState.bubbles.forEach(bubble => bubble.el.remove());
                gameState.bubbles = [];
                
                console.log('ü´ß ¬°Juego iniciado! Stage:', elements.stage);
                console.log('ü´ß Stage rect:', elements.stage.getBoundingClientRect());
                
                // üîä SONIDO DE INICIO DE JUEGO
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // üì± EVENT LISTENERS
            elements.startBtn.addEventListener('click', startGame);
            gameModal.querySelector('#bubble-again-btn').addEventListener('click', startGame);
            
            // üîä BOT√ìN DE SONIDO DEL JUEGO - SINCRONIZADO
            const gameSoundBtn = gameModal.querySelector('#bubble-sound-toggle');
            if (gameSoundBtn) {
                // Sincronizar con el estado actual del AudioManager
                const isMuted = window.audioManager ? window.audioManager.isMuted : false;
                gameSoundBtn.innerHTML = isMuted ? 
                    '<img src="images/ui/sonidoOff.png" style="width: 20px; height: 20px;">' : 
                    '<img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">';
                
                gameSoundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        window.audioManager.toggleMute();
                        // Actualizar imagen seg√∫n el estado
                        const isMuted = window.audioManager.isMuted;
                        gameSoundBtn.innerHTML = isMuted ? 
                            '<img src="images/ui/sonidoOff.png" style="width: 20px; height: 20px;">' : 
                            '<img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">';
                        
                        // Tambi√©n actualizar el bot√≥n del header unificado si existe
                        const unifiedSoundBtn = gameModal.querySelector('.sound-btn');
                        if (unifiedSoundBtn) {
                            unifiedSoundBtn.innerHTML = isMuted ? 
                                '<img src="images/ui/sonidoOff.png" style="width: 20px; height: 20px;">' : 
                                '<img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">';
                        }
                    }
                });
            }
            
            // Bot√≥n X de cerrar resultados
            const closeResultsBtn = gameModal.querySelector('.bubble-close-results-btn');
            if (closeResultsBtn) {
                closeResultsBtn.addEventListener('click', () => {
                    gameModal.remove();
                });
                
                // Efecto hover
                closeResultsBtn.addEventListener('mouseenter', () => {
                    closeResultsBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    closeResultsBtn.style.transform = 'scale(1.1)';
                });
                
                closeResultsBtn.addEventListener('mouseleave', () => {
                    closeResultsBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    closeResultsBtn.style.transform = 'scale(1)';
                });
            }
            
            const closeGame = () => {
                if (gameState.rafId) cancelAnimationFrame(gameState.rafId);
                gameState.running = false;
                gameModal.remove();
                // Volver a la ventana de juegos, no a la pecera
                document.getElementById('gamesModal').style.display = 'flex';
                console.log('ü´ß Juego cerrado');
            };
            
            // Event listeners para cerrar
            const closeBtn = gameModal.querySelector('.bubble-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeGame);
                console.log('‚úÖ Bot√≥n cerrar configurado correctamente');
            }
            
            // Bot√≥n de sonido del juego de burbujas
            const soundBtn = gameModal.querySelector('#bubble-sound-toggle');
            if (soundBtn) {
                // Inicializar estado del bot√≥n
                const img = soundBtn.querySelector('img');
                if (img && window.audioManager) {
                    img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                }
                
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        window.audioManager.toggleMute();
                        const img = soundBtn.querySelector('img');
                        if (img) {
                            img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                        }
                    }
                });
                console.log('‚úÖ Bot√≥n sonido configurado correctamente');
            }
            
            // Mantener compatibilidad con elementos existentes
            if (elements.backBtn) elements.backBtn.addEventListener('click', closeGame);
            gameModal.querySelector('#bubble-finish-btn')?.addEventListener('click', closeGame);
            
            console.log('üéÆ Juego de burbujas inicializado completamente');
        }
        
        // üíé JUEGO DE BLOQUES (MAR MATCH-3) - C√ìDIGO EXACTO DEL HTML QUE FUNCIONA
        function startBloquesGame() {
            console.log('üíé Iniciando juego Conecta 3 integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'bloquesGameOverlay';
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                backdrop-filter: blur(10px) !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            gameOverlay.innerHTML = `
                <div class="bloques-game-container">
                    <div class="bloques-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üåä Conecta 3</div>
                                <div class="header-controls">
                                    <button id="bloques-sound-toggle" class="sound-btn" style="
                                        background: rgba(255, 255, 255, 0.2);
                                        border: 2px solid rgba(255, 255, 255, 0.8);
                                        border-radius: 50%;
                                        width: 40px;
                                        height: 40px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                    ">
                                        <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                    </button>
                                    <button class="bloques-close-btn" style="
                                        background: rgba(255, 255, 255, 0.2);
                                        border: 2px solid rgba(255, 255, 255, 0.8);
                                        border-radius: 50%;
                                        width: 40px;
                                        height: 40px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                        color: white;
                                        font-size: 18px;
                                        font-weight: bold;
                                    ">‚úï</button>
                                </div>
                        </div>
                        
                        <!-- SEGUNDA L√çNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL 1</span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="bloques-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="bloques-best-display">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="bloques-timer-bar">
                        <div class="bloques-timer-fill" id="bloques-timer-fill"></div>
                    </div>
                    <div class="bloques-stage-container">
                        <div class="bloques-board" id="bloques-board"></div>
                    </div>
                    <div class="bloques-footer">
                        <button class="bloques-btn" id="bloques-restart">JUGAR</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'bloques');
            
            const closeBtn = gameOverlay.querySelector('.bloques-close-btn');
            const board = gameOverlay.querySelector('.bloques-board');
            const footer = gameOverlay.querySelector('.bloques-footer');
            const restartBtn = gameOverlay.querySelector('#bloques-restart');
            
            // Verificar que los elementos existen antes de usarlos
            if (!closeBtn || !board || !footer || !restartBtn) {
                console.error('‚ùå Elementos del juego no encontrados');
                return;
            }
            
            // Aplicar estilos del contenedor exterior (igual que burbujas)
            const stageContainer = gameOverlay.querySelector('.bloques-stage-container');
            if (stageContainer) {
                stageContainer.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.1) 0%, 
                        rgba(41, 182, 246, 0.05) 100%);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 14px;
                    padding: 10px;
                    margin: 10px;
                    flex: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            }
            
            // Aplicar estilos espec√≠ficos del tablero (m√°s peque√±o, centrado)
            board.style.cssText = `
                position: relative;
                width: calc(6 * 48px + 5 * 2px);
                height: calc(9 * 48px + 8 * 2px);
                background: rgba(255, 255, 255, 0.05);
                padding: 8px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                overflow: visible;
            `;
            
            // Aplicar estilos espec√≠ficos del footer
            footer.style.cssText = `
                padding: 20px !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                margin-top: auto !important;
                position: relative !important;
                background: rgba(255, 255, 255, 0.05) !important;
                border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
                min-height: 80px !important;
                width: 100% !important;
                visibility: visible !important;
                opacity: 1 !important;
                overflow: visible !important;
                z-index: 100 !important;
            `;
            
            // Aplicar estilos espec√≠ficos del bot√≥n restart
            restartBtn.style.cssText = `
                background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
                border: 2px solid rgb(21, 101, 192) !important;
                border-radius: 20px !important;
                padding: 12px 30px !important;
                font-size: 18px !important;
                font-weight: bold !important;
                color: white !important;
                cursor: pointer !important;
                transition: 0.3s !important;
                text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
                box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
                text-transform: uppercase !important;
                letter-spacing: 1px !important;
                width: 80% !important;
                max-width: 250px !important;
                margin: 15px auto !important;
                display: block !important;
                position: relative !important;
                z-index: 1000 !important;
                visibility: visible !important;
                opacity: 1 !important;
                height: auto !important;
                min-height: 50px !important;
                overflow: visible !important;
                clip: auto !important;
                clip-path: none !important;
            `;
            
            // Aplicar estilos espec√≠ficos de la barra de tiempo
            const timerBar = gameOverlay.querySelector('.bloques-timer-bar');
            const timerFill = gameOverlay.querySelector('.bloques-timer-fill');
            
            if (timerBar) {
                timerBar.style.cssText = `
                    width: 100%;
                    height: 8px;
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 4px;
                    overflow: hidden;
                    margin: 10px 0;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                `;
            }
            
            if (timerFill) {
                timerFill.style.cssText = `
                    height: 100%;
                    background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
                    width: 100%;
                    transition: width 1s linear;
                    border-radius: 3px;
                `;
            }

            // === C√ìDIGO EXACTO DEL HTML QUE FUNCIONA ===
            const COLS = 6, ROWS = 9, TYPES = 6;
            const CELL = 48, GAP = 2; // Gap m√°s peque√±o para cartas m√°s juntas
            const ICONS = ['üêö','üêü','üêô','üê†','ü¶Ä','üê¨']; // tema marino

            let grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));
            let score = 0, moves = 0, level = 1;
            let drag = null; // {r,c, el}
            
            // üíæ CARGAR PROGRESO GUARDADO
            const savedLevel = localStorage.getItem('bloques-level');
            const savedScore = localStorage.getItem('bloques-score');
            if (savedLevel) level = parseInt(savedLevel);
            if (savedScore) score = parseInt(savedScore);

            // --- UTILS
            const posToXY = (r,c) => ({
                x: c * (CELL + GAP),
                y: r * (CELL + GAP)
            });
            function updateUI(){ 
                const scoreEl = gameOverlay.querySelector('#bloques-score');
                const timeEl = gameOverlay.querySelector('#bloques-time');
                const timerFill = gameOverlay.querySelector('#bloques-timer-fill');
                const levelEl = gameOverlay.querySelector('.level');
                
                if (scoreEl) scoreEl.textContent = score;
                if (timeEl) timeEl.textContent = timeLeft;
                if (timerFill) {
                    const percentage = (timeLeft / 60) * 100;
                    timerFill.style.width = percentage + '%';
                }
                if (levelEl) levelEl.textContent = `NIVEL ${level}`;
            }

            function makeCell(r,c,t){
                const el = document.createElement('div');
                el.className = `bloques-cell t${t}`;
                el.dataset.r = r; el.dataset.c = c; el.dataset.t = t;
                const {x,y} = posToXY(r,c);
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                // No agregar animaci√≥n pop inicial

                const span = document.createElement('span');
                span.textContent = ICONS[t];
                el.appendChild(span);

                el.addEventListener('pointerdown', onPointerDown);
                el.addEventListener('pointerenter', onPointerEnter);

                return el;
            }

            function placeCell(r,c, cell){
                const {x,y} = posToXY(r,c);
                cell.style.left = x + 'px';
                cell.style.top = y + 'px';
                cell.dataset.r = r; cell.dataset.c = c;
            }

            function randomType(){ return Math.floor(Math.random()*TYPES); }

            function init(noCascades=true, showCards=false){
                score = 0; moves = 0; updateUI();
                // limpiar DOM y estado
                board.innerHTML = '';
                grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));

                for(let r=0;r<ROWS;r++){
                    for(let c=0;c<COLS;c++){
                        let t = randomType();
                        // evita nacimientos con match inmediato si noCascades=true
                        if(noCascades){
                            const left1 = c>0 ? grid[r][c-1]?.t : -1;
                            const left2 = c>1 ? grid[r][c-2]?.t : -2;
                            const up1 = r>0 ? grid[r-1][c]?.t : -1;
                            const up2 = r>1 ? grid[r-2][c]?.t : -2;
                            while((left1===t && left2===t) || (up1===t && up2===t)) t = randomType();
                        }
                        const el = makeCell(r,c,t);
                        grid[r][c] = { t, el };
                        board.appendChild(el);
                        
                        if (showCards) {
                            // Mostrar cartas con efecto
                            el.style.opacity = '1';
                            el.style.transform = 'scale(1)';
                        } else {
                            // Ocultar cartas inicialmente
                            el.style.opacity = '0';
                            el.style.transform = 'scale(0.8)';
                        }
                    }
                }
            }

            // --- INPUT (drag por celdas adyacentes)
            function onPointerDown(e){
                console.log('üéØ onPointerDown disparado!');
                e.preventDefault(); // Prevenir comportamiento por defecto
                const el = e.currentTarget;
                drag = { r: +el.dataset.r, c: +el.dataset.c, el };
                el.classList.add('ghost');
                console.log('‚úÖ Drag iniciado:', drag);
                
                // Sonido sutil al tocar una celda
                if (window.audioManager) {
                    window.audioManager.playSound('clean'); // Sonido suave para feedback t√°ctil
                }
                
                // Agregar event listeners globales para el drag
                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
            }
            function onPointerEnter(e){
                console.log('üéØ onPointerEnter disparado!', {drag: drag});
                if(!drag) return; // solo si estamos arrastrando desde otra celda
                const target = e.currentTarget;
                const r2 = +target.dataset.r, c2 = +target.dataset.c;
                const {r,c} = drag;
                console.log('üîÑ Intentando intercambio:', {from: {r,c}, to: {r2,c2}});
                if(isAdjacent(r,c,r2,c2)){
                    console.log('‚úÖ Son adyacentes, intercambiando...');
                    doSwap(r,c,r2,c2, true);
                    const matches = findMatches();
                    if(matches.length>0){
                        console.log('üéâ Match encontrado!', matches.length);
                        moves++; updateUI();
                        removeMatches(matches);
                    } else {
                        console.log('‚ùå No hay match, revirtiendo...');
                        // revertir si no hay match
                        doSwap(r2,c2,r,c, true);
                    }
                    endDrag();
                } else {
                    console.log('‚ùå No son adyacentes');
                }
            }
            function onPointerMove(e){
                if(!drag) return;
                // Encontrar el elemento bajo el cursor
                const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
                if(elementBelow && elementBelow.classList.contains('bloques-cell')){
                    onPointerEnter({currentTarget: elementBelow});
                }
            }
            
            function onPointerUp(){ 
                console.log('üéØ onPointerUp disparado!', {drag: drag});
                if(drag) {
                    // Remover event listeners globales
                    document.removeEventListener('pointermove', onPointerMove);
                    document.removeEventListener('pointerup', onPointerUp);
                    endDrag(); 
                }
            }
            function endDrag(){ 
                console.log('üõë endDrag llamado', {drag: drag});
                if(drag){ 
                    drag.el.classList.remove('ghost'); 
                    drag = null; 
                    console.log('‚úÖ Drag terminado');
                } 
            }
            function isAdjacent(r1,c1,r2,c2){ return (Math.abs(r1-r2)+Math.abs(c1-c2))===1; }

            function doSwap(r1,c1,r2,c2, animate=false){
                const a = grid[r1][c1], b = grid[r2][c2];
                grid[r1][c1] = b; grid[r2][c2] = a;
                if(animate){
                    placeCell(r1,c1,b.el); placeCell(r2,c2,a.el);
                    a.el.classList.add('pulse'); b.el.classList.add('pulse');
                    setTimeout(()=>{a.el.classList.remove('pulse'); b.el.classList.remove('pulse');}, 250);
                } else {
                    placeCell(r1,c1,b.el); placeCell(r2,c2,a.el);
                }
            }

            // --- DETECCI√ìN DE MATCHES (flood-fill 4 direcciones)
            function findMatches(){
                const seen = Array.from({length:ROWS},()=>Array(COLS).fill(false));
                const matches = [];
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

                for(let r=0;r<ROWS;r++){
                    for(let c=0;c<COLS;c++){
                        if(!grid[r][c] || seen[r][c]) continue;
                        const t = grid[r][c].t;
                        const stack=[[r,c]]; const group=[];
                        seen[r][c]=true;
                        while(stack.length){
                            const [rr,cc]=stack.pop(); group.push({r:rr,c:cc});
                            for(const [dr,dc] of dirs){
                                const nr=rr+dr,nc=cc+dc;
                                if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
                                if(seen[nr][nc]) continue;
                                if(grid[nr][nc] && grid[nr][nc].t===t){ seen[nr][nc]=true; stack.push([nr,nc]); }
                            }
                        }
                        if(group.length>=3) matches.push(...group);
                    }
                }

                // eliminar duplicados
                const key = p=>p.r+":"+p.c;
                const uniq = new Map();
                for(const m of matches) uniq.set(key(m), m);
                return [...uniq.values()];
            }

            // --- ELIMINACI√ìN, GRAVEDAD Y RELLENO
            function removeMatches(matches){
                // Menos puntos por match (antes era 10, ahora 2)
                score += matches.length * 2;
                
                // Sistema de niveles: cada 200 perlas sube de nivel
                const newLevel = Math.floor(score / 200) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // Actualizar nivel en la UI
                    const levelEl = gameOverlay.querySelector('.level');
                    if (levelEl) {
                        levelEl.textContent = `NIVEL ${level}`;
                    }
                    console.log(`üéâ ¬°Subiste al nivel ${level}!`);
                    
                    // üíæ GUARDAR PROGRESO EN LOCALSTORAGE
                    localStorage.setItem('bloques-level', level.toString());
                    localStorage.setItem('bloques-score', score.toString());
                    
                    // Sonido especial para subir de nivel
                    if (window.audioManager) {
                        window.audioManager.playSound('levelComplete');
                    }
                } else {
                    // Sonido de acierto normal
                    if (window.audioManager) {
                        window.audioManager.playSound('acierto');
                    }
                }
                
                updateUI();

                // Efecto de perlas volando al contador desde las posiciones de match
                createPearlEffectFromMatches(matches);

                // eliminar del DOM + marcar vac√≠os
                for(const {r,c} of matches){
                    const item = grid[r][c];
                    if(item && item.el){ item.el.style.opacity='0'; item.el.style.transform='scale(.6)'; setTimeout(()=>item.el.remove(),150); }
                    grid[r][c] = null;
                }

                // ca√≠da por columnas
                setTimeout(()=>{
                    for(let c=0;c<COLS;c++){
                        let write = ROWS-1;
                        for(let r=ROWS-1;r>=0;r--){
                            if(grid[r][c]){
                                if(write!==r){
                                    grid[write][c]=grid[r][c];
                                    placeCell(write,c, grid[write][c].el);
                                    grid[r][c]=null;
                                }
                                write--;
                            }
                        }
                        // generar nuevas arriba
                        for(let r=write;r>=0;r--){
                            const t = randomType();
                            const el = makeCell(r,c,t);
                            el.style.opacity='0'; el.style.transform='translateY(-24px)';
                            grid[r][c] = {t, el};
                            board.appendChild(el);
                            requestAnimationFrame(()=>{
                                el.style.transition='transform .35s ease, opacity .35s ease';
                                el.style.opacity='1'; el.style.transform='translateY(0)';
                            });
                        }
                    }

                    // cascada
                    setTimeout(()=>{
                        const again = findMatches();
                        if(again.length>0) removeMatches(again);
                    }, 120);
                }, 160);
            }

            let timerId = null, timeLeft = 60;
            function startTimer() {
                timerId = setInterval(() => {
                    timeLeft--;
                    updateUI();
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        console.log('‚è∞ Tiempo agotado!');
                        
                        // Sonido de fin de partida
                        if (window.audioManager) {
                            window.audioManager.playSound('fail');
                        }
                        
                        // Mostrar pantalla de fin de partida
                        showEndGameModal();
                    }
                }, 1000);
            }

            function showCardsEffect() {
                console.log('‚ú® Mostrando cartas con efecto...');
                
                // Obtener todas las cartas existentes
                const cells = board.querySelectorAll('.bloques-cell');
                
                // Hacer aparecer las cartas una por una con efecto suave
                cells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        cell.style.opacity = '1';
                        cell.style.transform = 'scale(1)';
                    }, index * 30); // Cada carta aparece con 30ms de diferencia
                });
                
                // Calcular tiempo total: (cells.length * 30ms) + 600ms (√∫ltima animaci√≥n)
                const totalTime = (cells.length * 30) + 600;
                return totalTime;
            }

            function createPearlEffectFromMatches(matches) {
                console.log(`üíé Creando efecto de perlas desde ${matches.length} matches...`);
                
                // Obtener posici√≥n del contador de perlas
                const pearlCounter = gameOverlay.querySelector('.perlas');
                if (!pearlCounter) return;
                
                const counterRect = pearlCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear perlas desde cada posici√≥n de match (m√°ximo 5 para que no sea demasiado)
                const maxPearls = Math.min(matches.length, 5);
                for (let i = 0; i < maxPearls; i++) {
                    const match = matches[i];
                    const cell = grid[match.r][match.c];
                    
                    if (cell && cell.el) {
                        // Obtener posici√≥n de la celda que hizo match
                        const cellRect = cell.el.getBoundingClientRect();
                        const startX = cellRect.left + cellRect.width / 2;
                        const startY = cellRect.top + cellRect.height / 2;
                        
                        const pearl = document.createElement('div');
                        pearl.innerHTML = '<img src="images/ui/perlas.png" style="width: 24px; height: 24px;">';
                        pearl.style.cssText = `
                            position: fixed;
                            z-index: 10000;
                            pointer-events: none;
                            left: ${startX}px;
                            top: ${startY}px;
                            opacity: 0;
                            transform: scale(0.5);
                            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        `;
                        
                        document.body.appendChild(pearl);
                        
                        // Aparecer y volar hacia el contador
                        setTimeout(() => {
                            pearl.style.opacity = '1';
                            pearl.style.transform = 'scale(1)';
                            
                            setTimeout(() => {
                                pearl.style.left = targetX + 'px';
                                pearl.style.top = targetY + 'px';
                                pearl.style.transform = 'scale(0.3)';
                                pearl.style.opacity = '0.7';
                            }, 200);
                        }, i * 100);
                        
                        // Remover despu√©s de la animaci√≥n
                        setTimeout(() => {
                            pearl.remove();
                        }, 1000 + (i * 100));
                    }
                }
            }

            function showEndGameModal() {
                console.log('üèÅ Mostrando modal de fin de partida...');
                
                // Crear modal de fin de partida (igual que Burbujas)
                const endModal = document.createElement('div');
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">üåä ¬°Tiempo Agotado!</h2>
                        <p style="
                            font-size: 18px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">Puntuaci√≥n: <strong>${score}</strong></p>
                        <button id="bloques-play-again" style="
                            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210));
                            border: 2px solid rgb(21, 101, 192);
                            border-radius: 20px;
                            padding: 12px 30px;
                            font-size: 18px;
                            font-weight: bold;
                            color: white;
                            cursor: pointer;
                            transition: 0.3s;
                            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">JUGAR</button>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listener para el bot√≥n
                const playAgainBtn = endModal.querySelector('#bloques-play-again');
                playAgainBtn.addEventListener('click', () => {
                    endModal.remove();
                    // Reiniciar juego
                    timeLeft = 60;
                    init(true, false);
                });
            }
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                if (timerId) clearInterval(timerId);
                gameOverlay.remove();
                // Volver a la ventana de juegos, no a la pecera
                document.getElementById('gamesModal').style.display = 'flex';
            });
            
            // Bot√≥n de sonido
            const soundBtn = gameOverlay.querySelector('#bloques-sound-toggle');
            if (soundBtn) {
                // Inicializar estado del bot√≥n
                const img = soundBtn.querySelector('img');
                if (img && window.audioManager) {
                    img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                }
                
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        // Usar el m√©todo correcto del AudioManager
                        window.audioManager.toggleMute();
                        const img = soundBtn.querySelector('img');
                        if (img) {
                            img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                        }
                    }
                });
            }
            
            // Actualizar UI inicial con progreso cargado
            updateUI();
            
            restartBtn.addEventListener('click', () => {
                console.log('üéÆ ¬°CLICK EN JUGAR DETECTADO!');
                if(timerId) clearInterval(timerId);
                
                // üîß ARREGLO: Resetear nivel y score de la partida
                level = 1;
                score = 0;
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                // Efecto de mostrar cartas
                const effectTime = showCardsEffect();
                
                setTimeout(() => {
                    startTimer();
                    console.log('üéÆ ¬°Juego iniciado!');
                }, effectTime); // Esperar a que termine el efecto
            });
            
            document.body.appendChild(gameOverlay);
            init(true, false); // No mostrar cartas inicialmente
            console.log('üíé Juego Conecta 3 iniciado');
        }
        
        // üß† JUEGO DE MEMORIA - PEZFLIP INFINITO
        function startMemoriaGame() {
            console.log('üß† Iniciando PezFlip Infinito...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego (igual que los otros)
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'memoryGameOverlay';
            gameOverlay.className = 'game-modal-overlay';
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                backdrop-filter: blur(10px) !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            gameOverlay.innerHTML = `
                <div class="memory-game-container">
                    <!-- üß† CABECERA DEL JUEGO (igual que los otros) -->
                    <div class="memory-game-header">
                        <div class="header-top">
                            <div class="game-title">üß† PezFlip Infinito</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="game-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL <span id="memory-level">1</span></span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="memory-bubbles">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="memory-best">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ‚è∞ BARRA DE TIEMPO -->
                    <div class="memory-timer-bar" style="
                        width: 100%;
                        height: 8px;
                        background: rgba(255, 255, 255, 0.2);
                        border-radius: 4px;
                        overflow: hidden;
                        margin: 10px 0;
                        border: 1px solid rgba(255, 255, 255, 0.3);
                    ">
                        <div class="memory-timer-fill" id="memory-timer-fill" style="
                            height: 100%;
                            background: linear-gradient(90deg, #29b6f6, #0288d1);
                            width: 100%;
                            transition: width 1s linear;
                        "></div>
                    </div>
                    
                    <!-- üéÆ √ÅREA DE JUEGO -->
                    <div class="memory-stage-container" style="
                        background: linear-gradient(135deg, 
                            rgba(79, 195, 247, 0.1) 0%, 
                            rgba(41, 182, 246, 0.05) 100%);
                        border: 2px solid rgba(255, 255, 255, 0.2);
                        border-radius: 14px;
                        padding: 10px;
                        margin: 10px;
                        flex: 1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div class="memory-board" id="memory-board" style="
                            display: grid;
                            grid-template-columns: repeat(5, 1fr);
                            grid-template-rows: repeat(4, 1fr);
                            gap: 8px;
                            width: 320px;
                            height: 256px;
                            background: rgba(255, 255, 255, 0.05);
                            padding: 10px;
                            border-radius: 10px;
                            border: 1px solid rgba(255, 255, 255, 0.1);
                        "></div>
                    </div>
                    
                    <!-- üéÆ BOT√ìN JUGAR -->
                    <div class="memory-footer" style="
                        padding: 20px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    ">
                       <button class="memory-btn" id="memory-restart" style="
                           background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
                           border: 2px solid rgb(21, 101, 192) !important;
                           border-radius: 20px !important;
                           padding: 12px 30px !important;
                           font-size: 18px !important;
                           font-weight: bold !important;
                           color: white !important;
                           cursor: pointer !important;
                           transition: 0.3s !important;
                           text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
                           box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
                           text-transform: uppercase !important;
                           letter-spacing: 1px !important;
                           width: 80% !important;
                           max-width: 250px !important;
                           margin: 20px auto !important;
                           display: block !important;
                       ">JUGAR</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(gameOverlay);
            console.log('üß† PezFlip overlay creado y a√±adido al DOM');
            
            // Variables del juego
            let cards = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let timeLeft = 120; // 2 minutos para que puedas jugar tranquilo
            let timerId = null;
            let gameActive = false;
            let bestScore = 0;
            let lockFlip = false; // Sistema de bloqueo mejorado
            let level = 1;
            let totalPairs = 2; // Empezar con 2 pares (4 cartas)
            let bubbles = 0; // Burbujas ganadas
            let baseTime = 90; // Tiempo base por nivel
            let closeDelay = 600; // Tiempo para cerrar cartas
            
            // Emojis marinos para las cartas (set expandido)
            const EMOJIS = [
                'üêü','üê†','üê°','ü¶à','üê¨','üê≥','üêã','ü¶Ä','ü¶û','ü¶ë',
                'ü¶ê','üêô','üêö','ü™∏','‚≠ê','‚öì','ü™º','ü¶≠','üêä','üåä'
            ];
            
            // Colores de nivel para los bordes de las cartas
            const LEVEL_COLORS = [
                'rgba(33, 150, 243, 0.8)',    // Nivel 1 - Azul
                'rgba(76, 175, 80, 0.8)',     // Nivel 2 - Verde
                'rgba(156, 39, 176, 0.8)',    // Nivel 3 - P√∫rpura
                'rgba(255, 152, 0, 0.8)',     // Nivel 4 - Naranja
                'rgba(244, 67, 54, 0.8)',     // Nivel 5 - Rojo
                'rgba(255, 193, 7, 0.8)',     // Nivel 6 - Amarillo
                'rgba(0, 188, 212, 0.8)',     // Nivel 7 - Cian
                'rgba(103, 58, 183, 0.8)',    // Nivel 8 - √çndigo
                'rgba(255, 87, 34, 0.8)',     // Nivel 9 - Naranja oscuro
                'rgba(233, 30, 99, 0.8)'      // Nivel 10+ - Rosa
            ];
            
            // Funci√≥n para obtener color del nivel
            function getLevelColor(level) {
                return LEVEL_COLORS[Math.min(level - 1, LEVEL_COLORS.length - 1)];
            }
            
            // Funci√≥n para calcular dificultad seg√∫n nivel
            function calculateDifficulty(level) {
                if (level <= 2) {
                    return { pairs: 2, time: 90, closeDelay: 600, grid: '2x2' };
                } else if (level <= 4) {
                    return { pairs: 4, time: 100, closeDelay: 500, grid: '2x4' };
                } else if (level <= 6) {
                    return { pairs: 6, time: 110, closeDelay: 400, grid: '3x4' };
                } else if (level <= 8) {
                    return { pairs: 8, time: 120, closeDelay: 350, grid: '4x4' };
                } else {
                    return { pairs: 10, time: 130, closeDelay: 300, grid: '4x5' };
                }
            }
            
            // Funci√≥n para actualizar el layout del grid
            function updateGridLayout(gridType) {
                const board = gameOverlay.querySelector('#memory-board');
                if (!board) return;
                
                switch(gridType) {
                    case '2x2':
                        board.style.gridTemplateColumns = 'repeat(2, 1fr)';
                        board.style.gridTemplateRows = 'repeat(2, 1fr)';
                        board.style.width = '160px';
                        board.style.height = '160px';
                        break;
                    case '2x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(2, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '160px';
                        break;
                    case '3x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(3, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '240px';
                        break;
                    case '4x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(4, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '320px';
                        break;
                    case '4x5':
                        board.style.gridTemplateColumns = 'repeat(5, 1fr)';
                        board.style.gridTemplateRows = 'repeat(4, 1fr)';
                        board.style.width = '400px';
                        board.style.height = '320px';
                        break;
                }
            }
            
            // Elementos del DOM
            const board = gameOverlay.querySelector('#memory-board');
            const levelEl = gameOverlay.querySelector('#memory-level');
            const bubblesEl = gameOverlay.querySelector('#memory-bubbles');
            const bestEl = gameOverlay.querySelector('#memory-best');
            const timerFill = gameOverlay.querySelector('#memory-timer-fill');
            const restartBtn = gameOverlay.querySelector('#memory-restart');
            const closeBtn = gameOverlay.querySelector('.game-close-btn');
            const soundBtn = gameOverlay.querySelector('.sound-btn');
            
            // Funci√≥n para crear las cartas
            function createCards() {
                board.innerHTML = '';
                cards = [];
                flippedCards = [];
                matchedPairs = 0;
                moves = 0;
                lockFlip = false; // Reiniciar bloqueo
                gameActive = false;
                
                // Calcular dificultad seg√∫n nivel
                const difficulty = calculateDifficulty(level);
                totalPairs = difficulty.pairs;
                timeLeft = difficulty.time;
                closeDelay = difficulty.closeDelay;
                
                // Actualizar grid din√°micamente
                updateGridLayout(difficulty.grid);
                
                // Crear cartas seg√∫n dificultad
                const availableEmojis = EMOJIS.slice(0, totalPairs);
                const cardData = [...availableEmojis, ...availableEmojis];
                for(let i = cardData.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardData[i], cardData[j]] = [cardData[j], cardData[i]];
                }
                
                cardData.forEach((emoji, index) => {
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.dataset.emoji = emoji;
                    card.dataset.index = index;
                    card.style.cssText = `
                        background: rgba(255, 255, 255, 0.1);
                        border: 3px solid ${getLevelColor(level)};
                        border-radius: 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        backdrop-filter: blur(10px);
                        opacity: 0;
                        transform: scale(0.8);
                        box-shadow: 0 0 15px ${getLevelColor(level)};
                    `;
                    
                    // Contenido de la carta (inicialmente oculto)
                    card.innerHTML = `
                        <div class="card-back" style="
                            width: 100%;
                            height: 100%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            background: linear-gradient(135deg, 
                                rgba(79, 195, 247, 0.3) 0%, 
                                rgba(41, 182, 246, 0.2) 100%);
                            border-radius: 6px;
                            font-size: 20px;
                        ">?</div>
                        <div class="card-front" style="
                            width: 100%;
                            height: 100%;
                            display: none;
                            align-items: center;
                            justify-content: center;
                            background: rgba(255, 255, 255, 0.9);
                            border-radius: 6px;
                            font-size: 24px;
                        ">${emoji}</div>
                    `;
                    
                    card.addEventListener('click', () => flipCard(card));
                    board.appendChild(card);
                    cards.push(card);
                });
                
                updateUI();
            }
            
            // Funci√≥n para voltear carta (sistema mejorado)
            function flipCard(card) {
                if (lockFlip || !gameActive || card.classList.contains('flipped') || card.classList.contains('matched')) {
                    return;
                }
                
                const open = Array.from(board.querySelectorAll('.memory-card.flipped:not(.matched)'));
                if (open.length >= 2) return; // Prevenir m√°s de 2 cartas abiertas
                
                card.classList.add('flipped');
                
                // Efecto de giro r√°pido
                card.style.transform = 'rotateY(180deg)';
                card.style.transition = 'transform 0.3s ease-in-out';
                
                // Mostrar el emoji despu√©s del giro
                setTimeout(() => {
                    const cardBack = card.querySelector('.card-back');
                    const cardFront = card.querySelector('.card-front');
                    cardBack.style.display = 'none';
                    cardFront.style.display = 'flex';
                }, 150);
                
                // Sonido de voltear (siempre)
                if (window.audioManager) {
                    window.audioManager.playSound('acierto');
                }
                
                const newlyOpen = [...open, card];
                if (newlyOpen.length === 2) {
                    moves++;
                    updateUI();
                    lockFlip = true;
                    
                    const [a, b] = newlyOpen;
                    const isMatch = a.dataset.emoji === b.dataset.emoji;
                    
                    setTimeout(() => {
                        if (isMatch) {
                            a.classList.add('matched');
                            b.classList.add('matched');
                            matchedPairs++;
                            
                            // Efecto visual verde para aciertos
                            a.style.background = 'linear-gradient(135deg, #4CAF50, #8BC34A)';
                            b.style.background = 'linear-gradient(135deg, #4CAF50, #8BC34A)';
                            a.style.transform = 'scale(1.1)';
                            b.style.transform = 'scale(1.1)';
                            
                            setTimeout(() => {
                                a.style.transform = 'scale(1)';
                                b.style.transform = 'scale(1)';
                            }, 300);
                            
                            // A√±adir burbujas por acierto
                            bubbles += 2;
                            
                            // Guardar burbujas
                            localStorage.setItem('memory-bubbles', bubbles.toString());
                            
                            // Sonido de acierto
                            if (window.audioManager) {
                                window.audioManager.playSound('nivelcompletado');
                            }
                            
                            // Efecto de perlas
                            createPearlEffect(a);
                            
                            if (matchedPairs === totalPairs) {
                                setTimeout(() => {
                                    // Sonido de nivel completado
                                    if (window.audioManager) {
                                        window.audioManager.playSound('levelComplete');
                                    }
                                    
                                    // Subir nivel
                                    level++;
                                    
                                    // Guardar progreso
                                    localStorage.setItem('memory-level', level.toString());
                                    localStorage.setItem('memory-bubbles', bubbles.toString());
                                    
                                    // Regenerar tablero (sistema infinito)
                                    createCards();
                                    showCardsEffect(); // Mostrar cartas con efecto
                                    updateUI();
                                    
                                    // Reiniciar timer para nueva ronda
                                    if (timerId) clearInterval(timerId);
                                    const newDifficulty = calculateDifficulty(level);
                                    timeLeft = newDifficulty.time; // Tiempo din√°mico seg√∫n nuevo nivel
                                    gameActive = true; // Reactivar el juego
                                    lockFlip = false; // Resetear bloqueo
                                    startTimer(); // Iniciar nuevo timer
                                }, 600);
                            }
                        } else {
                            // Voltear de vuelta con efecto de giro r√°pido
                            setTimeout(() => {
                                a.style.transform = 'rotateY(0deg)';
                                b.style.transform = 'rotateY(0deg)';
                                
                                setTimeout(() => {
                                    const cardBack1 = a.querySelector('.card-back');
                                    const cardFront1 = a.querySelector('.card-front');
                                    const cardBack2 = b.querySelector('.card-back');
                                    const cardFront2 = b.querySelector('.card-front');
                                    
                                    cardBack1.style.display = 'flex';
                                    cardFront1.style.display = 'none';
                                    cardBack2.style.display = 'flex';
                                    cardFront2.style.display = 'none';
                                    
                                    a.classList.remove('flipped');
                                    b.classList.remove('flipped');
                                }, 150);
                            }, 300);
                        }
                        lockFlip = false;
                    }, isMatch ? 250 : closeDelay);
                }
            }
            
            
            // Funci√≥n para crear efecto de burbujas volando al contador
            function createPearlEffect(card) {
                const rect = card.getBoundingClientRect();
                
                // Obtener posici√≥n del contador de burbujas
                const bubbleCounter = gameOverlay.querySelector('.perlas');
                if (!bubbleCounter) return;
                
                const counterRect = bubbleCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear 3 burbujas que vuelen al contador
                for (let i = 0; i < 3; i++) {
                    const pearl = document.createElement('div');
                    pearl.style.cssText = `
                        position: fixed;
                        left: ${rect.left + rect.width/2 + (i - 1) * 10}px;
                        top: ${rect.top + rect.height/2 + (i - 1) * 5}px;
                        width: 20px;
                        height: 20px;
                        background: url('images/ui/perlas.png') center/contain no-repeat;
                        pointer-events: none;
                        z-index: 99999;
                        animation: bubbleFly 1.2s ease-out forwards;
                    `;
                    
                    // A√±adir keyframes para la animaci√≥n
                    if (!document.getElementById('bubbleFlyKeyframes')) {
                        const style = document.createElement('style');
                        style.id = 'bubbleFlyKeyframes';
                        style.textContent = `
                            @keyframes bubbleFly {
                                0% {
                                    transform: scale(0.5) rotate(0deg);
                                    opacity: 1;
                                }
                                50% {
                                    transform: scale(1.2) rotate(180deg);
                                    opacity: 0.8;
                                }
                                100% {
                                    transform: scale(0.3) rotate(360deg);
                                    opacity: 0;
                                    left: ${targetX}px;
                                    top: ${targetY}px;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    document.body.appendChild(pearl);
                    setTimeout(() => pearl.remove(), 1200);
                }
            }
            
            // Funci√≥n para actualizar UI
            function updateUI() {
                if (levelEl) levelEl.textContent = level; // Nivel por rondas completadas
                if (bubblesEl) bubblesEl.textContent = bubbles;
                if (bestEl) bestEl.textContent = bestScore;
                const difficulty = calculateDifficulty(level);
                if (timerFill) timerFill.style.width = `${(timeLeft / difficulty.time) * 100}%`;
            }
            
            // Funci√≥n para iniciar timer
            function startTimer() {
                if (timerId) clearInterval(timerId); // Limpiar timer anterior
                timerId = setInterval(() => {
                    timeLeft--;
                    updateUI();
                    
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        endGame(false);
                    }
                }, 1000);
            }
            
            // Funci√≥n para mostrar cartas con efecto
            function showCardsEffect() {
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        card.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1)';
                    }, index * 50);
                });
            }
            
            // Funci√≥n para terminar juego
            function endGame(won) {
                if (!gameActive) return; // Evitar m√∫ltiples llamadas
                
                gameActive = false;
                if (timerId) clearInterval(timerId);
                
                // Actualizar r√©cord si es mejor
                if (won && moves < bestScore || bestScore === 0) {
                    bestScore = moves;
                    localStorage.setItem('memory-best', bestScore.toString());
                }
                
                // Sonido de fin
                if (window.audioManager) {
                    window.audioManager.playSound(won ? 'nivelcompletado' : 'fail');
                }
                
                // Verificar si ya existe un modal de fin
                if (gameOverlay.querySelector('.end-modal')) return;
                
                // Mostrar modal de fin (igual que Burbujas y Conecta 3)
                const endModal = document.createElement('div');
                endModal.className = 'end-modal';
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">
                            ${won ? 'üß† ¬°Felicidades!' : 'üß† ¬°Int√©ntalo de nuevo!'}
                        </h2>
                        <p style="
                            font-size: 18px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">
                            ${won ? '¬°Completaste todas las parejas!' : 'Sigue practicando'}
                        </p>
                        <p style="
                            font-size: 16px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">
                            Nivel alcanzado: <strong>${level}</strong><br>
                            Burbujas: <strong>${bubbles}</strong><br>
                            Movimientos: <strong>${moves}</strong>
                        </p>
                       <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                           <button class="restart-btn" style="
                               background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210));
                               border: 2px solid rgb(21, 101, 192);
                               border-radius: 20px;
                               padding: 12px 30px;
                               font-size: 18px;
                               font-weight: bold;
                               color: white;
                               cursor: pointer;
                               transition: 0.3s;
                               text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                               box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px;
                               text-transform: uppercase;
                               letter-spacing: 1px;
                               flex: 1;
                               min-width: 120px;
                           ">CONTINUAR</button>
                           <button class="reset-btn" style="
                               background: linear-gradient(135deg, rgb(244, 67, 54), rgb(211, 47, 47));
                               border: 2px solid rgb(183, 28, 28);
                               border-radius: 20px;
                               padding: 12px 20px;
                               font-size: 16px;
                               font-weight: bold;
                               color: white;
                               cursor: pointer;
                               transition: 0.3s;
                               text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                               box-shadow: rgba(244, 67, 54, 0.4) 0px 6px 20px;
                               text-transform: uppercase;
                               letter-spacing: 1px;
                               flex: 1;
                               min-width: 120px;
                           ">EMPEZAR DE CERO</button>
                       </div>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listeners del modal de fin
                endModal.querySelector('.restart-btn').addEventListener('click', () => {
                    endModal.remove();
                    startGame();
                });
                
                endModal.querySelector('.reset-btn').addEventListener('click', () => {
                    // Resetear progreso
                    level = 1;
                    bubbles = 0;
                    localStorage.removeItem('memory-level');
                    localStorage.removeItem('memory-bubbles');
                    endModal.remove();
                    startGame();
                });
                
                // Cerrar modal al hacer clic fuera
                endModal.addEventListener('click', (e) => {
                    if (e.target === endModal) {
                        endModal.remove();
                        gameOverlay.remove();
                        document.getElementById('gamesModal').style.display = 'flex';
                    }
                });
            }
            
            // Funci√≥n para iniciar juego
            function startGame() {
                // üîß ARREGLO: Resetear nivel y burbujas de la partida
                level = 1;
                bubbles = 0;
                const difficulty = calculateDifficulty(level);
                timeLeft = difficulty.time; // Tiempo din√°mico seg√∫n nivel
                lockFlip = false; // Reiniciar bloqueo
                createCards();
                showCardsEffect();
                
                setTimeout(() => {
                    gameActive = true;
                    startTimer();
                }, 2000);
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
            }
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                if (timerId) clearInterval(timerId);
                gameOverlay.remove();
                document.getElementById('gamesModal').style.display = 'flex';
            });
            
            restartBtn.addEventListener('click', startGame);
            
            // Bot√≥n de sonido
            if (soundBtn) {
                const img = soundBtn.querySelector('img');
                if (img && window.audioManager) {
                    img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                }
                
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        window.audioManager.toggleMute();
                        const img = soundBtn.querySelector('img');
                        if (img) {
                            img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                        }
                    }
                });
            }
            
            // Cargar r√©cord y progreso
            const savedBest = localStorage.getItem('memory-best');
            if (savedBest) bestScore = parseInt(savedBest);
            
            // Cargar nivel guardado
            const savedLevel = localStorage.getItem('memory-level');
            if (savedLevel) level = parseInt(savedLevel);
            
            // Cargar burbujas guardadas
            const savedBubbles = localStorage.getItem('memory-bubbles');
            if (savedBubbles) bubbles = parseInt(savedBubbles);
            
            // Inicializar juego
            createCards();
            updateUI();
            console.log('üß† PezFlip iniciado correctamente');
            console.log('üß† Overlay visible:', gameOverlay.style.display);
            console.log('üß† Overlay en DOM:', document.body.contains(gameOverlay));
        }
        
        // üéµ JUEGO DE SIM√ìN MARINO - INTEGRADO COMPLETO
        function startSimonGame() {
            console.log('üéµ Iniciando juego Sim√≥n Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            console.log('üéµ Modal de juegos cerrado');
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'simonGameOverlay';
            gameOverlay.innerHTML = `
                <div class="simon-game-container">
                    <div class="simon-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üéµ Sim√≥n Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="game-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL <span id="simon-game-level">1</span></span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="simon-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="simon-best">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="simon-board-wrap">
                        <div class="simon-board" id="simon-board">
                            <button class="simon-pad" id="simon-p1">üêü</button>
                            <button class="simon-pad" id="simon-p2">üêö</button>
                            <button class="simon-pad" id="simon-p3">‚≠ê</button>
                            <button class="simon-pad" id="simon-p4">üåä</button>
                        </div>
                    </div>
                    <div class="simon-footer">
                        <button class="simon-btn" id="simon-start">JUGAR</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'simon');
            console.log('üéµ Dise√±o aplicado');
            
            const boardWrap = gameOverlay.querySelector('.simon-board-wrap');
            boardWrap.style.cssText = `
                flex: 1; display: flex; align-items: center; justify-content: center; padding: 30px;
            `;
            
            const board = gameOverlay.querySelector('.simon-board');
            board.style.cssText = `
                display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
                gap: 15px; width: 100%; max-width: 300px; aspect-ratio: 1;
            `;
            
            const pads = gameOverlay.querySelectorAll('.simon-pad');
            const padColors = ['#1e88e5', '#43a047', '#f4511e', '#fdd835'];
            pads.forEach((pad, i) => {
                pad.style.cssText = `
                    border: none; border-radius: 18px; font-size: 32px; font-weight: 900;
                    background: linear-gradient(145deg, ${padColors[i]}, ${padColors[i]}dd);
                    color: #062130; cursor: pointer; user-select: none;
                    box-shadow: 0 8px 16px rgba(0,0,0,0.3); transition: all 0.15s ease;
                    aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
                    opacity: 0; transform: scale(0.8);
                `;
            });
            
            // Variables del juego
            let sequence = [], playerSequence = [], round = 1, score = 0, best = 0;
            let isShowing = false, isPlayerTurn = false, gameActive = false;
            let speed = 600; // Velocidad inicial (ms entre pads)
            
            // Cargar progreso guardado
            const savedBest = localStorage.getItem('simon-best');
            if (savedBest) {
                best = parseInt(savedBest);
                console.log('üéµ Simon: Mejor r√©cord cargado:', best);
            } else {
                console.log('üéµ Simon: No hay r√©cord guardado, empezando con 0');
            }
            
            // Funci√≥n para calcular velocidad basada en el nivel
            function updateSpeed() {
                // Cada 3 niveles, la velocidad aumenta (tiempo disminuye)
                const speedLevel = Math.floor(round / 3);
                speed = Math.max(300, 600 - (speedLevel * 50)); // M√≠nimo 300ms, m√°ximo 600ms
            }
            
            // Funciones del juego
            function initSimonGame() {
                // Mostrar las cartas con efecto
                pads.forEach((pad, index) => {
                    setTimeout(() => {
                        pad.style.opacity = '1';
                        pad.style.transform = 'scale(1)';
                    }, index * 100);
                });
                
                sequence = [];
                playerSequence = [];
                round = 1; // üîß ARREGLO: Empezar en nivel 1
                score = 0; // üîß ARREGLO: Resetear perlas de la partida
                speed = 600; // Resetear velocidad inicial
                isShowing = false;
                isPlayerTurn = false;
                gameActive = true;
                updateUI();
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                addToSequence();
            }
            
            function addToSequence() {
                const nextPad = Math.floor(Math.random() * 4);
                sequence.push(nextPad);
                round++;
                score += 5; // +5 perlas por ronda completada
                
                console.log('üéµ Simon: Nueva ronda! Round:', round, 'Score:', score);
                
                // Actualizar velocidad basada en el nivel
                updateSpeed();
                
                updateUI();
                
                // Efecto de perlas volando al contador
                createPearlEffect();
                
                showSequence();
            }
            
            function showSequence() {
                isShowing = true;
                isPlayerTurn = false;
                let i = 0;
                
                const showNext = () => {
                    if (i < sequence.length) {
                        lightUpPad(sequence[i]);
                        setTimeout(() => {
                            i++;
                            setTimeout(showNext, Math.max(150, speed - 200)); // Pausa entre pads
                        }, Math.max(400, speed - 100)); // Duraci√≥n del pad encendido
                    } else {
                        isShowing = false;
                        isPlayerTurn = true;
                        playerSequence = [];
                    }
                };
                
                setTimeout(showNext, 800);
            }
            
            function lightUpPad(padIndex) {
                const pad = pads[padIndex];
                
                // üîß ARREGLO: Guardar solo los estilos que vamos a cambiar
                const originalFilter = pad.style.filter;
                const originalTransform = pad.style.transform;
                
                pad.style.filter = 'brightness(1.4) contrast(1.1)';
                pad.style.transform = 'scale(1.05)';
                
                // Sonido simple
                playSimonSound(padIndex);
                
                setTimeout(() => {
                    // üîß ARREGLO: Restaurar solo los estilos espec√≠ficos
                    pad.style.filter = originalFilter;
                    pad.style.transform = 'scale(1)'; // Siempre volver a escala normal
                }, 400);
            }
            
            function playSimonSound(padIndex) {
                // üéµ Simon: Solo sonido musical √∫nico, NO sonido de burbujita
                // Crear AudioContext para sonidos √∫nicos
                if (!window.audioContext) {
                    try {
                        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch(e) {
                        console.log('AudioContext no disponible');
                        return;
                    }
                }
                
                try {
                    const oscillator = window.audioContext.createOscillator();
                    const gainNode = window.audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(window.audioContext.destination);
                    
                    const frequencies = [330, 415, 523, 659]; // Notas musicales
                    oscillator.frequency.setValueAtTime(frequencies[padIndex], window.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(window.audioContext.currentTime + 0.3);
                } catch(e) {
                    console.log('Audio no disponible');
                }
            }
            
            function handlePadClick(padIndex) {
                if (!isPlayerTurn || isShowing || !gameActive) return;
                
                // üéµ Simon: Solo efecto visual, no sonido de clic (ya tiene sonido musical)
                lightUpPad(padIndex);
                playerSequence.push(padIndex);
                
                // Verificar si es correcto
                const currentIndex = playerSequence.length - 1;
                if (playerSequence[currentIndex] !== sequence[currentIndex]) {
                    // Error - fin del juego
                    gameOver();
                    return;
                }
                
                // Si complet√≥ la secuencia
                if (playerSequence.length === sequence.length) {
                    console.log('üéµ Simon: ¬°Ronda completada! Llamando addToSequence...');
                    isPlayerTurn = false;
                    setTimeout(() => {
                        addToSequence();
                    }, 1000);
                }
            }
            
            function gameOver() {
                gameActive = false;
                isPlayerTurn = false;
                
                // Guardar el nivel m√°s alto alcanzado (no las perlas)
                if (round > best) {
                    best = round;
                    localStorage.setItem('simon-best', best.toString());
                    console.log('üéµ Simon: Nuevo r√©cord de nivel:', best);
                }
                
                // Dar recompensas basadas en el score (perlas ganadas)
                const bubbles = Math.floor(score / 6);  // Burbujas cada 6 perlas
                const stars = Math.floor(score / 8);    // Estrellas cada 8 perlas
                
                if (window.game && (bubbles > 0 || stars > 0)) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                updateUI();
                
                // Mostrar modal de fin de juego unificado
                setTimeout(() => {
                    showEndGameModal();
                }, 500);
            }
            
            function showEndGameModal() {
                // Evitar m√∫ltiples modales
                if (gameOverlay.querySelector('.end-modal')) return;
                
                const bubbles = Math.floor(score / 6);  // Burbujas cada 6 perlas
                const stars = Math.floor(score / 8);    // Estrellas cada 8 perlas
                
                const endModal = document.createElement('div');
                endModal.className = 'end-modal';
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <!-- BOT√ìN X EN ESQUINA SUPERIOR DERECHA -->
                        <button class="close-btn" style="
                            position: absolute;
                            top: 15px;
                            right: 15px;
                            background: rgba(255, 255, 255, 0.2);
                            border: 2px solid rgba(255, 255, 255, 0.8);
                            border-radius: 50%;
                            width: 35px;
                            height: 35px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            color: white;
                            font-size: 16px;
                            font-weight: bold;
                            z-index: 10;
                        ">‚úï</button>
                        
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">üéµ ¬°Fin del juego!</h2>
                        
                        <div style="margin: 15px 0; font-size: 16px;">
                            <p style="margin: 8px 0;"><strong>Nivel alcanzado:</strong> ${round}</p>
                            <p style="margin: 8px 0;"><strong>Perlas conseguidas:</strong> ${score}</p>
                            <p style="margin: 8px 0;"><strong>Mejor r√©cord:</strong> ${best}</p>
                            <p style="margin: 8px 0;"><strong>Burbujas ganadas:</strong> +${bubbles}</p>
                            <p style="margin: 8px 0;"><strong>Estrellas ganadas:</strong> +${stars}</p>
                        </div>
                        
                        <div style="margin-top: 25px;">
                            <button class="restart-btn" style="
                                background: linear-gradient(135deg, #4CAF50, #45a049);
                                color: white;
                                border: none;
                                padding: 12px 24px;
                                border-radius: 25px;
                                font-size: 16px;
                                font-weight: bold;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
                            ">JUGAR DE NUEVO</button>
                        </div>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listeners
                endModal.querySelector('.restart-btn').addEventListener('click', () => {
                    endModal.remove();
                    initSimonGame();
                });
                
                endModal.querySelector('.close-btn').addEventListener('click', () => {
                    gameOverlay.remove();
                    document.getElementById('gamesModal').style.display = 'flex';
                });
            }
            
            function updateUI() {
                const levelEl = document.getElementById('simon-game-level'); // üîß ARREGLO: ID correcto
                const scoreEl = document.getElementById('simon-score');
                const bestEl = document.getElementById('simon-best');
                
                console.log('üéµ Simon: updateUI - Round:', round, 'Score:', score, 'Best:', best);
                
                if (levelEl) {
                    levelEl.textContent = round; // Mostrar nivel actual (ronda completada)
                    console.log('üéµ Simon: Nivel actualizado a:', round);
                } else {
                    console.log('üéµ Simon: ERROR - No se encontr√≥ simon-game-level');
                }
                if (scoreEl) scoreEl.textContent = score;
                if (bestEl) bestEl.textContent = best;
            }
            
            // Funci√≥n para crear efecto de perlas volando al contador
            function createPearlEffect() {
                // Obtener posici√≥n del contador de perlas
                const pearlCounter = gameOverlay.querySelector('.perlas');
                if (!pearlCounter) return;
                
                const counterRect = pearlCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear 3 perlas que vuelen al contador desde el centro del tablero
                const board = gameOverlay.querySelector('#simon-board');
                const boardRect = board.getBoundingClientRect();
                const startX = boardRect.left + boardRect.width / 2;
                const startY = boardRect.top + boardRect.height / 2;
                
                for (let i = 0; i < 3; i++) {
                    const pearl = document.createElement('div');
                    pearl.style.cssText = `
                        position: fixed;
                        left: ${startX + (i - 1) * 15}px;
                        top: ${startY + (i - 1) * 10}px;
                        width: 20px;
                        height: 20px;
                        background: url('images/ui/perlas.png') center/contain no-repeat;
                        pointer-events: none;
                        z-index: 99999;
                        animation: bubbleFly 1.2s ease-out forwards;
                    `;
                    
                    // A√±adir keyframes para la animaci√≥n
                    if (!document.getElementById('bubbleFlyKeyframes')) {
                        const style = document.createElement('style');
                        style.id = 'bubbleFlyKeyframes';
                        style.textContent = `
                            @keyframes bubbleFly {
                                0% {
                                    transform: scale(0.5) rotate(0deg);
                                    opacity: 1;
                                }
                                50% {
                                    transform: scale(1.2) rotate(180deg);
                                    opacity: 0.8;
                                }
                                100% {
                                    transform: scale(0.3) rotate(360deg);
                                    opacity: 0;
                                    left: ${targetX}px;
                                    top: ${targetY}px;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    document.body.appendChild(pearl);
                    setTimeout(() => pearl.remove(), 1200);
                }
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.game-close-btn');
            console.log('üéµ Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameOverlay.remove();
                    document.getElementById('gamesModal').style.display = 'flex';
                    console.log('üéµ Juego Sim√≥n Marino cerrado');
                });
            } else {
                console.error('üéµ ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#simon-start');
            console.log('üéµ Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initSimonGame();
                });
            } else {
                console.error('üéµ ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            pads.forEach((pad, index) => {
                pad.addEventListener('click', () => handlePadClick(index));
            });
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üéµ Juego Sim√≥n Marino iniciado');
            console.log('üéµ Overlay visible:', gameOverlay.style.display);
            console.log('üéµ Overlay en DOM:', document.body.contains(gameOverlay));
            console.log('üéµ Overlay z-index:', gameOverlay.style.zIndex);
        }
        
        // üê¨ JUEGO DEL CARRIL DEL DELF√çN - INTEGRADO COMPLETO
        function startCarrilGame() {
            console.log('üê¨ Iniciando juego Carril del Delf√≠n integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            console.log('üê¨ Modal de juegos cerrado');
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'carrilGameOverlay';
            gameOverlay.innerHTML = `
                <div class="carril-game-container">
                    <div class="carril-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üê¨ Carril del Delf√≠n</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="carril-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: ESTAD√çSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Tiempo:</span>
                                    <span class="best-value" id="carril-time">60</span>s
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="carril-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">R√©cord:</span>
                                    <span class="best-value" id="carril-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="carril-stage" id="carril-stage">
                        <div class="carril-lanes">
                            <div class="carril-lane" id="carril-lane-0"></div>
                            <div class="carril-lane" id="carril-lane-1"></div>
                            <div class="carril-lane" id="carril-lane-2"></div>
                        </div>
                    </div>
                    <div class="carril-footer">
                        <div class="carril-controls">
                            <button class="carril-move-btn" data-lane="0">‚óÄ Izq</button>
                            <button class="carril-move-btn" data-lane="1">‚óè Centro</button>
                            <button class="carril-move-btn" data-lane="2">Dcha ‚ñ∂</button>
                        </div>
                        <button class="carril-btn" id="carril-start">‚ñ∂Ô∏è Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'carril');
            console.log('üê¨ Dise√±o aplicado');
            
            const stage = gameOverlay.querySelector('.carril-stage');
            stage.style.cssText = `
                flex: 1; position: relative; background: linear-gradient(#0a3d66, #0e5a92);
                border-radius: 14px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.15);
                margin: 10px;
            `;
            
            const lanes = gameOverlay.querySelector('.carril-lanes');
            lanes.style.cssText = `
                position: absolute; inset: 0; display: grid; grid-template-columns: repeat(3, 1fr);
                gap: 6px; padding: 6px;
            `;
            
            const laneElements = gameOverlay.querySelectorAll('.carril-lane');
            laneElements.forEach(lane => {
                lane.style.cssText = `
                    border-radius: 10px; background: rgba(255, 255, 255, 0.06);
                    position: relative; overflow: hidden;
                `;
            });
            
            // Variables del juego
            let gameActive = false, timeLeft = 60, score = 0, best = 0;
            let playerLane = 1, entities = [], gameLoop = null, spawnTimer = 0;
            
            // Cargar r√©cord
            const savedBest = localStorage.getItem('carril-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCarrilGame() {
                gameActive = true;
                timeLeft = 60;
                score = 0;
                playerLane = 1;
                entities = [];
                spawnTimer = 0;
                updateUI();
                createPlayer();
                startGameLoop();
                startTimer();
            }
            
            function createPlayer() {
                const player = document.createElement('div');
                player.className = 'carril-player';
                player.innerHTML = 'üê¨';
                player.style.cssText = `
                    position: absolute; width: 50px; height: 50px; border-radius: 12px;
                    background: #5bd0ff; color: #072a44; font-size: 30px; font-weight: 900;
                    display: flex; align-items: center; justify-content: center;
                    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.22), 0 6px 12px rgba(0,0,0,0.35);
                    bottom: 20px; left: 50%; transform: translateX(-50%);
                    transition: all 0.2s ease;
                `;
                
                const currentLane = laneElements[playerLane];
                currentLane.appendChild(player);
            }
            
            function movePlayer(newLane) {
                if (!gameActive || newLane === playerLane) return;
                
                // Remover jugador del carril actual
                const oldPlayer = laneElements[playerLane].querySelector('.carril-player');
                if (oldPlayer) oldPlayer.remove();
                
                // Cambiar carril
                playerLane = newLane;
                createPlayer();
            }
            
            function spawnEntity() {
                const lane = Math.floor(Math.random() * 3);
                const isGood = Math.random() < 0.3; // 30% bueno, 70% malo
                
                const entity = document.createElement('div');
                entity.className = isGood ? 'carril-good' : 'carril-bad';
                entity.innerHTML = isGood ? '‚≠ê' : 'üí•';
                entity.style.cssText = `
                    position: absolute; width: 50px; height: 50px; border-radius: 12px;
                    background: ${isGood ? '#ff9a3c' : '#ff7a6e'}; color: #072a44;
                    font-size: 30px; font-weight: 900; display: flex; align-items: center; justify-content: center;
                    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.22), 0 6px 12px rgba(0,0,0,0.35);
                    top: -60px; left: 50%; transform: translateX(-50%);
                `;
                
                entity.dataset.lane = lane;
                entity.dataset.good = isGood;
                entity.dataset.y = -60;
                
                laneElements[lane].appendChild(entity);
                entities.push(entity);
            }
            
            function updateEntities() {
                for (let i = entities.length - 1; i >= 0; i--) {
                    const entity = entities[i];
                    let y = parseInt(entity.dataset.y);
                    y += 4; // Velocidad de ca√≠da
                    entity.dataset.y = y;
                    entity.style.top = y + 'px';
                    
                    // Verificar colisi√≥n con jugador
                    const entityLane = parseInt(entity.dataset.lane);
                    if (entityLane === playerLane && y > stage.offsetHeight - 120 && y < stage.offsetHeight - 60) {
                        // Colisi√≥n!
                        const isGood = entity.dataset.good === 'true';
                        if (isGood) {
                            score += 10;
                            // Efecto visual positivo
                            entity.style.background = '#1bb37a';
                            entity.innerHTML = '‚ú®';
                        } else {
                            // Game over
                            gameOver();
                            return;
                        }
                        
                        // Remover entidad
                        entity.remove();
                        entities.splice(i, 1);
                        updateUI();
                    }
                    // Remover si sale de pantalla
                    else if (y > stage.offsetHeight + 60) {
                        entity.remove();
                        entities.splice(i, 1);
                    }
                }
            }
            
            function startGameLoop() {
                gameLoop = setInterval(() => {
                    if (!gameActive) return;
                    
                    updateEntities();
                    
                    // Spawn nuevas entidades
                    spawnTimer++;
                    if (spawnTimer >= 30) { // Cada ~500ms
                        spawnEntity();
                        spawnTimer = 0;
                    }
                }, 16); // ~60fps
            }
            
            function startTimer() {
                const timer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(timer);
                        return;
                    }
                    
                    timeLeft--;
                    updateUI();
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        gameOver();
                    }
                }, 1000);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameLoop) clearInterval(gameLoop);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('carril-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 3);  // M√°s burbujas
                const stars = Math.floor(score / 8);    // M√°s estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`üê¨ ¬°Fin de partida!\\nüåä Puntuaci√≥n: ${score}\\nüèÜ R√©cord: ${best}\\nü´ß +${bubbles} burbujas\\n‚≠ê +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('carril-time').textContent = timeLeft;
                document.getElementById('carril-score').textContent = score;
                document.getElementById('carril-best').textContent = best;
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.carril-close-btn');
            console.log('üê¨ Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                    console.log('üê¨ Juego Carril del Delf√≠n cerrado');
                });
            } else {
                console.error('üê¨ ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#carril-start');
            console.log('üê¨ Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCarrilGame();
                });
            } else {
                console.error('üê¨ ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            // Controles de movimiento
            gameOverlay.querySelectorAll('.carril-move-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const lane = parseInt(btn.dataset.lane);
                    movePlayer(lane);
                });
            });
            
            // Controles de teclado
            document.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer(Math.max(0, playerLane - 1));
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer(Math.min(2, playerLane + 1));
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer(1); // Centro
                        break;
                }
            });
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üê¨ Juego Carril del Delf√≠n iniciado');
            console.log('üê¨ Overlay visible:', gameOverlay.style.display);
            console.log('üê¨ Overlay en DOM:', document.body.contains(gameOverlay));
            console.log('üê¨ Overlay z-index:', gameOverlay.style.zIndex);
        }
        
        // üêâ JUEGO DEL DRAG√ìN MARINO - INTEGRADO B√ÅSICO
        function startCorrerGame() {
            console.log('üêâ Iniciando juego Drag√≥n Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'correrGameOverlay';
            gameOverlay.innerHTML = `
                <div class="correr-game-container">
                    <div class="correr-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üêâ Drag√≥n Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="correr-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: ESTAD√çSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="correr-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">R√©cord:</span>
                                    <span class="best-value" id="correr-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="correr-stage">
                        <canvas id="correr-canvas" width="400" height="300"></canvas>
                        <div class="correr-hint">Toca o pulsa ESPACIO para saltar</div>
                    </div>
                    <div class="correr-footer">
                        <button class="correr-btn" id="correr-jump">‚¨ÜÔ∏è Saltar</button>
                        <button class="correr-btn" id="correr-start">‚ñ∂Ô∏è Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'correr');
            
            const stage = gameOverlay.querySelector('.correr-stage');
            stage.style.cssText = `
                flex: 1; position: relative; background: linear-gradient(#083457, #0b4e7b);
                border-radius: 14px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.15);
                margin: 10px; display: flex; align-items: center; justify-content: center;
            `;
            
            const canvas = gameOverlay.querySelector('#correr-canvas');
            canvas.style.cssText = `
                border-radius: 10px; background: linear-gradient(#083457, #0b4e7b);
                max-width: 100%; max-height: 100%;
            `;
            
            const hint = gameOverlay.querySelector('.correr-hint');
            hint.style.cssText = `
                position: absolute; bottom: 8px; left: 0; right: 0; text-align: center;
                opacity: 0.7; font-size: 14px;
            `;
            
            // Variables del juego
            let gameActive = false, score = 0, best = 0;
            let player = { x: 50, y: 200, vy: 0, grounded: true, size: 30 };
            let obstacles = [], gameSpeed = 2, spawnTimer = 0;
            let gameLoop = null, ctx = canvas.getContext('2d');
            
            // Cargar r√©cord
            const savedBest = localStorage.getItem('correr-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCorrerGame() {
                gameActive = true;
                score = 0;
                gameSpeed = 2;
                spawnTimer = 0;
                obstacles = [];
                player = { x: 50, y: 200, vy: 0, grounded: true, size: 30 };
                updateUI();
                startGameLoop();
            }
            
            function jump() {
                if (gameActive && player.grounded) {
                    player.vy = -12;
                    player.grounded = false;
                }
            }
            
            function updateGame() {
                if (!gameActive) return;
                
                // F√≠sica del jugador
                player.vy += 0.6; // Gravedad
                player.y += player.vy;
                
                // Suelo
                if (player.y >= 200) {
                    player.y = 200;
                    player.vy = 0;
                    player.grounded = true;
                }
                
                // Spawn obst√°culos
                spawnTimer++;
                if (spawnTimer >= 120) { // Cada ~2 segundos
                    obstacles.push({
                        x: canvas.width,
                        y: 200,
                        width: 20,
                        height: 40,
                        passed: false
                    });
                    spawnTimer = 0;
                }
                
                // Actualizar obst√°culos
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    obs.x -= gameSpeed;
                    
                    // Colisi√≥n
                    if (obs.x < player.x + player.size && 
                        obs.x + obs.width > player.x &&
                        obs.y < player.y + player.size && 
                        obs.y + obs.height > player.y) {
                        gameOver();
                        return;
                    }
                    
                    // Puntuaci√≥n
                    if (!obs.passed && obs.x + obs.width < player.x) {
                        obs.passed = true;
                        score += 10;
                        updateUI();
                    }
                    
                    // Remover si sale de pantalla
                    if (obs.x + obs.width < 0) {
                        obstacles.splice(i, 1);
                    }
                }
                
                // Aumentar velocidad gradualmente
                gameSpeed += 0.001;
            }
            
            function drawGame() {
                // Limpiar canvas
                ctx.fillStyle = '#083457';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar suelo
                ctx.fillStyle = '#0d4670';
                ctx.fillRect(0, 230, canvas.width, 70);
                
                // Dibujar jugador (drag√≥n)
                ctx.fillStyle = '#5bd0ff';
                ctx.fillRect(player.x, player.y, player.size, player.size);
                ctx.fillStyle = '#072a44';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üêâ', player.x + player.size/2, player.y + player.size/2 + 7);
                
                // Dibujar obst√°culos
                ctx.fillStyle = '#ff7a6e';
                obstacles.forEach(obs => {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.fillStyle = '#072a44';
                    ctx.fillText('ü™®', obs.x + obs.width/2, obs.y + obs.height/2 + 7);
                    ctx.fillStyle = '#ff7a6e';
                });
            }
            
            function startGameLoop() {
                gameLoop = setInterval(() => {
                    updateGame();
                    drawGame();
                }, 16); // ~60fps
            }
            
            function gameOver() {
                gameActive = false;
                if (gameLoop) clearInterval(gameLoop);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('correr-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 6);  // M√°s burbujas
                const stars = Math.floor(score / 12);   // M√°s estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`üêâ ¬°Fin de partida!\\nüåä Puntuaci√≥n: ${score}\\nüèÜ R√©cord: ${best}\\nü´ß +${bubbles} burbujas\\n‚≠ê +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('correr-score').textContent = score;
                document.getElementById('correr-best').textContent = best;
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.correr-close-btn');
            console.log('üêâ Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                    console.log('üêâ Juego Drag√≥n Marino cerrado');
                });
            } else {
                console.error('üêâ ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#correr-start');
            console.log('üêâ Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCorrerGame();
                });
            } else {
                console.error('üêâ ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            const jumpBtn = gameOverlay.querySelector('#correr-jump');
            console.log('üêâ Bot√≥n SALTAR encontrado:', jumpBtn);
            if (jumpBtn) {
                jumpBtn.addEventListener('click', jump);
            } else {
                console.error('üêâ ERROR: No se encontr√≥ el bot√≥n SALTAR');
            }
            
            // Controles de teclado
            const keyHandler = (e) => {
                if (!gameActive) return;
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    jump();
                }
            };
            document.addEventListener('keydown', keyHandler);
            
            // Canvas click para saltar
            canvas.addEventListener('click', jump);
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    document.removeEventListener('keydown', keyHandler);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üêâ Juego Drag√≥n Marino iniciado');
        }
        
        // üéØ JUEGO DE CAZA DE PECES - INTEGRADO COMPLETO
        function startCazaGame() {
            console.log('üéØ Iniciando juego Caza de Peces integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'cazaGameOverlay';
            gameOverlay.innerHTML = `
                <div class="caza-game-container">
                    <div class="caza-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üéØ Caza de Peces</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="caza-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: ESTAD√çSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="caza-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Ronda:</span>
                                    <span class="best-value" id="caza-round">1</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">R√©cord:</span>
                                    <span class="best-value" id="caza-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="caza-game-area">
                        <div class="caza-timebar">
                            <div class="caza-fill" id="caza-fill"></div>
                            <div class="caza-tick" id="caza-tick">100%</div>
                        </div>
                        <div class="caza-main">
                            <div class="caza-objective">
                                Objetivo: <span class="caza-token" id="caza-obj-token">
                                    <span id="caza-obj-emoji">üêü</span>
                                </span>
                            </div>
                            <div class="caza-board" id="caza-board"></div>
                        </div>
                    </div>
                    <div class="caza-footer">
                        <button class="caza-btn" id="caza-start">‚ñ∂Ô∏è Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'caza');
            
            const gameArea = gameOverlay.querySelector('.caza-game-area');
            gameArea.style.cssText = `
                flex: 1; display: flex; gap: 10px; padding: 10px;
            `;
            
            const timebar = gameOverlay.querySelector('.caza-timebar');
            timebar.style.cssText = `
                width: 32px; background: #0a2f4f; border-radius: 8px; overflow: hidden;
                position: relative; border: 1px solid rgba(255, 255, 255, 0.18);
            `;
            
            const fill = gameOverlay.querySelector('.caza-fill');
            fill.style.cssText = `
                position: absolute; bottom: 0; left: 0; right: 0; height: 100%;
                background: linear-gradient(#25c3ea, #0ea5c6); transition: height 0.18s ease;
            `;
            
            const main = gameOverlay.querySelector('.caza-main');
            main.style.cssText = `
                flex: 1; display: flex; flex-direction: column; gap: 10px;
            `;
            
            const objective = gameOverlay.querySelector('.caza-objective');
            objective.style.cssText = `
                display: flex; align-items: center; gap: 8px; padding: 8px;
                background: rgba(255, 255, 255, 0.06); border-radius: 12px; font-weight: 800;
            `;
            
            const objToken = gameOverlay.querySelector('.caza-token');
            objToken.style.cssText = `
                width: 32px; height: 32px; border-radius: 50%; display: flex;
                align-items: center; justify-content: center; font-size: 20px;
                background: #e9d8a6;
            `;
            
            const board = gameOverlay.querySelector('.caza-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(6, 1fr); gap: 4px; background: transparent;
            `;
            
            // Variables del juego
            const EMOJIS = ["üêü", "‚≠ê", "üêô", "ü™∏", "ü¶Ä"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, round = 1, best = 0;
            let timeLeft = 100, currentTarget = 0, gameTimer = null;
            
            // Cargar r√©cord
            const savedBest = localStorage.getItem('caza-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCazaGame() {
                gameActive = true;
                score = 0;
                round = 1;
                timeLeft = 100;
                currentTarget = Math.floor(Math.random() * EMOJIS.length);
                updateUI();
                createBoard();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                
                // Crear 36 celdas (6x6)
                for (let i = 0; i < 36; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'caza-cell';
                    
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    cell.innerHTML = `
                        <div class="caza-token" data-type="${tokenType}">
                            ${EMOJIS[tokenType]}
                        </div>
                    `;
                    
                    cell.style.cssText = `
                        position: relative; display: flex; align-items: center; justify-content: center;
                        cursor: pointer; aspect-ratio: 1; background: transparent;
                    `;
                    
                    const token = cell.querySelector('.caza-token');
                    token.style.cssText = `
                        width: 100%; height: 100%; border-radius: 50%; display: flex;
                        align-items: center; justify-content: center; font-size: 20px;
                        background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    `;
                    
                    cell.addEventListener('click', () => handleClick(tokenType, token));
                    board.appendChild(cell);
                }
                
                // Asegurar que hay al menos 3 del tipo objetivo
                const targetCells = board.querySelectorAll(`[data-type="${currentTarget}"]`);
                if (targetCells.length < 3) {
                    for (let i = 0; i < 3; i++) {
                        const randomCell = board.children[Math.floor(Math.random() * 36)];
                        const token = randomCell.querySelector('.caza-token');
                        token.dataset.type = currentTarget;
                        token.innerHTML = EMOJIS[currentTarget];
                        token.style.background = COLORS[currentTarget];
                    }
                }
            }
            
            function handleClick(tokenType, tokenElement) {
                if (!gameActive) return;
                
                if (tokenType === currentTarget) {
                    // Correcto!
                    score += 10;
                    tokenElement.style.boxShadow = '0 0 12px rgba(27, 179, 122, 0.6)';
                    tokenElement.style.transform = 'scale(0.8)';
                    tokenElement.style.opacity = '0.3';
                    
                    // Verificar si quedan m√°s objetivos
                    setTimeout(() => {
                        const remaining = board.querySelectorAll(`[data-type="${currentTarget}"]`).length - 1;
                        if (remaining <= 0) {
                            nextRound();
                        }
                    }, 100);
                    
                } else {
                    // Incorrecto
                    tokenElement.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    tokenElement.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        tokenElement.style.transform = 'scale(1)';
                        tokenElement.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                    }, 200);
                    
                    // Penalizar tiempo
                    timeLeft -= 5;
                    if (timeLeft <= 0) {
                        gameOver();
                    }
                }
                
                updateUI();
            }
            
            function nextRound() {
                round++;
                currentTarget = Math.floor(Math.random() * EMOJIS.length);
                timeLeft = Math.min(100, timeLeft + 15); // Bonus tiempo
                createBoard();
                updateUI();
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    timeLeft -= 0.5;
                    if (timeLeft <= 0) {
                        gameOver();
                    }
                    updateUI();
                }, 50); // Actualizaci√≥n suave
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('caza-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 5);  // M√°s burbujas
                const stars = Math.floor(score / 10);   // M√°s estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`üéØ ¬°Fin de caza!\\nüåä Puntuaci√≥n: ${score}\\nüèÜ R√©cord: ${best}\\nü´ß +${bubbles} burbujas\\n‚≠ê +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('caza-score').textContent = score;
                document.getElementById('caza-round').textContent = round;
                document.getElementById('caza-best').textContent = best;
                document.getElementById('caza-obj-emoji').textContent = EMOJIS[currentTarget];
                document.getElementById('caza-obj-token').style.background = COLORS[currentTarget];
                document.getElementById('caza-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('caza-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.caza-close-btn');
            console.log('üéØ Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('üéØ Juego Caza de Peces cerrado');
                });
            } else {
                console.error('üéØ ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#caza-start');
            console.log('üéØ Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCazaGame();
                });
            } else {
                console.error('üéØ ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üéØ Juego Caza de Peces iniciado');
        }
        
        // üåä JUEGO DE SECUENCIA DE MAREAS - INTEGRADO COMPLETO
        function startSecuenciaGame() {
            console.log('üåä Iniciando juego Secuencia de Mareas integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'secuenciaGameOverlay';
            gameOverlay.innerHTML = `
                <div class="secuencia-game-container">
                    <div class="secuencia-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üåä Secuencia de Mareas</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="secuencia-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: ESTAD√çSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Ronda:</span>
                                    <span class="best-value" id="secuencia-round">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="secuencia-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">R√©cord:</span>
                                    <span class="best-value" id="secuencia-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="secuencia-game-area">
                        <div class="secuencia-timebar">
                            <div class="secuencia-fill" id="secuencia-fill"></div>
                            <div class="secuencia-tick" id="secuencia-tick">100%</div>
                        </div>
                        <div class="secuencia-main">
                            <div class="secuencia-hint" id="secuencia-hint">Mira la secuencia...</div>
                            <div class="secuencia-board" id="secuencia-board"></div>
                        </div>
                    </div>
                    <div class="secuencia-footer">
                        <button class="secuencia-btn" id="secuencia-start">‚ñ∂Ô∏è Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'secuencia');
            
            const gameArea = gameOverlay.querySelector('.secuencia-game-area');
            gameArea.style.cssText = `flex: 1; display: flex; gap: 10px; padding: 10px;`;
            
            const board = gameOverlay.querySelector('.secuencia-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(4, 1fr); gap: 6px; background: transparent;
            `;
            
            // Variables del juego - versi√≥n simplificada
            const EMOJIS = ["üêü", "‚≠ê", "üêô", "ü™∏", "ü¶Ä"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, round = 0, best = 0;
            let sequence = [], playerInput = [], timeLeft = 100;
            let showingSequence = false, gameTimer = null;
            
            // Cargar r√©cord
            const savedBest = localStorage.getItem('secuencia-best');
            if (savedBest) best = parseInt(savedBest);
            
            function initSecuenciaGame() {
                gameActive = true;
                score = 0;
                round = 0;
                timeLeft = 100;
                sequence = [];
                playerInput = [];
                showingSequence = false;
                updateUI();
                createBoard();
                nextRound();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    cell.innerHTML = `<div class="secuencia-token" data-type="${tokenType}" data-index="${i}">${EMOJIS[tokenType]}</div>`;
                    cell.style.cssText = `
                        display: flex; align-items: center; justify-content: center; cursor: pointer;
                        aspect-ratio: 1; background: transparent;
                    `;
                    const token = cell.querySelector('.secuencia-token');
                    token.style.cssText = `
                        width: 100%; height: 100%; border-radius: 50%; display: flex;
                        align-items: center; justify-content: center; font-size: 24px;
                        background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    `;
                    cell.addEventListener('click', () => handleTokenClick(i));
                    board.appendChild(cell);
                }
            }
            
            function nextRound() {
                round++;
                const randomIndex = Math.floor(Math.random() * 16);
                sequence.push(randomIndex);
                playerInput = [];
                document.getElementById('secuencia-hint').textContent = 'Mira la secuencia...';
                showSequence();
            }
            
            function showSequence() {
                showingSequence = true;
                let i = 0;
                const showNext = () => {
                    if (i < sequence.length) {
                        const token = board.children[sequence[i]].querySelector('.secuencia-token');
                        token.style.boxShadow = '0 0 20px rgba(255,255,255,0.8)';
                        token.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            token.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                            token.style.transform = 'scale(1)';
                            i++;
                            setTimeout(showNext, 300);
                        }, 500);
                    } else {
                        showingSequence = false;
                        document.getElementById('secuencia-hint').textContent = '¬°Repite la secuencia!';
                    }
                };
                setTimeout(showNext, 800);
            }
            
            function handleTokenClick(index) {
                if (!gameActive || showingSequence) return;
                
                playerInput.push(index);
                const token = board.children[index].querySelector('.secuencia-token');
                
                // Verificar si es correcto
                const currentStep = playerInput.length - 1;
                if (playerInput[currentStep] === sequence[currentStep]) {
                    // Correcto
                    token.style.boxShadow = '0 0 12px rgba(27, 179, 122, 0.6)';
                    score += 5;
                    
                    if (playerInput.length === sequence.length) {
                        // Secuencia completa
                        setTimeout(() => {
                            nextRound();
                        }, 800);
                    }
                } else {
                    // Error
                    token.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    gameOver();
                }
                
                updateUI();
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    timeLeft -= 0.3;
                    if (timeLeft <= 0) gameOver();
                    updateUI();
                }, 50);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('secuencia-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 4);  // M√°s burbujas
                const stars = Math.floor(score / 8);    // M√°s estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`üåä ¬°Fin de secuencia!\\nüåä Ronda: ${round}\\nüèÜ R√©cord: ${best}\\nü´ß +${bubbles} burbujas\\n‚≠ê +${stars} estrellas`);
                }, 300);
            }
            
            function updateUI() {
                document.getElementById('secuencia-round').textContent = round;
                document.getElementById('secuencia-score').textContent = score;
                document.getElementById('secuencia-best').textContent = best;
                document.getElementById('secuencia-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('secuencia-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.secuencia-close-btn');
            console.log('üåä Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('üåä Juego Secuencia de Mareas cerrado');
                });
            } else {
                console.error('üåä ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#secuencia-start');
            console.log('üåä Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initSecuenciaGame();
                });
            } else {
                console.error('üåä ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üåä Juego Secuencia de Mareas iniciado');
        }
        
        // üèñÔ∏è JUEGO DE TOCA-3 MARINO - INTEGRADO COMPLETO
        function startToca3Game() {
            console.log('üèñÔ∏è Iniciando juego Toca-3 Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'toca3GameOverlay';
            gameOverlay.innerHTML = `
                <div class="toca3-game-container">
                    <div class="toca3-game-header">
                        <!-- PRIMERA L√çNEA: T√çTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">üèñÔ∏è Toca-3 Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="toca3-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">‚úï</button>
                            </div>
                        </div>
                        <!-- SEGUNDA L√çNEA: ESTAD√çSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="toca3-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">R√©cord:</span>
                                    <span class="best-value" id="toca3-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="toca3-game-area">
                        <div class="toca3-timebar">
                            <div class="toca3-fill" id="toca3-fill"></div>
                            <div class="toca3-tick" id="toca3-tick">100%</div>
                        </div>
                        <div class="toca3-main">
                            <div class="toca3-board" id="toca3-board"></div>
                        </div>
                    </div>
                    <div class="toca3-footer">
                        <button class="toca3-btn" id="toca3-start">‚ñ∂Ô∏è Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar dise√±o perfecto unificado (igual que Burbujas)
            applyPerfectBubbleDesign(gameOverlay, 'toca3');
            
            const board = gameOverlay.querySelector('.toca3-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(8, 1fr); gap: 4px; background: transparent; padding: 10px;
            `;
            
            // Variables del juego - versi√≥n simplificada de match-3
            const EMOJIS = ["üêü", "‚≠ê", "üêô", "ü™∏", "ü¶Ä"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, best = 0, timeLeft = 100;
            let grid = [], selectedCells = [], gameTimer = null;
            
            // Cargar r√©cord
            const savedBest = localStorage.getItem('toca3-best');
            if (savedBest) best = parseInt(savedBest);
            
            function initToca3Game() {
                gameActive = true;
                score = 0;
                timeLeft = 100;
                selectedCells = [];
                grid = [];
                updateUI();
                createBoard();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                grid = [];
                
                // Crear tablero 6x8
                for (let r = 0; r < 8; r++) {
                    grid[r] = [];
                    for (let c = 0; c < 6; c++) {
                        const tokenType = Math.floor(Math.random() * EMOJIS.length);
                        const cell = document.createElement('div');
                        cell.innerHTML = `<div class="toca3-token" data-type="${tokenType}" data-r="${r}" data-c="${c}">${EMOJIS[tokenType]}</div>`;
                        cell.style.cssText = `
                            display: flex; align-items: center; justify-content: center; cursor: pointer;
                            aspect-ratio: 1; background: transparent;
                        `;
                        const token = cell.querySelector('.toca3-token');
                        token.style.cssText = `
                            width: 100%; height: 100%; border-radius: 50%; display: flex;
                            align-items: center; justify-content: center; font-size: 18px;
                            background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                        
                        cell.addEventListener('click', () => handleCellClick(r, c, tokenType, token));
                        board.appendChild(cell);
                        grid[r][c] = { type: tokenType, element: token };
                    }
                }
            }
            
            function handleCellClick(r, c, type, token) {
                if (!gameActive) return;
                
                const cellKey = `${r}-${c}`;
                const index = selectedCells.findIndex(cell => cell.key === cellKey);
                
                if (index >= 0) {
                    // Deseleccionar
                    selectedCells.splice(index, 1);
                    token.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                    token.style.transform = 'scale(1)';
                } else if (selectedCells.length < 3) {
                    // Seleccionar
                    selectedCells.push({ key: cellKey, r, c, type, token });
                    token.style.boxShadow = '0 0 12px rgba(255,255,255,0.6)';
                    token.style.transform = 'scale(1.1)';
                    
                    if (selectedCells.length === 3) {
                        checkMatch();
                    }
                }
            }
            
            function checkMatch() {
                const types = selectedCells.map(cell => cell.type);
                const allSame = types.every(type => type === types[0]);
                
                if (allSame) {
                    // Match correcto!
                    score += 15;
                    selectedCells.forEach(cell => {
                        cell.token.style.background = '#1bb37a';
                        cell.token.innerHTML = '‚ú®';
                        cell.token.style.transform = 'scale(0.8)';
                        cell.token.style.opacity = '0.7';
                    });
                    
                    setTimeout(() => {
                        // Remover tokens matched y hacer caer los de arriba
                        selectedCells.forEach(cell => {
                            fillFromTop(cell.c);
                        });
                        selectedCells = [];
                        timeLeft += 5; // Bonus tiempo
                    }, 500);
                    
                } else {
                    // No match
                    selectedCells.forEach(cell => {
                        cell.token.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    });
                    
                    setTimeout(() => {
                        selectedCells.forEach(cell => {
                            cell.token.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            cell.token.style.transform = 'scale(1)';
                        });
                        selectedCells = [];
                    }, 400);
                    
                    timeLeft -= 3; // Penalizaci√≥n
                }
                
                updateUI();
            }
            
            function fillFromTop(col) {
                // Simplificado: regenerar columna
                for (let r = 0; r < 8; r++) {
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    const cell = board.children[r * 6 + col];
                    const token = cell.querySelector('.toca3-token');
                    token.innerHTML = EMOJIS[tokenType];
                    token.style.background = COLORS[tokenType];
                    token.dataset.type = tokenType;
                    grid[r][col] = { type: tokenType, element: token };
                }
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    timeLeft -= 0.2;
                    if (timeLeft <= 0) gameOver();
                    updateUI();
                }, 50);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('toca3-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 5);  // M√°s burbujas
                const stars = Math.floor(score / 10);   // M√°s estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // üéÜ ANIMACI√ìN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`üèñÔ∏è ¬°Fin del juego!\\nüåä Puntuaci√≥n: ${score}\\nüèÜ R√©cord: ${best}\\nü´ß +${bubbles} burbujas\\n‚≠ê +${stars} estrellas`);
                }, 300);
            }
            
            function updateUI() {
                document.getElementById('toca3-score').textContent = score;
                document.getElementById('toca3-best').textContent = best;
                document.getElementById('toca3-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('toca3-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.toca3-close-btn');
            console.log('üèñÔ∏è Bot√≥n cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('üèñÔ∏è Juego Toca-3 Marino cerrado');
                });
            } else {
                console.error('üèñÔ∏è ERROR: No se encontr√≥ el bot√≥n de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#toca3-start');
            console.log('üèñÔ∏è Bot√≥n JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initToca3Game();
                });
            } else {
                console.error('üèñÔ∏è ERROR: No se encontr√≥ el bot√≥n JUGAR');
            }
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('üèñÔ∏è Juego Toca-3 Marino iniciado');
        }
        
        // üé® FUNCI√ìN AUXILIAR PARA APLICAR ESTILOS A IFRAMES DE JUEGOS
        function applyGameIframeStyles(gameModal) {
            gameModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, 
                    rgba(25, 30, 40, 0.9) 0%, 
                    rgba(15, 20, 30, 0.95) 100%);
                backdrop-filter: blur(15px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.3s ease;
            `;
            
            const container = gameModal.querySelector('.game-iframe-container');
            container.style.cssText = `
                background: rgba(35, 40, 50, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                width: 95vw;
                height: 95vh;
                max-width: 800px;
                max-height: 700px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            `;
            
            const header = gameModal.querySelector('.game-iframe-header');
            header.style.cssText = `
                background: rgba(79, 195, 247, 0.2);
                padding: 15px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            `;
            
            const title = header.querySelector('h2');
            title.style.cssText = `
                color: white;
                margin: 0;
                font-size: 20px;
                font-weight: 800;
            `;
            
            const closeBtn = gameModal.querySelector('.game-close-btn');
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                color: white;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            `;
            
            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                closeBtn.style.transform = 'scale(1.1)';
            });
            
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                closeBtn.style.transform = 'scale(1)';
            });
            
            const iframe = gameModal.querySelector('.game-iframe');
            iframe.style.cssText = `
                flex: 1;
                border: none;
                width: 100%;
                background: white;
            `;
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                gameModal.remove();
            });
            
            gameModal.addEventListener('click', (e) => {
                if (e.target === gameModal) {
                    gameModal.remove();
                }
            });
        }
    </script>
</body>
</html>



<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>🐠 Mi Pececito - Tamagotchi Virtual</title>
    
    <!-- 🔤 Google Fonts - Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- 🎨 CSS INTEGRADO PARA EVITAR PROBLEMAS DE CARGA -->
    
    <style>
        /* 🎨 VARIABLES CSS GLOBALES */
        :root {
          --bg-primary: #08243a;
          --bg-secondary: #1d4b6b;
          --bg-accent: #2a6287;
          --text-primary: #e9f6ff;
          --text-secondary: rgba(233, 246, 255, 0.8);
          --fish-baby-body: #d9ccff;
          --fish-baby-tail: #ff9ecf;
          --fish-baby-fin: #ffd0e2;
          --fish-baby-stripe: #ffba7a;
          --fish-young-body: #b1a1ff;
          --fish-young-tail: #f191cd;
          --fish-young-fin: #f1c4e4;
          --fish-young-stripe: #ffa960;
          --fish-adult-body: #5a48c8;
          --fish-adult-tail: #d073c6;
          --fish-adult-fin: #e2a8d6;
          --fish-adult-stripe: #ff9745;
          --button-primary: #205b86;
          --button-hover: #2a6287;
          --button-active: #1a4a73;
          --button-radius: 12px;
          --button-size: 80px;
          --badge-size: 64px;
          --bubble-size: 48px;
          --good-item: #4CAF50;
          --bad-item: #F44336;
          --star-color: #FFD700;
          --coin-color: #FF8C42;
          --fish-baby-size: 46px;
          --fish-young-size: 52px;
          --fish-adult-size: 60px;
            --egg-size: 130px; /* Tamaño ajustado para móvil */
          --pellet-size: 16px;
          --star-size: 32px;
          --transition-fast: 0.15s ease;
          --transition-smooth: 0.3s ease;
          --transition-slow: 0.6s ease;
          --bounce-animation: cubic-bezier(0.68, -0.55, 0.265, 1.55);
          --mobile-padding: 12px;
          --desktop-padding: 20px;
          --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.25);
          --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.4);
          --blur-light: blur(4px);
          --blur-strong: blur(10px);
          --rank-bronze: #CD7F32;
          --rank-silver: #C0C0C0;
          --rank-gold: #FFD700;
          --rank-diamond: #B9F2FF;
        }


        /* 🔘 COMPONENTES UNIVERSALES */
        .universal-btn {
          width: var(--button-size);
          height: var(--button-size);
          background: var(--button-primary);
          color: var(--text-primary);
          border: none;
          border-radius: var(--button-radius);
          box-shadow: var(--shadow-soft);
          transition: all var(--transition-fast);
          cursor: pointer;
          font-weight: 600;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
          font-size: 14px;
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }

        .universal-btn:hover {
          background: var(--button-hover);
          transform: translateY(-2px);
          box-shadow: var(--shadow-strong);
        }

        .universal-btn:active {
          background: var(--button-active);
          transform: translateY(0);
          box-shadow: var(--shadow-soft);
        }

        .fade-in {
          animation: fadeIn var(--transition-smooth) ease;
        }

        .bounce-in {
          animation: bounceIn 0.5s var(--bounce-animation);
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes bounceIn {
          0% { transform: scale(0.3); opacity: 0; }
          50% { transform: scale(1.05); }
          70% { transform: scale(0.9); }
          100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }

        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-6px); }
        }
        /* 📱 Estilos base móvil-first */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            font-family: 'Poppins', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
            padding: 0;
            box-sizing: border-box;
        }
        
        
        /* 🏆 CABECERA DEL JUEGO */
        #gameHeader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 15px 10px 15px;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(13, 71, 161, 0.4);
            z-index: 1000;
            border-bottom: 3px solid #0d47a1;
            backdrop-filter: blur(10px);
        }
        
        .fish-info-expanded {
            flex: 1;
            text-align: center;
            color: #fff;
            padding: 0 20px;
        }
        
        #fishAge {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        
        #fishName {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: linear-gradient(45deg, #26c6da, #4fc3f7);
            border: 3px solid #81d4fa;
            color: white;
            padding: 8px;
            border-radius: 50%;
            font-size: 18px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(38, 198, 218, 0.3);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(38, 198, 218, 0.4);
            border-color: #4fc3f7;
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .action-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* 🎒 MODAL DE INVENTARIO */
        #inventoryModal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 600px;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255,255,255,0.3);
        }
        
        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(255, 82, 82, 0.3);
        }
        
        .close-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(255, 82, 82, 0.4);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
        }
        
        .tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            padding: 15px 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 4px solid transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .tab-btn.active {
            color: white;
            border-bottom-color: white;
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-1px);
            border-radius: 8px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .item-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .item-card:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4fc3f7;
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .item-card.selected {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .item-preview {
            width: 80px;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin: 0 auto 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .item-name {
            color: #fff;
            font-size: 10px;
            font-weight: bold;
        }
        
        .item-cost {
            color: #4fc3f7;
            font-size: 9px;
            margin-top: 2px;
        }
        
        .coming-soon {
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-style: italic;
            padding: 40px 20px;
        }
        
        .locked-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        /* 🎨 MODALES BONITOS */
        @keyframes modalPop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes bubbleFloat {
            from {
                top: 100%;
                opacity: 0.8;
            }
            to {
                top: -10%;
                opacity: 0;
            }
        }
        
        /* 🎮 MODALES DE JUEGO MEJORADAS */
        .game-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-modal-overlay[style*="block"] {
            opacity: 1;
        }
        
        .game-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 650px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.4s ease-out;
            position: relative;
        }
        
        .games-modal {
            max-width: 700px;
        }
        
        .game-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .game-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 82, 82, 0.3);
        }
        
        .game-close-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 15px rgba(255, 82, 82, 0.5);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            padding: 16px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 4px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .game-tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-2px);
            border-radius: 8px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-tab-btn.active {
            color: white;
            border-bottom-color: #ffffff;
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .tab-text {
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-modal-body {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-tab-content {
            display: none;
        }
        
        .game-tab-content.active {
            display: block;
            animation: fadeInUp 0.3s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .game-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        
        .game-item-card {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-item-card:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-item-card.available {
            border-color: #4caf50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .game-item-card.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-item-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 12px;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }
        
        .game-item-info {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .game-item-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-reward {
            color: #4caf50;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-unlock {
            color: #ff9800;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-play-btn {
            width: 100%;
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 12px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .game-play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 18px rgba(76, 175, 80, 0.4);
            background: linear-gradient(45deg, #66bb6a, #4caf50);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-play-btn:active {
            transform: scale(0.98);
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        
        .game-locked-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
        }
        
        .lock-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        .lock-text {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .coming-soon-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .coming-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .coming-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .coming-desc {
            font-size: 14px;
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* 📱 MODALES MÓVILES SIMPLES */
        .mobile-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .mobile-modal-overlay[style*="flex"] {
            opacity: 1;
        }
        
        .mobile-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 3px solid #ffffff;
            border-radius: 20px;
            width: 95%;
            max-width: 400px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }
        
        .mobile-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .inventory-grid-simple {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar {
            width: 8px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .inventory-grid-simple::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .mobile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mobile-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .mobile-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .mobile-close-btn:active {
            transform: scale(0.95);
        }
        
        .header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .mobile-help-btn {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid rgba(255, 193, 7, 0.5);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-help-btn:hover {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.1);
            border-radius: 50%; /* Mantener esquinas redondeadas en hover */
        }
        
        .mobile-help-btn:active {
            transform: scale(0.95);
        }
        
        /* 🎮 GRID DE JUEGOS 3x3 */
        .games-grid-3x3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-card-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .game-card-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
            border-radius: 10px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card-square:active {
            transform: scale(0.98);
        }
        
        .game-card-square.available {
            border-color: #4caf50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .game-card-square.available:hover {
            border-color: #66bb6a;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            border-radius: 10px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .game-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .game-card-square.locked .game-lock-overlay {
            opacity: 1;
        }
        
        .lock-icon-small {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .lock-stars {
            color: #ffa726;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* 🎒 INVENTARIO SIMPLE */
        .inventory-grid-simple {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .inventory-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .inventory-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .inventory-section-header h3 {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        
        .inventory-section-subtitle {
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
        }
        
        .inventory-section-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
        }
        
        .inventory-item-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .inventory-item-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-item-square:active {
            transform: scale(0.98);
        }
        
        .inventory-item-square.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .selected-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .inventory-item-square.available {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }
        
        .inventory-item-square.owned {
            border-color: #4CAF50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .inventory-square-price {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 500;
            margin-top: 2px;
        }
        
        .owned-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .inventory-item-square.available:hover {
            border-color: #42a5f5;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .inventory-item-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .inventory-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .inventory-square-preview {
            width: 60px;
            height: 45px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin-bottom: 6px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .inventory-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .inventory-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .inventory-item-square.locked .inventory-lock-overlay {
            opacity: 1;
        }
        
        /* 📱 RESPONSIVE PARA MODALES MÓVILES */
        @media (max-width: 480px) {
            .mobile-modal-content {
                width: 98%;
                max-width: 350px;
                border-radius: 16px;
            }
            
            .mobile-modal-header {
                padding: 14px 18px;
            }
            
            .mobile-modal-header h2 {
                font-size: 16px;
            }
            
            .mobile-close-btn {
                width: 36px;
                height: 36px;
                font-size: 20px;
            }
            
            .games-grid-3x3 {
                gap: 10px;
                padding: 16px;
            }
            
            .game-card-square {
                border-radius: 10px;
            }
            
            .game-square-icon {
                font-size: 28px;
                margin-bottom: 4px;
            }
            
            .game-square-name {
                font-size: 10px;
            }
            
            .lock-icon-small {
                font-size: 18px;
            }
            
            .lock-stars {
                font-size: 9px;
            }
        }
        
        @media (max-width: 360px) {
            .games-grid-3x3 {
                gap: 8px;
                padding: 14px;
            }
            
            .game-square-icon {
                font-size: 24px;
            }
            
            .game-square-name {
                font-size: 9px;
            }
        }
        
        /* 📊 BARRAS DE NECESIDADES */
        .needs-bars {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .need-bar {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-icon {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        
        .bar-container {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .bar-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .bar-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .bar-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* 📊 BARRA DE NECESIDADES COMPACTA DEBAJO DE CABECERA */
        .needs-header-bar {
            background: linear-gradient(135deg, rgba(100, 150, 200, 0.8), rgba(130, 180, 230, 0.8)) !important;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 15px;
            display: none; /* OCULTA POR DEFECTO - SOLO VISIBLE CON PEZ */
            justify-content: center;
            align-items: center;
            gap: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 999;
            position: fixed;
            top: 100px;
            left: 0;
            right: 0;
            height: 0; /* ALTURA 0 CUANDO ESTÁ OCULTA */
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        /* CUANDO SE MUESTRA, TIENE ALTURA */
        .needs-header-bar[style*="flex"] {
            height: 35px !important;
        }
        
        .need-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .need-emoji {
            font-size: 16px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }
        
        .need-bar-mini {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .need-fill-mini {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        
        .need-fill-mini.hunger {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE→NARANJA→ROJO */
        }
        
        .need-fill-mini.dirt {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE→NARANJA→ROJO (como hambre) */
        }
        
        .need-fill-mini.fun {
            background: linear-gradient(90deg, #f44336, #ff9800, #4caf50); /* ROJO→NARANJA→VERDE */
        }
        
        
        /* 📊 BARRAS FLOTANTES COMPACTAS (OCULTAS) */
        .needs-overlay {
            display: none; /* OCULTAR las flotantes */
            position: absolute;
            top: 70px;
            right: 15px;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .need-mini {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-mini span {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .mini-bar {
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .mini-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .mini-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .mini-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .mini-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* 📱 RESPONSIVE PARA MÓVILES */
        @media (max-width: 768px) {
            .game-modal-content {
                width: 98%;
                max-height: 95vh;
                border-radius: 20px;
            }
            
            .game-modal-header {
                padding: 16px 20px;
            }
            
            .game-modal-header h2 {
                font-size: 18px;
            }
            
            .game-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .game-tabs {
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .game-tabs::-webkit-scrollbar {
                display: none;
            }
            
            .game-tab-btn {
                padding: 12px 8px;
                min-width: 80px;
            }
            
            .tab-icon {
                font-size: 18px;
            }
            
            .tab-text {
                font-size: 11px;
            }
            
            .game-modal-body {
                padding: 16px;
                max-height: 400px;
            }
            
            .game-items-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .game-item-card {
                padding: 16px;
            }
            
            .game-item-icon {
                font-size: 40px;
            }
            
            .game-item-name {
                font-size: 16px;
            }
            
            .game-item-description {
                font-size: 13px;
            }
            
            .game-play-btn {
                padding: 10px 14px;
                font-size: 13px;
            }
            
            .coming-soon-card {
                padding: 30px 16px;
            }
            
            .coming-icon {
                font-size: 40px;
            }
            
            .coming-text {
                font-size: 16px;
            }
            
            .coming-desc {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .game-modal-content {
                border-radius: 16px;
            }
            
            .game-modal-header {
                padding: 12px 16px;
            }
            
            .game-modal-header h2 {
                font-size: 16px;
            }
            
            .game-modal-body {
                padding: 12px;
                max-height: 350px;
            }
            
            .game-item-card {
                padding: 12px;
            }
            
            .game-item-icon {
                font-size: 36px;
            }
            
            .tab-icon {
                font-size: 16px;
            }
            
            .tab-text {
                font-size: 10px;
            }
        }
        
        .custom-modal h2 {
            color: white;
            font-size: 18px;
            margin: 0 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .custom-modal p {
            color: white;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .custom-input {
            width: 100%;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 16px;
            text-align: center;
            margin: 10px 0;
            background: rgba(255,255,255,0.9);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .custom-input:focus {
            outline: none;
            border-color: #81d4fa;
            box-shadow: 0 0 10px rgba(129, 212, 250, 0.5);
        }
        
        .custom-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .custom-btn {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .confirm-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            color: white;
        }
        
        .cancel-btn {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
            color: white;
        }
        
        .custom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .custom-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* 🎮 TARJETAS DE JUEGOS */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .game-card {
            background: linear-gradient(135deg, #1e88e5 0%, #2196f3 50%, #42a5f5 100%);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        .game-card.available {
            cursor: pointer;
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: white;
            box-shadow: 0 8px 20px rgba(255,255,255,0.2);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-card.locked {
            filter: grayscale(70%);
            opacity: 0.6;
        }
        
        .game-icon {
            font-size: 40px;
            margin-bottom: 15px;
        }
        
        .game-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .game-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-reward {
            color: #81d4fa;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .game-unlock {
            color: #ffab91;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .play-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(76, 175, 80, 0.4);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* 📸 ÁLBUM/DIARIO */
        .album-modal {
            max-width: 700px;
            max-height: 85%;
        }
        
        .album-header-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .album-action-btn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(79, 195, 247, 0.3);
        }
        
        .album-action-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(79, 195, 247, 0.4);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        .album-content {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .album-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .stat-item span {
            display: block;
            font-size: 16px;
            color: #81d4fa;
            margin-top: 5px;
        }
        
        .album-timeline {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .album-entry {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .album-entry:hover {
            transform: translateY(-2px);
            border-color: white;
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .album-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .album-entry-title {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        .album-entry-date {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .album-entry-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .album-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: rgba(255,255,255,0.6);
        }
        
        .album-entry-age {
            background: rgba(129, 212, 250, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        #gameCanvas {
            position: fixed;
            top: 100px; /* Header (70px) + Barra necesidades (30px) */
            left: 0;
            right: 0;
            bottom: 60px; /* Espacio para barra inferior */
            touch-action: none;
            background: var(--bg-primary);
            z-index: 10;
        }
        
        
        /* 🎮 UI Overlay */
        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        /* 💰 CONTADORES FLOTANTES */
        #currencyOverlay {
            position: absolute;
            top: 85px; /* Más cerca de la cabecera */
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px; /* Más compacto */
        }
        
        .currency-float {
            display: flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(38, 198, 218, 0.95), rgba(79, 195, 247, 0.95));
            border: 2px solid rgba(255,255,255,0.9);
            padding: 4px 6px;
            border-radius: 18px;
            box-shadow: 0 2px 6px rgba(38, 198, 218, 0.4);
            backdrop-filter: blur(6px);
            transition: all 0.3s ease;
            min-width: 55px;
        }
        
        .currency-float:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(38, 198, 218, 0.4);
            border-radius: 18px; /* Mantener esquinas redondeadas en hover */
        }
        
        .currency-float .currency-icon {
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .currency-float span:last-child {
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            min-width: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Animación cuando cambia el valor */
        .currency-float.updated {
            animation: currencyPulse 0.5s ease-out;
        }
        
        @keyframes currencyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 8px 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }
        
        /* 💨 Badge Turbo */
        #turboBadge {
            position: fixed;
            right: var(--mobile-padding);
            top: var(--mobile-padding);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: var(--blur-light);
            font-weight: 700;
            font-size: 14px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
        }
        
        #turboBadge.active {
            opacity: 1;
        }
        
        /* 🎯 Loading Screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity var(--transition-smooth);
            color: white;
            text-align: center;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content h2 {
            margin: 20px 0 10px 0;
            font-size: 24px;
            font-weight: bold;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            animation: logoFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .loading-dots {
            font-size: 30px;
            animation: loadingPulse 1.5s infinite;
        }

        .loading-dots span {
            animation: dotBounce 1.4s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes dotBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-20px); }
        }

        /* 🎆 EFECTOS DE RECOMPENSA */
        .reward-bubble {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(100,200,255,0.6));
            border: 3px solid rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 2000;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(100,200,255,0.6);
            animation: rewardBubbleFloat 2s ease-out forwards;
        }

        @keyframes rewardBubbleFloat {
            0% {
                transform: scale(0.5) translateY(0);
                opacity: 0;
            }
            20% {
                transform: scale(1.2) translateY(-20px);
                opacity: 1;
            }
            50% {
                transform: scale(1) translateY(-60px);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-100px);
                opacity: 0;
            }
        }

        .reward-explosion {
            position: fixed;
            width: 70px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8), transparent);
            z-index: 99999;
            pointer-events: none;
            animation: rewardExplosion 0.8s ease-out forwards;
        }

        @keyframes rewardExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        @keyframes starExplosion {
            0% {
                transform: scale(0) translate(0, 0);
                opacity: 1;
            }
            50% {
                transform: scale(1) translate(var(--random-x, 0), var(--random-y, 0));
                opacity: 0.8;
            }
            100% {
                transform: scale(0.3) translate(calc(var(--random-x, 0) * 2), calc(var(--random-y, 0) * 2));
                opacity: 0;
            }
        }

        @keyframes floatUp {
            0% {
                transform: translateX(-50%) translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translateX(-50%) translateY(-20px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) translateY(-100px) scale(1);
                opacity: 0;
            }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(233, 246, 255, 0.3);
            border-top: 3px solid var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes floatBubble {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            25% {
                transform: translateY(-8px) scale(1.05);
            }
            50% {
                transform: translateY(-3px) scale(0.98);
            }
            75% {
                transform: translateY(-12px) scale(1.02);
            }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.8;
        }
        
        /* 🚨 Error Screen */
        #errorScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: var(--mobile-padding);
            text-align: center;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .error-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .error-message {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 24px;
        }
        
        .retry-button {
            padding: 12px 24px;
            border: none;
            border-radius: var(--button-radius);
            background: var(--button-primary);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        
        .retry-button:hover {
            background: var(--button-hover);
            border-radius: 12px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* 🔧 Barra de Debug (solo en desarrollo) */
        #debugBar {
            position: fixed;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15); /* BLANQUECINO CRISTAL */
            backdrop-filter: blur(10px); /* EFECTO CRISTAL */
            border-radius: 12px;
            padding: 6px 4px;
            display: none;
            flex-direction: column;
            gap: 3px;
            z-index: 1002;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* SOMBRA SUAVE */
            width: 80px; /* Ancho fijo más pequeño */
        }
        
        #debugInfo {
            color: #ccc;
            font-family: 'Poppins', sans-serif;
            font-size: 7px;
            text-align: center;
            margin-bottom: 4px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-btn {
            padding: 4px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            font-size: 16px; /* Solo emoji */
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .debug-btn.danger {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .debug-btn.primary {
            border-color: #4488ff;
            color: #4488ff;
        }
        
        .debug-btn.warning {
            border-color: #ffaa44;
            color: #ffaa44;
        }
        
        .debug-btn.success {
            border-color: #4caf50;
            color: #4caf50;
        }
        
        .debug-btn.info {
            border-color: #00bcd4;
            color: #00bcd4;
        }
        
        .debug-btn.purple {
            border-color: #9c27b0;
            color: #9c27b0;
        }
        
        /* 🎮 BARRA DE HERRAMIENTAS COMPACTA COMO CABECERA */
        .action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 90px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2); /* IGUAL QUE CABECERA */
            box-shadow: 0 -4px 20px rgba(13, 71, 161, 0.4); /* SOMBRA HACIA ARRIBA */
            border-top: 3px solid #0d47a1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10px;
            gap: 8px;
            backdrop-filter: blur(20px);
            border-radius: 0; /* SIN ESQUINAS REDONDEADAS */
            z-index: 40;
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: none; /* SIN BORDES */
        }
        
        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none; /* SIN BORDES OSCUROS */
            border-radius: 13px; /* RADIO PERSONALIZADO */
            padding: 2px; /* PADDING REDUCIDO */
            cursor: pointer;
            transition: all 0.2s ease; /* TRANSICIÓN NORMAL Y SUAVE */
            width: 48px;
            height: 48px;
            overflow: hidden;
        }
        
        .menu-btn:hover:not(.disabled) {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px); /* EFECTO SUAVE NORMAL */
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4); /* SOMBRA SUAVE */
            border-radius: 13px; /* Mantener esquinas redondeadas en hover */
        }
        
        .menu-btn.disabled {
            background: linear-gradient(135deg, #bbb, #999);
            border: none; /* SIN BORDES EN DESHABILITADOS TAMBIÉN */
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .menu-btn.disabled:hover {
            transform: none;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        
        .menu-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .menu-btn:hover:not(.disabled) .menu-icon {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3)) brightness(1.1); /* EFECTO MÁS SUAVE */
        }
        
        .menu-btn.disabled .menu-icon {
            filter: grayscale(100%) drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        /* 🎨 LOGO DE LA WEB */
        .logo-container {
            display: flex;
            align-items: center;
        }
        
        .game-logo {
            height: 40px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .game-logo:hover {
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.4)) brightness(1.1);
            transform: scale(1.05);
        }
        
        /* 📝 INFO EN DOS LÍNEAS */
        .fish-info-stacked {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            text-align: center;
        }
        
        .fish-info-stacked #fishAge {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .fish-info-stacked #fishName {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* 💰 CONTADORES VERTICALES */
        .header-currency-vertical {
            display: flex;
            align-items: center;
        }
        
        .currency-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        
        
        .currency-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .currency-row .currency-icon {
            font-size: 12px;
        }
        
        .currency-row span {
            color: white;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* 🎯 ICONOS DE NECESIDADES FLOTANTES (SOLO VISUALES) */
        .need-bubble-game {
            position: absolute;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* NO clickeables */
            animation: needPulse 2s infinite ease-in-out;
            z-index: 90;
            opacity: 0.4; /* MÁS TRANSPARENTE Y SUTIL */
        }
        
        .need-icon {
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
        }
        
        /* 🎭 TRANSICIONES SUAVES PARA MOVIMIENTO DE ICONOS */
        .need-bubble-game {
            transition: opacity 1.8s ease, transform 1.8s ease;
        }
        
        /* 🍽️ ICONO DE COMIDA CON EFECTO ROJO */
        .need-bubble-game.hunger .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 50, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 50, 50, 0.6))
                hue-rotate(-15deg) 
                saturate(1.5) 
                brightness(1.2);
        }
        
        /* 🧽 ICONO DE LIMPIEZA CON EFECTO AZUL */
        .need-bubble-game.dirty .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 150, 255, 0.8))
                drop-shadow(0 0 12px rgba(50, 150, 255, 0.6))
                hue-rotate(20deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* 💊 ICONO DE MEDICINA CON EFECTO VERDE */
        .need-bubble-game.medicine .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 255, 100, 0.8))
                drop-shadow(0 0 12px rgba(50, 255, 100, 0.6))
                hue-rotate(30deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* 🎮 ICONO DE JUEGO CON EFECTO NARANJA */
        .need-bubble-game.play .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 150, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 150, 50, 0.6))
                hue-rotate(-30deg) 
                saturate(1.3) 
                brightness(1.1);
        }
        
        @keyframes needPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* 🎉 Pantalla de bienvenida - ESTILO MARINO BONITO */
        #welcomeScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
            padding: var(--mobile-padding);
            overflow: hidden;
        }

        /* 🌊 EFECTOS MARINOS DE FONDO */
        #welcomeScreen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255,255,255,0.1) 2px, transparent 2px),
                radial-gradient(circle at 80% 30%, rgba(255,255,255,0.08) 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, rgba(255,255,255,0.06) 3px, transparent 3px),
                radial-gradient(circle at 90% 80%, rgba(255,255,255,0.1) 2px, transparent 2px);
            background-size: 100px 100px, 150px 150px, 200px 200px, 120px 120px;
            animation: float-bubbles 20s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes float-bubbles {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-20px, -30px) rotate(5deg); }
            50% { transform: translate(30px, -20px) rotate(-3deg); }
            75% { transform: translate(-10px, 40px) rotate(2deg); }
        }

        /* 📱 Ocultar header durante bienvenida */
        #welcomeScreen:not([style*="display: none"]) + * #gameHeader,
        #welcomeScreen[style*="flex"] ~ #gameHeader {
            display: none !important;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.15);
            padding: 32px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .welcome-content h1 {
            font-size: 28px;
            margin-bottom: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .welcome-content p {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 24px;
        }
        
        /* 🎓 TUTORIAL STEPS */
        .welcome-tutorial {
            margin: 20px 0;
            text-align: left;
        }
        
        .tutorial-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 14px;
            opacity: 0.9;
            animation: tutorial-fade-in 0.6s ease-out forwards;
        }
        
        .tutorial-step:nth-child(1) { animation-delay: 0.2s; opacity: 0; }
        .tutorial-step:nth-child(2) { animation-delay: 0.4s; opacity: 0; }
        .tutorial-step:nth-child(3) { animation-delay: 0.6s; opacity: 0; }
        .tutorial-step:nth-child(4) { animation-delay: 0.8s; opacity: 0; }
        .tutorial-step:nth-child(5) { animation-delay: 1.0s; opacity: 0; }
        
        .tutorial-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }
        
        .tutorial-text {
            flex: 1;
            font-weight: 500;
        }
        
        @keyframes tutorial-fade-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 0.9; transform: translateX(0); }
        }
        
        /* 🥚 MENSAJE SIMPLE DEL HUEVITO */
        .welcome-info {
            margin: 20px 0;
        }
        
        .egg-message {
            font-size: 16px;
            opacity: 0.9;
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.1);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 12px;
        }
        
        .games-tip {
            font-size: 14px;
            opacity: 0.85;
            line-height: 1.4;
            background: rgba(76, 175, 80, 0.15); /* Verde suave */
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            animation: tip-glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes tip-glow {
            from { box-shadow: 0 0 5px rgba(76, 175, 80, 0.3); }
            to { box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
        }
        
        /* 💖 EFECTO PULSE PARA BARRA DE DIVERSIÓN */
        @keyframes ping {
            0% { box-shadow: 0 0 0 0 rgba(155,231,255,.9) }
            100% { box-shadow: 0 0 0 14px rgba(155,231,255,0) }
        }
        .pulse { animation: ping 1.1s ease-out; }

        /* 🎮 MODAL DE JUEGOS HERMOSO */
        .games-modal-content {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .games-info {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .star-system {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .star-rule {
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            color: #ffd700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .user-stars-display {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
        }
        
        .stars-total {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 193, 7, 0.15) 100%);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 12px;
            padding: 12px 20px;
        }
        
        .stars-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(255, 215, 0, 0.6));
        }
        
        .stars-label {
            font-size: 14px;
            font-weight: 600;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .stars-count {
            font-size: 18px;
            font-weight: 800;
            color: #FFD700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* ❓ MODAL DE AYUDA */
        .help-modal-content {
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .help-content {
            padding: 20px;
        }
        
        .help-section {
            margin-bottom: 25px;
        }
        
        .help-section h3 {
            color: #FFD700;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .help-section p {
            color: #fff;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .star-rules {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .star-rule-help {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .star-icon {
            font-size: 24px;
            filter: drop-shadow(0 2px 4px rgba(255, 215, 0, 0.6));
        }
        
        .rule-text {
            color: #fff;
            line-height: 1.4;
        }
        
        .rule-text strong {
            color: #FFD700;
            font-size: 16px;
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .game-card {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 20px;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .game-card.available {
            border-color: rgba(76, 175, 80, 0.4);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.1),
                0 0 20px rgba(76, 175, 80, 0.1);
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(76, 175, 80, 0.6);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 0 30px rgba(76, 175, 80, 0.3);
        }
        
        .game-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .game-icon {
            font-size: 32px;
            margin-bottom: 10px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .game-description {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-stats {
            font-size: 11px;
            color: #ffd700;
            font-weight: 600;
        }
        
        .game-lock {
            font-size: 12px;
            color: #999;
            font-weight: 500;
        }
        
        /* 🔊 BOTÓN DE VOLUMEN SIMPLE */
        .volume-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            margin-top: 8px;
            margin-left: 12px; /* Separación de los contadores */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .volume-button:hover {
            transform: scale(1.1);
            border-radius: 13px; /* Mantener esquinas redondeadas en hover */
        }

        .volume-button:active {
            transform: scale(0.95);
        }

        #volumeIcon {
            width: 28px;
            height: 28px;
            opacity: 0.75; /* Translúcido para que pegue con el resto */
            transition: all 0.3s ease;
        }
        
        .volume-button:hover #volumeIcon {
            opacity: 1; /* Completamente opaco al hover */
        }
        
        .volume-icon {
            pointer-events: none;
        }
        
        .start-button {
            padding: 16px 32px;
            border: 3px solid #01579b;
            border-radius: 25px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: white;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.6);
        }
        
        .start-button:hover {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.8);
            border-radius: 20px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* 🔄 BOTÓN DE RESET BONITO */
        .reset-button {
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
            border-radius: 20px; /* Mantener esquinas redondeadas en hover */
        }
        
        /* 🎨 LOGO ANIMADO */
        .logo-animated {
            margin-bottom: 20px;
        }
        
        .logo-bounce {
            width: 80px;
            height: 60px;
            animation: logoBounce 3s ease-in-out infinite;
            filter: drop-shadow(0 4px 15px rgba(79, 195, 247, 0.6));
        }
        
        @keyframes logoBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-10px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.02); }
            75% { transform: translateY(-15px) scale(1.08); }
        }
        
        /* 🌊 BURBUJAS ANIMADAS DE FONDO */
        .welcome-bubbles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .bubble {
            position: absolute;
            font-size: 20px;
            opacity: 0.7;
            animation: bubbleFloat 4s ease-in-out infinite;
        }
        
        .bubble-1 { left: 10%; animation-delay: 0s; }
        .bubble-2 { left: 20%; animation-delay: 1s; }
        .bubble-3 { left: 80%; animation-delay: 2s; }
        .bubble-4 { left: 90%; animation-delay: 0.5s; }
        .bubble-5 { left: 60%; animation-delay: 1.5s; }
        
        @keyframes bubbleFloat {
            0% { transform: translateY(100vh) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20px) scale(1.2); opacity: 0; }
        }
        
        /* 🎮 GRID DE JUEGOS COMPACTO MARINO */
        .games-grid-simple {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .game-card {
            background: linear-gradient(135deg, #29b6f6 0%, #42a5f5 50%, #64b5f6 100%);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #0066cc;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,150,255,0.2);
            backdrop-filter: blur(15px);
        }
        
        .game-card.locked {
            background: linear-gradient(135deg, rgba(200,200,200,0.6) 0%, rgba(180,180,180,0.5) 100%);
            border-color: rgba(150,150,150,0.6);
            color: #999;
            opacity: 0.8;
        }
        
        .game-card:hover:not(.locked) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(0,150,255,0.25);
            border-color: rgba(0,200,255,0.9);
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(230,248,255,0.9) 100%);
            border-radius: 15px; /* Mantener esquinas redondeadas en hover */
        }
        
        .game-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .game-name {
            font-weight: bold;
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1.1;
        }
        
        .game-requirement {
            font-size: 11px;
            opacity: 0.8;
        }
        
        /* 🎓 Pantalla de tutorial - ESTILO MARINO BONITO */
        #tutorialScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 998;
            padding: var(--mobile-padding);
        }
        
        .tutorial-content {
            text-align: center;
            max-width: 350px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 24px;
            border-radius: 16px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        .tutorial-content h2 {
            margin-bottom: 16px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .tutorial-hint {
            background: #f0f8ff;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-size: 14px;
        }
        
        /* Eliminado - Ya no hay botón saltar */
        
        /* 🎮 Responsive ajustes */
        @media (max-width: 480px) {
            #turboBadge {
                font-size: 12px;
                padding: 4px 8px;
            }
        }

        /* 🌊 Conecta 3 - Estilos del juego (basado en prototipo funcional) */
        .bloques-cell {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            font-weight: 900;
            color: #fff;
            user-select: none;
            -webkit-user-drag: none;
            touch-action: none;
            cursor: grab;
            transition: transform .18s ease, box-shadow .18s ease, filter .18s ease, opacity .18s ease;
            background: #2c3e50;
            box-shadow: inset 0 6px 10px rgba(255,255,255,.15), inset 0 -8px 14px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.2);
            border: 2px solid #34495e;
        }

        .bloques-cell span {
            font-size: 26px;
            line-height: 1;
            pointer-events: none;
        }

        .bloques-cell:active {
            cursor: grabbing;
        }

        .bloques-cell.ghost {
            opacity: 0.7;
            filter: brightness(1.15);
        }

        .bloques-cell.pop {
            animation: pop .25s ease;
        }

        @keyframes pop {
            from { transform: scale(.85); }
            to { transform: scale(1); }
        }

        .bloques-cell.pulse {
            animation: pulse .9s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 0 rgba(255,255,255,.15); }
            50% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 8px rgba(255,255,255,0); }
            100% { box-shadow: inset 0 8px 14px rgba(255,255,255,.08), inset 0 -10px 18px rgba(0,0,0,.35), 0 0 0 0 rgba(255,255,255,0); }
        }

        /* Pistas sutiles por tipo (bordecito) */
        .bloques-cell.t0 { outline: 2px solid #4ac1ff66; }
        .bloques-cell.t1 { outline: 2px solid #7aff7a66; }
        .bloques-cell.t2 { outline: 2px solid #ffd84a66; }
        .bloques-cell.t3 { outline: 2px solid #ff7adf66; }
        .bloques-cell.t4 { outline: 2px solid #a88bff66; }
        .bloques-cell.t5 { outline: 2px solid #ff9a4a66; }

        /* 🌊 Conecta 3 - Estilos de la cabecera (igual que burbujas) */
        .bloques-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }

        .bloques-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bloques-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bloques-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }

        .bloques-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .bloques-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bloques-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .bloques-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }

        .bloques-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🧠 Memoria - Estilos del contenedor */
        .memory-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }

        /* 🧠 Memoria - Estilos de la cabecera (igual que Conecta 3) */
        .memory-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }

        .memory-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .memory-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .memory-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .memory-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .memory-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .memory-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .memory-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .memory-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        .memory-btn {
            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
            border: 2px solid rgb(21, 101, 192) !important;
            border-radius: 20px !important;
            padding: 12px 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: white !important;
            cursor: pointer !important;
            transition: 0.3s !important;
            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            width: 80% !important;
            max-width: 250px !important;
            margin: 20px auto !important;
            display: block !important;
        }

        /* 🎵 Simón - Estilos del contenedor */
        /* 🎮 CONTENEDOR UNIFICADO PARA TODOS LOS JUEGOS */
        .unified-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }
        
        .simon-game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            width: 90vw;
            height: 95vh;
            max-width: 500px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px;
        }

        /* 🎵 Simón - Estilos de la cabecera (igual que Burbujas) */
        .simon-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .simon-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .simon-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .simon-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .simon-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .simon-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .simon-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .simon-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .simon-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        .simon-btn {
            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
            border: 2px solid rgb(21, 101, 192) !important;
            border-radius: 20px !important;
            padding: 12px 30px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            color: white !important;
            cursor: pointer !important;
            transition: 0.3s !important;
            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
            width: 80% !important;
            max-width: 250px !important;
            margin: 20px auto !important;
            display: block !important;
        }

        /* 🐬 Carril - Estilos de la cabecera (igual que Burbujas) */
        .carril-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .carril-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .carril-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .carril-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .carril-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .carril-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .carril-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .carril-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .carril-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🐉 Dragón - Estilos de la cabecera (igual que Burbujas) */
        .correr-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .correr-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .correr-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .correr-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .correr-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .correr-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .correr-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .correr-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .correr-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🎯 Caza - Estilos de la cabecera (igual que Burbujas) */
        .caza-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .caza-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .caza-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .caza-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .caza-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .caza-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .caza-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .caza-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .caza-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🌊 Secuencia - Estilos de la cabecera (igual que Burbujas) */
        .secuencia-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .secuencia-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .secuencia-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .secuencia-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .secuencia-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .secuencia-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .secuencia-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .secuencia-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .secuencia-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🏖️ Toca-3 - Estilos de la cabecera (igual que Burbujas) */
        .toca3-game-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.3) 0%, 
                rgba(129, 212, 250, 0.2) 100%);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            border-bottom: 2px solid rgba(255, 255, 255, 0.25);
            gap: 8px;
        }
        .toca3-game-header .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .toca3-game-header .header-bottom {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .toca3-game-header .game-stats {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-size: 16px;
            font-weight: bold;
        }
        .toca3-game-header .game-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .toca3-game-header .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toca3-game-header .best-score-display {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .toca3-game-header .best-label {
            opacity: 0.8;
            font-size: 11px;
        }
        .toca3-game-header .best-value {
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 🌊 Conecta 3 - Estilos del contenedor */
        .bloques-game-container {
            background: linear-gradient(135deg, 
                rgba(30, 60, 114, 0.95) 0%, 
                rgba(42, 82, 152, 0.9) 100%);
            border-radius: 20px;
            padding: 0;
            max-width: 90vw;
            max-height: calc(100vh - 80px);
            width: 95%;
            height: 600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 60px rgba(0,0,0,.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            position: relative;
            z-index: 1;
            margin-top: 30px;
            margin-bottom: 30px;
        }


    </style>
</head>
<body>
    <!-- 🏆 CABECERA CON LOGO -->
    <div id="gameHeader">
        <!-- 🎨 LOGO DE LA WEB -->
        <div class="logo-container">
            <img src="./images/ui/logo.png" alt="Mi Pececito" class="game-logo">
    </div>
    
        <!-- 📝 INFO EN DOS LÍNEAS -->
        <div class="fish-info-stacked">
            <div id="fishAge">Huevo</div>
            <div id="fishName">Mi Pececito</div>
        </div>
        
        <!-- 💰 CONTADORES VERTICALES -->
        <div class="header-currency-vertical">
            <div class="currency-stack">
                <div class="currency-row">
                    <span class="currency-icon">🫧</span>
                    <span id="bubblesCount">0</span>
                </div>
                <div class="currency-row">
                    <span class="currency-icon">⭐</span>
                    <span id="starsCount">0</span>
                </div>
            </div>
            <!-- 🔊 BOTÓN DE VOLUMEN BONITO -->
            <button id="volumeBtn" class="volume-button" title="Controlar sonido">
                <img id="volumeIcon" src="./images/ui/sonidoOn.png" alt="Sonido" class="volume-icon">
            </button>
        </div>
    </div>
    
    <!-- 📊 BARRA DE NECESIDADES (SIEMPRE VISIBLE) -->
    <div id="needsHeaderBar" class="needs-header-bar">
        <div class="need-compact" title="Hambre: MÁS ROJO = MÁS HAMBRE">
            <img src="./images/ui/barra_comida.png" alt="Hambre" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini hunger" id="hungerBarHeader" style="width: 80%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Suciedad: MÁS ROJO = MÁS SUCIO">
            <img src="./images/ui/barra_limpieza.png" alt="Limpieza" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini dirt" id="dirtBarHeader" style="width: 65%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Diversión: MÁS AZUL = MÁS FELIZ">
            <img src="./images/ui/barra_diversion.png" alt="Diversión" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini fun" id="funBarHeader" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- 🎮 BARRA DE MENÚ LIMPIA SIN TEXTO -->
    <div class="action-bar">
        <button class="menu-btn disabled" id="feedBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_hunger.png" alt="Comida" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn disabled" id="cleanBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_dirty.png" alt="Limpiar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="playButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_play.png" alt="Jugar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="inventoryButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_inventario.png" alt="Inventario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="createUserButton" title="Crear Usuario">
            <div class="btn-icon">
                <img src="./images/ui/badge_config.png" alt="Crear Usuario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="resetButton" title="Cuidar otro pececito">
            <div class="btn-icon">
                <img src="./images/ui/badge_caravera.png" alt="Reset" class="menu-icon">
            </div>
        </button>
    </div>

    <!-- 👤 MODAL DE CREAR USUARIO -->
    <div id="createUserModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>👤 Crear Usuario</h2>
                <button class="mobile-close-btn" id="closeCreateUser">×</button>
            </div>
            <div class="mobile-modal-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <p style="color: var(--text-primary); font-size: 16px; line-height: 1.5;">
                        <strong>¡No queremos perder a tu pececito!</strong><br>
                        Crea una cuenta para guardar tu progreso y nunca perder a tu compañero acuático.
                    </p>
                </div>
                
                <form id="createUserForm" style="display: flex; flex-direction: column; gap: 15px;">
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            👤 Nombre completo
                        </label>
                        <input type="text" id="userFullName" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu nombre completo">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            🏷️ Nombre de usuario
                        </label>
                        <input type="text" id="userNickname" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu nombre de usuario">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            📧 Correo electrónico
                        </label>
                        <input type="email" id="userEmail" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="tu@email.com">
                    </div>
                    
                    <div>
                        <label style="color: var(--text-primary); font-weight: 600; display: block; margin-bottom: 5px;">
                            🔒 Contraseña
                        </label>
                        <input type="password" id="userPassword" required 
                               style="width: 100%; padding: 12px; border: 2px solid rgba(255,255,255,0.3); 
                                      border-radius: 8px; background: rgba(255,255,255,0.1); 
                                      color: var(--text-primary); font-size: 14px;"
                               placeholder="Tu contraseña segura">
                    </div>
                    
                    <button type="submit" 
                            style="background: linear-gradient(135deg, var(--button-primary), var(--button-hover)); 
                                   color: var(--text-primary); border: none; padding: 15px; 
                                   border-radius: 12px; font-size: 16px; font-weight: 600; 
                                   cursor: pointer; transition: all 0.3s ease; margin-top: 10px;">
                        ¡Crear mi cuenta!
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- 🎮 Canvas principal del juego -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- 📊 BARRAS DE NECESIDADES FLOTANTES -->
    <div class="needs-overlay">
        <div class="need-mini" title="Hambre: MÁS ROJO = MÁS HAMBRE">
            <span>🍎</span>
            <div class="mini-bar">
                <div class="mini-fill hunger" id="hungerBar" style="width: 80%"></div>
            </div>
        </div>
        <div class="need-mini" title="Suciedad: MÁS VERDE = MÁS SUCIO">
            <span>🧹</span>
            <div class="mini-bar">
                <div class="mini-fill dirt" id="dirtBar" style="width: 65%"></div>
            </div>
        </div>
        <div class="need-mini" title="Diversión: MÁS AZUL = MÁS FELIZ">
            <span>🎉</span>
            <div class="mini-bar">
                <div class="mini-fill fun" id="funBar" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- 🐠 CONTENEDOR LOTTIE PARA EL PEZ -->
    <div id="lottieContainer" style="
        position: absolute;
        width: 60px;
        height: 60px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        pointer-events: none;
        display: none;
        /* filter: brightness(1.3) contrast(1.1) saturate(1.2); */ /* DESHABILITADO - conflicto con JS dinámico */
    "></div>
    
    <!-- 🎯 UI Overlay -->
    <div class="ui-overlay">
        <!-- 💨 Badge de turbo -->
        <div id="turboBadge">TURBO 💨</div>
        
        
        <!-- 🎯 ICONOS DE NECESIDADES (SOLO VISUALES - NO CLICKEABLES) -->
        <!-- ICONOS FLOTANTES ELIMINADOS - ERAN MOLESTOS -->
    </div>
    
    <!-- 📱 Pantalla de carga ELIMINADA -->
    
    <!-- 🎉 Pantalla de bienvenida (primera vez) -->
    <div id="welcomeScreen" style="display: none;">
        <div class="welcome-content">
            <!-- 🎨 LOGO ANIMADO -->
            <div class="logo-animated">
                <img src="./images/ui/logo.png" alt="Mi Pececito" class="logo-bounce">
            </div>
            
            <h1>Mi Pececito</h1>
            <p>Tu mascota virtual</p>
            
            <!-- MENSAJE SIMPLE DEL HUEVITO -->
            <div class="welcome-info">
                <p class="egg-message">
                    Tu huevo nacerá en <strong>5 minutos</strong><br>
                    Juega mientras esperas
                </p>
            </div>
            
            <!-- 🌊 BURBUJAS SUTILES (MENOS ICONOS) -->
            <div class="welcome-bubbles">
                <div class="bubble bubble-1">🫧</div>
                <div class="bubble bubble-2">🫧</div>
                <div class="bubble bubble-3">🫧</div>
            </div>
            
            <button id="startGameBtn" class="start-button">Empezar</button>
            
            <!-- Botón de reset eliminado - Solo aparece en menú si ya tienes pez -->
        </div>
    </div>
    
    <!-- 🎓 Pantalla de tutorial -->
    <div id="tutorialScreen" style="display: none;">
        <div class="tutorial-content">
            <h2>🥚 Tu Primer Huevo</h2>
            <p>Toca la pantalla para colocar tu huevo en el acuario</p>
            <div class="tutorial-hint">💡 El huevo tardará 24 horas en eclosionar</div>
        </div>
    </div>

    <!-- 🎮 MODAL DE JUEGOS MODERNO -->
    <div id="gamesModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content games-modal-content">
            <div class="mobile-modal-header">
                <h2>🎮 Juegos</h2>
                <div class="header-buttons">
                    <button id="helpGames" class="mobile-help-btn" title="¿Cómo ganar estrellas?">?</button>
                    <button id="closeGames" class="mobile-close-btn">×</button>
                </div>
            </div>
            
            <!-- 🏆 ESTRELLAS TOTALES DEL USUARIO -->
            <div class="games-info">
                <div class="user-stars-display">
                    <div class="stars-total">
                        <span class="stars-icon">⭐</span>
                        <span class="stars-label">Tus estrellas:</span>
                        <span class="stars-count" id="modal-stars-count">0</span>
                    </div>
                </div>
            </div>
            
            <!-- 🎯 GRID DE JUEGOS -->
            <div class="games-grid">
                <div class="game-card available" data-game="bubbles">
                    <div class="game-icon">🫧</div>
                    <div class="game-title">Atrapa Burbujas</div>
                    <div class="game-description">Revienta las burbujas buenas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bubbles-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="bubbles-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="bloques">
                    <div class="game-icon">💎</div>
                    <div class="game-title">Conecta 3</div>
                    <div class="game-description">Conecta 3 gemas marinas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bloques-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="bloques-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="memoria">
                    <div class="game-icon">🧠</div>
                    <div class="game-title">PezFlip</div>
                    <div class="game-description">Encuentra las parejas</div>
                    <div class="game-stats">
                        <span class="best-score">Partidas: <span id="memoria-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="memoria-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="simon">
                    <div class="game-icon">🎵</div>
                    <div class="game-title">Simón Marino</div>
                    <div class="game-description">Repite la secuencia</div>
                    <div class="game-stats">
                        <span class="best-score">Récord: <span id="simon-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="simon-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="carril">
                    <div class="game-icon">🐬</div>
                    <div class="game-title">Carril del Delfín</div>
                    <div class="game-description">Runner de 3 carriles</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="carril-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="carril-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="correr">
                    <div class="game-icon">🐉</div>
                    <div class="game-title">Dragón Marino</div>
                    <div class="game-description">Corre y salta obstáculos</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="correr-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="correr-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="caza">
                    <div class="game-icon">🎯</div>
                    <div class="game-title">Caza de Peces</div>
                    <div class="game-description">Toca el objetivo</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="caza-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="caza-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="secuencia">
                    <div class="game-icon">🌊</div>
                    <div class="game-title">Secuencia de Mareas</div>
                    <div class="game-description">Memoriza y repite</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="secuencia-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="secuencia-level">1</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="toca3">
                    <div class="game-icon">🏖️</div>
                    <div class="game-title">Toca-3 Marino</div>
                    <div class="game-description">Pez en la arena</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="toca3-best">0</span></span>
                        <span class="level-reached">🏆 Nivel: <span id="toca3-level">1</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ❓ MODAL DE AYUDA - ESTRELLAS -->
    <div id="helpModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content help-modal-content">
            <div class="mobile-modal-header">
                <h2>❓ ¿Cómo ganar estrellas?</h2>
                <button id="closeHelp" class="mobile-close-btn">×</button>
            </div>
            
            <div class="help-content">
                <div class="help-section">
                    <h3>⭐ Sistema de Estrellas</h3>
                    <p>Las estrellas son la moneda principal para desbloquear nuevos juegos y contenido.</p>
                </div>
                
                <div class="help-section">
                    <h3>🎮 Cómo ganar estrellas:</h3>
                    <div class="star-rules">
                        <div class="star-rule-help">
                            <span class="star-icon">⭐</span>
                            <div class="rule-text">
                                <strong>1 estrella</strong><br>
                                Por jugar cualquier juego (ganes o pierdas)
                            </div>
                        </div>
                        <div class="star-rule-help">
                            <span class="star-icon">⭐⭐</span>
                            <div class="rule-text">
                                <strong>2 estrellas</strong><br>
                                Si superas tu récord personal
                            </div>
                        </div>
                        <div class="star-rule-help">
                            <span class="star-icon">⭐⭐⭐</span>
                            <div class="rule-text">
                                <strong>3 estrellas</strong><br>
                                Si superas el récord global
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="help-section">
                    <h3>🔓 Desbloqueo de juegos:</h3>
                    <p>Algunos juegos requieren un número mínimo de estrellas para desbloquearse. ¡Juega más para acceder a todo el contenido!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 🎒 MODAL DE INVENTARIO SIMPLE -->
    <div id="inventoryModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>🎒 Inventario</h2>
                <button id="closeInventory" class="mobile-close-btn">×</button>
            </div>
            
            <div class="mobile-modal-body">
            <div class="inventory-grid-simple">
                    <!-- Los fondos se cargarán dinámicamente -->
            </div>
                    </div>
        </div>
    </div>


    <!-- 📸 MODAL DE ÁLBUM -->
    <div id="albumModal" style="display: none;">
        <div class="modal-content album-modal">
            <div class="modal-header">
                <h2>📸 Álbum de Mi Pececito</h2>
                <div class="album-header-buttons">
                    <button id="shareFromAlbum" class="album-action-btn" title="Compartir mi pez">📱</button>
                    <button id="closeAlbum" class="close-btn">❌</button>
                </div>
            </div>
            
            <div class="album-content">
                <div class="album-stats">
                    <div class="stat-item">📅 Días juntos: <span id="albumDays">0</span></div>
                    <div class="stat-item">📸 Recuerdos: <span id="albumEvents">0</span></div>
                    <div class="stat-item">🎉 Hitos: <span id="albumMilestones">0</span></div>
                </div>
                
                <div class="album-timeline" id="albumTimeline">
                    <!-- Se llenará dinámicamente -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 🚨 Pantalla de error -->
    <div id="errorScreen">
        <div class="error-icon">😢</div>
        <div class="error-title">¡Oops! Algo salió mal</div>
        <div class="error-message">No se pudo cargar el juego. Verifica tu conexión.</div>
        <button class="retry-button" onclick="location.reload()">Reintentar</button>
    </div>
    
    <!-- 🔧 Barra de Debug (solo desarrollo) -->
    <div id="debugBar">
        <div id="debugInfo">
            --fps
        </div>
        <button class="debug-btn danger" id="debugResetBtn" title="Reset juego">🔄</button>
        <button class="debug-btn primary" id="forceHatchBtn" title="Forzar eclosión">🐣</button>
        <button class="debug-btn success" id="evolveToYoungBtn" title="Evolucionar a Joven">🌱</button>
        <button class="debug-btn info" id="evolveToAdultBtn" title="Evolucionar a Adulto">👑</button>
        <button class="debug-btn warning" id="moveFishLeftBtn" title="Mover pez a la izquierda">⬅️</button>
        <button class="debug-btn warning" id="moveFishRightBtn" title="Mover pez a la derecha">➡️</button>
        <button class="debug-btn info" id="advanceTimeBtn" title="Avanzar tiempo 1 hora">⏰</button>
    </div>
    
    <!-- 🎨 Librería Lottie -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- 🚀 Script principal -->
    <!-- 🥚 MODAL ELIMINADA - YA NO SE NECESITA -->

    <script>
        // VERSIÓN CON LOTTIE REAL
        // import { createGame } from './src/core/Game.js';
        
        // 🎮 Variables globales
        let game = null;
        let audioManager = null;
        
        // 🚀 Inicializar juego
        async function initializeGame() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const errorScreen = document.getElementById('errorScreen');
            
            try {
                console.log('🎮 Iniciando Mi Pececito...');
                console.log('🔧 Creando CompleteGame...');
                
                // Crear juego completo
                game = new CompleteGame();
                window.game = game; // Asignar inmediatamente para que esté disponible
                console.log('✅ CompleteGame creado correctamente');
                
                // Crear AudioManager
                console.log('🎵 Iniciando AudioManager...');
                audioManager = new AudioManager();
                window.audioManager = audioManager; // Hacer disponible globalmente
                console.log('✅ AudioManager creado correctamente');
                
                // 📊 FORZAR ACTUALIZACIÓN DE BARRAS DE NECESIDADES
                setTimeout(() => {
                    if (game && game.updateNeedBars) {
                        game.updateNeedBars();
                        console.log('📊 Barras de necesidades actualizadas');
                    }
                }, 500);
                
                // Configurar eventos globales
                setupGlobalEvents();
                
                // Verificar si es primera vez (sin huevo colocado)
                const savedData = localStorage.getItem('miPececito_gameData');
                const hasPlayed = localStorage.getItem('miPececito_hasPlayed');
                const isFirstTime = !savedData || !hasPlayed;
                console.log('🔍 DEBUG PRIMERA VEZ:');
                console.log('   savedData:', !!savedData);
                console.log('   hasPlayed:', hasPlayed);
                console.log('   isFirstTime:', isFirstTime);
                
                // IR DIRECTO (sin pantalla de carga)
                
                // LÓGICA CORRECTA: Solo bienvenida si NO hay pez
                if (isFirstTime) {
                    // Primera vez: mostrar bienvenida
                    console.log('🪟 Mostrando bienvenida (primera vez)...');
                    console.log('🪟 welcomeScreen encontrado:', !!welcomeScreen);
                    if (welcomeScreen) {
                        welcomeScreen.style.display = 'flex';
                        welcomeScreen.style.visibility = 'visible';
                        welcomeScreen.style.opacity = '1';
                        welcomeScreen.style.zIndex = '9999';
                        console.log('🪟 Modal forzada a visible');
                    }
                    setupWelcomeFlow();
                } else {
                    // Ya tiene pez: mostrar pantalla de carga personalizada
                    game.showLoadingWithFishName();
                    // Añadir botón reset al menú
                    game.addResetButtonToMenu();
                }
                
                console.log('✅ ¡Juego listo!', isFirstTime ? '(Primera vez)' : '(Jugador veterano)');
                
                // 🎮 ACTUALIZAR UI DE JUEGOS
                updateGamesUI();
                
            } catch (error) {
                console.error('❌ Error inicializando juego:', error);
                
                // Mostrar pantalla de error
                errorScreen.style.display = 'flex';
            }
        }
        
        // 🎮 ACTUALIZAR UI DE JUEGOS
        function updateGamesUI() {
            // Obtener estrellas totales del juego principal
            let totalStars = 0;
            if (window.game && window.game.gameState) {
                totalStars = window.game.gameState.stars || 0;
            }
            
            // Fallback: cargar desde localStorage si no hay estrellas
            if (totalStars === 0) {
                const savedData = localStorage.getItem('miPececito_gameData');
                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        totalStars = parsed.stars || 0;
                        console.log(`🔍 Fallback: Estrellas desde localStorage: ${totalStars}`);
                    } catch (e) {
                        console.log(`❌ Error parsing savedData: ${e}`);
                    }
                }
            }
            
            console.log(`🔍 updateGamesUI: totalStars=${totalStars}, window.game=${!!window.game}`);
            
            // Actualizar juego de burbujas (solo nivel y mejor puntuación)
            const bubblesBest = document.getElementById('bubbles-best');
            const bubblesLevel = document.getElementById('bubbles-level');
            
            if (bubblesBest) {
                bubblesBest.textContent = localStorage.getItem('bubbles_best') || '0';
            }
            if (bubblesLevel) {
                bubblesLevel.textContent = localStorage.getItem('bubbles_level') || '1';
            }
            
            // Actualizar otros juegos (solo sus estadísticas específicas)
            const otherGames = ['bloques', 'memoria', 'simon', 'carril', 'correr', 'caza', 'secuencia', 'toca3'];
            otherGames.forEach(gameName => {
                const bestEl = document.getElementById(`${gameName}-best`);
                if (bestEl) {
                    const bestScore = localStorage.getItem(`${gameName}_best`) || '0';
                    bestEl.textContent = bestScore;
                }
            });
        }
        
        // 🎉 Configurar flujo de bienvenida
        function setupWelcomeFlow() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const tutorialScreen = document.getElementById('tutorialScreen');
            const startGameBtn = document.getElementById('startGameBtn');
            
            // Botón "Empezar Aventura"
            startGameBtn.addEventListener('click', () => {
                console.log('🚀 Empezar aventura clickeado - OCULTANDO MODAL');
                welcomeScreen.style.display = 'none';
                
                // 🎵 INICIAR MÚSICA DE FONDO INMEDIATAMENTE
                if (audioManager && !audioManager.isMuted) {
                    audioManager.startBackgroundMusic();
                    console.log('🎵 Música de fondo iniciada al empezar el juego');
                }
                
                // Marcar como jugado
                localStorage.setItem('miPececito_hasPlayed', 'true');
                
                // IR DIRECTO A COLOCAR HUEVO (sin modal intermedia)
                if (game && game.startEggPlacement) {
                    game.startEggPlacement();
                } else {
                    // Fallback si game no está listo
                    setTimeout(() => {
                        if (game && game.startEggPlacement) {
                            game.startEggPlacement();
                        }
                    }, 500);
                }
            });
            
            // 🥚 EVENT LISTENER ELIMINADO - YA NO SE NECESITA
            
            // Botón "Cuidar otro pececito" ELIMINADO - Solo aparece en menú dinámicamente
            /*
            const resetGameBtn = document.getElementById('resetGameBtn');
            if (false) { // DESHABILITADO
                resetGameBtn.addEventListener('click', () => {
                    if (game) {
                        game.showCustomModal({
                            title: '🌊 Despedida de tu Pececito',
                            message: `🐠💭 "¿De verdad me vas a dejar libre?"\n\n🏠 Volveré al océano y seré feliz\n💕 Siempre recordaré nuestros momentos\n🎮 Podrás cuidar a un nuevo compañero\n\n⚠️ Se perderá todo el progreso actual`,
                            confirmText: '🌊 ¡Sé libre y feliz!',
                            cancelText: '💕 ¡No, te quiero!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            },
                            onCancel: () => {
                                game.showCustomModal({
                                    title: '💕 ¡Qué alegría!',
                                    message: '🐠💭 "¡Sabía que no me abandonarías!"\n\n¡Sigamos jugando juntos! 🎮',
                                    confirmText: '🥰 ¡Siempre!',
                                    onConfirm: () => {}
                                });
                            }
                        });
                    }
                });
            }
            */
        }
        
        // 🎓 Configurar handler del tutorial
        function setupTutorialHandler() {
            const tutorialScreen = document.getElementById('tutorialScreen');
            
            // Tutorial: Toque ANYWHERE para colocar huevo
            const tutorialHandler = (e) => {
                console.log('👆 Toque detectado en tutorial');
                
                // Cerrar tutorial inmediatamente
                tutorialScreen.style.display = 'none';
                
                // Colocar huevo en el centro (o donde tocó si es en canvas)
                let x = window.innerWidth / 2;
                let y = window.innerHeight / 2;
                
                // Si tocó en el canvas, usar esa posición
                if (e.target.id === 'gameCanvas') {
                    const rect = e.target.getBoundingClientRect();
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                if (game) {
                    game.placeFirstEgg(x, y);
                }
                
                // Remover listener del tutorial
                document.removeEventListener('click', tutorialHandler);
                
                console.log('🥚 Primer huevo colocado - Tutorial cerrado');
            };
            
            // Escuchar toques en TODA la pantalla
            document.addEventListener('click', tutorialHandler);
        }
        
        // ⚙️ Configurar eventos globales
        function setupGlobalEvents() {
            // Badge de turbo
            const turboBadge = document.getElementById('turboBadge');
            
            // Escuchar eventos del juego
            document.addEventListener('turboStart', () => {
                turboBadge.classList.add('active');
            });
            
            document.addEventListener('turboEnd', () => {
                turboBadge.classList.remove('active');
            });
            
            // Prevenir zoom en móviles
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            
            // Debug info (solo en desarrollo)
            if (window.location.hostname === 'localhost') {
                setupDebugInfo();
            }
            
            // 🔊 BOTÓN DE VOLUMEN
            const volumeBtn = document.getElementById('volumeBtn');
            if (volumeBtn && audioManager) {
                volumeBtn.addEventListener('click', () => {
                    audioManager.toggleMute();
                    console.log('🔊 Botón de volumen clickeado');
                });
                
                // Inicializar estado del botón
                audioManager.updateVolumeButton();
                
                // 🎵 MÚSICA SE INICIA AUTOMÁTICAMENTE AL HACER CLICK EN "¡Cuidar mi huevo!"
                // (Ya no necesitamos listeners genéricos)
            }
            
        // Event listeners de la cabecera
        setupHeaderEvents();
        }
        
        // 🏆 Configurar eventos de cabecera
        function setupHeaderEvents() {
            console.log('🔧 Configurando eventos de cabecera...');
            
            // 🏷️ CLICK EN NOMBRE DEL PEZ PARA CAMBIARLO
            const fishNameElement = document.getElementById('fishName');
            if (fishNameElement) {
                fishNameElement.style.cursor = 'pointer';
                fishNameElement.title = 'Click para cambiar nombre';
                fishNameElement.addEventListener('click', () => {
                    if (game && game.gameState.stage !== 'egg' && game.gameState.stage !== 'waiting') {
                        game.showChangeNameModal();
                    }
                });
                console.log('🏷️ Evento de cambio de nombre configurado');
            }
            
            // Verificar que el botón existe
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            
            console.log('🎮 Botón de jugar encontrado:', !!playBtn);
            console.log('🎮 Modal de juegos encontrada:', !!gamesModal);
            
            if (!playBtn) {
                console.error('❌ Botón playButton no encontrado!');
                return;
            }
            
            if (!gamesModal) {
                console.error('❌ Modal gamesModal no encontrada!');
                return;
            }
            
            // Botón de jugar
            playBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('🎮 ¡CLICK EN BOTÓN JUGAR DETECTADO!');
                
                // Abrir modal directamente
                console.log('🎮 Abriendo modal de juegos...');
                gamesModal.style.display = 'flex';
                
                // Forzar la animación
                requestAnimationFrame(() => {
                    gamesModal.style.opacity = '1';
                });
                
                console.log('🎮 Modal abierta, display:', gamesModal.style.display);
            });
            
            // Botón de inventario
            document.getElementById('inventoryButton').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de items
                if (window.game) {
                    window.game.updateInventoryAvailability?.();
                }
            });
            
            // Botón de crear usuario
            document.getElementById('createUserButton').addEventListener('click', () => {
                const modal = document.getElementById('createUserModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                console.log('👤 Modal de crear usuario abierta');
            });
            
            
            // Cerrar inventario con animación
            document.getElementById('closeInventory').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar modal de crear usuario
            document.getElementById('closeCreateUser').addEventListener('click', () => {
                const modal = document.getElementById('createUserModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Formulario de crear usuario
            document.getElementById('createUserForm').addEventListener('submit', (e) => {
                e.preventDefault();
                
                const fullName = document.getElementById('userFullName').value;
                const nickname = document.getElementById('userNickname').value;
                const email = document.getElementById('userEmail').value;
                const password = document.getElementById('userPassword').value;
                
                console.log('👤 Datos del usuario:', { fullName, nickname, email, password: '***' });
                
                // Aquí iría la lógica para crear el usuario
                // Por ahora solo mostramos un mensaje de éxito
                alert('🐠 ¡Usuario creado exitosamente!\n\n' +
                      `Nombre: ${fullName}\n` +
                      `Usuario: ${nickname}\n` +
                      `Email: ${email}\n\n` +
                      '¡Tu pececito está seguro!');
                
                // Cerrar modal
                const modal = document.getElementById('createUserModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar juegos con animación
            document.getElementById('closeGames').addEventListener('click', () => {
                const modal = document.getElementById('gamesModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Botón de ayuda
            document.getElementById('helpGames').addEventListener('click', () => {
                const helpModal = document.getElementById('helpModal');
                helpModal.style.display = 'flex';
                setTimeout(() => helpModal.style.opacity = '1', 10);
            });
            
            // Cerrar ayuda
            document.getElementById('closeHelp').addEventListener('click', () => {
                const helpModal = document.getElementById('helpModal');
                helpModal.style.opacity = '0';
                setTimeout(() => helpModal.style.display = 'none', 300);
            });
            
            // Event listeners para las tarjetas de juegos cuadradas
            document.querySelectorAll('.game-card-square').forEach(card => {
                card.addEventListener('click', () => {
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`🎮 Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('gamesModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            window.game.startGame(gameId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`🔒 Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showGameLocked(starsNeeded);
                    }
                });
            });
            
            // Event listeners para las tarjetas de inventario cuadradas
            document.querySelectorAll('.inventory-item-square').forEach(card => {
                card.addEventListener('click', () => {
                    const itemId = card.dataset.item;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`🎒 Usando item: ${itemId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('inventoryModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            // Aquí puedes añadir la lógica para usar el item
                            window.game.useInventoryItem?.(itemId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`🔒 Item bloqueado: ${itemId}`);
                        // Mostrar mensaje de item bloqueado
                        const bubblesNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showItemLocked?.(bubblesNeeded);
                    }
                });
            });
            

            // Botón de reset (calavera)
            document.getElementById('resetButton').addEventListener('click', () => {
                if (game) {
                    game.showResetModal();
                }
            });
            
            // 🍎 BOTÓN DE ALIMENTACIÓN (UNA BOLITA COMO EN ORIGINAL)
            document.getElementById('feedBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('❌ Botón de comida DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish) {
                    game.dropFood(); // UNA SOLA BOLITA
                    console.log('🍎 Una bolita pequeña soltada');
                }
            });
            
            // 🧹 BOTÓN DE LIMPIEZA
            document.getElementById('cleanBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('❌ Botón de limpieza DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish) {
                    game.startCleaning();
                    console.log('🧹 Limpiando la pecera...');
                }
            });
            
            // 💊 BOTÓN DE MEDICINA
            // 💊 BOTÓN DE MEDICINA - ELIMINADO (YA NO SE USA)
            
            // Botón de reset se añade dinámicamente
            
            // Cerrar álbum
            document.getElementById('closeAlbum').addEventListener('click', () => {
                document.getElementById('albumModal').style.display = 'none';
            });
            
            // Compartir desde álbum
            document.getElementById('shareFromAlbum').addEventListener('click', () => {
                if (window.game) {
                    window.game.shareMyFish();
                } else {
                    console.warn('🚨 Game no disponible para compartir');
                }
                console.log('📱 Compartir desde álbum clickeado');
            });
            
            // 🎮 MODAL DE JUEGOS
            document.getElementById('playButton').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'flex';
                console.log('🎮 Modal de juegos abierta');
            });
            
            document.getElementById('closeGames').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'none';
                console.log('🎮 Modal de juegos cerrada');
            });
            
            // 🫧 JUEGO DE BURBUJAS (INTEGRADO)
            document.querySelector('[data-game="bubbles"]').addEventListener('click', () => {
                startBubblesGameIntegrated();
            });
            
            // 💎 JUEGO DE BLOQUES (MAR MATCH-3)
            document.querySelector('[data-game="bloques"]').addEventListener('click', () => {
                startBloquesGame();
            });
            
            // 🧠 JUEGO DE MEMORIA
            document.querySelector('[data-game="memoria"]').addEventListener('click', () => {
                startMemoriaGame();
            });
            
            // 🎵 JUEGO DE SIMÓN MARINO
            document.querySelector('[data-game="simon"]').addEventListener('click', () => {
                startSimonGame();
            });
            
            // 🐬 JUEGO DEL CARRIL DEL DELFÍN
            document.querySelector('[data-game="carril"]').addEventListener('click', () => {
                startCarrilGame();
            });
            
            // 🐉 JUEGO DEL DRAGÓN MARINO
            document.querySelector('[data-game="correr"]').addEventListener('click', () => {
                startCorrerGame();
            });
            
            // 🎯 JUEGO DE CAZA DE PECES
            document.querySelector('[data-game="caza"]').addEventListener('click', () => {
                startCazaGame();
            });
            
            // 🌊 JUEGO DE SECUENCIA DE MAREAS
            document.querySelector('[data-game="secuencia"]').addEventListener('click', () => {
                startSecuenciaGame();
            });
            
            // 🏖️ JUEGO DE TOCA-3 MARINO
            document.querySelector('[data-game="toca3"]').addEventListener('click', () => {
                startToca3Game();
            });
            
            // 🔗 CONECTORES ADICIONALES PARA NOMBRES ALTERNATIVOS
            const alternativeConnectors = [
                { selector: '[data-game="memory"]', handler: startMemoriaGame },
                { selector: '[data-game="snake"]', handler: startCarrilGame }, // Snake -> Carril
                { selector: '[data-game="puzzle"]', handler: startBloquesGame }, // Puzzle -> Bloques
                { selector: '[data-game="race"]', handler: startCorrerGame }, // Race -> Correr
                { selector: '[data-game="target"]', handler: startCazaGame }, // Target -> Caza
                { selector: '[data-game="adventure"]', handler: startSecuenciaGame }, // Adventure -> Secuencia
                { selector: '[data-game="tower"]', handler: startToca3Game }, // Tower -> Toca3
                { selector: '[data-game="boss"]', handler: startSimonGame } // Boss -> Simon
            ];
            
            alternativeConnectors.forEach(({selector, handler}) => {
                const element = document.querySelector(selector);
                if (element) {
                    element.addEventListener('click', handler);
                    console.log(`🔗 Conector alternativo añadido: ${selector}`);
                }
            });
            
            // Tabs del inventario y juegos (sistema unificado)
            document.querySelectorAll('.game-tab-btn, .tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    const modalContainer = btn.closest('.game-modal-content') || btn.closest('.modal-content');
                    
                    if (modalContainer) {
                        // Cambiar tab activo en el modal específico
                        modalContainer.querySelectorAll('.game-tab-btn, .tab-btn').forEach(b => b.classList.remove('active'));
                        modalContainer.querySelectorAll('.game-tab-content, .tab-content').forEach(c => c.classList.remove('active'));
                    
                    btn.classList.add('active');
                        const targetTab = document.getElementById(tab + '-tab');
                        if (targetTab) {
                            targetTab.classList.add('active');
                        }
                    }
                });
            });
            
            // Botones de jugar en las modales mejoradas
            document.querySelectorAll('.game-play-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const gameId = btn.dataset.game;
                    if (gameId && window.game) {
                        console.log(`🎮 Iniciando juego: ${gameId}`);
                        window.game.startGame(gameId);
                    }
                });
            });
        }
        
        // 🔧 Configurar barra de debug
        function setupDebugInfo() {
            const debugBar = document.getElementById('debugBar');
            const debugInfo = document.getElementById('debugInfo');
            debugBar.style.display = 'flex';
            
            // Actualizar info cada segundo
            setInterval(() => {
                if (game) {
                    const info = game.getGameInfo();
                    const elapsed = info.eggTime || 0;
                    const hours = Math.floor(elapsed / (1000 * 60 * 60));
                    const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
                    
                    // Debug expandido con necesidades y edad
                    const hungerHours = Math.floor((Date.now() - game.gameState.lastFeed) / (1000 * 60 * 60));
                    const playHours = Math.floor((Date.now() - game.gameState.lastPlay) / (1000 * 60 * 60));
                    const cleanHours = Math.floor((Date.now() - game.gameState.lastClean) / (1000 * 60 * 60));
                    
                    debugInfo.innerHTML = `${Math.round(1 / (game.deltaTime || 0.016))}fps`;
                }
            }, 1000);
            
            // BOTONES DE DEBUG
            document.getElementById('debugResetBtn').addEventListener('click', () => {
                if (confirm('🔄 ¿Resetear todo el juego?')) {
                    console.log('🔄 Reseteando juego completo...');
                    
                    // Limpiar TODO el localStorage AGRESIVAMENTE
                    console.log('🧹 LIMPIEZA TOTAL del localStorage...');
                    localStorage.removeItem('miPececito_gameState');
                    localStorage.removeItem('miPececito_gameData');
                    localStorage.removeItem('miPececito_hasPlayed');
                    localStorage.removeItem('bubbleGame_personalRecord');
                    localStorage.removeItem('bubbleGame_globalRecord');
                    localStorage.clear(); // Por si hay más
                    console.log('✅ localStorage completamente limpio');
                    
                    // Recargar página para volver al inicio
                    setTimeout(() => {
                        location.reload();
                    }, 100);
                }
            });
            
            document.getElementById('forceHatchBtn').addEventListener('click', () => {
                if (game) {
                    game.setEggTimeToFinalSeconds(); // Ir a los últimos 5 segundos
                    console.log('🐣 Huevo a punto de eclosionar (5 segundos)');
                }
            });
            
            // 🌱 BOTÓN EVOLUCIONAR A JOVEN
            document.getElementById('evolveToYoungBtn').addEventListener('click', () => {
                if (game && game.gameState.stage === 'baby') {
                    console.log('🌱 DEBUG: Forzando evolución a joven...');
                    game.startEvolution('young');
                } else {
                    console.log('❌ Solo se puede evolucionar desde bebé a joven');
                }
            });
            
            // 👑 BOTÓN EVOLUCIONAR A ADULTO  
            document.getElementById('evolveToAdultBtn').addEventListener('click', () => {
                if (game && game.gameState.stage === 'young') {
                    console.log('👑 DEBUG: Forzando evolución a adulto...');
                    game.startEvolution('adult');
                } else {
                    console.log('❌ Solo se puede evolucionar desde joven a adulto');
                }
            });
            
            // ⬅️ BOTÓN MOVER PEZ A LA IZQUIERDA
            document.getElementById('moveFishLeftBtn').addEventListener('click', () => {
                if (game && game.fish) {
                    const padLeft = 60;
                    game.fish.x = padLeft;
                    game.fish.vx = 0;
                    console.log(`⬅️ DEBUG: Pez movido a la izquierda (x: ${padLeft})`);
                } else {
                    console.log('❌ No hay pez para mover');
                }
            });
            
            // ➡️ BOTÓN MOVER PEZ A LA DERECHA
            document.getElementById('moveFishRightBtn').addEventListener('click', () => {
                if (game && game.fish) {
                    const padRight = 30;
                    const W = game.canvas.width;
                    game.fish.x = W - padRight;
                    game.fish.vx = 0;
                    console.log(`➡️ DEBUG: Pez movido a la derecha (x: ${W - padRight})`);
                } else {
                    console.log('❌ No hay pez para mover');
                }
            });
            
            // ⏰ BOTÓN AVANZAR TIEMPO
            document.getElementById('advanceTimeBtn').addEventListener('click', () => {
                if (game) {
                    game.advanceTime(1);
                    console.log('⏰ DEBUG: Tiempo avanzado 1 hora');
                } else {
                    console.log('❌ No hay juego para avanzar tiempo');
                }
            });
            
            
            
            
            
            
            
        }
        
        // 🎯 Manejar errores globales
        window.addEventListener('error', (e) => {
            console.error('❌ Error global:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('❌ Promesa rechazada:', e.reason);
        });
        
        // 🚀 Iniciar cuando la página esté lista
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // 🎮 SISTEMA COMPLETO DE JUEGO
        class CompleteGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 🐠 SISTEMAS REFACTORIZADOS
                console.log('🔧 Inicializando FishSystem...');
                this.fishSystem = new FishSystem(this);
                console.log('✅ FishSystem inicializado:', !!this.fishSystem);
                
                console.log('🔧 Inicializando NeedsSystem...');
                this.needsSystem = new NeedsSystem(this);
                console.log('✅ NeedsSystem inicializado:', !!this.needsSystem);
                
                // 🫧 CAPA OFFSCREEN PARA BURBUJAS (FIX DPR)
                this.bubLayer = null;
                this.bubCtx = null;
                
                this.setupCanvas();
                this.ensureBubLayer(); // INICIALIZAR CAPA OFFSCREEN
                
                // Estado del juego
                this.gameState = {
                    stage: 'waiting', // NUEVO: Esperando a colocar huevo
                    eggStartTime: null, // NO hay tiempo hasta colocar huevo
                    bubbles: 0,   // EMPEZAR SIN BURBUJAS
                    stars: 0,     // Sin estrellas al inicio
                    currentBackground: 'Mi casa',
                    bubblesCreated: false,
                    
                    // 📊 SISTEMA DE NECESIDADES REALISTA (0-100)
                    needs: {
                        hunger: 80,  // Bebé nace con hambre (normal)
                        dirt: 0,     // PANTALLA LIMPIA AL INICIAR 
                        fun: 95      // EMPIEZA FELIZ
                    },
                    
                    // 🚨 FLAGS DE CRISIS (75+ es crisis)
                    crisis: {
                        hunger: false,
                        dirt: false, 
                        bored: false
                    },
                    
                    // Sistema de edad
                    birthDate: null,
                    ageInDays: 0,
                    // Nombre del pez
                    fishName: null,
                    hasAskedForName: false,
                    // Sistema de álbum/diario
                    album: [],
                    lastEventTime: Date.now()
                };
                
                // 🚫 VARIABLES DE CONTROL ELIMINADAS - YA NO SE NECESITAN
                
                // Sistema de huevo
                this.egg = {
                    x: 0, y: 0,
                    floatTime: 0,
                    bobSpeed: 2,
                    bobAmount: 8
                };
                
                // Imágenes del huevo
                this.eggImages = {};
                this.bgImage = null;
                this.loadAssets();
                
                // Efectos
                this.bgBubbles = [];
                this.explosionBubbles = [];
                this.lightRays = [];
                this.explosionHappened = false;
                
                // 🍎 ARRAYS DEL SISTEMA REALISTA
                this.food = [];           // Comida que cae
                this.cleanBubbles = [];   // Burbujas de limpieza  
                this.tinyBubbles = [];    // Burbujas de respiración
                this.flyers = [];         // Corazones voladores
                this.floatingMessages = []; // Mensajes sutiles del pez
                this.ripples = [];        // Ondas de click
                this.labels = [];         // Textos flotantes
                
                // 🧹 ESTADO DE LIMPIEZA
                this.cleaningActive = false;
                this.cleanEmitT = 0;
                this.cleanDur = 2.6;
                this.dirtStart = 0;
                
                // ⏰ TIEMPO DEL JUEGO (para animaciones)
                this.gameTime = 0;
                
                // Burbujas de necesidades
                this.needBubbles = [];
                
                // Pez
                this.fish = null;
                this.lottieAnimation = null;
                
                this.setupBubbles();
                
                // NUNCA cargar datos en primera vez
                const isFirstTime = !localStorage.getItem('miPececito_hasPlayed');
                if (isFirstTime) {
                    console.log('🎉 Primera vez - Empezar completamente limpio');
                    // NO cargar nada, mantener estado inicial 'waiting'
                } else {
                    // Solo cargar si es veterano
                    if (!this.loadGame()) {
                        console.log('🆕 Veterano sin datos - empezar nuevo');
                    }
                }
                
                // Cargar fondos disponibles
                this.availableBackgrounds = [];
                this.loadAvailableBackgrounds();
                
                this.startLoop();
                this.startAutoSave();
                this.updateUI();
            }
            
            setupCanvas() {
                const resize = () => {
                    // VERSIÓN SIMPLE QUE FUNCIONABA
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 130; // 70px header + 60px botones
                    
                    // CANVAS SIEMPRE DESDE EL HEADER (SIN ESPACIO AZUL)
                    this.canvas.style.top = '70px'; // SIEMPRE PEGADO AL HEADER
                    this.canvas.style.position = 'fixed';
                    this.canvas.style.left = '0';
                    this.canvas.style.right = '0';
                    this.canvas.style.bottom = '60px'; // Espacio para botones compactos
                    
                    // 🧱 CALCULAR Y GUARDAR LÍMITES DINÁMICOS (con delay para asegurar que el canvas esté listo)
                    setTimeout(() => {
                        this.calculateAndSaveBoundaries();
                    }, 100);
                };
                window.addEventListener('resize', resize);
                resize();
                
                // AÑADIR EVENT LISTENER PARA CLICK EN CANVAS
                this.canvas.addEventListener('click', (event) => {
                    console.log('👆 Click detectado - usando FishSystem...');
                    this.fishSystem.handleCanvasClick(event);
                });
                
                console.log('👆 Click en canvas habilitado - El pez vendrá a tu dedo');
            }
            
            // 🧱 CALCULAR Y GUARDAR LÍMITES DINÁMICOS DEL PEZ
            calculateAndSaveBoundaries() {
                console.log('🧱 Calculando límites dinámicos del pez...');
                
                // Verificar que el canvas esté disponible
                if (!this.canvas) {
                    console.warn('⚠️ Canvas no disponible, usando límites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Obtener dimensiones reales del canvas
                const canvasRect = this.canvas.getBoundingClientRect();
                const actualWidth = canvasRect.width || this.canvas.width || window.innerWidth;
                const actualHeight = canvasRect.height || this.canvas.height || window.innerHeight - 130;
                
                console.log('🧱 Debug cálculo límites:');
                console.log(`  - canvasRect: ${canvasRect.width}x${canvasRect.height}`);
                console.log(`  - canvas.width/height: ${this.canvas.width}x${this.canvas.height}`);
                console.log(`  - window.inner: ${window.innerWidth}x${window.innerHeight}`);
                console.log(`  - actualWidth/Height: ${actualWidth}x${actualHeight}`);
                
                // Verificar dimensiones válidas
                if (actualWidth <= 0 || actualHeight <= 0) {
                    console.warn('⚠️ Dimensiones de canvas inválidas, usando límites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Calcular límites con márgenes seguros
                const fishSize = 60; // Tamaño aproximado del pez
                const safeMargin = 30; // Margen de seguridad
                
                // Calcular bottom de forma segura
                let bottomY;
                try {
                    bottomY = this.getFloorY ? this.getFloorY() : actualHeight - 60;
                } catch (e) {
                    console.warn('⚠️ Error al calcular getFloorY, usando valor por defecto');
                    bottomY = actualHeight - 60;
                }
                
                // CORREGIR CÁLCULO DE LÍMITES - Asegurar que el pez esté completamente visible
                const boundaries = {
                    left: fishSize / 2, // Mitad del pez desde el borde izquierdo
                    right: actualWidth - fishSize / 2, // Mitad del pez desde el borde derecho
                    top: 125, // Debajo del header
                    bottom: bottomY - 10, // Casi hasta el fondo para alcanzar la comida
                    width: actualWidth,
                    height: actualHeight,
                    timestamp: Date.now()
                };
                
                console.log('🧱 Límites calculados:');
                console.log(`  - left: ${boundaries.left}`);
                console.log(`  - right: ${boundaries.right} (ancho: ${actualWidth})`);
                console.log(`  - top: ${boundaries.top}`);
                console.log(`  - bottom: ${boundaries.bottom} (alto: ${actualHeight})`);
                
                // Verificar que los límites sean válidos
                if (boundaries.right <= boundaries.left || boundaries.bottom <= boundaries.top) {
                    console.warn('⚠️ Límites inválidos calculados, usando límites por defecto');
                    return this.getDefaultBoundaries();
                }
                
                // Guardar en el estado del juego
                if (this.gameState) {
                    this.gameState.boundaries = boundaries;
                }
                
                // Guardar en localStorage para persistencia
                try {
                    localStorage.setItem('miPececito_boundaries', JSON.stringify(boundaries));
                } catch (e) {
                    console.warn('⚠️ Error al guardar límites en localStorage:', e);
                }
                
                console.log('🧱 Límites calculados:', boundaries);
                console.log(`📱 Canvas: ${actualWidth}x${actualHeight}px`);
                console.log(`🐟 Área de movimiento: ${boundaries.right - boundaries.left}x${boundaries.bottom - boundaries.top}px`);
                
                return boundaries;
            }
            
            // 🧱 LÍMITES POR DEFECTO COMO FALLBACK
            getDefaultBoundaries() {
                const fishSize = 60;
                const defaultBoundaries = {
                    left: fishSize / 2, // Mitad del pez desde el borde izquierdo
                    right: window.innerWidth - fishSize / 2, // Mitad del pez desde el borde derecho
                    top: 125,
                    bottom: window.innerHeight - 130 - 10, // Casi hasta el fondo
                    width: window.innerWidth,
                    height: window.innerHeight - 130,
                    timestamp: Date.now()
                };
                
                console.log('🧱 Usando límites por defecto:', defaultBoundaries);
                return defaultBoundaries;
            }
            
            // 🧱 RECALCULAR LÍMITES MANUALMENTE (para debug)
            recalculateBoundaries() {
                console.log('🧱 Recalculando límites manualmente...');
                localStorage.removeItem('miPececito_boundaries'); // Forzar recálculo
                return this.calculateAndSaveBoundaries();
            }
            
            // 🧱 OBTENER LÍMITES GUARDADOS O CALCULAR NUEVOS
            getBoundaries() {
                // Intentar cargar límites guardados
                try {
                    const saved = localStorage.getItem('miPececito_boundaries');
                    if (saved) {
                        const boundaries = JSON.parse(saved);
                        const age = Date.now() - (boundaries.timestamp || 0);
                        
                        // Verificar que los límites sean válidos
                        if (boundaries && 
                            typeof boundaries.left === 'number' && 
                            typeof boundaries.right === 'number' &&
                            typeof boundaries.top === 'number' &&
                            typeof boundaries.bottom === 'number' &&
                            boundaries.right > boundaries.left &&
                            boundaries.bottom > boundaries.top) {
                            
                            // Si los límites son recientes (menos de 5 minutos), usarlos
                            if (age < 5 * 60 * 1000) {
                                console.log('🧱 Usando límites guardados (edad:', Math.round(age/1000), 's)');
                                return boundaries;
                            }
                        } else {
                            console.warn('⚠️ Límites guardados inválidos, recalculando...');
                        }
                    }
                } catch (e) {
                    console.warn('⚠️ Error al cargar límites guardados:', e);
                }
                
                // Si no hay límites válidos, calcular nuevos
                console.log('🧱 Calculando nuevos límites...');
                return this.calculateAndSaveBoundaries();
            }
            
            async loadAssets() {
                console.log('📁 Cargando assets...');
                
                // Cargar imágenes del huevo
                const eggStages = ['00', '01', '02', '03', '04'];
                for (const stage of eggStages) {
                    try {
                        const img = new Image();
                        img.src = `./images/fish/egg_${stage}_clean.png`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                        });
                        this.eggImages[stage] = img;
                        console.log(`✅ Cargado: egg_${stage}_clean.png`);
                    } catch (error) {
                        console.warn(`⚠️ No se pudo cargar egg_${stage}_clean.png`);
                    }
                }
                
                // Cargar fondo
                try {
                    this.bgImage = new Image();
                    this.bgImage.src = './images/backgrounds/Mi casa.png';
                    await new Promise((resolve, reject) => {
                        this.bgImage.onload = resolve;
                        this.bgImage.onerror = reject;
                    });
                    console.log('✅ Fondo cargado: Mi casa.png');
                } catch (error) {
                    console.warn('⚠️ No se pudo cargar Mi casa.png');
                }
            }
            
            setupBubbles() {
                // Burbujas de fondo
                for (let i = 0; i < 15; i++) {
                    this.bgBubbles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        r: 1 + Math.random() * 4,
                        speed: 20 + Math.random() * 30,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            startLoop() {
                let lastTime = 0;
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
            
            update(deltaTime) {
                this.gameTime += deltaTime; // Actualizar tiempo del juego
                
                // Posición del huevo (centro de la pantalla)
                this.egg.x = this.canvas.width / 2;
                this.egg.y = this.canvas.height * 0.6;
                this.egg.floatTime += deltaTime;
                
                // Burbujas de fondo
                for (const bubble of this.bgBubbles) {
                    bubble.y -= bubble.speed * deltaTime;
                    if (bubble.y < 0) {
                        bubble.y = this.canvas.height + 10;
                        bubble.x = Math.random() * this.canvas.width;
                    }
                }
                
                // Actualizar burbujas de explosión
                for (let i = this.explosionBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.explosionBubbles[i];
                    bubble.x += bubble.vx * deltaTime;
                    bubble.y += bubble.vy * deltaTime;
                    bubble.life -= deltaTime;
                    
                    if (bubble.life <= 0) {
                        this.explosionBubbles.splice(i, 1);
                    }
                }
                
                // Actualizar rayos de luz
                for (let i = this.lightRays.length - 1; i >= 0; i--) {
                    const ray = this.lightRays[i];
                    ray.length = Math.min(ray.length + 200 * deltaTime, ray.maxLength);
                    ray.life -= deltaTime;
                    
                    if (ray.life <= 0) {
                        this.lightRays.splice(i, 1);
                    }
                }
                
                // Lógica de eclosión (solo si hay huevo colocado)
                if (this.gameState.stage === 'egg' && this.gameState.eggStartTime) {
                    const elapsed = Date.now() - this.gameState.eggStartTime;
                    const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                    
                    if (elapsed >= total) {
                        this.startHatching();
                    }
                }
                
                // Movimiento del pez (todas las etapas)
                if (this.fish && (this.gameState.stage === 'baby' || this.gameState.stage === 'young' || this.gameState.stage === 'adult')) {
                    // 🚀 SISTEMA REALISTA COMPLETO
                    console.log('🎯 Actualizando necesidades con NeedsSystem...');
                    this.needsSystem.updateAllNeeds(deltaTime);      // Necesidades automáticas
                    this.updateFood(deltaTime);           // 🍎 COMIDA DEL DOCUMENTO
                    this.updateCleaning(deltaTime);       // 🧹 LIMPIEZA ESPECTACULAR
                    console.log('🐠 Actualizando movimiento con FishSystem...');
                    this.fishSystem.updateFishMovement(deltaTime);    // Movimiento realista
                    // this.fishSystem.updateBubbles(deltaTime);         // Burbujas de la boca - TEMPORALMENTE DESHABILITADO
                    this.updateTinyBubbles(deltaTime);     // Burbujas de respiración
                    this.updateFlyers(deltaTime);          // Corazones voladores
                    this.updateLabels(deltaTime);          // 🍎 LABELS ("Ñam")
                    this.updateEatingParticles(deltaTime); // ✨ PARTÍCULAS DE COMIDA
                    this.updateRewardParticles(deltaTime); // 🎆 PARTÍCULAS DE RECOMPENSA
                    this.updateFloatingMessages(deltaTime); // 💬 MENSAJES FLOTANTES
                    
                    // Actualizar UI cada pocos segundos
                    if (Math.random() < 0.05) { // MÁS FRECUENTE PARA DEBUG (era 0.01)
                        this.updateUI();
                        this.checkForAlbumEvents(); // Verificar eventos del álbum
                        this.checkEvolution(); // Verificar evolución
                    }
                }
                
                // Actualizar burbujas de necesidades (DESACTIVADO - ICONOS SOBRAN)
                // for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                //     const bubble = this.needBubbles[i];
                //     bubble.life -= deltaTime;
                //     bubble.y += Math.sin(bubble.life * 3) * 10 * deltaTime;
                //     
                //     if (bubble.life <= 0) {
                //         this.needBubbles.splice(i, 1);
                //     }
                // }
            }
            
        render() {
            // 🎯 VOLVER AL SISTEMA SIMPLE QUE FUNCIONABA
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.globalCompositeOperation = 'source-over';
                
                // Fondo (coordenadas físicas normales)
                if (this.bgImage && this.bgImage.complete) {
                    this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo degradado como fallback
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#0b1b2b');
                    gradient.addColorStop(1, '#133754');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // ✨ EFECTOS MÁGICOS: MUCHAS BURBUJITAS QUE TAPAN EL HUEVO
                if (this.gameState.stage === 'egg' && this.gameState.showMagicBubbles) {
                    this.ctx.save();
                    
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const time = Date.now() * 0.001;
                    const effectTime = time - (this.gameState.magicStartTime || time);
                    
                    // FASE 1: MUCHÍSIMAS burbujitas pequeñas que TAPAN todo (primeros 2 segundos)
                    if (effectTime < 2) {
                        const density = Math.max(0, 1 - effectTime / 2); // Se reduce con el tiempo
                        const numBubbles = Math.floor(800 * density); // 800 → 0 burbujas (EXPLOSIÓN MASIVA)
                        
                        // CAPA 1: Burbujas grandes de fondo
                        for (let i = 0; i < Math.floor(numBubbles * 0.3); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 140;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 15 + Math.random() * 10; // Grandes (15-25px)
                            
                            this.ctx.globalAlpha = 0.3 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${180 + Math.random() * 60}, 70%, ${70 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 12;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 2: Burbujas medianas
                        for (let i = 0; i < Math.floor(numBubbles * 0.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 100;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 8 + Math.random() * 8; // Medianas (8-16px)
                            
                            this.ctx.globalAlpha = 0.5 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${190 + Math.random() * 40}, 80%, ${65 + Math.random() * 25}%)`;
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 3: Burbujitas pequeñas (las que más tapan)
                        for (let i = 0; i < Math.floor(numBubbles * 0.7); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 3 + Math.random() * 6; // Pequeñitas (3-9px)
                            
                            this.ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${60 + Math.random() * 30}%)`;
                            
                            // Muchas con brillo
                            if (Math.random() > 0.5) {
                                this.ctx.shadowBlur = 4;
                                this.ctx.shadowColor = this.ctx.fillStyle;
                            } else {
                                this.ctx.shadowBlur = 0;
                            }
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 4: Micro-burbujas como las del agua (MUCHÍSIMAS)
                        for (let i = 0; i < Math.floor(numBubbles * 1.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance + (Math.random() - 0.5) * 30;
                            const y = centerY + Math.sin(angle) * distance + (Math.random() - 0.5) * 30;
                            const size = 0.5 + Math.random() * 2; // Micro-burbujas (0.5-2.5px)
                            
                            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${75 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 1;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 5: Espuma densa (como burbujas de jabón)
                        for (let i = 0; i < Math.floor(numBubbles * 2); i++) {
                            const x = centerX + (Math.random() - 0.5) * 160;
                            const y = centerY + (Math.random() - 0.5) * 160;
                            const size = 0.3 + Math.random() * 1.5; // Súper micro (0.3-1.8px)
                            
                            this.ctx.globalAlpha = 0.4 + Math.random() * 0.3;
                            this.ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#f0f8ff';
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    // FASE 2: Burbujas decorativas flotantes (después de 1.5s)
                    if (effectTime > 1.5) {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + time * 0.3;
                            const distance = 100 + Math.sin(time * 2 + i) * 40;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance + Math.sin(time * 1.5 + i) * 25;
                            const size = 8 + Math.sin(time * 4 + i) * 4;
                            
                            this.ctx.globalAlpha = 0.5 + Math.sin(time * 3 + i) * 0.3;
                            this.ctx.fillStyle = i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#add8e6' : '#b0e0e6';
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // 🫧 BURBUJITAS SUTILES DEL AGUA (AMBIENTE)
                this.drawAmbientBubbles();
                
                // 🍎 DIBUJAR COMIDA ANTES DEL PEZ (COMO DICE CHAT)
                this.drawFood();
                
                // Burbujas de fondo (sistema original - REACTIVADO)
                this.drawBackgroundBubbles();
                
                // Haces de luz ocasionales durante el juego
                this.drawOccasionalLightRays();
                
                // Efecto de suciedad en toda la pecera
                this.drawDirtyEffect();
                
                // Huevo (solo si está en stage 'egg')
                if (this.gameState.stage === 'egg') {
                    this.drawEgg();
                    this.drawEggTimer(); // Timer bonito en pantalla
                } else if (this.gameState.stage === 'waiting') {
                    // ESPERANDO: No hacer nada, solo esperar click del usuario
                }
                
                // Burbujas de explosión
                this.drawExplosionBubbles();
                
                // Pez (solo si no es Lottie)
                if (this.fish && !this.fish.isLottie) {
                    console.log('🎨 Dibujando pez con FishSystem...');
                    this.fishSystem.drawFish();
                    // this.fishSystem.drawBubbles(); // TEMPORALMENTE DESHABILITADO
                }
                
                // Actualizar posición del Lottie
                if (this.fish && this.fish.isLottie) {
                    this.updateLottiePosition();
                }
                
                // Partículas de comida (DESACTIVADO - CONFLICTO)
                // this.drawFoodParticles();
                
                // Comida cayendo (DESACTIVADO - CONFLICTO)  
                // this.drawFallingFood();
                
                // Burbujas de limpieza
                this.drawCleaningBubbles();
                
                // Burbujas de necesidades (DESACTIVADAS)
                // this.drawNeedBubbles();
                
                // Efectos de comer (DESACTIVADOS)
                // this.drawEatingEffects();
                
                // Textos flotantes (DESACTIVADOS)
                // this.drawFloatingTexts();
                
                // Burbujas de necesidades (DESACTIVADAS)  
                // this.drawNeedBubbles();
                
                // 🧹 DIBUJAR BURBUJAS SIMPLE (REVERTIR A VERSIÓN QUE FUNCIONABA)
                this.drawCleanBubbles();
                
                // 💖 DIBUJAR CORAZONES VOLADORES
                this.drawFlyers();
                
                // ✨ DIBUJAR PARTÍCULAS DE COMIDA
                this.drawEatingParticles();
                
                // 🎆 DIBUJAR PARTÍCULAS DE RECOMPENSA
                this.drawRewardParticles();
                
                // 💬 DIBUJAR MENSAJES FLOTANTES
                this.drawFloatingMessages();
                
                // 🍎 DIBUJAR LABELS ("Ñam") ENCIMA DE TODO
                this.drawLabels();
                
                // 🍎 COMIDA YA SE DIBUJA ANTES DEL PEZ (LÍNEA 3743)
            }
            
            // 🖌️ MÉTODOS DE RENDERIZADO
            
            drawBackgroundBubbles() {
                // SISTEMA SIMPLE Y FUNCIONAL
                this.ctx.save();
                
                for (let i = this.bgBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bgBubbles[i];
                    
                    // 🫧 TODAS LAS BURBUJAS (TEST + NUEVAS + EFECTOS)
                    if (bubble.isTestBubble || bubble.type) {
                        // Actualizar posición
                        bubble.x += bubble.vx * 0.016; // deltaTime aproximado
                        bubble.y += bubble.vy * 0.016;
                        
                        // Actualizar vida (compatible con ambos sistemas)
                        if (bubble.maxLife) {
                            bubble.life += 0.016; // Incrementar para nuevas burbujas
                        } else {
                            bubble.life--; // Decrementar para burbujas viejas
                        }
                        
                        // Eliminar si se acabó la vida (compatible con ambos sistemas)
                        const shouldRemove = bubble.maxLife ? 
                            (bubble.life >= bubble.maxLife) : // Nuevas: life >= maxLife
                            (bubble.life <= 0); // Viejas: life <= 0
                            
                        if (shouldRemove) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar burbuja
                        this.ctx.save();
                        
                        if (bubble.sparkle) {
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = bubble.color;
                        }
                        
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 0.8;
                        this.ctx.fillStyle = bubble.color;
                        this.ctx.beginPath();
                        this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                        continue;
                    }
                    
                    // 🎆 SISTEMA VIEJO (APARICIÓN)
                    if (bubble.isAppearanceEffect) {
                        bubble.x += bubble.vx;
                        bubble.y += bubble.vy;
                        bubble.life -= 16.67; // ~60fps
                        
                        // Eliminar si se acabó la vida (EXCEPTO inmortales)
                        if (bubble.life <= 0 && !bubble.immortal) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Calcular alpha basado en vida restante
                        const maxLife = bubble.maxLife || 3000; // Fallback
                        const lifeRatio = bubble.life / maxLife;
                        bubble.opacity = (bubble.alpha || 1) * lifeRatio;
                    }
                    
                    this.ctx.save();
                    
                    // 🎆 EFECTO DE BRILLO PARA PARTÍCULAS MÁGICAS
                    if (bubble.sparkle) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = bubble.color || '#ffd700';
                        
                        // Brillo pulsante
                        const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                        this.ctx.globalAlpha = (bubble.alpha || bubble.opacity || 1) * pulse;
                    } else {
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 1;
                    }
                    
                    this.ctx.fillStyle = bubble.color || '#87ceeb';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size || bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // DEBUG: Log de burbujas rojas de aparición (DESACTIVADO)
                    // if (bubble.isAppearanceEffect && bubble.color === '#ff0000') {
                    //     console.log(`🔴 DIBUJANDO burbuja roja en (${bubble.x.toFixed(0)}, ${bubble.y.toFixed(0)}) tamaño ${bubble.r}`);
                    // }
                    this.ctx.restore();
                }
                
                this.ctx.restore(); // CERRAR SAVE INICIAL
            }
            
            drawEgg() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 horas
                const progress = Math.min(elapsed / total, 1);
                
                // 🎆 ANIMACIÓN SUAVE: SOLO FADE (SIN ESCALA BRUSCA)
                if (this.egg.appearing) {
                    // Solo fade in gradual (sin escala)
                    if (this.egg.alpha < this.egg.targetAlpha) {
                        this.egg.alpha += this.egg.fadeSpeed * 0.016; // Suave y controlado
                    }
                    
                    // Terminar animación cuando esté opaco
                    if (this.egg.alpha >= this.egg.targetAlpha) {
                        this.egg.appearing = false;
                        this.egg.alpha = 1;
                        console.log('✨ Animación suave completada');
                    }
                }
                
                // Obtener imagen correcta del huevo CON TRANSICIÓN
                const currentImage = this.getCurrentEggImage(progress);
                
                // 🎭 DETECTAR CAMBIO DE HUEVO Y HACER TRANSICIÓN
                if (!this.egg.lastImage) this.egg.lastImage = currentImage;
                if (currentImage !== this.egg.lastImage) {
                    console.log('🥚 ¡Huevo evolucionando! Transición suave...');
                    this.egg.lastImage = currentImage;
                    this.createEggTransitionEffect();
                }
                
                if (currentImage) {
                    // Animación de flotación
                    const floatOffset = Math.sin(this.egg.floatTime * this.egg.bobSpeed) * this.egg.bobAmount;
                    const drawY = this.egg.y + floatOffset;
                    
                    // TEMBLOR cuando se acerca la eclosión
                    let shakeX = 0;
                    let shakeY = 0;
                    
                    if (progress > 0.85) { // Últimos 15% = 3.6 horas
                        const shakeIntensity = (progress - 0.85) / 0.15; // 0 a 1
                        const maxShake = 6;
                        
                        shakeX = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        shakeY = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        
                        // Temblor INTENSO en los últimos segundos
                        if (progress > 0.98) { // Últimos 2%
                            shakeX *= 2.5;
                            shakeY *= 2.5;
                        }
                    }
                    
                    // Dibujar huevo MÁS GRANDE - USAR CSS VARIABLE
                    const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                    const eggWidth = eggSize; // Usar variable CSS
                    const eggHeight = eggSize; // Cuadrado perfecto
                    
                    this.ctx.save();
                    
                    // 🎆 APLICAR ANIMACIÓN DE APARICIÓN
                    const scale = this.egg.scale || 1;
                    const alpha = this.egg.alpha || 1;
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.translate(this.egg.x + shakeX, drawY + shakeY);
                    this.ctx.scale(scale, scale);
                    
                    this.ctx.drawImage(
                        currentImage,
                        -eggWidth/2,
                        -eggHeight/2,
                        eggWidth,
                        eggHeight
                    );
                    
                    // 🫧 BURBUJITAS SUTILES DE GESTACIÓN
                    this.drawEggGestationBubbles();
                    
                    // 🎆 CHISPORROTEO ALREDEDOR (COMO HIRVIENDO)
                    this.drawEggSizzleEffect();
                    
                    this.ctx.restore();
                } else {
                    // Fallback: huevo dibujado MÁS GRANDE
                    this.ctx.fillStyle = '#8ad7ff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(this.egg.x, this.egg.y, 50, 60, 0, 0, Math.PI * 2); // Más grande
                    this.ctx.fill();
                }
            }
            
            getCurrentEggImage(progress) {
                // 🥚 CADA MINUTO CAMBIA DE HUEVO (5 huevos en 5 minutos)
                if (progress < 0.2) return this.eggImages['00']; // Minuto 0-1
                if (progress < 0.4) return this.eggImages['01']; // Minuto 1-2  
                if (progress < 0.6) return this.eggImages['02']; // Minuto 2-3
                if (progress < 0.8) return this.eggImages['03']; // Minuto 3-4
                return this.eggImages['04']; // Minuto 4-5 (eclosión)
            }
            
            // ✨ EFECTOS SUAVES PARA APARICIÓN DEL HUEVO
            createSoftEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // 🌈 PARTÍCULAS DE COLORES SUAVES (como nacimiento del pez pero diferentes)
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (20 + Math.random() * 30),
                        vy: Math.sin(angle) * (20 + Math.random() * 30),
                        r: 3 + Math.random() * 4,
                        life: 0,
                        maxLife: 3 + Math.random() * 2,
                        opacity: 0.7 + Math.random() * 0.3,
                        color: i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#b0e0e6' : '#e0f6ff', // Azules suaves
                        type: 'soft-magic'
                    });
                }
                
                console.log('✨ 50 partículas suaves creadas para el huevo');
            }
            
            // 🎭 EFECTO DE TRANSICIÓN CUANDO CAMBIA EL HUEVO
            createEggTransitionEffect() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                // 🌟 PARTÍCULAS DORADAS DE EVOLUCIÓN (diferentes a las azules)
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (10 + Math.random() * 15),
                        vy: Math.sin(angle) * (10 + Math.random() * 15) - 20, // Hacia arriba
                        r: 2 + Math.random() * 3,
                        life: 0,
                        maxLife: 1.5 + Math.random() * 1,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: i % 2 === 0 ? '#ffd700' : '#ffec8b', // Dorado suave
                        type: 'egg-evolution'
                    });
                }
                
                console.log('🌟 Efecto de evolución del huevo creado');
            }
            
            // 🎆 EXPLOSIÓN DE BURBUJAS PARA APARICIÓN DEL HUEVO (COMO NACIMIENTO)
            createEggExplosionBubbles() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('✨ Creando efecto de aparición del huevo (estilo nacimiento)');
                
                // LIMPIAR explosionBubbles para el huevo
                this.explosionBubbles.length = 0;
                
                // EXPLOSIÓN DE BURBUJAS - VERSIÓN HUEVO (colores diferentes)
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 80; // Velocidad variada
                    const size = 3 + Math.random() * 8; // Tamaños variados
                    const life = 3 + Math.random() * 2; // Duraderas
                    
                    // Colores DORADOS y BLANCOS (diferentes al nacimiento)
                    const colors = ['#FFFFFF', '#FFF8DC', '#FFEBCD', '#F0E68C', '#FFD700', '#FFA500', '#FFEC8B'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: size,
                        life: life, // VIDA INICIAL
                        maxLife: life,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: color,
                        type: 'egg-birth'
                    });
                }
                
                console.log('🎆 100 burbujas doradas creadas para aparición del huevo');
            }
            
            // 🎆 EFECTO CHISPORROTEO ALREDEDOR DEL HUEVO (COMO HIRVIENDO)
            drawEggSizzleEffect() {
                const time = Date.now() * 0.003; // Tiempo rápido para chispas
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                const radius = eggSize * 0.6; // Alrededor del huevo
                
                // 🎇 8 CHISPAS ROTANDO ALREDEDOR
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time; // Rotación
                    const sparkRadius = radius + Math.sin(time * 3 + i) * 8; // Vibración
                    const x = Math.cos(angle) * sparkRadius;
                    const y = Math.sin(angle) * sparkRadius;
                    
                    // Chispa con transparencia variable
                    const opacity = 0.3 + Math.sin(time * 4 + i * 0.5) * 0.3;
                    const size = 2 + Math.sin(time * 5 + i) * 1;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = i % 2 === 0 ? '#ffeb3b' : '#ff9800'; // Amarillo/naranja
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // 🔥 PARTÍCULAS ASCENDENTES (como vapor)
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const startRadius = radius * 0.8;
                    const x = Math.cos(angle) * startRadius;
                    const y = Math.sin(angle) * startRadius;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -20 - Math.random() * 15, // Hacia arriba
                        r: 1 + Math.random() * 2,
                        life: 0,
                        maxLife: 1 + Math.random() * 0.5,
                        opacity: 0.4 + Math.random() * 0.3,
                        color: '#fff8e1', // Vapor blanquecino
                        type: 'egg-sizzle'
                    });
                }
            }
            
            drawEggTimer() {
                if (this.gameState.stage !== 'egg' || !this.gameState.eggStartTime) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 HORAS
                const remaining = Math.max(0, total - elapsed);
                
                // DEBUG: Verificar que el tiempo avanza
                if (Math.random() < 0.02) { // Log más frecuente para debug
                    console.log(`⏰ Timer Debug:`);
                    console.log(`   Current: ${new Date(currentTime).toLocaleTimeString()}`);
                    console.log(`   EggStart: ${new Date(this.gameState.eggStartTime).toLocaleTimeString()}`);
                    console.log(`   Elapsed: ${(elapsed/1000/60).toFixed(1)}min`);
                    console.log(`   Remaining: ${(remaining/1000/60).toFixed(1)}min`);
                }
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                // Progreso para efectos del cronómetro
                const timerProgress = elapsed / total;
                
                // CRONÓMETRO BONITO EN PANTALLA
                const centerX = this.canvas.width / 2;
                const timerY = 80; // Más arriba y visible
                
                this.ctx.save();
                
                // CRONÓMETRO SUTIL SIN FONDO NEGRO
                this.ctx.textAlign = 'center';
                
                // Sombra sutil para el texto
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 8;
                this.ctx.shadowOffsetY = 2;
                
                // Título más sutil SIN EMOJI
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 16px system-ui'; // Reducido para móvil
                this.ctx.fillText('Nacerá en:', centerX, timerY - 20);
                
                // Countdown principal
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 20px system-ui'; // Reducido para móvil
                
                let timeText;
                if (hours > 0) {
                    timeText = `${hours}h ${minutes}m ${seconds}s`; // SIEMPRE mostrar segundos
                } else if (minutes > 0) {
                    timeText = `${minutes}m ${seconds}s`;
                } else {
                    // Últimos segundos - MUY dramático
                    this.ctx.fillStyle = remaining < 10000 ? '#ff6b6b' : '#ffeb3b';
                    timeText = `${seconds}s`;
                }
                
                this.ctx.fillText(timeText, centerX, timerY);
                
                this.ctx.restore();
            }
            
            drawLightRays() {
                for (const ray of this.lightRays) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height * 0.6;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.opacity * (ray.life / ray.maxLife);
                    this.ctx.strokeStyle = '#ffdd44';
                    this.ctx.lineWidth = ray.width;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffdd44';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(ray.angle) * ray.length,
                        centerY + Math.sin(ray.angle) * ray.length
                    );
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            // ✨ HACES DE LUZ OCASIONALES
            drawOccasionalLightRays() {
                // Inicializar timer de rayos si no existe
                if (!this.lightRayTimer) this.lightRayTimer = 0;
                if (!this.occasionalRays) this.occasionalRays = [];
                
                this.lightRayTimer += 1/60; // Asumiendo 60fps
                
                // Crear rayos ocasionalmente (cada 20-40 segundos)
                if (this.lightRayTimer > 20 + Math.random() * 20) {
                    this.createOccasionalLightRay();
                    this.lightRayTimer = 0;
                }
                
                // Dibujar y actualizar rayos existentes
                for (let i = this.occasionalRays.length - 1; i >= 0; i--) {
                    const ray = this.occasionalRays[i];
                    
                    // Actualizar rayo
                    ray.life -= 1/60;
                    ray.alpha = Math.max(0, ray.life / ray.maxLife);
                    
                    // Eliminar si expiró
                    if (ray.life <= 0) {
                        this.occasionalRays.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar REFLEJO SUTIL como luz real del sol
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.alpha * 0.08; // SÚPER sutil
                    this.ctx.globalCompositeOperation = 'lighter';
                    
                    const gradient = this.ctx.createLinearGradient(ray.x1, ray.y1, ray.x2, ray.y2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(0.2, 'rgba(255, 255, 240, 0.3)'); // Amarillo muy suave
                    gradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.4)'); // Azul casi transparente
                    gradient.addColorStop(0.8, 'rgba(255, 255, 240, 0.2)'); // Amarillo suave otra vez
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = ray.width * 0.8; // Más finos
                    this.ctx.shadowBlur = 1;
                    this.ctx.shadowColor = 'rgba(255, 255, 240, 0.2)';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(ray.x1, ray.y1);
                    this.ctx.lineTo(ray.x2, ray.y2);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
            }
            
            createOccasionalLightRay() {
                // Crear 2-4 REFLEJOS DEL SOL desde arriba
                const numRays = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numRays; i++) {
                    // Rayos vienen desde arriba con ángulos naturales
                    const startX = Math.random() * this.canvas.width;
                    const startY = -50; // Empiezan fuera de la pantalla arriba
                    
                    // Ángulo hacia abajo con ligera inclinación
                    const angle = Math.PI/2 + (Math.random() - 0.5) * 0.6; // 90° ± 30°
                    const length = this.canvas.height + 100; // Atraviesan toda la pantalla
                    
                    const ray = {
                        x1: startX,
                        y1: startY,
                        x2: startX + Math.cos(angle) * length,
                        y2: startY + Math.sin(angle) * length,
                        width: 2 + Math.random() * 3,
                        life: 5 + Math.random() * 4, // Más duraderos
                        maxLife: 5 + Math.random() * 4,
                        alpha: 1
                    };
                    
                    this.occasionalRays.push(ray);
                }
                
                console.log(`☀️ Reflejos del sol creados (${numRays} rayos desde arriba)`);
            }
            
            // 🦠 EFECTO DE SUCIEDAD UNIFICADO (BASADO EN BARRAS)
            drawDirtyEffect() {
                // USAR EL MISMO SISTEMA QUE LAS BARRAS
                const dirtValue = this.gameState.needs.dirt; // 0-100
                
                if (dirtValue > 15) { // Efecto visual más temprano (era 30)
                    // Calcular nivel de suciedad (0 a 1)
                    const dirtLevel = Math.min((dirtValue - 15) / 85, 1); // Escala desde 15-100
                    
                    // Crear overlay de suciedad MÁS SUTIL
                    this.ctx.save();
                    this.ctx.globalAlpha = dirtLevel * 0.15; // Máximo 15% opacidad (más sutil)
                    this.ctx.globalCompositeOperation = 'multiply';
                    
                    // Gradiente de suciedad
                    const gradient = this.ctx.createRadialGradient(
                        this.canvas.width / 2, this.canvas.height / 2, 0,
                        this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                    );
                    gradient.addColorStop(0, 'rgba(139, 115, 85, 0.2)'); // Marrón claro centro
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)'); // Marrón medio
                    gradient.addColorStop(1, 'rgba(62, 39, 35, 0.6)'); // Marrón oscuro bordes
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Partículas de suciedad flotando
                    if (!this.dirtParticles) this.dirtParticles = [];
                    
                    // Crear partículas ocasionalmente
                    if (Math.random() < 0.02 * dirtLevel) {
                        this.dirtParticles.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            size: 1 + Math.random() * 3,
                            life: 5 + Math.random() * 5,
                            maxLife: 5 + Math.random() * 5,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10
                        });
                    }
                    
                    // Dibujar partículas de suciedad
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = Math.min(0.9, dirtLevel * 2.0); // MUCHO MÁS OPACO
                    
                    for (let i = this.dirtParticles.length - 1; i >= 0; i--) {
                        const particle = this.dirtParticles[i];
                        
                        // Actualizar partícula
                        particle.x += particle.vx * (1/60);
                        particle.y += particle.vy * (1/60);
                        particle.life -= 1/60;
                        
                        // Eliminar si expiró
                        if (particle.life <= 0) {
                            this.dirtParticles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar partícula sucia
                        const alpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha = alpha * dirtLevel * 1.5; // MUCHO MÁS DENSA
                        this.ctx.fillStyle = '#8b7355';
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                    
                    // OVERLAY GENERAL DE SUCIEDAD (agua SUPER turbia como algas)
                    this.ctx.globalAlpha = Math.min(0.8, dirtLevel * 1.5); // MUCHO más denso
                    
                    // Gradiente marrón-verde como algas
                    const dirtGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    dirtGradient.addColorStop(0, 'rgba(139, 115, 85, 0.6)'); // Marrón arriba
                    dirtGradient.addColorStop(0.5, 'rgba(101, 67, 33, 0.8)'); // Marrón oscuro medio
                    dirtGradient.addColorStop(1, 'rgba(46, 125, 50, 0.7)'); // Verde algas abajo
                    
                    this.ctx.fillStyle = dirtGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.globalAlpha = 1;
                    
                    // Log ocasional
                    if (Math.random() < 0.005) {
                        console.log(`🦠 Pecera sucia - Nivel: ${dirtValue.toFixed(1)}% (barra unificada)`);
                    }
                } else {
                    // Limpiar partículas cuando no está sucio
                    if (this.dirtParticles) {
                        this.dirtParticles = [];
                    }
                }
            }
            
            drawExplosionBubbles() {
                for (const bubble of this.explosionBubbles) {
                    this.ctx.save();
                    
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha;
                    
                    if (bubble.isLight) {
                        // Partículas de luz
                        this.ctx.fillStyle = '#ffeb3b';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#ffeb3b';
                    } else {
                        // Burbujas normales
                        this.ctx.fillStyle = `hsl(${200 + Math.random() * 60}, 70%, 80%)`;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(bubble.x - 1, bubble.y - 1, 2, 2);
                    }
                    
                    this.ctx.restore();
                }
            }
            
            // 🐠 FUNCIÓN drawFish() ELIMINADA - AHORA EN fish-system.js
            
            // 📏 FUNCIÓN getFishSizeForStage() ELIMINADA - AHORA EN fish-system.js
            
            // 🎨 FUNCIÓN getFishColors() ELIMINADA - AHORA EN fish-system.js
            
            // 📏 FUNCIÓN getStripeWidth() ELIMINADA - AHORA EN fish-system.js
            
            // 🫧 FUNCIÓN createFishBubble() ELIMINADA - AHORA EN fish-system.js
            
            // drawNeedBubbles() - ELIMINADO (ahora en needs-system.js)
            
            // 🐣 SISTEMA DE ECLOSIÓN
            
            startHatching() {
                if (this.gameState.stage !== 'egg') return;
                
                console.log('🐣 ¡ECLOSIÓN SIMULTÁNEA!');
                
                // 🔊 SONIDO DE ECLOSIÓN
                if (window.audioManager) {
                    window.audioManager.playSound('hatch');
                }
                
                // CREAR PEZ INMEDIATAMENTE (simultáneo con burbujas)
                this.createFish();
                this.gameState.stage = 'baby';
                
                // Burbujas de eclosión al mismo tiempo
                this.createExplosionBubbles();
                
                console.log('🥚➡️🐟 Huevo desaparece y pez aparece AL MISMO TIEMPO');
            }
            
            createEggBubbles() {
                console.log('🥚 Creando burbujitas blancas para el huevo');
                
                this.explosionBubbles.length = 0;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // BURBUJITAS BLANCAS SUAVES (COMO LAS DE NACIMIENTO PERO MÁS BLANCAS)
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 15 + Math.random() * 40; // Más suaves
                    const size = 2 + Math.random() * 8; // Más pequeñas
                    const life = 3 + Math.random() * 2;
                    
                    // COLORES MÁS BLANCOS
                    const colors = ['#FFFFFF', '#F8FCFF', '#F0F8FF', '#E8F4FF', '#E0F0FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 30,
                        y: centerY + (Math.random() - 0.5) * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20,
                        r: size,
                        life: life,
                        maxLife: life,
                        color: color,
                        alpha: 0.8
                    });
                }
                
                console.log('🥚 80 burbujitas blancas creadas para el huevo');
            }
            
            createExplosionBubbles() {
                if (this.explosionHappened) return;
                
                this.explosionBubbles.length = 0;
                this.lightRays.length = 0;
                this.explosionHappened = true;
                
                console.log('✨ Creando efecto suave de nacimiento');
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // EXPLOSIÓN MASIVA DE BURBUJAS - LLENAR TODA LA PANTALLA
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 100; // Velocidad variada
                    const size = 3 + Math.random() * 12; // Tamaños muy variados
                    const life = 4 + Math.random() * 3; // Más duraderas
                    
                    // Colores azules brillantes y blancos
                    const colors = ['#FFFFFF', '#E6F3FF', '#CCE7FF', '#99D6FF', '#66C7FF', '#33B8FF', '#00A9FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 30, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.3, // Más brillo
                        isLight: false
                    });
                }
                
                // ONDAS MASIVAS: 4 ondas consecutivas
                for (let wave = 0; wave < 4; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            const speed = 50 + Math.random() * 80;
                            const size = 2 + Math.random() * 8;
                            
                            this.explosionBubbles.push({
                                x: centerX + (Math.random() - 0.5) * 20,
                                y: centerY + (Math.random() - 0.5) * 20,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: size,
                                life: 3 + Math.random() * 2,
                                maxLife: 3 + Math.random() * 2,
                                sparkle: Math.random() < 0.4,
                                isLight: false
                            });
                        }
                    }, wave * 200);
                }
                
                console.log(`✨ Efecto suave creado: ${this.explosionBubbles.length} burbujas delicadas (sin rayos amarillos)`);
            }
            
            // createFish() - ELIMINADO (ahora en fish-system.js)
            
            // createLottieFish() - ELIMINADO (ahora en fish-system.js)
            
            // updateLottiePosition() - ELIMINADO (ahora en fish-system.js)
            
            // createCanvasFish() - ELIMINADO (ahora en fish-system.js)
            
            
            // updateNaturalFishMovement() - ELIMINADO (ahora en fish-system.js)
            
            // 👆 CLICK EN PANTALLA - PEZ VIENE AL DEDO (SISTEMA DEL DEMO)
            // 👆 FUNCIÓN handleCanvasClick() ELIMINADA - AHORA EN fish-system.js
            
            // 💖 LANZAR CORAZÓN QUE AUMENTA DIVERSIÓN (SOLO CUANDO TOCAS AL PEZ)
            launchHeartToFun(x, y) {
                // IMPORTANTE: Esta función solo debe llamarse cuando el usuario toca al pez
                // NO cuando el pez come
                
                // Si no se pasan coordenadas, usar posición del pez
                const startX = x !== undefined ? x : this.fish.x;
                const startY = y !== undefined ? y : this.fish.y;
                
                // Crear corazón visual
                const heart = {
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 50, // Velocidad horizontal aleatoria
                    vy: -80, // Velocidad hacia arriba
                    life: 2.0, // 2 segundos de vida
                    maxLife: 2.0,
                    size: 20 + Math.random() * 10,
                    color: ['💖', '❤️', '🧡', '💛', '💚', '💙', '💜'][Math.floor(Math.random() * 7)]
                };
                
                if (!this.flyers) this.flyers = [];
                this.flyers.push(heart);
                
                // 🎉 AUMENTAR DIVERSIÓN
                this.gameState.needs.fun = Math.min(100, this.gameState.needs.fun + 25); // +25 diversión (más feliz)
                this.needsSystem.updateCrisisFlags();
                this.needsSystem.updateNeedBars();
                
                console.log(`💖 Corazón lanzado por tocar al pez! Diversión: ${this.gameState.needs.fun}`);
                
                // 📸 EVENTO DE JUEGO OCASIONAL
                if (Math.random() < 0.08) { // 8% chance
                    const playMessages = [
                        '¡Me encanta jugar contigo! Eres el mejor cuidador.',
                        'Cuando vienes a jugar conmigo me siento súper feliz.',
                        '¡Qué divertido! Me gusta mucho cuando interactúas conmigo.',
                        'Estos momentos de juego son mis favoritos del día.',
                        'Gracias por dedicarme tiempo para jugar. ¡Eres genial!'
                    ];
                    const msg = playMessages[Math.floor(Math.random() * playMessages.length)];
                    this.addAlbumEvent('playing', '🎮 Momento de juego', msg);
                }
            }
            
            // YA NO NECESITAMOS CAMBIOS DE COMPORTAMIENTO
            // El pez simplemente NADA en una dirección hasta llegar al borde
            
            // 🍽️ SISTEMA DE HAMBRE - ELIMINADO (ahora en needs-system.js)
            
            // showHungerBubble() - ELIMINADO (ahora en needs-system.js)
            
            // showNeedBubble() - ELIMINADO (ahora en needs-system.js)
            
            // 🎯 MOSTRAR ICONO QUE SE MUEVE (APARECE/DESAPARECE/CAMBIA LUGAR)
            showFixedNeedIcon(bubbleId, needType) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Inicializar timer de movimiento si no existe
                if (!bubble.moveTimer) bubble.moveTimer = 0;
                if (!bubble.currentPosition) bubble.currentPosition = 0;
                
                bubble.moveTimer += 1/60;
                
                // Cambiar posición cada 8-15 segundos (MÁS LENTO)
                if (bubble.moveTimer > 8 + Math.random() * 7) {
                    bubble.currentPosition = (bubble.currentPosition + 1) % 4; // Rotar entre 4 posiciones
                    bubble.moveTimer = 0;
                    
                    // DESAPARECER MUY LENTAMENTE (1.5 segundos)
                    bubble.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
                    bubble.style.opacity = '0';
                    bubble.style.transform = 'scale(0.7)';
                    
                    setTimeout(() => {
                        // Cambiar posición mientras está invisible
                        this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                        
                        // APARECER MUY LENTAMENTE (2 segundos)
                        setTimeout(() => {
                            bubble.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
                            bubble.style.opacity = '1';
                            bubble.style.transform = 'scale(1)';
                        }, 200);
                        
                    }, 1500); // Esperar a que termine de desaparecer
                    
                    console.log(`🎯 Icono ${needType} se mueve SUAVEMENTE a nueva posición`);
                } else {
                    // Mantener posición actual
                    this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                }
                
                bubble.style.display = 'block';
            }
            
            updateIconPosition(bubble, bubbleId, positionIndex) {
                // 4 posiciones diferentes para cada icono
                const allPositions = [
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.25 }, // Superior izquierda
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.25 }, // Superior derecha
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.75 }, // Inferior derecha
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.75 }  // Inferior izquierda
                ];
                
                const pos = allPositions[positionIndex] || allPositions[0];
                
                bubble.style.left = pos.x + 'px';
                bubble.style.top = pos.y + 'px';
            }
            
            // 😢 SISTEMA DE APATÍA Y TRISTEZA
            // 🐠 FUNCIÓN updateFishMood() ELIMINADA - AHORA EN fish-system.js
            
            // updateAllNeedBubbles() - ELIMINADO (ahora en needs-system.js)
            
            // 📍 ACTUALIZAR POSICIONES DE BURBUJAS QUE SIGUEN AL PEZ
            updateVisibleBubblesPositions() {
                if (!this.fish) return;
                
                const bubbles = [
                    { id: 'hungerBubble', offsetX: 15, offsetY: -45 },
                    { id: 'dirtyBubble', offsetX: -60, offsetY: -30 },
                    { id: 'medicineBubble', offsetX: 60, offsetY: -30 },
                    { id: 'playBubble', offsetX: 0, offsetY: -70 }
                ];
                
                bubbles.forEach(bubbleInfo => {
                    const bubble = document.getElementById(bubbleInfo.id);
                    if (bubble && bubble.style.display !== 'none') {
                        // Actualizar posición para que siga al pez
                        bubble.style.left = (this.fish.x + bubbleInfo.offsetX) + 'px';
                        bubble.style.top = (this.fish.y + bubbleInfo.offsetY) + 'px';
                    }
                });
            }
            
            // 🍽️ ALIMENTAR DESDE BOTÓN (SISTEMA ANTIGUO - DESACTIVADO)
            startFeeding() {
                console.log('🍽️ startFeeding() DESACTIVADO - Usar dropFood() en su lugar');
                return;
                
                // Crear 3 bolitas con MEJOR ESPACIADO
                setTimeout(() => {
                    this.createFallingFood(1); // Primera comida
                }, 0);
                
                setTimeout(() => {
                    this.createFallingFood(2); // Segunda comida
                }, 800); // Después de 800ms
                
                setTimeout(() => {
                    this.createFallingFood(3); // Tercera comida
                }, 1600); // Después de 1.6s
                
                // Activar modo persecución del pez (velocidad más suave)
                this.fish.isChasing = true;
                this.fish.chaseSpeed = this.fish.speed * 1.5; // Solo 50% más rápido
                
                // Desactivar persecución después de 15 segundos
                setTimeout(() => {
                    if (this.fish) {
                        this.fish.isChasing = false;
                        console.log('🐠 Pez dejó de perseguir comida - Volviendo a comportamiento normal');
                    }
                }, 15000);
                
                // Actualizar tiempo de alimentación
                this.fish.lastFeedTime = Date.now();
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('🏃 ¡Pez activado en modo persecución! Velocidad x1.5 (más natural)');
            }
            
            // 🍽️ ALIMENTAR DESDE BURBUJA (MODO ORIGINAL)
            feedFish() {
                if (this.needsSystem) {
                    this.needsSystem.feedFish();
                }
            }
            
            
            // 🍖 CREAR COMIDA CON POSICIONES ESTRATÉGICAS
            createFallingFood(foodNumber) {
                // SISTEMA ANTIGUO - DESACTIVADO
                return;
                
                let startX;
                if (this.fish) {
                    const fishX = this.fish.x;
                    const canvasWidth = this.canvas.width;
                    
                    // POSICIONES ESTRATÉGICAS para cada comida
                    switch(foodNumber) {
                        case 1:
                            // Primera: A la izquierda del pez
                            startX = Math.max(80, fishX - 80 - Math.random() * 60);
                            break;
                        case 2:
                            // Segunda: A la derecha del pez
                            startX = Math.min(canvasWidth - 80, fishX + 80 + Math.random() * 60);
                            break;
                        case 3:
                            // Tercera: Cerca del pez (arriba o centro)
                            startX = fishX + (Math.random() - 0.5) * 100;
                            startX = Math.max(80, Math.min(canvasWidth - 80, startX));
                            break;
                        default:
                            startX = 100 + Math.random() * (canvasWidth - 200);
                    }
                } else {
                    // Si no hay pez, usar posición aleatoria
                    startX = 100 + Math.random() * (this.canvas.width - 200);
                }
                
                const food = {
                    x: startX,
                    y: this.canvas.height * 0.25, // Un poco más abajo
                    vy: 18 + Math.random() * 8, // Velocidad más lenta para dar tiempo
                    size: 9 + Math.random() * 3, // Tamaño más visible
                    life: 18, // Más tiempo para comer
                    maxLife: 18,
                    eaten: false,
                    type: Math.random() > 0.8 ? 'premium' : 'normal',
                    number: foodNumber
                };
                
                this.fallingFood.push(food);
                console.log(`🍖 Comida #${foodNumber} creada en x:${startX.toFixed(0)} (${foodNumber === 1 ? 'IZQUIERDA' : foodNumber === 2 ? 'DERECHA' : 'CENTRO'})`);
            }
            
            drawFoodParticles() {
                if (!this.foodParticles) return;
                
                // Actualizar y dibujar partículas
                for (let i = this.foodParticles.length - 1; i >= 0; i--) {
                    const particle = this.foodParticles[i];
                    
                    // Actualizar posición
                    particle.y += particle.vy * (1/60); // Asumiendo 60fps
                    particle.life -= 1/60;
                    
                    // Eliminar si expiró
                    if (particle.life <= 0) {
                        this.foodParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar partícula de comida
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    // Color marrón/dorado para la comida
                    this.ctx.fillStyle = '#D2691E';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pequeño brillo
                    this.ctx.fillStyle = '#F4A460';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x - 1, particle.y - 1, particle.size * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // 🍖 DIBUJAR Y ACTUALIZAR COMIDA CAYENDO
            drawFallingFood() {
                if (!this.fallingFood) return;
                
                // Actualizar y dibujar comida cayendo
                for (let i = this.fallingFood.length - 1; i >= 0; i--) {
                    const food = this.fallingFood[i];
                    
                    if (food.eaten) continue;
                    
                    // Actualizar posición
                    food.y += food.vy * (1/60);
                    food.life -= 1/60;
                    
                    // Eliminar si expiró o salió de pantalla
                    if (food.life <= 0 || food.y > this.canvas.height + 50) {
                        this.fallingFood.splice(i, 1);
                        continue;
                    }
                    
                    // Verificar si el pez la alcanzó
                    if (this.fish && !food.eaten) {
                        const distance = Math.sqrt(
                            Math.pow(this.fish.x - food.x, 2) + 
                            Math.pow(this.fish.y - food.y, 2)
                        );
                        
                        if (distance < 30) { // Pez alcanzó la comida (área más grande)
                            food.eaten = true;
                            this.createEatingEffect(food.x, food.y);
                            this.createBigEatingEffect(food.x, food.y, food.type);
                            console.log(`🍽️ ¡Pez comió comida ${food.type}! ¡ÑAM ÑAM!`);
                            
                            // ACTUALIZAR TIEMPO DE COMIDA Y ESTADO
                            this.fish.lastFeedTime = Date.now();
                            this.fish.excited = true; // ¡FELIZ AL COMER!
                            console.log('😊 ¡Pez feliz después de comer!');
                            
                            // Quitar felicidad después de 3 segundos
                            setTimeout(() => {
                                this.fish.excited = false;
                            }, 3000);
                            
                            // Quitar comida después de un momento
                            setTimeout(() => {
                                const index = this.fallingFood.indexOf(food);
                                if (index > -1) this.fallingFood.splice(index, 1);
                            }, 100);
                            continue;
                        }
                        
                    }
                    
                    // Dibujar comida
                    this.ctx.save();
                    
                    // Color según tipo
                    const color = food.type === 'premium' ? '#FFD700' : '#D2691E';
                    const highlightColor = food.type === 'premium' ? '#FFF8DC' : '#F4A460';
                    
                    // Sombra
                    this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetY = 2;
                    
                    // Comida principal
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo
                    this.ctx.fillStyle = highlightColor;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x - 2, food.y - 2, food.size * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Si el pez está persiguiendo, encontrar la comida más cercana
                if (this.fish && this.fish.isChasing && this.fallingFood.length > 0) {
                    this.findAndChaseClosestFood();
                }
            }
            
            // 🔍 ENCONTRAR Y PERSEGUIR LA COMIDA MÁS CERCANA
            findAndChaseClosestFood() {
                if (!this.fallingFood || this.fallingFood.length === 0) return;
                
                const fish = this.fish;
                let closestFood = null;
                let closestDistance = Infinity;
                
                // Encontrar la comida más cercana
                for (const food of this.fallingFood) {
                    if (food.eaten) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(fish.x - food.x, 2) + 
                        Math.pow(fish.y - food.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
                
                // Si encontramos comida, perseguirla
                if (closestFood) {
                    this.makeFishChaseFood(closestFood);
                }
            }
            
            // 🏃 HACER QUE EL PEZ PERSIGA LA COMIDA (SIN GIROS LOCOS)
            makeFishChaseFood(food) {
                const fish = this.fish;
                
                // Calcular dirección hacia la comida
                const dx = food.x - fish.x;
                const dy = food.y - fish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Velocidad de persecución más natural
                    const chaseSpeed = fish.chaseSpeed || (fish.speed * 1.5); // 50% más rápido
                    
                    // Normalizar y aplicar velocidad
                    fish.vx = (dx / distance) * chaseSpeed;
                    fish.vy = (dy / distance) * chaseSpeed;
                    
                    // SOLO cambiar orientación si hay un cambio SIGNIFICATIVO
                    const significantChange = Math.abs(dx) > 20; // Solo si está a más de 20px
                    if (significantChange) {
                        const newDirection = dx > 0 ? 1 : -1;
                        // Solo cambiar si es realmente diferente
                        if (newDirection !== fish.direction) {
                            fish.direction = newDirection;
                            console.log(`🔄 Pez cambió orientación: ${fish.direction === 1 ? 'DERECHA' : 'IZQUIERDA'}`);
                        }
                    }
                    
                    // Log menos spam
                    if (Math.random() < 0.1) { // Solo 10% de las veces
                        console.log(`🏃 Persiguiendo comida: ${distance.toFixed(0)}px`);
                    }
                }
            }
            
            // ✨ EFECTO AL COMER
            createEatingEffect(x, y) {
                // Pequeñas partículas al comer
                for (let i = 0; i < 5; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 30,
                        vy: (Math.random() - 0.5) * 30,
                        life: 0.5,
                        maxLife: 0.5,
                        size: 2 + Math.random() * 2,
                        color: '#FFD700'
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
            }
            
            // 💥 EFECTO GRANDE AL COMER
            createBigEatingEffect(x, y, type) {
                // Crear muchas partículas espectaculares
                const particleCount = type === 'premium' ? 15 : 10;
                const colors = type === 'premium' 
                    ? ['#FFD700', '#FFF8DC', '#FFFF00', '#FFE55C'] 
                    : ['#D2691E', '#F4A460', '#DEB887', '#CD853F'];
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 40 + Math.random() * 30;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 3 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
                
                // Texto "ÑAM ÑAM" flotante
                this.createFloatingText(x, y, type === 'premium' ? '¡ÑAM ÑAM!' : 'ñam ñam', 
                                       type === 'premium' ? '#FFD700' : '#D2691E');
            }
            
            // 📝 TEXTO FLOTANTE
            createFloatingText(x, y, text, color) {
                const textEffect = {
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 2,
                    maxLife: 2,
                    vy: -30 // Flota hacia arriba
                };
                
                if (!this.floatingTexts) this.floatingTexts = [];
                this.floatingTexts.push(textEffect);
            }
            
            // 🎨 DIBUJAR EFECTOS DE COMER
            drawEatingEffects() {
                if (!this.eatingEffects) return;
                
                for (let i = this.eatingEffects.length - 1; i >= 0; i--) {
                    const particle = this.eatingEffects[i];
                    
                    // Actualizar partícula
                    particle.x += particle.vx * (1/60);
                    particle.y += particle.vy * (1/60);
                    particle.life -= 1/60;
                    
                    // Eliminar si expiró
                    if (particle.life <= 0) {
                        this.eatingEffects.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar partícula
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // 📝 DIBUJAR TEXTOS FLOTANTES
            drawFloatingTexts() {
                if (!this.floatingTexts) return;
                
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    // Actualizar texto
                    text.y += text.vy * (1/60);
                    text.life -= 1/60;
                    
                    // Eliminar si expiró
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar texto
                    const alpha = text.life / text.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.fillStyle = text.color;
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.textAlign = 'center';
                    
                    // Contorno blanco
                    this.ctx.strokeText(text.text, text.x, text.y);
                    // Texto principal
                    this.ctx.fillText(text.text, text.x, text.y);
                    
                    this.ctx.restore();
                }
            }
            
            // ⏰ AVANZAR TIEMPO DEL JUEGO (WRAPPER)
            advanceTime(hours) {
                this.advanceGameTime(hours);
            }
            
            // ⏰ AVANZAR TIEMPO DEL JUEGO (DEBUG)
            advanceGameTime(hours) {
                if (!this.fish) return;
                
                const timeAdvance = hours * 60 * 60 * 1000; // Convertir horas a milisegundos
                
                // Avanzar TODOS los tiempos del juego
                if (this.fish.lastFeedTime) {
                    this.fish.lastFeedTime -= timeAdvance; // Retroceder = como si hubiera pasado tiempo
                }
                
                if (this.gameState.lastPlay) {
                    this.gameState.lastPlay -= timeAdvance;
                }
                
                if (this.gameState.lastClean) {
                    this.gameState.lastClean -= timeAdvance;
                }
                
                if (this.gameState.birthDate) {
                    this.gameState.birthDate -= timeAdvance; // Hacer más viejo
                }
                
                // Actualizar edad
                this.updateAgeDisplay();
                
                // Forzar actualización de necesidades - simular tiempo transcurrido
                const cfg = this.getStageCfg(this.gameState);
                const hoursPassed = hours;
                
                // Aumentar hambre, suciedad y disminuir diversión
                const hungerIncrease = (100 / cfg.hungerHours) * hoursPassed;
                const dirtIncrease = (100 / cfg.dirtHours) * hoursPassed;
                const funDecrease = (100 / cfg.funHours) * hoursPassed;
                
                this.gameState.needs.hunger = Math.min(100, this.gameState.needs.hunger + hungerIncrease);
                this.gameState.needs.dirt = Math.min(100, this.gameState.needs.dirt + dirtIncrease);
                this.gameState.needs.fun = Math.max(0, this.gameState.needs.fun - funDecrease);
                
                this.needsSystem.updateCrisisFlags();
                this.needsSystem.updateNeedBars();
                this.updateButtonStates();
                
                console.log(`⏰ Tiempo del juego avanzado +${hours} hora(s)`);
                console.log(`🍽️ Última comida: hace ${Math.round((Date.now() - this.fish.lastFeedTime) / (60*60*1000))} horas`);
                console.log(`📊 Necesidades actualizadas: Hambre: ${this.gameState.needs.hunger.toFixed(1)}%, Suciedad: ${this.gameState.needs.dirt.toFixed(1)}%, Diversión: ${this.gameState.needs.fun.toFixed(1)}%`);
            }
            
            // 🎮 ACTUALIZAR ESTADO DE BOTONES
            updateButtonStates() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales según la edad
                let hungerThreshold, cleanThreshold, medicineThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 día
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas descuido
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000; // 2 días
                        medicineThreshold = 14 * 60 * 60 * 1000; // 14 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000; // 3 días
                        medicineThreshold = 26 * 60 * 60 * 1000; // 26 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                }
                
                // Verificar necesidades BASADAS EN LOS VALORES REALES
                const needsFood = this.gameState.needs.hunger > 20; // Si hambre > 20%, activar botón (AJUSTADO)
                const needsCleaning = true; // LIMPIEZA SIEMPRE DISPONIBLE
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                
                // Actualizar botones (MEDICINA ELIMINADA) - MÁS DEBUG
                console.log('🔘 BOTONES DEBUG:', 
                    'Hambre:', this.gameState.needs.hunger.toFixed(1) + '% → needsFood:', needsFood,
                    'Suciedad:', this.gameState.needs.dirt.toFixed(1) + '% → needsCleaning:', needsCleaning,
                    'Umbral limpieza: >10%');
                    
                // DEBUG EXTRA para limpieza
                if (this.gameState.needs.dirt > 50) {
                    console.log('🧹 LIMPIEZA DEBUG EXTRA:', 
                        'dirt:', this.gameState.needs.dirt,
                        'needsCleaning:', needsCleaning,
                        'cleanBtn existe:', !!document.getElementById('cleanBtn'));
                }
                this.toggleButton('feedBtn', needsFood);
                this.toggleButton('cleanBtn', needsCleaning);
                // this.toggleButton('medicineBtn', needsMedicine); // ELIMINADO
            }
            
            // 🔘 HABILITAR/DESHABILITAR BOTÓN
            toggleButton(buttonId, enabled) {
                const button = document.getElementById(buttonId);
                if (!button) {
                    console.log(`❌ toggleButton: Botón ${buttonId} NO ENCONTRADO`);
                    return;
                }
                
                console.log(`🔘 toggleButton: ${buttonId} → ${enabled ? 'HABILITADO' : 'DESHABILITADO'}`);
                
                if (enabled) {
                    button.classList.remove('disabled');
                    console.log(`✅ ${buttonId}: Clase 'disabled' REMOVIDA`);
                    button.onclick = () => {
                        switch(buttonId) {
                            case 'feedBtn': this.dropFood(); break; // USAR SISTEMA NUEVO
                            case 'cleanBtn': this.startCleaning(); break;
                            // case 'medicineBtn': this.giveMedicine(); break; // ELIMINADO
                        }
                    };
                } else {
                    button.classList.add('disabled');
                    console.log(`❌ ${buttonId}: Clase 'disabled' AÑADIDA`);
                    button.onclick = () => {
                        console.log(`❌ ${buttonId}: El pez no necesita esto ahora`);
                    };
                }
            }
            
            // 🧽 FUNCIÓN DUPLICADA ELIMINADA - SE USA LA DEL EFECTO ESPECTACULAR
            
            // 🫧 SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
            updateNeedBubbles(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;
                
                const fish = this.fish;
                fish.needBubbleTimer += deltaTime;
                
                // Crear burbuja cada 3-5 segundos si tiene necesidades
                if (fish.needBubbleTimer > 3 + Math.random() * 2) {
                    fish.needBubbleTimer = 0;
                    
                    const currentTime = Date.now();
                    const currentStage = this.gameState.stage;
                    
                    // Verificar necesidades
                    const timeSinceFood = fish.lastFeedTime ? currentTime - fish.lastFeedTime : 0;
                    const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                    const timeSinceMedicine = this.gameState.lastMedicine ? currentTime - this.gameState.lastMedicine : 0;
                    
                    // Umbrales
                    const hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                    const playThreshold = 5 * 60 * 60 * 1000;   // 5 horas
                    const medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                    
                    // Crear burbujas según necesidades (en orden de prioridad)
                    if (timeSinceFood > hungerThreshold) {
                        this.createNeedBubble('./images/ui/badge_hunger.png', '#ff5555');
                        console.log('🫧 Burbuja de HAMBRE creada');
                    }
                    
                    if (timeSinceMedicine > medicineThreshold) {
                        this.createNeedBubble('./images/ui/badge_medicine.png', '#55ff55');
                        console.log('🫧 Burbuja de MEDICINA creada');
                    }
                    
                    if (timeSincePlay > playThreshold) {
                        this.createNeedBubble('./images/ui/badge_play.png', '#ffaa55');
                        console.log('🫧 Burbuja de JUEGO creada');
                    }
                }
                
                // Actualizar burbujas existentes
                this.updateExistingNeedBubbles(deltaTime);
            }
            
            createNeedBubble(icon, color) {
                if (!this.fish) return;
                
                // Posición desde la boca del pez
                const fish = this.fish;
                const direction = fish.direction || 1;
                const mouthX = fish.x + (direction > 0 ? 30 : -30); // Boca del pez
                const mouthY = fish.y;
                
                this.needBubbles.push({
                    x: mouthX,
                    y: mouthY,
                    vx: (Math.random() - 0.5) * 3, // MUY lento horizontal
                    vy: -8 - Math.random() * 5, // MUY lento hacia arriba
                    size: 22, // Tamaño para ver bien el icono
                    life: 5 + Math.random() * 2, // Duran más tiempo
                    maxLife: 5 + Math.random() * 2,
                    iconPath: icon, // Ruta de la imagen PNG
                    color: color,
                    alpha: 1,
                    iconImage: null // Se cargará dinámicamente
                });
            }
            
            updateExistingNeedBubbles(deltaTime) {
                if (!this.needBubbles) return;
                
                for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.needBubbles[i];
                    
                    // Actualizar posición (COMO BURBUJAS NORMALES)
                    bubble.x += bubble.vx; // Sin deltaTime - movimiento frame por frame
                    bubble.y += bubble.vy;
                    bubble.life -= deltaTime;
                    
                    // Eliminar si expiró
                    if (bubble.life <= 0) {
                        this.needBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Actualizar alpha
                    bubble.alpha = bubble.life / bubble.maxLife;
                }
            }
            
            // drawNeedBubbles() - ELIMINADO (ahora en needs-system.js)
            
            // ✨ DIBUJAR BURBUJAS DE LIMPIEZA
            drawCleaningBubbles() {
                if (!this.cleaningBubbles || this.cleaningBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (let i = this.cleaningBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cleaningBubbles[i];
                    
                    // Actualizar burbuja
                    bubble.x += bubble.vx * (1/60);
                    bubble.y += bubble.vy * (1/60);
                    bubble.life -= 1/60;
                    
                    // Eliminar si expiró
                    if (bubble.life <= 0) {
                        this.cleaningBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar burbuja de limpieza
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha * 0.8;
                    
                    // Color azul brillante para limpieza
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#ffffff'; // Burbujas brillantes
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00bfff';
                    } else {
                        this.ctx.fillStyle = '#87ceeb'; // Burbujas normales azul cielo
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#4169e1';
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo interno
                    this.ctx.globalAlpha = alpha * 0.4;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // 🎮 FUNCIONES DE JUEGOS
            playBubbleGame() {
                this.showCustomModal({
                    title: '🫧 Juego de Burbujas',
                    message: '🐠💭 "¡Este juego está en desarrollo!"\n\n🚧 Próximamente disponible...\n\n🎮 ¡Será súper divertido!',
                    confirmText: '👍 ¡Esperaré!',
                    onConfirm: () => {}
                });
            }
            
            playMemoryGame() {
                this.showCustomModal({
                    title: '🧠 Juego de Memoria',
                    message: '🐠💭 "¡Este juego está en desarrollo!"\n\n🚧 Próximamente disponible...\n\n🧠 ¡Será súper desafiante!',
                    confirmText: '👍 ¡Esperaré!',
                    onConfirm: () => {}
                });
            }
            
            showGameLocked(starsNeeded) {
                this.showCustomModal({
                    title: '🔒 Juego Bloqueado',
                    message: `🐠💭 "¡Necesitamos más estrellas para este juego!"\n\n⭐ Tienes: ${this.gameState.stars || 0} estrellas\n⭐ Necesitas: ${starsNeeded} estrellas\n\n🎮 ¡Juega otros juegos para ganar estrellas!`,
                    confirmText: '💪 ¡Entendido!',
                    onConfirm: () => {}
                });
            }
            
            showItemLocked(bubblesNeeded) {
                this.showCustomModal({
                    title: '🔒 Item Bloqueado',
                    message: `🐠💭 "¡Necesitamos más burbujas para este item!"\n\n🫧 Tienes: ${this.gameState.bubbles || 0} burbujas\n🫧 Necesitas: ${bubblesNeeded} burbujas\n\n🎮 ¡Juega para ganar burbujas!`,
                    confirmText: '💪 ¡Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // 🎒 USAR ITEM DEL INVENTARIO
            useInventoryItem(itemId) {
                console.log(`🎒 Usando item del inventario: ${itemId}`);
                
                // Si es un fondo, manejar compra o selección
                if (itemId.startsWith('bg-')) {
                    const bgName = itemId.replace('bg-', '');
                    const item = document.querySelector(`[data-item="${itemId}"]`);
                    const isOwned = item?.dataset.owned === 'true';
                    const cost = parseInt(item?.dataset.cost || '0');
                    
                    if (isOwned) {
                        // Ya lo tiene, solo cambiar fondo
                        console.log(`🎨 Cambiando fondo a: ${bgName}`);
                        const bg = this.availableBackgrounds.find(b => b.name === bgName);
                        if (bg) {
                            this.gameState.currentBackground = bgName;
                            this.bgImage = bg.image;
                            console.log(`🎨 Fondo cambiado: ${bgName}, imagen: ${bg.image ? 'cargada' : 'no cargada'}`);
                        }
                        this.updateInventoryAvailability(); // Actualizar selección
                        this.saveGame();
                        
                        // Mostrar mensaje de cambio
                        this.showCustomModal({
                            title: '🎨 ¡Fondo cambiado!',
                            message: `🐠💭 "¡Me encanta mi nuevo hogar!"\n\n✨ Fondo aplicado: ${bgName}`,
                            confirmText: '🎮 ¡Genial!',
                            onConfirm: () => {}
                        });
                    } else if (this.gameState.bubbles >= cost) {
                        // Mostrar modal de confirmación de compra
                        this.showCustomModal({
                            title: '🛒 ¿Comprar Fondo?',
                            message: `🐠💭 "¿Quieres comprarme este hermoso fondo?"\n\n🫧 Costo: ${cost} burbujas\n🫧 Tienes: ${this.gameState.bubbles} burbujas\n🫧 Quedarán: ${this.gameState.bubbles - cost} burbujas\n\n✨ ¡El fondo se aplicará inmediatamente!`,
                            confirmText: '🛒 ¡Comprar!',
                            cancelText: '❌ Cancelar',
                            onConfirm: () => {
                                // Comprar fondo
                                this.gameState.bubbles -= cost;
                                
                                // Marcar como desbloqueado y aplicar fondo
                                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                                if (bg) {
                                    bg.unlocked = true;
                                    this.gameState.currentBackground = bgName;
                                    this.bgImage = bg.image;
                                    console.log(`🎨 Fondo comprado y aplicado: ${bgName}`);
                                }
                                
                                // Actualizar UI
                                this.updateUI();
                                this.updateInventoryAvailability();
                                this.saveGame();
                                
                                // Efecto visual de compra
                                this.createBubbleEffect(0); // Sin burbujas voladoras, solo actualizar contador
                                
                                // Mostrar confirmación de compra exitosa
                                this.showCustomModal({
                                    title: '🎉 ¡Fondo Comprado!',
                                    message: `🐠💭 "¡Gracias por comprarme este hermoso fondo!"\n\n🫧 Costo: ${cost} burbujas\n🫧 Restantes: ${this.gameState.bubbles} burbujas\n\n✨ ¡El fondo está ahora aplicado!`,
                                    confirmText: '🎮 ¡Genial!',
                                    onConfirm: () => {}
                                });
                            },
                            onCancel: () => {
                                console.log('❌ Compra cancelada por el usuario');
                            }
                        });
                    } else {
                        // No tiene suficientes burbujas
                        this.showItemLocked(`${cost}🫧`);
                    }
                    return;
                }
                
                // Otros items (decoraciones, etc.)
                const itemCosts = {
                    'food-special': 30,
                    'decoration': 40
                };
                
                const cost = itemCosts[itemId];
                if (cost && this.gameState.bubbles >= cost) {
                    // Desbloquear item
                    this.gameState.bubbles -= cost;
                    this.updateUI();
                    this.saveGame();
                    
                    this.showCustomModal({
                        title: '🎉 ¡Item Desbloqueado!',
                        message: `🐠💭 "¡Gracias por comprarme este item!"\n\n🫧 Costo: ${cost} burbujas\n🫧 Restantes: ${this.gameState.bubbles} burbujas\n\n✨ ¡El item está ahora disponible!`,
                        confirmText: '🎮 ¡Genial!',
                        onConfirm: () => {}
                    });
                } else {
                    this.showItemLocked(`${cost}🫧`);
                }
            }
            
            startGame(gameId) {
                // Cerrar modal de juegos
                document.getElementById('gamesModal').style.display = 'none';
                
                // 🔊 SONIDO DE INICIO DE JUEGO
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                // 🎮 INICIAR TRACKING DE TIEMPO DE JUEGO
                this.gameStartTime = Date.now();
                this.currentGameId = gameId;
                console.log(`🎮 Iniciando juego: ${gameId} - Tiempo: ${this.gameStartTime}`);
                
                switch(gameId) {
                    case 'bubbles':
                        this.startBubbleGame();
                        break;
                    case 'memory':
                        this.startMemoryGame();
                        break;
                    default:
                        this.showCustomModal({
                            title: '🚧 En Desarrollo',
                            message: `🐠💭 "¡Este juego está en desarrollo!"\n\n✨ Próximamente disponible...`,
                            confirmText: '👍 ¡Esperaré!',
                            onConfirm: () => {}
                        });
                }
            }

            // 🎮 FINALIZAR JUEGO Y CALCULAR DIVERSIÓN
            endGame(gameWon = true, reason = '') {
                console.log(`🎮 endGame del juego principal llamado: gameWon=${gameWon}, reason=${reason}`);
                console.log(`🎮 gameStartTime: ${this.gameStartTime}, currentGameId: ${this.currentGameId}`);
                if (!this.gameStartTime || !this.currentGameId) {
                    console.log('🎮 No hay juego activo para finalizar');
                    return;
                }

                const gameEndTime = Date.now();
                const playTime = (gameEndTime - this.gameStartTime) / 1000; // Tiempo en segundos
                
                console.log(`🎮 Finalizando juego: ${this.currentGameId} - Tiempo jugado: ${playTime.toFixed(1)}s`);
                
                // 🎯 CALCULAR DIVERSIÓN BASADA EN TIEMPO DE JUEGO
                let funIncrease = 0;
                
                if (gameWon) {
                    // Diversión basada en tiempo jugado (máximo 30 segundos = 15 diversión)
                    funIncrease = Math.min(15, Math.floor(playTime * 0.5)); // 0.5 diversión por segundo
                } else {
                    // Si perdió, menos diversión pero algo
                    funIncrease = Math.min(5, Math.floor(playTime * 0.2)); // 0.2 diversión por segundo
                }
                
                // Aplicar diversión al pez
                if (funIncrease > 0) {
                    this.gameState.needs.fun = Math.min(100, this.gameState.needs.fun + funIncrease);
                    this.needsSystem.updateCrisisFlags();
                    this.needsSystem.updateNeedBars();
                    
                    console.log(`🎮 +${funIncrease} diversión por jugar ${playTime.toFixed(1)}s (${gameWon ? 'ganado' : 'perdido'})`);
                    
                    // Actualizar lastPlay
                    this.gameState.lastPlay = Date.now();
                    
                    // Mensaje de diversión removido (era molesto)
                }
                
                // 🎮 ACTUALIZAR TIEMPO TOTAL DE JUEGO
                this.gameState.totalPlayTime = (this.gameState.totalPlayTime || 0) + playTime;
                console.log(`🎮 Tiempo total jugado: ${(this.gameState.totalPlayTime / 60).toFixed(1)} minutos`);
                
                // Resetear tracking
                this.gameStartTime = null;
                this.currentGameId = null;
            }

            showGameLocked(starsRequired) {
                this.showCustomModal({
                    title: '🔒 Juego Bloqueado',
                    message: `🐠💭 "¡Necesito más estrellas para jugar!"\n\n⭐ Necesitas: ${starsRequired} estrellas\n⭐ Tienes: ${this.gameState.stars}\n\n🎮 ¡Juega más para conseguir estrellas!`,
                    confirmText: '💪 ¡Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // 🌊 MODAL DE RESET EMOTIVO
            showResetModal() {
                const fishName = this.gameState.fishName || 'tu pececito';
                
                this.showCustomModal({
                    title: 'Despedida de tu Pececito',
                    message: `🐠 "${fishName === 'tu pececito' ? 'Hola' : 'Soy ' + fishName}... ¿de verdad me vas a dejar libre?"

Volveré al océano infinito y seré feliz
Siempre recordaré nuestros momentos juntos
Podrás cuidar a un nuevo compañero
Nuestros recuerdos quedarán en mi corazón

⚠️ **Se perderá todo el progreso actual**
🫧 Burbujas: ${this.gameState.bubbles || 0}
⭐ Estrellas: ${this.gameState.stars || 0}
📅 Días juntos: ${this.gameState.ageInDays || 0}`,
                    confirmText: '¡Sé libre y feliz!',
                    cancelText: '¡No, te quiero!',
                    onConfirm: () => {
                        this.showCustomModal({
                            title: '¡Hasta siempre!',
                            message: `🐠 "¡Gracias por todo! ¡Fui muy feliz contigo!"\n\n*Nada hacia el océano infinito*\n\nTu nueva aventura comenzará en un momento...`,
                            confirmText: '¡Adiós!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            }
                        });
                    },
                    onCancel: () => {
                        this.showCustomModal({
                            title: '💕 ¡Qué alegría!',
                            message: `🐠💭 "¡Sabía que no me abandonarías!"\n\n¡Sigamos siendo los mejores amigos! 🎮\n\n💪 ¡Vamos a vivir más aventuras juntos!`,
                            confirmText: '🥰 ¡Siempre juntos!',
                            onConfirm: () => {}
                        });
                    }
                });
            }

            // 🎮 Pantalla de carga ELIMINADA (ya no se usa)
            showLoadingWithFishName() {
                console.log('🎮 showLoadingWithFishName() ELIMINADO - Ya no hay pantalla de carga');
                // Método eliminado - ir directo al juego
            }

            // 💀 Añadir botón reset al menú solo si ya tienes pez
            addResetButtonToMenu() {
                const actionBar = document.querySelector('.action-bar');
                if (!document.getElementById('resetButton')) {
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'menu-btn';
                    resetBtn.id = 'resetButton';
                    resetBtn.title = 'Cuidar otro pececito';
                    resetBtn.innerHTML = '<div class="btn-icon">💀</div>';
                    
                    resetBtn.addEventListener('click', () => {
                        this.showResetModal();
                    });
                    
                    actionBar.appendChild(resetBtn);
                    console.log('💀 Botón reset añadido al menú');
                }
            }
            
            // 🫧 JUEGO DE BURBUJAS - DIRECTO
            startBubbleGame() {
                console.log('🫧 Iniciando juego de burbujas...');
                // ✅ LLAMAR AL JUEGO BUENO
                window.startBubbleGameDirect();
            }
            
            // ❌ JUEGO MALO ELIMINADO - NO USAR
            /*
            runBubbleGame() {
                // Crear overlay del juego completo
                const gameOverlay = document.createElement('div');
                gameOverlay.id = 'bubbleGameOverlay';
                gameOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                    z-index: 2000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    padding: 20px;
                    font-family: 'Poppins', sans-serif;
                    overflow: hidden;
                `;

                // UI del juego
                const gameUI = document.createElement('div');
                gameUI.style.cssText = `
                    color: white;
                    text-align: center;
                    margin-bottom: 15px;
                    font-size: 20px;
                    font-weight: bold;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                    background: rgba(255,255,255,0.1);
                    padding: 10px 20px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.3);
                `;
                gameUI.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                        <div>⏱️ Tiempo: <span id="bubbleTimer">20</span>s</div>
                        <div>🫧 Puntos: <span id="bubbleScore">0</span></div>
                        <button id="exitGameBtn" style="
                            background: rgba(255,255,255,0.2);
                            border: 2px solid rgba(255,255,255,0.5);
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            color: white;
                            font-size: 18px;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">❌</button>
                    </div>
                    <div style="
                        color: rgba(255,255,255,0.8);
                        font-size: 12px;
                        text-align: center;
                        margin-top: 8px;
                        line-height: 1.3;
                    ">
                        🔵 Toca burbujas azules (+3 pts +tiempo) 🔴 Evita rojas (-2 pts)<br>
                        ⭐ 1 estrella por jugar • 2 por récord personal • 3 por récord global
                    </div>
                `;

                const gameArea = document.createElement('div');
                gameArea.id = 'bubbleGameArea';
                gameArea.style.cssText = `
                    position: relative;
                    width: 100%;
                    max-width: 350px;
                    height: 450px;
                    border-radius: 20px;
                    overflow: hidden;
                    cursor: pointer;
                    background: rgba(255,255,255,0.05);
                    border: 3px solid rgba(255,255,255,0.2);
                `;

                gameOverlay.appendChild(gameUI);
                gameOverlay.appendChild(gameArea);
                document.body.appendChild(gameOverlay);

                // Botón de salir
                document.getElementById('exitGameBtn').addEventListener('click', () => {
                    gameActive = false;
                    clearInterval(gameTimer);
                    clearInterval(bubbleSpawner);
                    document.body.removeChild(gameOverlay);
                    if (document.head.contains(style)) {
                        document.head.removeChild(style);
                    }
                });

                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                let baseSpawnRate = 800; // Velocidad base de aparición
                let currentSpawnRate = baseSpawnRate;
                let gameStartTime = Date.now();
                
                // Sistema de récords
                const personalRecord = parseInt(localStorage.getItem('bubbleGame_personalRecord') || '0');
                const globalRecord = parseInt(localStorage.getItem('bubbleGame_globalRecord') || '50'); // Récord global inicial

                // Actualizar UI
                const updateUI = () => {
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    document.getElementById('bubbleScore').textContent = score;
                };

                // Crear burbuja
                const createBubble = () => {
                    if (!gameActive) return;

                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35; // 65% buenas, 35% malas
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        border-radius: 50%;
                        background: ${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid ${isGood ? '#ffffff' : '#ffdddd'};
                        box-shadow: 0 0 12px ${isGood ? 'rgba(135,206,235,0.8)' : 'rgba(255,107,107,0.8)'};
                        cursor: pointer;
                        animation: bubbleFloat 3.5s linear;
                        top: 100%;
                        left: ${Math.random() * (350 - size)}px;
                        z-index: 1001;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${size * 0.4}px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                    `;

                    bubble.innerHTML = isGood ? '🔵' : '🔴';
                    bubble.dataset.good = isGood;
                    
                    bubble.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!gameActive) return;

                        if (isGood) {
                            score += 3;
                            // ⏰ AÑADIR TIEMPO POR BURBUJA BUENA
                            timeLeft += 1; // +1 segundo por burbuja buena
                            bubble.style.background = 'radial-gradient(circle, #00ff88, #32cd32)';
                            bubble.innerHTML = '+3 +1s';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                            
                            // 🚀 AUMENTAR DIFICULTAD PROGRESIVAMENTE
                            if (score > 0 && score % 15 === 0) { // Cada 15 puntos
                                currentSpawnRate = Math.max(300, currentSpawnRate - 50); // Más rápido, mínimo 300ms
                                console.log(`🚀 Dificultad aumentada: ${currentSpawnRate}ms`);
                            }
                        } else {
                            score = Math.max(0, score - 2);
                            bubble.style.background = 'radial-gradient(circle, #ff4444, #dc143c)';
                            bubble.innerHTML = '-2';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                        }
                        
                        updateUI();
                        
                        setTimeout(() => {
                            if (bubble.parentNode) bubble.remove();
                        }, 600);
                    });

                    gameArea.appendChild(bubble);
                    bubbles.push(bubble);

                    // Remover burbuja después de la animación
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                        const index = bubbles.indexOf(bubble);
                        if (index > -1) bubbles.splice(index, 1);
                    }, 3500);
                };

                // Añadir CSS de animación
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes bubbleFloat {
                        0% { 
                            transform: translateY(0) rotate(0deg) scale(0.8);
                            opacity: 0.7;
                        }
                        10% { 
                            opacity: 1;
                            transform: translateY(-40px) rotate(20deg) scale(1);
                        }
                        100% { 
                            transform: translateY(-500px) rotate(360deg) scale(0.9);
                            opacity: 0.8;
                        }
                    }
                `;
                document.head.appendChild(style);

                // Timer del juego
                const gameTimer = setInterval(() => {
                    timeLeft--;
                    updateUI();

                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        clearInterval(bubbleSpawner);
                        
                        // Finalizar juego
                        setTimeout(() => {
                            document.body.removeChild(gameOverlay);
                            document.head.removeChild(style);
                            
                            // Actualizar burbujas del jugador
                            const finalScore = Math.max(0, score);
                            this.gameState.bubbles += finalScore;
                            
                            // ⭐ SISTEMA DE ESTRELLAS SEGÚN RENDIMIENTO
                            let starsEarned = 1; // 1 estrella por jugar
                            let achievement = 'Partida completada';
                            
                            if (finalScore > personalRecord) {
                                starsEarned = 2; // 2 estrellas por récord personal
                                achievement = '¡Nuevo récord personal!';
                                localStorage.setItem('bubbleGame_personalRecord', finalScore.toString());
                            }
                            
                            if (finalScore > globalRecord) {
                                starsEarned = 3; // 3 estrellas por récord global
                                achievement = '¡RÉCORD GLOBAL! ¡Eres increíble!';
                                localStorage.setItem('bubbleGame_globalRecord', finalScore.toString());
                            }
                            
                            this.gameState.stars += starsEarned;
                            
                            // 🎆 EFECTOS VISUALES DE RECOMPENSA
                            if (finalScore > 0) {
                                this.showRewardEffect('bubbles', finalScore);
                                setTimeout(() => {
                                    this.showRewardEffect('stars', starsEarned);
                                }, 800);
                            }
                            
                            this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                            this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                            this.saveGame();

                            // Mostrar resultado
                            this.showCustomModal({
                                title: starsEarned === 3 ? '🏆 ¡RÉCORD GLOBAL!' : starsEarned === 2 ? '🎉 ¡Nuevo Récord!' : '🎮 ¡Bien Jugado!',
                                message: `🐠💭 "${achievement}"\n\n🫧 Puntos: ${finalScore}\n⭐ Estrellas ganadas: ${starsEarned}\n📊 Récord personal: ${Math.max(personalRecord, finalScore)}\n🏆 Récord global: ${Math.max(globalRecord, finalScore)}\n\n💰 Total: 🫧 ${this.gameState.bubbles} | ⭐ ${this.gameState.stars}`,
                                confirmText: '🎮 ¡Genial!'
                            });
                        }, 1000);
                    }
                }, 1000);

                // Spawner de burbujas dinámico
                const bubbleSpawner = setInterval(() => {
                    if (gameActive) {
                        createBubble();
                    }
                }, currentSpawnRate);

                // Actualizar spawner dinámicamente
                const updateSpawner = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(updateSpawner);
                        return;
                    }
                    clearInterval(bubbleSpawner);
                    const newSpawner = setInterval(() => {
                        if (gameActive) createBubble();
                    }, currentSpawnRate);
                }, 1000);

                // Crear burbujas iniciales
                setTimeout(() => createBubble(), 300);
                setTimeout(() => createBubble(), 800);
                setTimeout(() => createBubble(), 1200);
            }
            */
            
            // 🧠 JUEGO DE MEMORIA
            startMemoryGame() {
                this.showCustomModal({
                    title: '🧠 Juego de Memoria',
                    message: `🐠💭 "¡A ejercitar la mente!"\n\n🎯 **Objetivo:**\nEncuentra todas las parejas de cartas\nRecuerda dónde están las imágenes\n\n🏆 **Recompensas:**\n+3 burbujas por pareja encontrada\nBonus de velocidad\n\n🃏 Cartas: 8 parejas (16 cartas)`,
                    confirmText: '🧠 ¡Empezar!',
                    cancelText: '❌ Cancelar',
                    onConfirm: () => {
                        this.runMemoryGame();
                    }
                });
            }
            
            runMemoryGame() {
                // Implementación del juego de memoria
                this.showCustomModal({
                    title: '🧠 ¡Jugando Memoria!',
                    message: `🎮 **DEMO DEL JUEGO**\n\n🃏 Parejas encontradas: 6/8\n👁️ Cartas volteadas: 18\n⏱️ Tiempo: 45s\n\n🏆 Puntuación actual: +18 burbujas`,
                    confirmText: '✅ Terminar',
                    onConfirm: () => {
                        // Dar recompensa
                        this.gameState.bubbles += 18;
                        this.gameState.stars += 3;
                        this.updateUI();
                        
                        this.showCustomModal({
                            title: '🏆 ¡Excelente Memoria!',
                            message: `🐠💭 "¡Tienes una memoria increíble!"\n\n🎉 **Recompensas obtenidas:**\n🫧 +18 burbujas\n⭐ +3 estrellas\n\n💰 Total: 🫧 ${this.gameState.bubbles} | ⭐ ${this.gameState.stars}`,
                            confirmText: '🥰 ¡Gracias!',
                            onConfirm: () => {}
                        });
                    }
                });
            }
            
            // 💊 DAR MEDICINA (PLACEHOLDER)
            giveMedicine() {
                console.log('💊 Dando medicina al pez...');
                this.gameState.lastMedicine = Date.now();
                this.gameState.health = Math.min(100, this.gameState.health + 40);
                console.log('🏥 Pez curado - Salud:', this.gameState.health);
            }

            // 💰 SISTEMA DE COSTOS PROGRESIVOS
            getBackgroundCost(bgName) {
                const costs = {
                    'cartoon': 15,   // Primer fondo - fácil de conseguir
                    'coral': 25,     // Segundo fondo
                    'mario': 40,     // Más caro
                    'minecraft': 60  // El más caro
                };
                return costs[bgName] || 30; // Costo por defecto
            }

            // 🎆 EFECTOS DE RECOMPENSA
            showRewardEffect(type, amount, sourceElement = null) {
                const emoji = type === 'bubbles' ? '🫧' : '⭐';
                const color = type === 'bubbles' ? 'rgba(100,200,255,0.6)' : 'rgba(255,215,0,0.6)';
                
                // Posición de origen (elemento fuente o centro de pantalla)
                let startX, startY;
                if (sourceElement) {
                    const rect = sourceElement.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                } else {
                    startX = window.innerWidth / 2;
                    startY = window.innerHeight / 2;
                }

                // Crear múltiples burbujas según la cantidad
                const bubbleCount = Math.min(amount, 5); // Máximo 5 burbujas
                for (let i = 0; i < bubbleCount; i++) {
                    setTimeout(() => {
                        this.createRewardBubble(emoji, color, startX, startY, i);
                    }, i * 150); // Delay escalonado
                }

                // Explosión dorada al final
                setTimeout(() => {
                    this.createRewardExplosion(startX, startY);
                }, bubbleCount * 150 + 500);
            }

            createRewardBubble(emoji, color, startX, startY, index) {
                const bubble = document.createElement('div');
                bubble.className = 'reward-bubble';
                bubble.textContent = emoji;
                bubble.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), ${color})`;
                bubble.style.boxShadow = `0 0 20px ${color}`;
                
                // Posición inicial con variación
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 50;
                bubble.style.left = (startX + offsetX - 30) + 'px';
                bubble.style.top = (startY + offsetY - 30) + 'px';
                
                document.body.appendChild(bubble);
                
                // Limpiar después de la animación
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                }, 2000);
            }

            createRewardExplosion(x, y) {
                const explosion = document.createElement('div');
                explosion.className = 'reward-explosion';
                explosion.style.left = (x - 50) + 'px';
                explosion.style.top = (y - 50) + 'px';
                
                document.body.appendChild(explosion);
                
                // Limpiar después de la animación
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.remove();
                    }
                }, 800);
            }

            // 🎓 MODAL DE TUTORIAL BONITO
            showTutorialModal() {
                this.showCustomModal({
                    title: 'Tu Primera Aventura Marina',
                    message: `"¡Hola! Soy tu nuevo compañero virtual."\n\n🥚 Primero apareceré como un huevito\n⏰ En 24 horas eclosionaré y nadaré contigo\n🎮 Mientras tanto, puedes jugar minijuegos\n\n¡Clica aquí y aparecerá tu huevito de pez!`,
                    confirmText: '¡Colocar mi huevo!',
                    onConfirm: () => {
                        // CERRAR MODAL PRIMERO para ver el efecto
                        const customModal = document.querySelector('.custom-modal');
                        if (customModal) {
                            customModal.remove();
                        }
                        
                        // Pequeño delay para que se vea el cierre
                        setTimeout(() => {
                            this.startEggPlacement();
                        }, 300);
                    }
                });
            }

            // 🥚 INICIAR COLOCACIÓN DEL HUEVO
            startEggPlacement() {
                console.log('✨ INICIANDO MAGIA DEL HUEVO...');
                
                // CERRAR MODAL INMEDIATAMENTE para que no se vea el huevo
                const modals = document.querySelectorAll('.custom-modal, .modal-overlay, .game-modal-overlay');
                modals.forEach(modal => {
                    modal.remove();
                    console.log('🚪 Modal eliminada');
                });
                
                // También ocultar cualquier modal por CSS
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 100);
                
                // 🎵 INICIAR MÚSICA DE FONDO AL APARECER EL HUEVO (si no está ya sonando)
                if (window.audioManager && !window.audioManager.isMuted && !window.audioManager.backgroundMusic?.played?.length) {
                    window.audioManager.startBackgroundMusic();
                    console.log('🎵 Música de fondo iniciada con el huevo');
                }
                
                // ASEGURAR que NO hay huevo todavía
                this.gameState.stage = 'waiting';
                this.gameState.eggStartTime = null;
                
                // 🏷️ RESETEAR NOMBRE PARA NUEVO PEZ
                this.gameState.hasAskedForName = false;
                this.gameState.fishName = null;
                console.log('🏷️ Estado de nombre reseteado para nuevo pez');
                
                // 🧼 RESETEAR SOLO PANTALLA Y BURBUJAS AL INICIAR HUEVO
                this.gameState.needs.dirt = 0;     // Pantalla limpia
                this.gameState.bubbles = 0;        // Sin burbujas
                console.log('🧼 Pantalla reseteada: limpia, sin burbujas');
                
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                // PASO 1: USAR EL MISMO EFECTO QUE EL NACIMIENTO DEL PEZ
                console.log('🚀 LLAMANDO createEggExplosionBubbles()...');
                this.createEggExplosionBubbles();
                console.log('🚀 createEggExplosionBubbles() EJECUTADO');
                    
                console.log('✨ Burbujas de aparición del huevo (como nacimiento)...');
                
                // PASO 2: Colocar huevo y EMPEZAR CRONÓMETRO (2.2s)
                    setTimeout(() => {
                    const now = Date.now();
                    
                    // Colocar huevo Y empezar cronómetro AL MISMO TIEMPO
                    this.gameState.stage = 'egg';
                    this.gameState.eggStartTime = now;
                    this.egg.x = centerX;
                    this.egg.y = centerY;
                    
                    // Iniciar animación de aparición del huevo
                    this.startEggAppearanceAnimation();
                    
                    console.log('🥚 ¡Huevo + cronómetro iniciados!');
                }, 800); // MUCHO MÁS RÁPIDO (era 2200ms)
                
                // PASO 3: Desactivar efectos gradualmente (6s total)
                setTimeout(() => {
                    this.gameState.showMagicBubbles = false;
                    console.log('✨ Magia completada');
                }, 6000);
            }

            // 🫧 BURBUJAS COPIADAS DEL TEST QUE FUNCIONA
            createSimpleBubbles() {
                console.log('✨ COPIANDO SISTEMA DEL TEST...');
                
                // LIMPIAR COMPLETAMENTE
                this.bgBubbles = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // EXACTAMENTE como en el test que funciona
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 150;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const burbuja = {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        r: 8 + Math.random() * 12,
                        alpha: 0.6 + Math.random() * 0.4,
                        color: `hsl(${190 + Math.random() * 40}, 70%, 70%)`,
                        life: 120, // 2 segundos a 60fps
                        sparkle: Math.random() > 0.5,
                        isTestBubble: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(burbuja);
                }
                
                console.log(`🫧 ${this.bgBubbles.length} burbujas TEST creadas`);
            }

            // 🌫️ EFECTOS ANTES DEL HUEVO - SISTEMA PERSISTENTE (VIEJO)
            createPreEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('✨ TEST BURBUJAS INMORTALES...');
                
                // LIMPIAR burbujas existentes
                this.bgBubbles = [];
                
                // TEST: 10 burbujas INMORTALES que NUNCA se eliminen
                for (let i = 0; i < 10; i++) {
                    const x = 50 + i * 35;
                    const y = 150;
                    
                    const bubble = {
                        x: x,
                        y: y,
                        vx: 0, // SIN MOVIMIENTO
                        vy: 0, // ESTÁTICAS
                        r: 25, // GRANDES
                        alpha: 1, // OPACAS
                        color: '#ff0000', // ROJO BRILLANTE
                        life: 999999, // VIDA INFINITA
                        maxLife: 999999,
                        sparkle: false,
                        isAppearanceEffect: true,
                        immortal: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(bubble);
                    console.log(`🔴 Burbuja INMORTAL ${i+1} en (${x}, ${y})`);
                }
                
                console.log(`🫧 ${this.bgBubbles.length} burbujas INMORTALES creadas`);
            }

            // 💬 MENSAJE TEMPORAL EN PANTALLA
            showTemporaryMessage(text, duration) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 40%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 50, 100, 0.8);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 12px;
                    font-size: 14px;
                    font-weight: bold;
                    text-align: center;
                    z-index: 1500;
                    border: 2px solid rgba(255,255,255,0.4);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    animation: messageFloat 0.5s ease-out;
                `;
                messageDiv.textContent = text;
                
                // Añadir CSS de animación si no existe
                if (!document.getElementById('messageFloatStyle')) {
                    const style = document.createElement('style');
                    style.id = 'messageFloatStyle';
                    style.textContent = `
                        @keyframes messageFloat {
                            from { 
                                transform: translate(-50%, -50%) scale(0.8);
                                opacity: 0;
                            }
                            to { 
                                transform: translate(-50%, -50%) scale(1);
                                opacity: 1;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageDiv);
                
                // Remover después del tiempo especificado
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, duration);
            }
            
            // 🎮 MOSTRAR JUEGOS - MODAL SIMPLE Y FUNCIONAL
            showGames() {
                console.log('🎮 Abriendo modal de juegos simple...');
                
                // Usar la nueva modal simple
                const modal = document.getElementById('gamesModal');
                modal.style.display = 'flex';
                
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar estrellas en el modal
                const modalStarsCount = document.getElementById('modal-stars-count');
                if (modalStarsCount) {
                    modalStarsCount.textContent = this.gameState.stars || 0;
                }
                
                // Actualizar disponibilidad de juegos dinámicamente
                this.updateGameAvailabilitySquare();
            }
            
            // 🎯 ACTUALIZAR DISPONIBILIDAD DE JUEGOS CUADRADOS
            updateGameAvailabilitySquare() {
                const stars = this.gameState.stars || 0;
                
                const gameRequirements = {
                    'bubbles': 0,
                    'memory': 10,
                    'snake': 25,
                    'puzzle': 50,
                    'race': 75,
                    'target': 100,
                    'adventure': 150,
                    'tower': 200,
                    'boss': 300
                };
                
                // Actualizar cada juego según las estrellas disponibles
                Object.entries(gameRequirements).forEach(([gameId, requiredStars]) => {
                    const card = document.querySelector(`[data-game="${gameId}"]`);
                    if (card) {
                        if (stars >= requiredStars) {
                            card.classList.remove('locked');
                            card.classList.add('available');
                        } else {
                            card.classList.add('locked');
                            card.classList.remove('available');
                        }
                    }
                });
                
                console.log(`🎮 Juegos cuadrados actualizados. Estrellas: ${stars}`);
            }
            
            // Función temporal para mantener compatibilidad
            populateGamesGrid() {
                // Esta función ya no es necesaria con el nuevo diseño
                console.log('🎮 populateGamesGrid() - Ya no es necesaria con el nuevo diseño');

                const buttonsHTML = gameButtons.map(game => {
                    if (game.available) {
                        return `<button onclick="game.startGame('${game.id}')" style="
                            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
                            border: 2px solid #0277bd;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: white;
                            font-size: 16px;
                            cursor: pointer;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                        </button>`;
                    } else {
                        return `<button style="
                            background: linear-gradient(135deg, #bbb, #999);
                            border: 2px solid #666;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: #666;
                            font-size: 16px;
                            cursor: not-allowed;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                            opacity: 0.6;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                            <div style="font-size: 10px;">⭐ ${game.stars}</div>
                        </button>`;
                    }
                }).join('');

                this.showCustomModal({
                    title: '🎮 Minijuegos',
                    message: `🐠💭 "¡Elige un juego para divertirnos!"\n\n<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 5px;">${buttonsHTML}</div>`,
                    confirmText: '❌ Cerrar',
                    onConfirm: () => {}
                });
            }
            
            populateGamesGrid() {
                const gamesGrid = document.getElementById('gamesGrid');
                if (!gamesGrid) return;
                
                const games = [
                    { id: 'bubbles', icon: '🫧', name: 'Burbujas', available: true, stars: 0 },
                    { id: 'memory', icon: '🧠', name: 'Memoria', available: this.gameState.stars >= 10, stars: 10 },
                    { id: 'target', icon: '🎯', name: 'Puntería', available: false, stars: 25 },
                    { id: 'race', icon: '🏃', name: 'Carrera', available: false, stars: 50 },
                    { id: 'puzzle', icon: '🧩', name: 'Puzzle', available: false, stars: 75 },
                    { id: 'adventure', icon: '🗺️', name: 'Aventura', available: false, stars: 100 }
                ];
                
                gamesGrid.innerHTML = games.map(game => {
                    const isAvailable = game.available;
                    
                    return `
                        <div class="game-card ${isAvailable ? 'available' : 'locked'}" 
                             data-game-id="${game.id}" 
                             data-available="${isAvailable}"
                             data-stars="${game.stars}">
                            <div class="game-icon">${game.icon}</div>
                            <div class="game-name">${game.name}</div>
                            ${!isAvailable ? `<div class="game-requirement">⭐ ${game.stars}</div>` : ''}
                        </div>
                    `;
                }).join('');

                // Añadir event listeners a las cartas de juego
                setTimeout(() => {
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.addEventListener('click', (e) => {
                            const gameId = card.dataset.gameId;
                            const isAvailable = card.dataset.available === 'true';
                            const stars = parseInt(card.dataset.stars);

                            console.log(`🎮 Click en juego: ${gameId}, disponible: ${isAvailable}`);

                            if (isAvailable) {
                                console.log(`🚀 Iniciando juego: ${gameId}`);
                                // CERRAR MODAL ANTES DE INICIAR JUEGO
                                const customModal = document.querySelector('.custom-modal');
                                if (customModal) {
                                    customModal.remove();
                                }
                                this.startGame(gameId);
                            } else {
                                console.log(`🔒 Juego bloqueado: ${gameId}, necesita ${stars} estrellas`);
                                this.showGameLocked(stars);
                            }
                        });
                    });
                }, 100);
            }
            
            // 🎒 MOSTRAR INVENTARIO (PLACEHOLDER)
            showInventory() {
                console.log('🎒 Abriendo inventario...');
                
                this.showCustomModal({
                    title: '🎒 Mi Inventario',
                    message: `🐠💭 "¡Mira todas mis cosas!"

💰 Tienes: 🫧 ${this.gameState.bubbles || 0} burbujas | ⭐ ${this.gameState.stars || 0} estrellas

🌊 **Fondos de Pecera** - DISPONIBLE
Cambia el fondo de tu acuario
🖼️ ${this.availableBackgrounds ? this.availableBackgrounds.length : 23} fondos disponibles

🎨 **Decoraciones** - PRÓXIMAMENTE
Rocas, plantas, castillos...
🚧 En desarrollo

🍽️ **Comida Especial** - PRÓXIMAMENTE  
Comida premium y de cumpleaños
🚧 En desarrollo`,
                    confirmText: '🌊 Ver Fondos',
                    cancelText: '❌ Cerrar',
                    onConfirm: () => {
                        // Abrir selector de fondos (función existente)
                        document.getElementById('inventoryModal').style.display = 'flex';
                    },
                    onCancel: () => {
                        console.log('🎒 Inventario cerrado');
                    }
                });
            }
            
            // 🎒 ACTUALIZAR DISPONIBILIDAD DEL INVENTARIO
            updateInventoryAvailability() {
                console.log('🎒 Actualizando disponibilidad del inventario...');
                
                if (!this.availableBackgrounds) {
                    console.warn('⚠️ availableBackgrounds no está disponible');
                    return;
                }
                
                const grid = document.querySelector('.inventory-grid-simple');
                if (!grid) {
                    console.warn('⚠️ Grid de inventario no encontrado');
                    return;
                }
                
                // Limpiar grid actual
                grid.innerHTML = '';
                
                // 🎨 BLOQUE DE FONDOS
                const backgroundsSection = document.createElement('div');
                backgroundsSection.className = 'inventory-section';
                backgroundsSection.innerHTML = `
                    <div class="inventory-section-header">
                        <h3>🌊 Fondos de Pecera</h3>
                        <span class="inventory-section-subtitle">🫧 Tienes: ${this.gameState.bubbles || 0} burbujas</span>
                    </div>
                    <div class="inventory-section-grid"></div>
                `;
                grid.appendChild(backgroundsSection);
                
                const backgroundsGrid = backgroundsSection.querySelector('.inventory-section-grid');
                
                // Crear items dinámicamente basados en fondos reales
                this.availableBackgrounds.forEach((bg, index) => {
                    const item = document.createElement('div');
                    const isUnlocked = bg.unlocked !== false; // Por defecto desbloqueado
                    const isSelected = this.gameState.currentBackground === bg.name;
                    const cost = bg.cost || 0;
                    const canAfford = this.gameState.bubbles >= cost;
                    const isOwned = bg.unlocked === true || bg.name === 'Mi casa'; // Mi casa es gratis
                    
                    item.className = `inventory-item-square ${isOwned ? 'owned' : (canAfford ? 'available' : 'locked')}`;
                    if (isSelected) item.classList.add('selected');
                    
                    item.dataset.item = `bg-${bg.name}`;
                    item.dataset.cost = cost;
                    item.dataset.owned = isOwned;
                    
                    // Icono basado en el nombre del fondo
                    let icon = '🌊';
                    switch(bg.name) {
                        case 'basic': icon = '🌊'; break;
                        case 'cartoon': icon = '🎨'; break;
                        case 'coral': icon = '🪸'; break;
                        case 'mario': icon = '🍄'; break;
                        case 'minecraft': icon = '🧱'; break;
                        default: icon = '🌊';
                    }
                    
                    item.innerHTML = `
                        <div class="inventory-square-preview" style="background-image: url('./images/backgrounds/${bg.file}')${!isOwned && !canAfford ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="inventory-square-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="inventory-square-price">${cost === 0 ? 'Gratis' : cost + '🫧'}</div>
                        ${!isOwned && !canAfford ? `
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">🔒</div>
                                <div class="lock-stars">${cost}🫧</div>
                            </div>
                        ` : ''}
                        ${isSelected ? '<div class="selected-indicator">✓</div>' : ''}
                        ${isOwned && !isSelected ? '<div class="owned-indicator">✓</div>' : ''}
                    `;
                    
                    backgroundsGrid.appendChild(item);
                });
                
                // 🎨 BLOQUE DE DECORACIONES (PRÓXIMAMENTE)
                const decorationsSection = document.createElement('div');
                decorationsSection.className = 'inventory-section';
                decorationsSection.innerHTML = `
                    <div class="inventory-section-header">
                        <h3>🎨 Decoraciones</h3>
                        <span class="inventory-section-subtitle">🚧 Próximamente</span>
                    </div>
                    <div class="inventory-section-grid">
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">🏰</div>
                            <div class="inventory-square-name">Castillo</div>
                            <div class="inventory-square-price">50🫧</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">🚧</div>
                                <div class="lock-stars">Próximamente</div>
                            </div>
                        </div>
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">🌿</div>
                            <div class="inventory-square-name">Plantas</div>
                            <div class="inventory-square-price">30🫧</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">🚧</div>
                                <div class="lock-stars">Próximamente</div>
                            </div>
                        </div>
                        <div class="inventory-item-square locked">
                            <div class="inventory-square-icon">🪨</div>
                            <div class="inventory-square-name">Rocas</div>
                            <div class="inventory-square-price">20🫧</div>
                            <div class="inventory-lock-overlay">
                                <div class="lock-icon-small">🚧</div>
                                <div class="lock-stars">Próximamente</div>
                            </div>
                        </div>
                    </div>
                `;
                grid.appendChild(decorationsSection);
                
                // Añadir event listeners a los elementos del inventario
                const inventoryItems = document.querySelectorAll('.inventory-item-square');
                inventoryItems.forEach(card => {
                    const itemId = card.dataset.item;
                    if (!itemId) return;
                    
                    card.addEventListener('click', () => {
                        const isLocked = card.classList.contains('locked');
                        
                        if (!isLocked && window.game) {
                            console.log(`🎒 Usando item: ${itemId}`);
                            // Cerrar modal primero
                            const modal = document.getElementById('inventoryModal');
                            modal.style.opacity = '0';
                            setTimeout(() => {
                                modal.style.display = 'none';
                                // Llamar a la función de usar item
                                window.game.useInventoryItem?.(itemId);
                            }, 300);
                        } else if (isLocked) {
                            console.log(`🔒 Item bloqueado: ${itemId}`);
                            // Mostrar mensaje de item bloqueado
                            const bubblesNeeded = card.querySelector('.lock-stars')?.textContent || '';
                            window.game?.showItemLocked?.(bubblesNeeded);
                        }
                    });
                });
                
                console.log(`🎒 Inventario actualizado con ${this.availableBackgrounds.length} fondos`);
            }
            
            // 📸 FUNCIÓN PLACEHOLDER ELIMINADA - USAR LA FUNCIÓN REAL MÁS ABAJO
            
            // 🔄 DETECCIÓN MUY TEMPRANA DE BORDES
            handleSimpleFishBoundaries() {
                const fish = this.fish;
                const fishSize = 60; // Tamaño aproximado del pez Lottie
                const padding = fishSize + 40; // MARGEN MUY GRANDE (100px total)
                
                // DETECCIÓN TEMPRANA: Antes de que se salga del borde
                
                // BORDE IZQUIERDO
                if (fish.x <= padding && fish.direction === -1) {
                    fish.direction = 1; // Girar a la derecha
                    fish.x = padding + 10; // Reposicionar MÁS adentro
                    console.log(`🐠 Detección MUY temprana IZQUIERDO (x=${fish.x.toFixed(0)}) → Gira a la DERECHA`);
                }
                
                // BORDE DERECHO  
                if (fish.x >= this.canvas.width - padding && fish.direction === 1) {
                    fish.direction = -1; // Girar a la izquierda
                    fish.x = this.canvas.width - padding - 10; // Reposicionar MÁS adentro
                    console.log(`🐠 Detección MUY temprana DERECHO (x=${fish.x.toFixed(0)}) → Gira a la IZQUIERDA`);
                }
                
                // BORDE SUPERIOR - Más margen
                if (fish.y <= this.canvas.height * 0.2 && fish.verticalDirection === -1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : 1;
                    fish.y = this.canvas.height * 0.2 + 10;
                    console.log(`🐠 Detección MUY temprana SUPERIOR (y=${fish.y.toFixed(0)}) → Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ABAJO ↓'}`);
                }
                
                // BORDE INFERIOR - Más margen
                if (fish.y >= this.canvas.height * 0.8 && fish.verticalDirection === 1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : -1;
                    fish.y = this.canvas.height * 0.8 - 10;
                    console.log(`🐠 Detección MUY temprana INFERIOR (y=${fish.y.toFixed(0)}) → Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ARRIBA ↑'}`);
                }
                
                // SEGURIDAD SILENCIOSA: Solo reposicionar sin spam de logs
                const safetyMargin = 80;
                if (fish.x < safetyMargin) {
                    fish.x = safetyMargin;
                    fish.direction = 1; // Forzar dirección hacia la derecha
                }
                if (fish.x > this.canvas.width - safetyMargin) {
                    fish.x = this.canvas.width - safetyMargin;
                    fish.direction = -1; // Forzar dirección hacia la izquierda
                }
                if (fish.y < safetyMargin) {
                    fish.y = safetyMargin;
                    fish.verticalDirection = 1; // Forzar hacia abajo
                }
                if (fish.y > this.canvas.height - safetyMargin) {
                    fish.y = this.canvas.height - safetyMargin;
                    fish.verticalDirection = -1; // Forzar hacia arriba
                }
            }
            
            // 🔄 ORIENTACIÓN CORREGIDA
            // 🔄 FUNCIÓN updateFishOrientation() ELIMINADA - AHORA EN fish-system.js
            
            updateCanvasFishAnimations(deltaTime) {
                const fish = this.fish;
                
                // Actualizar timers de animación
                if (!fish.breatheTime) fish.breatheTime = 0;
                if (!fish.blinkTime) fish.blinkTime = 0;
                if (!fish.finTime) fish.finTime = 0;
                if (!fish.bubbleTime) fish.bubbleTime = 0;
                if (!fish.floatTime) fish.floatTime = 0;
                if (!fish.baseY) fish.baseY = this.canvas.height * 0.6;
                
                fish.breatheTime += deltaTime * 1.5;
                fish.blinkTime += deltaTime;
                fish.finTime += deltaTime * 2;
                fish.bubbleTime += deltaTime;
                fish.floatTime += deltaTime * 0.8;
                
                // Animaciones Canvas
                const breatheCycle = fish.breatheTime % (2.5 * Math.PI);
                fish.breatheScale = 1 + Math.sin(breatheCycle) * 0.06;
                
                // PARPADEO DESHABILITADO - Se maneja en updateFishMovement()
                // if (fish.blinkTime > 4 + Math.random() * 3) {
                //     fish.eyeOpen = 0;
                //     setTimeout(() => {
                //         if (this.fish) this.fish.eyeOpen = 1;
                //     }, 200);
                //     fish.blinkTime = 0;
                // }
                
                const finCycle = (fish.finTime % (2.5 * Math.PI)) / (2.5 * Math.PI);
                const minRotation = -36 * Math.PI / 180;
                const maxRotation = 4 * Math.PI / 180;
                fish.finRotation = minRotation + (maxRotation - minRotation) * (Math.sin(finCycle * Math.PI * 2) * 0.5 + 0.5);
                
                const floatCycle = fish.floatTime % (2.5 * Math.PI);
                const floatAmount = 10;
                fish.y = fish.baseY + Math.sin(floatCycle) * floatAmount;
                
                if (fish.bubbleTime > 4 + Math.random() * 6) {
                    this.createFishBubble();
                    fish.bubbleTime = 0;
                }
            }
            
            // 🔄 EVOLUCIÓN AUTOMÁTICA CON EFECTOS ESPECTACULARES
            checkEvolution() {
                if (!this.fish || this.evolutionInProgress) return;
                
                const ageInDays = this.gameState.ageInDays || 0;
                const currentStage = this.gameState.stage;
                
                // Bebé → Joven (3 días)
                if (currentStage === 'baby' && ageInDays >= 3 && !this.gameState.hasEvolvedToYoung) {
                    this.startEvolution('young');
                    this.gameState.hasEvolvedToYoung = true;
                }
                
                // Joven → Adulto (8 días)
                if (currentStage === 'young' && ageInDays >= 8 && !this.gameState.hasEvolvedToAdult) {
                    this.startEvolution('adult');
                    this.gameState.hasEvolvedToAdult = true;
                }
            }
            
            // 🎭 INICIAR EVOLUCIÓN ESPECTACULAR
            startEvolution(newStage) {
                console.log(`🎭 ¡EVOLUCIÓN INICIADA! ${this.gameState.stage} → ${newStage}`);
                
                this.evolutionInProgress = true;
                this.evolutionStartTime = Date.now();
                this.evolutionTargetStage = newStage;
                
                // 🫧 CREAR EXPLOSIÓN DE BURBUJAS (como el huevo)
                this.createEvolutionBubbles();
                
                // 🔊 SONIDO DE EVOLUCIÓN
                if (window.audioManager) {
                    window.audioManager.playSound('evolution'); // Sonido mágico específico
                }
                
                // 🎉 EFECTO EN EL PEZ
                if (this.fish) {
                    this.fish.happyBurst = 4.0; // Giro más largo
                    this.fish.spinKind = "evolution";
                }
                
                // ⏰ PROGRAMAR CAMBIO DE ETAPA DESPUÉS DE 2 SEGUNDOS
                setTimeout(() => {
                    this.completeEvolution(newStage);
                }, 2000);
            }
            
            // 🎆 CREAR BURBUJAS DE EVOLUCIÓN (COMO LAS DEL HUEVO)
            createEvolutionBubbles() {
                console.log('🎆 Creando explosión de evolución...');
                
                // Limpiar burbujas anteriores
                this.explosionBubbles = this.explosionBubbles || [];
                this.explosionBubbles.length = 0;
                
                // Crear explosión desde el pez
                const fishX = this.fish ? this.fish.x : this.canvas.width / 2;
                const fishY = this.fish ? this.fish.y : this.canvas.height / 2;
                
                // 🎆 EXPLOSIÓN MASIVA DE EVOLUCIÓN (como el huevo pero dorada)
                for (let i = 0; i < 120; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 40 + Math.random() * 120; // Velocidad variada
                    const size = 4 + Math.random() * 10; // Tamaños variados
                    const life = 3 + Math.random() * 2; // Duraderas
                    
                    // Colores DORADOS Y AMARILLOS brillantes
                    const colors = ['#FFD700', '#FFA500', '#FFEB3B', '#FFF176', '#FFCC02', '#FFB300', '#FF8F00'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: fishX + (Math.random() - 0.5) * 60,
                        y: fishY + (Math.random() - 0.5) * 60,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.4, // Más brillo
                        color: color,
                        opacity: 0.9
                    });
                }
                
                console.log(`🎆 Burbujas de evolución doradas creadas: ${this.explosionBubbles.length}`);
            }
            
            // ✅ COMPLETAR EVOLUCIÓN CON MODAL BONITO
            completeEvolution(newStage) {
                // Cambiar etapa
                this.gameState.stage = newStage;
                this.evolutionInProgress = false;
                
                // 📏 ACTUALIZAR TAMAÑO DEL PEZ (LOTTIE Y CANVAS)
                if (this.fish) {
                    this.fish.size = this.fishSystem.getFishSizeForStage(newStage);
                    
                    // ESCALAR LOTTIE SEGÚN ETAPA - MÁS GRANDES
                    const scaleByStage = {
                        'baby': 1.0,
                        'young': 1.5, // 50% más grande (antes 20%)
                        'adult': 1.8  // 80% más grande (antes 40%)
                    };
                    
                    this.fish.targetScale = scaleByStage[newStage] || 1.0;
                    this.fish.scale = this.fish.targetScale; // Cambio inmediato
                    
                    console.log(`📏 Tamaño actualizado para ${newStage}: size=${this.fish.size}px, scale=${this.fish.scale}`);
                }
                
                // 🎨 RECARGAR LOTTIE CON NUEVA ETAPA (MANTENER DISEÑOS BONITOS)
                this.reloadLottieForStage(newStage);
                
                // Añadir al álbum
                const messages = {
                    'young': {
                        title: '🌱 ¡He crecido!',
                        desc: 'Ya no soy un bebé. ¡Ahora soy un pez joven y más fuerte!'
                    },
                    'adult': {
                        title: '👑 ¡Soy adulto!',
                        desc: 'He crecido completamente. ¡Ahora soy un pez adulto y sabio!'
                    }
                };
                
                const msg = messages[newStage];
                if (msg) {
                    this.addAlbumEvent('evolution', msg.title, msg.desc);
                    
                    // 🎉 MOSTRAR MODAL BONITO
                    this.showCustomModal({
                        title: msg.title,
                        message: `${msg.desc}\n\n✨ ¡Mis necesidades han cambiado!\n🍎 Tendré hambre más lentamente\n🧹 Me ensuciaré menos\n🎮 Me aburriré menos`,
                        confirmText: '🎉 ¡Qué emocionante!',
                        onConfirm: () => {
                            console.log(`✅ Evolución a ${newStage} completada`);
                            this.saveGame(); // Guardar inmediatamente
                        }
                    });
                }
                
                console.log(`🎭 EVOLUCIÓN COMPLETADA: ${newStage}`);
            }
            
            // 🎨 RECARGAR LOTTIE PARA NUEVA ETAPA (PRESERVANDO ESCALA)
            async reloadLottieForStage(newStage) {
                try {
                    // Guardar escala antes de destruir
                    const savedScale = this.fish ? this.fish.scale : 1.0;
                    const savedPosition = this.fish ? {x: this.fish.x, y: this.fish.y} : null;
                    
                    // Destruir animación actual
                    if (this.lottieAnimation) {
                        this.lottieAnimation.destroy();
                        this.lottieAnimation = null;
                    }
                    
                    // Cargar nueva animación
                    await this.createLottieFish();
                    
                    // RESTAURAR ESCALA Y POSICIÓN
                    if (this.fish) {
                        this.fish.scale = savedScale;
                        this.fish.targetScale = savedScale;
                        this.fish.growing = false; // No volver a crecer
                        
                        if (savedPosition) {
                            this.fish.x = savedPosition.x;
                            this.fish.y = savedPosition.y;
                        }
                    }
                    
                    console.log(`🎨 Lottie recargado para etapa: ${newStage} con escala: ${savedScale}`);
                    
                } catch (error) {
                    console.error('❌ Error recargando Lottie:', error);
                }
            }
            
            // 🍎 SISTEMA DE NECESIDADES
            
            // FUNCIÓN VIEJA DESHABILITADA - Usamos updateAllNeedBubbles ahora
            // updateNeeds(deltaTime) {
            //     // Esta función vieja estaba mostrando texto en lugar de iconos
            //     // Ahora usamos updateAllNeedBubbles() que muestra los iconos correctamente
            // }
            
            // FUNCIÓN VIEJA DESHABILITADA - Mostraba texto en lugar de iconos
            // showNeedBubble(icon, urgent = false) {
            //     // Esta función vieja está comentada porque mostraba texto
            //     // Usamos la nueva showNeedBubble(bubbleId, needType, offsetX, offsetY)
            // }
            
            // 🎨 SISTEMA DE FONDOS
            
            async loadAvailableBackgrounds() {
                // Lista de todos los fondos disponibles
                const knownBackgrounds = [
                    'Mi casa.png',           // Renombrado de basic
                    'Azulito.png',
                    'Bajo el mar.png',
                    'Bolas de dragon.png',
                    'Cuadrados corales.png',
                    'Cuadrados de noche.png',
                    'Cuadrados en el mar.png',
                    'El cielo.png',
                    'Entre corales.png',
                    'Guardianes.png',
                    'Hielo.png',
                    'Magico.png',
                    'Mi paraiso.png',
                    'Oscuro.png',
                    'Peppa Fish.png',
                    'Perretes.png',
                    'Piratas.png',
                    'Plastelina Isla.png',
                    'Plastelina.png',
                    'Playa.png',
                    'Slayer.png',
                    'Tuberias.png',
                    'Villa Volcan.png'
                ];
                
                for (const bgFile of knownBackgrounds) {
                    const bgName = bgFile.replace('.png', ''); // Usar nombre completo sin extensión
                    try {
                        const img = new Image();
                        img.src = `./images/backgrounds/${bgFile}`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            setTimeout(reject, 2000); // Timeout de 2s
                        });
                        
                        this.availableBackgrounds.push({
                            name: bgName,
                            file: bgFile,
                            image: img,
                            cost: bgName === 'Mi casa' ? 0 : this.getBackgroundCost(bgName), // Mi casa es gratis
                            unlocked: bgName === 'Mi casa' // Solo Mi casa desbloqueado
                        });
                        
                        console.log(`✅ Fondo cargado: ${bgName}`);
                    } catch (error) {
                        console.warn(`⚠️ No se pudo cargar: ${bgFile}`);
                    }
                }
                
                console.log(`🎨 ${this.availableBackgrounds.length} fondos disponibles`);
                this.populateBackgroundsGrid();
            }
            
            populateBackgroundsGrid() {
                const grid = document.getElementById('backgroundsGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                for (const bg of this.availableBackgrounds) {
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    if (this.gameState.currentBackground === bg.name) {
                        card.classList.add('selected');
                    }
                    
                    const isLocked = bg.cost > 0 && this.gameState.bubbles < bg.cost;
                    
                    card.innerHTML = `
                        <div class="item-preview" style="background-image: url('./images/backgrounds/${bg.file}')${isLocked ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="item-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="item-cost">${bg.cost === 0 ? 'Gratis' : bg.cost + ' 🫧'}</div>
                        ${isLocked ? '<div class="locked-overlay">🔒</div>' : ''}
                    `;
                    
                    card.addEventListener('click', () => {
                        this.useInventoryItem(`bg-${bg.name}`);
                    });
                    
                    grid.appendChild(card);
                }
            }
            
            selectBackground(bgName) {
                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                if (!bg) return;
                
                // Si ya está seleccionado, no hacer nada
                if (this.gameState.currentBackground === bgName) {
                    console.log('🎨 Ya tienes este fondo seleccionado');
                    return;
                }
                
                // Si cuesta burbujas, pedir confirmación
                if (bg.cost > 0) {
                    // Verificar si tiene suficientes burbujas
                    if (this.gameState.bubbles < bg.cost) {
                        const needed = bg.cost - this.gameState.bubbles;
                        this.showCustomModal({
                            title: '🐠💭 ¡Me encanta este fondo!',
                            message: `Pero necesitamos más burbujas...\n\n🫧 Necesitas: ${bg.cost} burbujas\n🫧 Tienes: ${this.gameState.bubbles} burbujas\n❌ Te faltan: ${needed} burbujas\n\n🎮 ¡Juega minijuegos para ganar más burbujas!`,
                            confirmText: '🎮 ¡Vamos a jugar!',
                            onConfirm: () => {}
                        });
                        return;
                    }
                    
                    // Mensajes personalizados por fondo
                    const bgDisplayName = bg.name.charAt(0).toUpperCase() + bg.name.slice(1);
                    const fishMessages = {
                        'cartoon': '🐠💭 "¡Wow! Este lugar parece súper divertido!"',
                        'coral': '🐠💭 "¡Me encanta nadar entre corales!"',
                        'mario': '🐠💭 "¡Como en los videojuegos! ¡Genial!"',
                        'minecraft': '🐠💭 "¡Un mundo de bloques para explorar!"'
                    };
                    
                    const fishMessage = fishMessages[bg.name] || '🐠💭 "¡Este lugar se ve genial para nadar!"';
                    
                    this.showCustomModal({
                        title: '🏠 ¡Tu pececito quiere un nuevo hogar!',
                        message: `🎨 Fondo: ${bgDisplayName}\n🫧 Cuesta: ${bg.cost} burbujas\n🫧 Tienes: ${this.gameState.bubbles} burbujas\n\n${fishMessage}`,
                        confirmText: '✨ ¡Desbloquear fondo!',
                        cancelText: '🚫 Mejor no',
                        onConfirm: () => {
                            // Proceder con la compra
                            this.completePurchase(bg);
                        },
                        onCancel: () => {
                            console.log('🚫 Compra cancelada');
                        }
                    });
                    return; // Salir aquí, la compra se completa en completePurchase
                }
                
                // Si es gratis, comprar directamente
                this.completePurchase(bg);
            }
            
            completePurchase(bg) {
                // Cobrar
                if (bg.cost > 0) {
                    this.gameState.bubbles -= bg.cost;
                    console.log(`💳 Pagado: ${bg.cost} burbujas`);
                }
                
                // Cambiar fondo
                this.gameState.currentBackground = bg.name;
                this.bgImage = bg.image;
                
                console.log(`🎨 Fondo cambiado a: ${bg.name}, imagen: ${bg.image ? 'cargada' : 'no cargada'}`);
                
                // Mensaje de éxito
                if (bg.cost > 0) {
                    const successMessages = {
                        'cartoon': '🎉 ¡Tu pececito está súper feliz en su nuevo hogar cartoon!',
                        'coral': '🎉 ¡Tu pececito nada feliz entre los corales!',
                        'mario': '🎉 ¡Tu pececito se siente como en un videojuego!',
                        'minecraft': '🎉 ¡Tu pececito explora su mundo de bloques!'
                    };
                    
                    const successMsg = successMessages[bg.name] || '🎉 ¡Tu pececito ama su nuevo hogar!';
                    
                    // Mostrar mensaje de éxito con modal bonito
                    this.showCustomModal({
                        title: '🎉 ¡Fondo desbloqueado!',
                        message: `${successMsg}\n\n🐠💭 "¡Gracias! ¡Me encanta!"`,
                        confirmText: '🥰 ¡De nada!',
                        onConfirm: () => {}
                    });
                }
                
                // Añadir evento al álbum
                const purchaseMsg = bg.cost > 0 ? 
                    `He comprado un nuevo fondo ${bg.name} por ${bg.cost} burbujas. ¡Me encanta mi nuevo hogar!` :
                    `He cambiado mi acuario por uno ${bg.name}. ¡Me encanta mi nuevo hogar!`;
                this.addAlbumEvent('background', `🎨 Nuevo hogar: ${bg.name}`, purchaseMsg);
                
                console.log(`🎨 Fondo cambiado a: ${bg.name}`);
                this.populateBackgroundsGrid(); // Actualizar selección
                this.updateUI();
                this.saveGame();
            }
            
            // 🖥️ ACTUALIZACIÓN DE UI
            
            updateUI() {
                // Actualizar contadores con animación
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                
                // Actualizar edad y nombre
                this.updateAgeDisplay();
                
                // Actualizar UI de todos los juegos con las estrellas totales
                if (typeof updateGamesUI === 'function') {
                    updateGamesUI();
                }
            }
            
            // 📊 FUNCIÓN updateNeedBars() ELIMINADA - AHORA EN needs-system.js
            
            updateCurrencyDisplay(elementId, newValue) {
                const element = document.getElementById(elementId);
                const currentValue = parseInt(element.textContent) || 0;
                
                if (newValue !== currentValue) {
                    element.textContent = newValue;
                    
                    // Añadir animación
                    const floatContainer = element.closest('.currency-float');
                    if (floatContainer) {
                        floatContainer.classList.add('updated');
                        setTimeout(() => {
                            floatContainer.classList.remove('updated');
                        }, 500);
                    }
                }
            }
            
            updateAgeDisplay() {
                const fishAge = document.getElementById('fishAge');
                const fishName = document.getElementById('fishName');
                
                if (this.gameState.stage === 'waiting') {
                    fishAge.textContent = 'Esperando...';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.gameState.stage === 'egg') {
                    fishAge.textContent = 'Huevo';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.fish && this.gameState.birthDate) {
                    // Calcular edad en días
                    const now = Date.now();
                    const ageInMs = now - this.gameState.birthDate;
                    const ageInDays = Math.floor(ageInMs / (24 * 60 * 60 * 1000));
                    this.gameState.ageInDays = ageInDays;
                    
                    // Mostrar etapa y edad
                    const stageEmojis = {
                        'baby': '🍼',
                        'young': '🌱', 
                        'adult': '👑'
                    };
                    
                    const stageNames = {
                        'baby': 'Bebé',
                        'young': 'Joven',
                        'adult': 'Adulto'
                    };
                    
                    const stageName = stageNames[this.gameState.stage] || 'Pez';
                    
                    fishAge.textContent = `${stageName} - ${ageInDays} día${ageInDays !== 1 ? 's' : ''}`;
                    
                    // Nombre del juego con el nombre del pez
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                } else {
                    fishAge.textContent = '🍼 Bebé';
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                }
            }
            
            // 🏷️ MODAL PARA CAMBIAR NOMBRE DEL PEZ
            showChangeNameModal() {
                const currentName = this.gameState.fishName || 'Sin nombre';
                
                this.showCustomModal({
                    title: '🏷️ Cambiar nombre',
                    message: `Nombre actual: "${currentName}"\n\n¿Cómo quieres llamar a tu pez?`,
                    confirmText: '✅ Cambiar',
                    cancelText: '❌ Cancelar',
                    input: true, // ACTIVAR CAMPO DE INPUT
                    inputPlaceholder: 'Nuevo nombre...',
                    inputValue: currentName === 'Sin nombre' ? '' : currentName,
                    onConfirm: (newName) => {
                        if (newName && newName.trim()) {
                            const oldName = this.gameState.fishName;
                            this.gameState.fishName = newName.trim();
                            this.updateUI();
                            this.saveGame();
                            
                            // Añadir evento al álbum
                            this.addAlbumEvent('rename', '🏷️ Nuevo nombre', 
                                oldName ? `Cambié mi nombre de "${oldName}" a "${newName.trim()}"` : 
                                `¡Ahora me llamo "${newName.trim()}"!`);
                            
                            console.log(`🏷️ Nombre cambiado a: ${newName.trim()}`);
                        }
                    }
                });
            }
            
            // 🐠 SISTEMA DE NOMBRE
            
            askForFishName() {
                console.log('🏷️ DEBUG NOMBRE:', {
                    hasAskedForName: this.gameState.hasAskedForName,
                    fishName: this.gameState.fishName,
                    shouldAsk: !this.gameState.hasAskedForName && !this.gameState.fishName
                });
                
                if (this.gameState.hasAskedForName || this.gameState.fishName) {
                    console.log('❌ No preguntar nombre - Ya preguntado o ya tiene nombre');
                    return;
                }
                
                this.gameState.hasAskedForName = true;
                console.log('🏷️ Preguntando nombre del pez...');
                
                // Mostrar burbuja de nombre
                this.showNameBubble();
            }
            
            showNameBubble() {
                if (!this.fish) return;
                
                // Crear modal bonito para el nombre
                this.showCustomModal({
                    title: 'Hola! Soy tu nuevo pececito',
                    message: 'Como quieres llamarme?\n\nSi no escribes nada, elegiré un nombre bonito para mi',
                    input: true,
                    inputPlaceholder: 'Mi nombre...',
                    confirmText: 'Confirmar',
                    onConfirm: (name) => {
                        if (name && name.trim()) {
                            this.gameState.fishName = name.trim();
                            console.log(`🏷️ Pez nombrado: ${this.gameState.fishName}`);
                            
                            // Mostrar mensaje de bienvenida con consejos
                            this.showCustomModal({
                                title: '¡Perfecto!',
                                message: `🐠 "¡Me encanta mi nombre ${this.gameState.fishName}!"\n\n¡Gracias por elegirme!\n\n💡 Consejos para cuidarme:\n🫧 Alimenta cuando tenga hambre → +2 burbujas\n🧹 Límpiame cuando esté sucio → +3 burbujas\n🎮 Juega conmigo → +burbujas y estrellas\n\n¡Con burbujas podrás comprarme fondos bonitos!`,
                                confirmText: '¡Empecemos juntos!',
                                onConfirm: () => {}
                            });
                        } else {
                            this.setRandomName();
                            console.log(`🏷️ Nombre aleatorio elegido: ${this.gameState.fishName}`);
                        }
                        this.updateUI();
                        this.saveGame();
                    }
                });
            }
            
            setRandomName() {
                const randomNames = ['Burbujín', 'Nadador', 'Azulito', 'Brillante', 'Saltarín', 'Coralito'];
                this.gameState.fishName = randomNames[Math.floor(Math.random() * randomNames.length)];
                
                this.showCustomModal({
                    title: '🌟 ¡Sorpresa!',
                    message: `"Me llamaré ${this.gameState.fishName}"\n\n¡Espero que te guste mi nombre!\n\n💡 Consejos para cuidarme:\n\nAliméntame cuando tenga hambre → ganarás burbujas.\n\nLímpiame cuando esté sucio → obtendrás más burbujas.\n\nJuega conmigo → conseguirás burbujas y estrellas.\n\n✨ Con las burbujas podrás regalarme fondos bonitos.`,
                    confirmText: '¡Empecemos juntos!',
                    onConfirm: () => {}
                });
            }
            
            // 🎨 MODAL PERSONALIZADO BONITO
            showCustomModal(options) {
                // Crear modal dinámicamente
                const modal = document.createElement('div');
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <div class="custom-modal-content">
                        <div class="custom-modal-header">
                            <h2>${options.title}</h2>
                        </div>
                        <div class="custom-modal-body">
                            <p>${options.message.replace(/\n/g, '<br>')}</p>
                            ${options.input ? `<input type="text" class="custom-input" placeholder="${options.inputPlaceholder}" maxlength="15">` : ''}
                        </div>
                        <div class="custom-modal-buttons">
                            <button class="custom-btn confirm-btn">${options.confirmText}</button>
                            ${options.cancelText ? `<button class="custom-btn cancel-btn">${options.cancelText}</button>` : ''}
                        </div>
                    </div>
                `;
                
                // Añadir estilos inline para que funcione inmediatamente
                modal.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const content = modal.querySelector('.custom-modal-content');
                content.style.cssText = `
                    background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
                    border: 4px solid #ffffff;
                    border-radius: 25px;
                    padding: 25px;
                    max-width: 350px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    animation: modalPop 0.3s ease-out;
                `;
                
                // Event listeners
                const confirmBtn = modal.querySelector('.confirm-btn');
                const cancelBtn = modal.querySelector('.cancel-btn');
                const input = modal.querySelector('.custom-input');
                
                confirmBtn.addEventListener('click', () => {
                    const value = input ? input.value : null;
                    document.body.removeChild(modal);
                    options.onConfirm(value);
                });
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        options.onCancel();
                    });
                }
                
                // Focus en input si existe
                document.body.appendChild(modal);
                if (input) {
                    // Asignar valor inicial si se proporcionó
                    if (options.inputValue) {
                        input.value = options.inputValue;
                    }
                    input.focus();
                    input.select(); // Seleccionar todo el texto
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmBtn.click();
                        }
                    });
                }
            }
            
            // 📸 MOSTRAR ÁLBUM
            
            showAlbum() {
                this.populateAlbum();
                document.getElementById('albumModal').style.display = 'flex';
            }
            
            populateAlbum() {
                const albumTimeline = document.getElementById('albumTimeline');
                const albumDays = document.getElementById('albumDays');
                const albumEvents = document.getElementById('albumEvents');
                const albumMilestones = document.getElementById('albumMilestones');
                
                // Estadísticas
                const daysSinceBirth = this.gameState.birthDate ? 
                    Math.floor((Date.now() - this.gameState.birthDate) / (24 * 60 * 60 * 1000)) : 0;
                const totalEvents = this.gameState.album?.length || 0;
                const milestones = this.gameState.album?.filter(e => 
                    ['birth', 'naming', 'background'].includes(e.type)).length || 0;
                
                albumDays.textContent = daysSinceBirth;
                albumEvents.textContent = totalEvents;
                albumMilestones.textContent = milestones;
                
                // Timeline
                albumTimeline.innerHTML = '';
                
                if (!this.gameState.album || this.gameState.album.length === 0) {
                    albumTimeline.innerHTML = `
                        <div class="album-entry">
                            <div class="album-entry-title">📝 Diario vacío</div>
                            <div class="album-entry-description">¡Los recuerdos aparecerán aquí mientras juegas!</div>
                        </div>
                    `;
                    return;
                }
                
                // Mostrar eventos más recientes primero
                const sortedEvents = [...this.gameState.album].reverse();
                
                sortedEvents.forEach(event => {
                    const entry = document.createElement('div');
                    entry.className = 'album-entry';
                    entry.innerHTML = `
                        <div class="album-entry-header">
                            <div class="album-entry-title">${event.title}</div>
                            <div class="album-entry-date">${event.date} ${event.time}</div>
                        </div>
                        <div class="album-entry-description">${event.description}</div>
                        <div class="album-entry-meta">
                            <div class="album-entry-age">Día ${event.fishAge}</div>
                            <div>${event.fishName}</div>
                        </div>
                    `;
                    albumTimeline.appendChild(entry);
                });
            }
            
            // 📸 SISTEMA DE ÁLBUM/DIARIO
            
            addAlbumEvent(type, title, description, photo = null) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type, // 'birth', 'naming', 'feeding', 'playing', 'background', 'milestone'
                    title: title,
                    description: description,
                    photo: photo, // URL de la foto o null
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                
                // Mantener solo los últimos 50 eventos para no saturar
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                
                console.log(`📸 Evento añadido al álbum: ${title}`);
                this.saveGame();
                
                // Verificar logros después de añadir evento
                this.checkAchievements();
            }
            
            // 🫧 EFECTO VISUAL DE BURBUJAS AL CONTADOR
            createBubbleEffect(amount) {
                console.log(`🫧 Creando efecto de ${amount} burbujas al contador`);
                
                // Obtener posición del contador de burbujas
                const bubbleCounter = document.getElementById('bubblesCount');
                if (!bubbleCounter) return;
                
                const counterRect = bubbleCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Obtener posición del pez (convertir coordenadas del canvas a coordenadas de pantalla)
                const canvasRect = this.canvas.getBoundingClientRect();
                const startX = canvasRect.left + (this.fish ? this.fish.x : this.canvas.width/2);
                const startY = canvasRect.top + (this.fish ? this.fish.y : this.canvas.height/2);
                
                // Calcular distancia y duración de animación
                const distance = Math.sqrt((targetX - startX) ** 2 + (targetY - startY) ** 2);
                const duration = Math.max(800, Math.min(2000, distance * 2)); // 800ms mínimo, 2000ms máximo
                
                console.log(`🫧 Animación: ${distance.toFixed(0)}px en ${duration}ms`);
                
                // Crear burbujas que vuelan desde el pez al contador
                for (let i = 0; i < amount; i++) {
                    const bubble = document.createElement('div');
                    bubble.innerHTML = '🫧';
                    bubble.style.cssText = `
                        position: fixed;
                        left: ${startX}px;
                        top: ${startY}px;
                        font-size: 20px;
                        pointer-events: none;
                        z-index: 10000;
                        transition: all ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        transform: translate(0, 0) scale(1);
                        opacity: 1;
                    `;
                    
                    document.body.appendChild(bubble);
                    
                    // Animar hacia el contador
                    setTimeout(() => {
                        bubble.style.left = `${targetX}px`;
                        bubble.style.top = `${targetY}px`;
                        bubble.style.transform = 'translate(-50%, -50%) scale(0.3)';
                        bubble.style.opacity = '0';
                    }, 50 + (i * 100)); // Delay escalonado con offset mínimo
                    
                    // Remover después de la animación
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, duration + 50 + (i * 100) + 200);
                }
                
                // Actualizar contador con animación
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
            }
            
            // 🎆 ANIMACIONES DINÁMICAS PARA RECOMPENSAS EXTRA
            createRewardAnimation(stars, bubbles, sourceElement = null) {
                if (stars >= 2 || bubbles >= 10) {
                    console.log(`🎆 ¡RECOMPENSA EXTRA! ${stars} estrellas, ${bubbles} burbujas`);
                    
                    // Crear explosión de partículas doradas
                    if (!this.rewardParticles) this.rewardParticles = [];
                    
                    const centerX = sourceElement ? sourceElement.offsetLeft + sourceElement.offsetWidth/2 : this.canvas.width/2;
                    const centerY = sourceElement ? sourceElement.offsetTop + sourceElement.offsetHeight/2 : this.canvas.height/2;
                    
                    // Crear partículas especiales basadas en las recompensas
                    const particleCount = Math.min(stars * 15 + Math.floor(bubbles/2), 50);
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = 100 + Math.random() * 150;
                        const life = 2 + Math.random() * 1.5;
                        
                        // Colores especiales para diferentes recompensas
                        let color = '#FFD700'; // Dorado por defecto
                        if (stars >= 3) color = '#FF6B9D'; // Rosa para 3+ estrellas
                        else if (stars >= 2) color = '#4ECDC4'; // Cyan para 2+ estrellas
                        else if (bubbles >= 20) color = '#45B7D1'; // Azul para muchas burbujas
                        
                        this.rewardParticles.push({
                            x: centerX + (Math.random() - 0.5) * 40,
                            y: centerY + (Math.random() - 0.5) * 40,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed - 30,
                            r: 3 + Math.random() * 5,
                            life: life,
                            maxLife: life,
                            color: color,
                            sparkle: Math.random() < 0.6,
                            type: stars >= 2 ? 'star' : 'bubble'
                        });
                    }
                    
                    // Sonido especial para recompensas extra
                    if (window.audioManager && stars >= 2) {
                        window.audioManager.playSound('achievement');
                    }
                    
                    // Mensaje flotante - CENTRADO EN EL CANVAS (ya no hay juego de burbujas integrado)
                    // Los efectos de recompensa se muestran en el centro del canvas principal
                }
            }
            
            // 💫 ACTUALIZAR PARTÍCULAS DE RECOMPENSA
            updateRewardParticles(deltaTime) {
                if (!this.rewardParticles) return;
                
                for (let i = this.rewardParticles.length - 1; i >= 0; i--) {
                    const p = this.rewardParticles[i];
                    p.life -= deltaTime;
                    
                    // Física de partículas
                    p.vy += 150 * deltaTime; // Gravedad
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    
                    // Eliminar partículas muertas
                    if (p.life <= 0 || p.y > this.canvas.height + 50) {
                        this.rewardParticles.splice(i, 1);
                    }
                }
            }
            
            // ✨ DIBUJAR PARTÍCULAS DE RECOMPENSA
            drawRewardParticles() {
                if (!this.rewardParticles || this.rewardParticles.length === 0) return;
                
                this.ctx.save();
                for (const p of this.rewardParticles) {
                    const alpha = Math.max(0, p.life / p.maxLife);
                    this.ctx.globalAlpha = alpha;
                    
                    if (p.type === 'star') {
                        // Dibujar estrella
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        const spikes = 5;
                        const outerRadius = p.r * 1.5;
                        const innerRadius = p.r * 0.7;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes;
                            const x = p.x + Math.cos(angle) * radius;
                            const y = p.y + Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                    } else {
                        // Dibujar burbuja
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (p.sparkle) {
                            this.ctx.fillStyle = 'white';
                            this.ctx.beginPath();
                            this.ctx.arc(p.x - p.r * 0.3, p.y - p.r * 0.3, p.r * 0.2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                this.ctx.restore();
            }
            
            // 💬 MOSTRAR MENSAJE FLOTANTE
            showFloatingMessage(text, x, y) {
                if (!this.floatingMessages) this.floatingMessages = [];
                
                this.floatingMessages.push({
                    text: text,
                    x: x,
                    y: y,
                    life: 2.5,
                    maxLife: 2.5,
                    vy: -60 // Velocidad hacia arriba
                });
            }
            
            // 🐠 MENSAJES SUTILES DEL PEZ
            showFishMessage(message, color = '#FFD700') {
                if (!this.fish) return;
                
                // Mensajes más pequeños y sutiles
                if (!this.floatingMessages) this.floatingMessages = [];
                
                    this.floatingMessages.push({
                        text: message,
                        x: this.fish.x,
                        y: this.fish.y - 20,
                        life: 3.0,
                        maxLife: 3.0,
                        vy: -40, // Más lento
                        color: '#FFFFFF', // Texto blanco
                        size: 18 // Más pequeño
                });
            }
            
            // 📝 ACTUALIZAR MENSAJES FLOTANTES
            updateFloatingMessages(deltaTime) {
                if (!this.floatingMessages) return;
                
                for (let i = this.floatingMessages.length - 1; i >= 0; i--) {
                    const msg = this.floatingMessages[i];
                    msg.life -= deltaTime;
                    msg.y += msg.vy * deltaTime;
                    
                    if (msg.life <= 0) {
                        this.floatingMessages.splice(i, 1);
                    }
                }
            }
            
            // ✨ DIBUJAR MENSAJES FLOTANTES
            drawFloatingMessages() {
                if (!this.floatingMessages || this.floatingMessages.length === 0) return;
                
                this.ctx.save();
                for (const msg of this.floatingMessages) {
                    const alpha = Math.max(0, msg.life / msg.maxLife);
                    this.ctx.globalAlpha = alpha;
                    
                    // Tamaño y color personalizables
                    const fontSize = msg.size || 24;
                    const color = msg.color || '#FFD700';
                    
                    this.ctx.font = `bold ${fontSize}px Arial`;
                    this.ctx.fillStyle = color;
                    this.ctx.textAlign = 'center';
                    
                    // Solo texto sin borde negro
                    this.ctx.fillText(msg.text, msg.x, msg.y);
                }
                this.ctx.restore();
            }
            
            // 🏆 SISTEMA DE LOGROS INTEGRADO
            checkAchievements() {
                if (!this.gameState.achievements) {
                    this.gameState.achievements = [];
                }
                
                const achievements = [
                    {
                        id: 'first_birth',
                        title: '🐣 Primera Vida',
                        desc: 'Tu primer pececito ha nacido',
                        condition: () => this.gameState.stage !== 'egg',
                        reward: { bubbles: 5, stars: 1 }
                    },
                    {
                        id: 'first_evolution',
                        title: '🌱 Crecimiento',
                        desc: 'Tu pez ha evolucionado por primera vez',
                        condition: () => this.gameState.hasEvolvedToYoung,
                        reward: { bubbles: 10, stars: 2 }
                    },
                    {
                        id: 'adult_fish',
                        title: '👑 Madurez',
                        desc: 'Tu pez ha alcanzado la edad adulta',
                        condition: () => this.gameState.hasEvolvedToAdult,
                        reward: { bubbles: 20, stars: 3 }
                    },
                    {
                        id: 'bubble_collector',
                        title: '🫧 Coleccionista',
                        desc: 'Has reunido 100 burbujas',
                        condition: () => this.gameState.bubbles >= 100,
                        reward: { bubbles: 25, stars: 2 }
                    },
                    {
                        id: 'star_hunter',
                        title: '⭐ Cazador de Estrellas',
                        desc: 'Has reunido 50 estrellas',
                        condition: () => this.gameState.stars >= 50,
                        reward: { bubbles: 30, stars: 5 }
                    },
                    {
                        id: 'caring_owner',
                        title: '💖 Cuidador Ejemplar',
                        desc: 'Has alimentado a tu pez 20 veces',
                        condition: () => {
                            const feedEvents = this.gameState.album.filter(e => 
                                e.type === 'feeding' || e.description.includes('comido')
                            ).length;
                            return feedEvents >= 20;
                        },
                        reward: { bubbles: 15, stars: 3 }
                    },
                    {
                        id: 'week_survivor',
                        title: '📅 Una Semana Juntos',
                        desc: 'Tu pez ha vivido 7 días',
                        condition: () => (this.gameState.ageInDays || 0) >= 7,
                        reward: { bubbles: 35, stars: 5 }
                    }
                ];
                
                achievements.forEach(achievement => {
                    // Verificar si ya se obtuvo este logro
                    const alreadyEarned = this.gameState.achievements.includes(achievement.id);
                    
                    if (!alreadyEarned && achievement.condition()) {
                        // ¡Logro desbloqueado!
                        this.gameState.achievements.push(achievement.id);
                        
                        // Dar recompensas
                        this.gameState.bubbles += achievement.reward.bubbles;
                        this.gameState.stars += achievement.reward.stars;
                        
                        // Añadir al álbum como evento especial
                        this.addAlbumEventDirect('achievement', achievement.title, achievement.desc);
                        
                        // Mostrar notificación
                        this.showAchievementNotification(achievement);
                        
                        console.log(`🏆 ¡LOGRO DESBLOQUEADO! ${achievement.title}`);
                        this.updateUI(); // Actualizar burbujas/estrellas
                    }
                });
            }
            
            // 📸 AÑADIR EVENTO SIN RECURSIÓN
            addAlbumEventDirect(type, title, description) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type,
                    title: title,
                    description: description,
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                this.saveGame();
            }
            
            // 🎉 NOTIFICACIÓN DE LOGRO
            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="achievement-content">
                        <div class="achievement-icon">🏆</div>
                        <div class="achievement-text">
                            <div class="achievement-title">${achievement.title}</div>
                            <div class="achievement-desc">${achievement.desc}</div>
                            <div class="achievement-reward">+${achievement.reward.bubbles}🫧 +${achievement.reward.stars}⭐</div>
                        </div>
                    </div>
                `;
                
                notification.style.cssText = `
                    position: fixed; top: 80px; right: 20px;
                    background: linear-gradient(135deg, #1bb37a, #2e7d32);
                    color: white; border: 2px solid #4caf50; border-radius: 15px; padding: 15px;
                    box-shadow: 0 8px 25px rgba(27, 179, 122, 0.4); z-index: 10000;
                    animation: slideInRight 0.5s ease; max-width: 300px;
                `;
                
                // Añadir animaciones CSS si no existen
                if (!document.querySelector('#achievement-animations')) {
                    const style = document.createElement('style');
                    style.id = 'achievement-animations';
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        @keyframes bounce {
                            0%, 20%, 53%, 80%, 100% { transform: scale(1); }
                            40%, 43% { transform: scale(1.1); }
                            70% { transform: scale(1.05); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                const content = notification.querySelector('.achievement-content');
                content.style.cssText = `display: flex; align-items: center; gap: 12px;`;
                
                const icon = notification.querySelector('.achievement-icon');
                icon.style.cssText = `font-size: 32px; animation: bounce 0.6s ease;`;
                
                const title = notification.querySelector('.achievement-title');
                title.style.cssText = `font-weight: bold; font-size: 16px; margin-bottom: 4px;`;
                
                const desc = notification.querySelector('.achievement-desc');
                desc.style.cssText = `font-size: 12px; opacity: 0.9; margin-bottom: 4px;`;
                
                const reward = notification.querySelector('.achievement-reward');
                reward.style.cssText = `font-size: 12px; font-weight: bold; color: #ffeb3b;`;
                
                document.body.appendChild(notification);
                
                // Remover después de 4 segundos
                setTimeout(() => {
                    notification.style.animation = 'slideInRight 0.5s ease reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
                
                // Sonido de logro
                if (window.audioManager) {
                    window.audioManager.playSound('achievement');
                }
            }
            
            // 📱 SISTEMA DE COMPARTIR PEZ
            shareMyFish() {
                console.log('📱 Iniciando sistema de compartir...');
                
                // Crear imagen bonita para compartir
                this.generateShareImage().then(shareData => {
                    // Mostrar modal de compartir
                    this.showShareModal(shareData);
                }).catch(error => {
                    console.error('Error generando imagen:', error);
                    this.showSimpleShare();
                });
            }
            
            async generateShareImage() {
                // Crear canvas temporal para captura
                const shareCanvas = document.createElement('canvas');
                shareCanvas.width = 400;
                shareCanvas.height = 300;
                const ctx = shareCanvas.getContext('2d');
                
                // Fondo bonito
                const gradient = ctx.createLinearGradient(0, 0, 400, 300);
                gradient.addColorStop(0, '#4fc3f7');
                gradient.addColorStop(0.5, '#29b6f6');
                gradient.addColorStop(1, '#0288d1');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 300);
                
                // Título
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🐠 Mi Pececito', 200, 40);
                
                // Info del pez
                const fishName = this.gameState.fishName || 'Sin nombre';
                const stage = this.gameState.stage;
                const age = this.gameState.ageInDays || 0;
                const bubbles = this.gameState.bubbles || 0;
                const stars = this.gameState.stars || 0;
                
                ctx.font = '18px Arial';
                ctx.fillText(`Nombre: ${fishName}`, 200, 80);
                ctx.fillText(`Etapa: ${stage === 'baby' ? 'Bebé' : stage === 'young' ? 'Joven' : 'Adulto'}`, 200, 110);
                ctx.fillText(`Edad: ${age} días`, 200, 140);
                ctx.fillText(`🫧 ${bubbles} burbujas  ⭐ ${stars} estrellas`, 200, 170);
                
                // Mensaje
                ctx.font = '16px Arial';
                ctx.fillStyle = '#e3f2fd';
                ctx.fillText('¡Ven a cuidar tu propio pececito!', 200, 220);
                ctx.fillText('🌊 Mi Pececito - Mascota Virtual 🌊', 200, 250);
                
                // Convertir a blob
                return new Promise(resolve => {
                    shareCanvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        resolve({
                            image: url,
                            text: `🐠 ¡Mira mi pececito ${fishName}! Es un ${stage === 'baby' ? 'bebé' : stage === 'young' ? 'joven' : 'adulto'} de ${age} días. ¡Únete a Mi Pececito! 🌊`,
                            url: window.location.href
                        });
                    }, 'image/png');
                });
            }
            
            showShareModal(shareData) {
                this.showCustomModal({
                    title: '📱 Compartir mi pez',
                    message: `¿Cómo quieres compartir a ${this.gameState.fishName || 'tu pececito'}?`,
                    confirmText: '📋 Copiar texto',
                    cancelText: '❌ Cancelar',
                    onConfirm: () => {
                        // Copiar al portapapeles
                        navigator.clipboard.writeText(shareData.text).then(() => {
                            alert('📋 ¡Texto copiado! Pégalo en WhatsApp, Telegram, etc.');
                        }).catch(() => {
                            // Fallback para navegadores sin clipboard API
                            this.showTextToCopy(shareData.text);
                        });
                    },
                    extraButtons: [
                        {
                            text: '📸 Descargar imagen',
                            onclick: () => {
                                const link = document.createElement('a');
                                link.download = `mi-pececito-${this.gameState.fishName || 'mascota'}.png`;
                                link.href = shareData.image;
                                link.click();
                                URL.revokeObjectURL(shareData.image);
                            }
                        },
                        {
                            text: '🌐 Compartir web',
                            onclick: () => {
                                if (navigator.share) {
                                    navigator.share({
                                        title: 'Mi Pececito',
                                        text: shareData.text,
                                        url: shareData.url
                                    });
                                } else {
                                    this.showTextToCopy(shareData.url);
                                }
                            }
                        }
                    ]
                });
            }
            
            showSimpleShare() {
                const fishName = this.gameState.fishName || 'mi pececito';
                const stage = this.gameState.stage;
                const age = this.gameState.ageInDays || 0;
                const text = `🐠 ¡Mira mi pececito ${fishName}! Es un ${stage === 'baby' ? 'bebé' : stage === 'young' ? 'joven' : 'adulto'} de ${age} días. ¡Únete a Mi Pececito! 🌊`;
                
                this.showTextToCopy(text);
            }
            
            showTextToCopy(text) {
                this.showCustomModal({
                    title: '📋 Copiar para compartir',
                    message: 'Copia este texto y compártelo:',
                    confirmText: '✅ Entendido',
                    input: true,
                    inputValue: text,
                    inputReadonly: true,
                    onConfirm: () => {
                        console.log('📱 Texto para compartir mostrado');
                    }
                });
            }
            
            // ✨ EFECTOS DE PARTÍCULAS AL COMER (SOLO PARTÍCULAS, NO CORAZONES NI PUNTOS)
            createEatingParticles(x, y) {
                if (!this.eatingParticles) this.eatingParticles = [];
                
                // Crear 8-12 partículas brillantes de comida
                const particleCount = 8 + Math.floor(Math.random() * 5);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                    const speed = 60 + Math.random() * 40;
                    const size = 3 + Math.random() * 4;
                    const life = 1.2 + Math.random() * 0.8;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20, // Hacia arriba
                        size: size,
                        life: life,
                        maxLife: life,
                        color: ['#ffeb3b', '#ffc107', '#ff9800', '#4caf50', '#2196f3'][Math.floor(Math.random() * 5)],
                        sparkle: Math.random() < 0.5
                    };
                    
                    this.eatingParticles.push(particle);
                }
                
                // IMPORTANTE: Solo crear partículas, NO corazones ni textos flotantes con puntos
                console.log(`✨ ${particleCount} partículas de comida creadas en (${x.toFixed(1)}, ${y.toFixed(1)})`);
            }
            
            // ✨ ACTUALIZAR PARTÍCULAS DE COMIDA
            updateEatingParticles(deltaTime) {
                if (!this.eatingParticles) return;
                
                for (let i = this.eatingParticles.length - 1; i >= 0; i--) {
                    const p = this.eatingParticles[i];
                    
                    // Física
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.vy += 80 * deltaTime; // Gravedad suave
                    p.vx *= 0.98; // Fricción
                    
                    // Vida
                    p.life -= deltaTime;
                    
                    // Remover si murió
                    if (p.life <= 0) {
                        this.eatingParticles.splice(i, 1);
                    }
                }
            }
            
            // ✨ DIBUJAR PARTÍCULAS DE COMIDA
            drawEatingParticles() {
                if (!this.eatingParticles || this.eatingParticles.length === 0) return;
                
                this.ctx.save();
                
                for (const p of this.eatingParticles) {
                    const alpha = p.life / p.maxLife;
                    const size = p.size * (0.5 + alpha * 0.5);
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = p.color;
                    
                    // Partícula brillante
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo extra para algunas partículas
                    if (p.sparkle) {
                        this.ctx.globalAlpha = alpha * 0.6;
                        this.ctx.fillStyle = 'white';
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, size * 0.5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.restore();
            }
            
            checkForAlbumEvents() {
                const now = Date.now();
                const hoursSinceLastEvent = (now - this.gameState.lastEventTime) / (1000 * 60 * 60);
                
                // Solo generar eventos cada 1+ horas para más actividad
                if (hoursSinceLastEvent < 1) return;
                
                // Eventos aleatorios basados en el estado del pez
                if (this.fish && Math.random() < 0.15) { // 15% chance cada check
                    const stage = this.gameState.stage;
                    const age = this.gameState.ageInDays || 0;
                    const bubbles = this.gameState.bubbles || 0;
                    const stars = this.gameState.stars || 0;
                    
                    const randomEvents = [
                        // Eventos básicos
                        { type: 'swimming', title: '🏊 Nadando feliz', desc: 'Hoy he nadado mucho y me siento muy activo.' },
                        { type: 'exploring', title: '🔍 Explorando', desc: 'He descubierto un rincón nuevo de mi acuario.' },
                        { type: 'playing', title: '🎈 Jugando', desc: 'He estado jugando con las burbujas. ¡Qué divertido!' },
                        { type: 'resting', title: '😴 Descansando', desc: 'He encontrado un lugar cómodo para relajarme.' },
                        
                        // Eventos por etapa
                        ...(stage === 'baby' ? [
                            { type: 'curious', title: '👀 Curiosidad', desc: 'Todo me parece nuevo y emocionante. ¡Quiero explorarlo todo!' },
                            { type: 'learning', title: '🧠 Aprendiendo', desc: 'Estoy aprendiendo a nadar mejor cada día.' },
                            { type: 'growing', title: '📏 Creciendo', desc: 'Siento que cada día soy un poquito más grande.' }
                        ] : []),
                        
                        ...(stage === 'young' ? [
                            { type: 'energetic', title: '⚡ Lleno de energía', desc: 'Me siento súper activo y lleno de vida.' },
                            { type: 'social', title: '👋 Sociable', desc: 'Me encanta cuando vienes a visitarme.' },
                            { type: 'adventurous', title: '🗺️ Aventurero', desc: 'Tengo ganas de explorar más allá de mi pecera.' }
                        ] : []),
                        
                        ...(stage === 'adult' ? [
                            { type: 'wise', title: '🧙 Sabiduría', desc: 'Con la experiencia he aprendido muchas cosas.' },
                            { type: 'peaceful', title: '☮️ Tranquilo', desc: 'Disfruto de la paz y tranquilidad de mi hogar.' },
                            { type: 'mentor', title: '👨‍🏫 Mentor', desc: 'Me gustaría enseñar a otros peces jóvenes.' }
                        ] : []),
                        
                        // Eventos por logros
                        ...(bubbles >= 50 ? [
                            { type: 'wealthy', title: '💰 Próspero', desc: 'He acumulado muchas burbujas. ¡Soy rico!' }
                        ] : []),
                        
                        ...(stars >= 20 ? [
                            { type: 'skilled', title: '🌟 Habilidoso', desc: 'Mis habilidades en los juegos han mejorado mucho.' }
                        ] : []),
                        
                        // Eventos por edad
                        ...(age >= 3 ? [
                            { type: 'memories', title: '💭 Recuerdos', desc: 'Recuerdo cuando era solo un huevito. ¡Qué tiempos!' }
                        ] : []),
                        
                        ...(age >= 7 ? [
                            { type: 'milestone', title: '🎂 Una semana especial', desc: 'Ya llevo una semana contigo. ¡Qué feliz soy!' }
                        ] : []),
                        
                        // Eventos especiales por hora del día
                        ...(new Date().getHours() < 12 ? [
                            { type: 'morning', title: '🌅 Buenos días', desc: 'La mañana es perfecta para nadar y jugar.' }
                        ] : new Date().getHours() < 18 ? [
                            { type: 'afternoon', title: '☀️ Tarde soleada', desc: 'Los rayos de sol hacen brillar el agua.' }
                        ] : [
                            { type: 'evening', title: '🌙 Noche tranquila', desc: 'La noche es perfecta para relajarse.' }
                        ])
                    ];
                    
                    const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                    this.addAlbumEvent(event.type, event.title, event.desc);
                    this.gameState.lastEventTime = now;
                }
            }
            
            // 💾 SISTEMA DE GUARDADO
            
            saveGame() {
                const saveData = {
                    version: '1.0.0',
                    
                    // 👤 DATOS DEL USUARIO
                    userId: this.gameState.userId || null,
                    username: this.gameState.username || null,
                    
                    // 🐠 DATOS DEL PEZ
                    fishName: this.gameState.fishName,
                    fishStage: this.gameState.stage,
                    fishAge: this.gameState.ageInDays || 0,
                    fishBirthTime: this.gameState.birthTime,
                    fishEvolutionTimes: {
                        toYoung: this.gameState.hasEvolvedToYoung ? this.gameState.evolutionToYoungTime : null,
                        toAdult: this.gameState.hasEvolvedToAdult ? this.gameState.evolutionToAdultTime : null
                    },
                    
                    // 🎨 FONDO ACTUAL Y DESBLOQUEADOS
                    currentBackground: this.gameState.currentBackground,
                    unlockedBackgrounds: this.availableBackgrounds?.filter(bg => bg.unlocked).map(bg => bg.name) || [],
                    
                    // 💰 CURRENCY
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars,
                    
                    // 📊 NECESIDADES
                    needs: this.gameState.needs,
                    
                    // 🏆 LOGROS Y PROGRESO
                    achievements: this.gameState.achievements || [],
                    album: this.gameState.album || [],
                    
                    // 🎮 PROGRESO DE JUEGOS
                    gameProgress: {
                        bubbleGame: {
                            bestScore: this.gameState.bubbleGame?.bestScore || 0,
                            totalGames: this.gameState.bubbleGame?.totalGames || 0,
                            starsEarned: this.gameState.bubbleGame?.starsEarned || 0
                        },
                        memoryGame: {
                            bestScore: this.gameState.memoryGame?.bestScore || 0,
                            totalGames: this.gameState.memoryGame?.totalGames || 0,
                            starsEarned: this.gameState.memoryGame?.starsEarned || 0
                        },
                        simonGame: {
                            bestScore: this.gameState.simonGame?.bestScore || 0,
                            totalGames: this.gameState.simonGame?.totalGames || 0,
                            starsEarned: this.gameState.simonGame?.starsEarned || 0
                        },
                        carrilGame: {
                            bestScore: this.gameState.carrilGame?.bestScore || 0,
                            totalGames: this.gameState.carrilGame?.totalGames || 0,
                            starsEarned: this.gameState.carrilGame?.starsEarned || 0
                        },
                        correrGame: {
                            bestScore: this.gameState.correrGame?.bestScore || 0,
                            totalGames: this.gameState.correrGame?.totalGames || 0,
                            starsEarned: this.gameState.correrGame?.starsEarned || 0
                        },
                        cazaGame: {
                            bestScore: this.gameState.cazaGame?.bestScore || 0,
                            totalGames: this.gameState.cazaGame?.totalGames || 0,
                            starsEarned: this.gameState.cazaGame?.starsEarned || 0
                        },
                        secuenciaGame: {
                            bestScore: this.gameState.secuenciaGame?.bestScore || 0,
                            totalGames: this.gameState.secuenciaGame?.totalGames || 0,
                            starsEarned: this.gameState.secuenciaGame?.starsEarned || 0
                        },
                        toca3Game: {
                            bestScore: this.gameState.toca3Game?.bestScore || 0,
                            totalGames: this.gameState.toca3Game?.totalGames || 0,
                            starsEarned: this.gameState.toca3Game?.starsEarned || 0
                        },
                        bloquesGame: {
                            bestScore: this.gameState.bloquesGame?.bestScore || 0,
                            totalGames: this.gameState.bloquesGame?.totalGames || 0,
                            starsEarned: this.gameState.bloquesGame?.starsEarned || 0
                        }
                    },
                    
                    // 🥚 ESTADO DEL HUEVO
                    egg: this.egg,
                    eggStartTime: this.gameState.eggStartTime,
                    explosionHappened: this.explosionHappened,
                    
                    // 🐠 DATOS DEL PEZ (para compatibilidad)
                    fish: this.fish,
                    
                    // ⏰ METADATOS
                    lastPlayed: Date.now(),
                    totalPlayTime: this.gameState.totalPlayTime || 0,
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('miPececito_gameData', JSON.stringify(saveData));
                    console.log('💾 Juego guardado correctamente');
                    console.log('📊 Guardado completo:', {
                        usuario: this.gameState.username || 'Anónimo',
                        pez: this.gameState.fishName || 'Sin nombre',
                        etapa: this.gameState.stage,
                        edad: this.gameState.ageInDays || 0,
                        fondo: this.gameState.currentBackground,
                        fondosDesbloqueados: this.availableBackgrounds?.filter(bg => bg.unlocked).length || 0,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        logros: this.gameState.achievements?.length || 0,
                        album: this.gameState.album?.length || 0,
                        juegosJugados: Object.values(saveData.gameProgress).reduce((total, game) => total + (game.totalGames || 0), 0)
                    });
                } catch (error) {
                    console.error('❌ Error guardando:', error);
                }
            }
            
            loadGame() {
                try {
                    const savedData = localStorage.getItem('miPececito_gameData');
                    if (!savedData) return false;
                    
                    const data = JSON.parse(savedData);
                    
                    // Restaurar estado del juego
                    if (data.gameState) {
                        this.gameState = { ...this.gameState, ...data.gameState };
                    }
                    
                    // Restaurar huevo y pez
                    if (data.egg) {
                        this.egg = { ...this.egg, ...data.egg };
                    }
                    
                    if (data.fish) {
                        this.fish = { ...this.fish, ...data.fish };
                    }
                    
                    // Restaurar explosión
                    this.explosionHappened = data.explosionHappened || false;
                    
                    // Restaurar fondos desbloqueados
                    if (data.availableBackgrounds && this.availableBackgrounds) {
                        data.availableBackgrounds.forEach(savedBg => {
                            const bg = this.availableBackgrounds.find(b => b.name === savedBg.name);
                            if (bg) {
                                bg.unlocked = savedBg.unlocked;
                            }
                        });
                    }
                    
                    console.log('📁 Juego cargado correctamente');
                    console.log('📊 Cargado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                    
                    return true;
                } catch (error) {
                    console.error('❌ Error cargando:', error);
                    return false;
                }
            }
            
            // Auto-guardado cada 30 segundos
            startAutoSave() {
                setInterval(() => {
                    this.saveGame();
                }, 30000);
            }
            
            // 🔧 MÉTODOS DE DEBUG
            
            placeFirstEgg(x, y) {
                const now = Date.now();
                
                // CAMBIAR STAGE A 'EGG' Y INICIAR TIEMPO
                this.gameState.stage = 'egg';
                this.gameState.eggStartTime = now;
                
                // 📊 OCULTAR BARRAS DE NECESIDADES CON HUEVO
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'none';
                    this.setupCanvas(); // REAJUSTAR CANVAS SIN BARRAS
                    console.log('📊 Barras ocultas con huevo + Canvas reajustado');
                }
                
                // 🎆 BURBUJITAS BLANCAS PRIMERO, LUEGO HUEVO
                this.createEggBubbles();
                
                // ESPERAR 1 SEGUNDO PARA QUE SE VEAN LAS BURBUJAS PRIMERO
                setTimeout(() => {
                    this.egg.x = x || this.canvas.width / 2;
                    this.egg.y = y || this.canvas.height * 0.6;
                    this.startEggAppearanceAnimation();
                    console.log('🥚 Huevo aparece DESPUÉS de las burbujas');
                }, 1000);
                
                this.saveGame(); // Guardar al colocar huevo
                console.log(`🥚 Huevo colocado - Stage cambiado a 'egg'`);
                console.log(`🥚 Tiempo inicio: ${new Date(now).toLocaleTimeString()}`);
                console.log(`⏰ EggStartTime configurado: ${this.gameState.eggStartTime}`);
            }

            // 🎆 ANIMACIÓN DE APARICIÓN DEL HUEVO (SOLO APARICIÓN)
            startEggAppearanceAnimation() {
                // EFECTO SUAVE: Solo fade, sin escala brusca
                this.egg.appearing = true;
                this.egg.scale = 1; // TAMAÑO NORMAL DESDE EL INICIO
                this.egg.targetScale = 1;
                this.egg.alpha = 0; // EMPEZAR TRANSPARENTE
                this.egg.targetAlpha = 1; // IR A OPACO
                this.egg.fadeSpeed = 0.8; // VELOCIDAD SUAVE
                
                console.log('🥚 Iniciando aparición SUAVE del huevo (fade)...');
            }

            // 🌫️ BURBUJAS DE APARICIÓN - TEST VISUAL DIRECTO
            createEggAppearanceBubbles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`🌫️ Creando burbujas de aparición en (${centerX}, ${centerY})`);
                console.log(`🔍 bgBubbles array actual: ${this.bgBubbles.length} burbujas`);
                
                // LIMPIAR burbujas existentes para evitar conflictos
                this.bgBubbles = [];
                
                // Crear 10 burbujas GRANDES y VISIBLES para test
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = 50 + i * 20; // Distancias variadas
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const testBubble = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2 - 3, // Hacia arriba
                        r: 20, // TAMAÑO FIJO GRANDE
                        size: 20,
                        opacity: 1,
                        alpha: 1,
                        life: 5000, // 5 segundos fijos
                        maxLife: 5000,
                        color: i % 2 === 0 ? '#ff0000' : '#00ff00', // ROJO/VERDE ALTERNADO para ver
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(testBubble);
                    console.log(`🔴🟢 Burbuja TEST ${i+1}/10 creada: ${testBubble.color} en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
                
                console.log(`🎯 TEST: ${this.bgBubbles.length} burbujas grandes creadas`);
            }

            // ✨ PARTÍCULAS MÁGICAS - TEST VISUAL
            createMagicParticles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`✨ Creando partículas mágicas en (${centerX}, ${centerY})`);
                
                // Crear 5 partículas ENORMES y DORADAS para test
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 80 + i * 15;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const magicParticle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1 - 2,
                        r: 25, // ENORMES para test
                        size: 25,
                        opacity: 1,
                        alpha: 1,
                        life: 6000, // 6 segundos
                        maxLife: 6000,
                        color: '#ffff00', // AMARILLO PURO
                        sparkle: true,
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(magicParticle);
                    console.log(`⭐ Partícula TEST ${i+1}/5 creada: AMARILLA 25px en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
            }
            
            setEggTimeToFinalSeconds() {
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                this.gameState.eggStartTime = Date.now() - (total - 5000);
                console.log('🐣 Huevo a punto de eclosionar (5 segundos)');
            }
            
            addTime(ms) {
                this.gameState.eggStartTime -= ms;
                console.log(`⏰ +${ms/1000/60/60}h añadidas`);
            }
            
            toggleBackground() {
                // Por ahora solo tenemos basic
                console.log('🖼️ Fondo cambiado (solo basic disponible)');
            }
            
            addCurrency(type, amount) {
                if (type === 'bubbles') {
                    this.gameState.bubbles += amount;
                } else if (type === 'stars') {
                    this.gameState.stars += amount;
                }
                console.log(`💰 +${amount} ${type} añadidas`);
                this.updateUI(); // ACTUALIZAR UI INMEDIATAMENTE
            }
            
            getGameInfo() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                return {
                    stage: this.gameState.stage,
                    eggTime: elapsed,
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars
                };
            }
            
            // 🔧 FUNCIONES HELPER COPIADAS DEL CÓDIGO REALISTA
            clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }
            
            dist(x1, y1, x2, y2) {
                return Math.hypot(x2 - x1, y2 - y1);
            }
            
            // === Helpers de canvas/DPR (CSS px coherentes) ===
            getDPR() { 
                return window.devicePixelRatio || 1; 
            }
            
            viewW() { 
                return this.canvas.width / this.getDPR(); // ancho en CSS px
            }
            
            viewH() { 
                return this.canvas.height / this.getDPR(); // alto en CSS px
            }
            
            // ——— SUELO ÚNICO COHERENTE CON LA BARRA INFERIOR ———
            getFloorY() {
                // Si quieres medir la barra real:
                // const bar = document.querySelector('.bottom-bar');
                // const uiBottom = bar ? bar.getBoundingClientRect().height : 100;

                const uiBottom = 100;  // ← ajusta si tu barra real es otra
                const safeGap  = 12;   // margen para no pisar la UI
                return this.viewH() - (uiBottom + safeGap);
            }
            
            // Llamar al principio de cada render()
            beginFrame() {
                const ctx = this.ctx;
                // limpiar en píxeles físicos
                ctx.setTransform(1,0,0,1,0,0);
                ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
                // reescalar a CSS px
                const r = this.getDPR();
                ctx.setTransform(r,0,0,r,0,0);
            }
            
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            vary(val, amt, min, max) {
                const v = val + (Math.random() * 2 - 1) * amt;
                return this.clamp(v, min, max);
            }
            
            // 🍎 SISTEMA DE COMIDA SEGÚN CHAT
            pelletColors() {
                const PELLET_FAMILIES = [
                    {h:38,s:85,l:62},{h:30,s:80,l:58},{h:46,s:68,l:70},
                    {h:28,s:60,l:55},{h:60,s:35,l:65},{h:22,s:55,l:54}
                ];
                const b = PELLET_FAMILIES[Math.floor(Math.random() * PELLET_FAMILIES.length)];
                const h = this.vary(b.h, 5, 10, 70);
                const s = this.vary(b.s, 10, 20, 95);
                const l = this.vary(b.l, 8, 35, 85);
                const strokeL = Math.max(10, l - 22);
                const strokeS = Math.max(25, Math.round(s * 0.85));
                return { 
                    fill: `hsl(${Math.round(h)} ${Math.round(s)}% ${Math.round(l)}%)`, 
                    stroke: `hsl(${Math.round(h)} ${Math.round(strokeS)}% ${Math.round(strokeL)}%)` 
                };
            }
            
            dropFood() {
                console.log('🍎 dropFood() llamado - Array food existe:', !!this.food);
                
                // ZONA ACCESIBLE PARA EL PEZ (evitar extremos)
                const fishSize = 80;
                const fishHalfSize = fishSize / 2;
                const leftLimit = fishHalfSize + 15; // 55px
                const rightLimit = this.canvas.width - fishHalfSize - 15; // W-55px
                const accessibleWidth = rightLimit - leftLimit;
                
                const x = leftLimit + Math.random() * accessibleWidth; // Solo en zona accesible
                const col = this.pelletColors();
                const r = 2.6 + Math.random() * 1.2;
                
                const pellet = {
                    x: x,
                    y: 120, // MÁS ABAJO para que esté cerca del pez
                    vx: 0,
                    vy: 4 + Math.random() * 4, // CAÍDA MÁS LENTA
                    bottomT: 0,
                    colorFill: col.fill,
                    colorStroke: col.stroke,
                    r: r
                };
                
                this.food.push(pellet);
                console.log('🍎 Pellet añadido en ZONA SEGURA:', 
                    `x=${x.toFixed(1)} (rango: ${leftLimit}-${rightLimit})`,
                    'Total food:', this.food.length);
            }
            
            // 🧹 LIMPIEZA CON MÁQUINA DE ESTADOS SINCRONIZADA
            startCleaning() {
                console.log('🧹 ¡INICIANDO LIMPIEZA SINCRONIZADA!');
                
                // 🫧 DAR BURBUJAS SI ESTABA SUCIO
                const wasReallyDirty = this.gameState.needs.dirt > 15; // Solo si estaba realmente sucio
                if (wasReallyDirty) {
                    this.gameState.bubbles += 3;
                    console.log(`🫧 +3 burbujas por limpiar cuando estaba sucio (suciedad previa: ${this.gameState.needs.dirt.toFixed(1)}%)`);
                    
                    // 🎆 EFECTO VISUAL DE BURBUJAS AL CONTADOR
                    this.createBubbleEffect(3);
                }
                
                // 🎯 INICIALIZAR ESTADO DE LIMPIEZA
                this.cleaningState = 'burst'; // burst -> fade -> settle
                this.cleaningTimer = 0;
                this._time = this._time || 0;
                this.cleanBubbles = this.cleanBubbles || [];

                // 🐟 EFECTO EN EL PEZ
                if (this.fish) { 
                    this.fish.happyBurst = 3.2; 
                    this.fish.spinKind = "clean"; 
                }
                
                // 🫧 CREAR BURBUJAS INMEDIATAMENTE (RÁFAGA INICIAL)
                this.emitCleanBubblesBurst();
                console.log(`🫧 RÁFAGA INICIAL: ${this.cleanBubbles.length} burbujas creadas`);
                
                // 🔊 SONIDO SINCRONIZADO
                if (window.audioManager) {
                    window.audioManager.playSound('clean');
                }
                
                // 🧹 CONFIGURAR LIMPIEZA
                this.dirtStart = this.gameState.needs.dirt;
            }
            
            // 🫧 RÁFAGA INTENSA DE BURBUJAS PARA SINCRONIZACIÓN
            emitCleanBubblesBurst() {
                const W = this.viewW();
                const H = this.viewH();
                
                // 🎯 CREAR MUCHAS BURBUJAS DE UNA VEZ (RÁFAGA)
                for (let wave = 0; wave < 3; wave++) {
                    for (let i = 0; i < 25; i++) {
                        const b = {
                            x0: 30 + Math.random() * (W - 60),
                            y0: H * 0.8 + Math.random() * (H * 0.15),
                            t: wave * 0.1, // Escalonar ligeramente las ondas
                            dur: 2.0 + Math.random() * 0.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 2,
                            wobAmp: 8 + Math.random() * 12,
                            r: 4 + Math.random() * 6
                        };
                        b.x = b.x0;
                        b.y = b.y0;
                        this.cleanBubbles.push(b);
                    }
                }
                
                console.log(`🫧 Ráfaga creada: ${this.cleanBubbles.length} burbujas totales`);
            }
            
            emitCleanBubbles() {
                const W = this.viewW();   // CSS px
                const H = this.viewH();   // CSS px
                const vents = Math.max(16, Math.floor(W / 24));
                const perVent = 2;

                for (let i = 0; i < vents; i++) {
                    const baseX = (i + 0.5) * (W / vents) + (Math.random() - 0.5) * 8;

                    for (let k = 0; k < perVent; k++) {
                        const vy  = 260 + Math.random() * 120;     // velocidad vertical (CSS px/s)
                        const y0  = H - 1 + Math.random() * 0.5;   // nacen pegadas al fondo
                        const dur = (H + 24) / vy;                 // tiempo exacto hasta salir por arriba
                        const x0  = this.clamp(baseX + (Math.random() - 0.5) * 6, 2, W - 2);

                        this.cleanBubbles.push({
                            // guardo origen (x0,y0) y movimiento paramétrico por tiempo
                            x: x0, y: y0,
                            x0, y0, dur, t: 0,
                            r: 1.5 + Math.random() * 2.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 1.2,
                            wobAmp: 6 + Math.random() * 10,
                            from: 'clean'
                        });
                    }
                }

                // Límite de memoria
                if (this.cleanBubbles.length > 1400) {
                    this.cleanBubbles.splice(0, this.cleanBubbles.length - 1400);
                }
            }
            
            // updateCleaning() - ELIMINADO (ahora en needs-system.js)
            
            // drawCleanBubbles() - ELIMINADO (ahora en needs-system.js)
            
            updateFood(deltaTime) {
                if (!this.food) {
                    console.log('🍎 updateFood: Array food no existe');
                    return;
                }
                
                // 🐟 PERSECUCIÓN DE COMIDA MANEJADA EN updateFishMovement()
                
                const h = this.canvas.height;
                const drag = 0.99;
                
                // EXACTO DEL DOCUMENTO - LÍNEAS 254-256
                for (const f of this.food) {
                    if (f.bottomT > 0) {
                        f.bottomT += deltaTime;
                    } else {
                        f.vy = Math.min(f.vy + 50 * deltaTime, 60);
                        f.y += f.vy * deltaTime;
                        f.x += f.vx * deltaTime;
                        f.vx *= drag;
                // USAR SUELO UNIFICADO
                const floorY = this.getFloorY();
                        if (f.y > floorY) {
                            f.y = floorY;
                            f.vy = 0;
                            f.vx = 0;
                            f.bottomT = Math.max(0.001, f.bottomT || 0.001);
                        }
                    }
                }
                
                // EXACTO DEL DOCUMENTO - LÍNEAS 258-269
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const f = this.food[i];
                    const distance = this.fish ? this.dist(this.fish.x, this.fish.y, f.x, f.y) : 999;
                    
                    // 🍎 COLISIÓN CON EL PEZ (radio de colisión más amplio)
                    if (this.fish && distance < 28) { // Aumentado de 22 a 28 para mejor detección
                        console.log(`🍎 COLISIÓN: Pez en (${this.fish.x.toFixed(1)}, ${this.fish.y.toFixed(1)}) come pellet en (${f.x.toFixed(1)}, ${f.y.toFixed(1)}) - Distancia: ${distance.toFixed(1)}`);
                        this.food.splice(i, 1);
                        
                        // 🍎 COMER CON CONFIG POR ETAPA
                        const cfg = this.getStageCfg(this.gameState);
                        const hadRealHunger = this.gameState.needs.hunger > 20; // Solo si tenía hambre significativa
                        this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger - cfg.eatReduce, 0, 100);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerPellet, 0, 100);
                        
                        // 🐠 SALIR DEL ESTADO DEPRIMIDO SI COME
                        if (this.fish.isDepressed && this.gameState.needs.hunger < 70) {
                            this.fish.isDepressed = false;
                            this.fish.isInCorner = false;
                            this.fish.hideTimer = 0;
                            console.log('🐠 ¡Pez sale del estado deprimido al comer!');
                        }
                        
                        // 🫧 DAR BURBUJAS SI TENÍA HAMBRE REAL
                        if (hadRealHunger) {
                            this.gameState.bubbles += 2;
                            console.log(`🫧 +2 burbujas por comer con hambre real (hambre previa: ${this.gameState.needs.hunger + cfg.eatReduce}%)`);
                            
                            // 🎆 EFECTO VISUAL DE BURBUJAS AL CONTADOR
                            this.createBubbleEffect(2);
                        }
                        
                        console.log(`🍎 ¡PEZ COME! Etapa: ${this.gameState.stage} - Reduce hambre: ${cfg.eatReduce} - Añade suciedad: ${cfg.dirtPerPellet}`);
                        
                        // 🔊 SONIDO SIEMPRE
                        if (window.audioManager) {
                            window.audioManager.playSound('eat');
                        }
                        
                        // 🎬 ÑAM SIEMPRE
                            this.labels.push({
                                x: this.fish.x,
                                y: this.fish.y - 12,
                                text: "Ñam",
                                a: 1,
                                vy: 40,
                                life: 1.4
                            });
                            
                            this.fish.happyBurst = Math.max(this.fish.happyBurst, 1.2);
                            this.fish.spinKind = "eat";
                            
                        // 📊 ACTUALIZAR BARRAS SIEMPRE
                        this.needsSystem.updateCrisisFlags();
                        this.needsSystem.updateNeedBars();
                        
                        console.log(`🍎 ¡Ñam completo! Nueva hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                        
                        // ✨ EFECTOS DE PARTÍCULAS AL COMER (SOLO PARTÍCULAS, NO CORAZONES)
                        this.createEatingParticles(f.x, f.y);
                        
                        // 📝 CREAR TEXTO FLOTANTE "ÑAM" (NO PUNTOS NI CORAZONES)
                        this.createFloatingText(f.x, f.y - 20, 'ñam', '#4caf50');
                        
                        // 📸 EVENTO DE ALIMENTACIÓN OCASIONAL
                        if (Math.random() < 0.1) { // 10% chance
                            const feedingMessages = [
                                'Mmm, ¡qué rico! Esta comida está deliciosa.',
                                '¡Ñam ñam! Me encanta cuando me das de comer.',
                                'Gracias por cuidarme tan bien. Esta comida me da mucha energía.',
                                '¡Qué sabroso! Ahora me siento mucho mejor.',
                                'Esta comida me recuerda a cuando era pequeño.'
                            ];
                            const msg = feedingMessages[Math.floor(Math.random() * feedingMessages.length)];
                            this.addAlbumEvent('feeding', '🍽️ Hora de comer', msg);
                        }
                        
                        // ⚠️ ELIMINADO: No limitar hambre en crisis para que siga persiguiendo
                        // if (this.gameState.crisis.hunger) {
                        //     this.gameState.needs.hunger = Math.min(this.gameState.needs.hunger, 60);
                        // }
                        
                        this.needsSystem.updateCrisisFlags();
                        this.needsSystem.updateNeedBars();
                        continue; // Importante: saltar al siguiente pellet
                    } 
                    
                    // 🗑️ PUDRIR COMIDA VIEJA (después de 8 segundos en el fondo)
                    if (f.bottomT > 0 && f.bottomT > 8) {
                        console.log(`🗑️ Pellet podrido después de ${f.bottomT.toFixed(1)}s en el fondo`);
                        const cfg = this.getStageCfg(this.gameState);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerRotten, 0, 100);
                        console.log(`🦠 Suciedad por pudrición: +${cfg.dirtPerRotten} (total: ${this.gameState.needs.dirt.toFixed(1)}%)`);
                        this.needsSystem.updateNeedBars();
                        this.food.splice(i, 1);
                    }
                }
                
                // 📊 LOG PERIÓDICO PARA DEBUG
                // Log reducido: solo cada 5 segundos o cuando cambia significativamente
                this.lastFoodLogTime = this.lastFoodLogTime || 0;
                if (Date.now() - this.lastFoodLogTime > 5000) {
                    console.log(`🍎 Estado: ${this.food.length} pellets - Hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                    this.lastFoodLogTime = Date.now();
                }
            }
            
            drawFood() {
                if (!this.food || this.food.length === 0) {
                    // console.log('🍎 drawFood: No hay comida que dibujar');
                    return;
                }
                
                // Solo log cuando hay cambios importantes
                if (this.food.length > (this.lastFoodCount || 0)) {
                    console.log('🍎 Comida añadida:', this.food.length, 'pellets');
                    this.lastFoodCount = this.food.length;
                }
                
                this.ctx.save();
                for (let i = 0; i < this.food.length; i++) {
                    const f = this.food[i];
                    // console.log(`🍎 Dibujando pellet ${i}:`, f.x, f.y, f.r); // Log deshabilitado para performance
                    
                    this.ctx.beginPath();
                    this.ctx.arc(f.x, f.y, f.r || 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = f.colorFill || '#ffd166';
                    this.ctx.fill();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = f.colorStroke || '#cc8400';
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }
            
            // 🍎 FUNCIONES DE COMIDA
            nearestFood() {
                let best = null, bestD = 1e9;
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                return best || null;
            }
            
            // ❤️ CORAZÓN VOLADOR (cuando tocas el pez)
            launchHeartToFun() {
                // VERSIÓN CHATGPT: Convertir coords DOM de la barra a coords canvas
                const barF = document.getElementById('funBarHeader'); // Barra de diversión del header
                if (!barF) {
                    console.log('❌ No se encontró barra de diversión');
                    return;
                }
                
                const crect = this.canvas.getBoundingClientRect();
                const frect = barF.getBoundingClientRect();
                
                const sx = this.fish.x, sy = this.fish.y; // origen corazón (pez)
                const ex = frect.left + frect.width * 0.9 - crect.left; // destino barra
                const ey = frect.top + frect.height * 0.5 - crect.top;
                
                // control point para Bezier (curvita agradable)
                const cx = (sx + ex) / 2;
                const cy = Math.min(sy, ey) - 100;
                
                this.flyers.push({ 
                    t: 0, dur: 1.8, sx, sy, cx, cy, ex, ey, given: false 
                });
                
                // 💖 ACTUALIZAR DIVERSIÓN (+25)
                this.gameState.needs.fun = Math.min(100, this.gameState.needs.fun + 25);
                this.updateUI();
                
                console.log('❤️ Corazón lanzado hacia barra de diversión (coords DOM)');
                console.log('💖 +25 diversión por tocar al pez');
            }
            
            // 🫧 BURBUJAS DE RESPIRACIÓN (desde la boca)
            emitMouthBubbles(n = 4, x0, y0) {
                const fish = this.fish;
                if (!fish) return;
                
                // Posición de la boca del pez
                const bodyW = fish.size * 0.4;
                const bodyH = fish.size * 0.24;
                const mx = fish.x + (fish.facing > 0 ? 1 : -1) * (bodyW * 0.42);
                const my = fish.y - bodyH * 0.12;
                
                for (let i = 0; i < n; i++) {
                    this.tinyBubbles.push({
                        x: mx + (Math.random() * 6 - 3),
                        y: my + (Math.random() * 6 - 3),
                        r: 0.9 + Math.random() * 1.3,
                        vy: 50 + Math.random() * 40,
                        wob: Math.random() * Math.PI * 2,
                        wobSpd: 1.2 + Math.random() * 0.8,
                        wobAmp: 3 + Math.random() * 4,
                        a: 1,
                        life: 1.2
                    });
                }
            }
            
            // 🫧 BURBUJITAS SUTILES DE AMBIENTE (REALMENTE SUTILES)
            drawAmbientBubbles() {
                const time = this.gameTime || Date.now() * 0.001;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                this.ctx.save();
                
                // 8 burbujitas REALMENTE pequeñas y sutiles
                for (let i = 0; i < 8; i++) {
                    // Posición que se mueve muy lentamente
                    const baseX = (i * 97 + (time * 15) % W) % W;
                    const baseY = H - ((time * 25 + i * 80) % H);
                    
                    // Pequeño wobble muy sutil
                    const x = baseX + Math.sin(time * 1.5 + i) * 4;
                    const y = baseY + Math.cos(time * 1.2 + i) * 3;
                    
                    // Tamaño muy pequeño (1-3px)
                    const size = 1 + (i % 2) + Math.sin(time * 2 + i) * 0.3;
                    
                    // MUY transparente
                    this.ctx.globalAlpha = 0.15 + Math.sin(time * 1.8 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    this.ctx.shadowBlur = 0; // Sin sombra
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // 🫧 BURBUJITAS SUTILES DURANTE GESTACIÓN DEL HUEVO
            drawEggGestationBubbles() {
                const time = (Date.now() * 0.001) % 1000; // Tiempo lento
                const eggX = 0; // Relativo al huevo (ya transformado)
                const eggY = 0;
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                
                // 6 burbujitas muy sutiles alrededor del huevo
                for (let i = 0; i < 6; i++) {
                    const angle = (time * 0.3 + i * Math.PI / 3) % (Math.PI * 2);
                    const radius = eggSize * 0.35 + Math.sin(time * 2 + i) * 10;
                    
                    const x = eggX + Math.cos(angle) * radius;
                    const y = eggY + Math.sin(angle) * radius * 0.6; // Más ovalado
                    
                    // Tamaño muy pequeño (2-4px)
                    const size = 2 + Math.sin(time * 3 + i) * 1;
                    
                    // MUY transparente y suave
                    this.ctx.globalAlpha = 0.1 + Math.sin(time * 1.5 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 3 burbujitas más grandes que suben lentamente
                for (let i = 0; i < 3; i++) {
                    const yOffset = ((time * 20 + i * 40) % 120) - 60; // Suben lentamente
                    const x = eggX + (i - 1) * 25 + Math.sin(time * 2 + i) * 8;
                    const y = eggY - eggSize * 0.4 - yOffset;
                    
                    const size = 3 + i * 0.5;
                    this.ctx.globalAlpha = 0.15 - (yOffset / 120) * 0.1; // Se desvanecen al subir
                    this.ctx.fillStyle = '#b3e5fc'; // Azul claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // 🍎 ACTUALIZAR Y DIBUJAR LABELS ("Ñam", etc.)
            updateLabels(deltaTime) {
                for (let i = this.labels.length - 1; i >= 0; i--) {
                    const label = this.labels[i];
                    label.life -= deltaTime;
                    label.y -= label.vy * deltaTime;
                    label.a = Math.max(0, label.life / 1.4); // Fade out
                    
                    if (label.life <= 0) {
                        this.labels.splice(i, 1);
                    }
                }
            }
            
            drawLabels() {
                this.ctx.save();
                this.ctx.font = 'bold 18px system-ui';
                this.ctx.textAlign = 'center';
                
                for (const label of this.labels) {
                    this.ctx.globalAlpha = label.a;
                    this.ctx.fillStyle = '#ff6b35';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.strokeText(label.text, label.x, label.y);
                    this.ctx.fillText(label.text, label.x, label.y);
                }
                
                this.ctx.restore();
            }
            
            // 🎯 VIEW HELPERS - COORDENADAS SIMPLES 
        // 🌍 TAMAÑO CANVAS SIMPLE (VERSIÓN QUE FUNCIONABA)
        viewW() { return this.canvas.width; }
        viewH() { return this.canvas.height; }
        
        // 🫧 GESTIÓN CAPA OFFSCREEN
        ensureBubLayer() {
            if (!this.bubLayer) {
                this.bubLayer = document.createElement('canvas');
                this.bubCtx = this.bubLayer.getContext('2d');
            }
            this.resizeBubLayer();
        }
        
        resizeBubLayer() {
            if (!this.bubLayer) return;
            const dpr = window.devicePixelRatio || 1;
            const w = this.viewW(), h = this.viewH();
            this.bubLayer.width = Math.max(1, Math.floor(w * dpr));
            this.bubLayer.height = Math.max(1, Math.floor(h * dpr));
            this.bubLayer.style.width = w + 'px';
            this.bubLayer.style.height = h + 'px';
        }
        
        // 🫧 DIBUJAR BURBUJAS EN CAPA OFFSCREEN
        drawBubblesLayer() {
            this.ensureBubLayer();
            const dpr = window.devicePixelRatio || 1;
            
            // Limpiar offscreen en device px y fijar su DPR
            this.bubCtx.setTransform(1, 0, 0, 1, 0, 0);
            this.bubCtx.clearRect(0, 0, this.bubLayer.width, this.bubLayer.height);
            this.bubCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Tiny bubbles (respiración)
            for (const b of this.tinyBubbles) {
                this.bubCtx.globalAlpha = Math.max(0.2, b.a || 0.8);
                this.bubCtx.beginPath(); 
                this.bubCtx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                this.bubCtx.fillStyle = '#e8fbff'; 
                this.bubCtx.fill();
                this.bubCtx.lineWidth = 0.7; 
                this.bubCtx.strokeStyle = 'rgba(255,255,255,0.8)'; 
                this.bubCtx.stroke();
            }
        }
            
            // 🐟 MOVIMIENTO FLUIDO CON FÍSICA AVANZADA (DESDE movimiento_pez_final.html)
            // 🐠 FUNCIÓN updateFishMovement() ELIMINADA - AHORA EN fish-system.js
            
            // 🎯 FUNCIONES seek(), nearestFood(), getStageCfg(), updateAutoNeeds() ELIMINADAS - AHORA EN fish-system.js y needs-system.js
            
            resetForEgg() {
                this.food = [];
                this.cleanBubbles = [];
                this.labels = [];
                this.flyers = [];
                if (this.fish) this.fish.desire = null; // Limpiar desire del pez
                this.cleaning = null;

                this.gameState.needs = { hunger: 15, dirt: 0, fun: 95 };
                this.updateNeedBars?.();
                this.gameState.stage = 'egg';

                // Si tienes contadores de monedas/estrellas, pon sus valores de inicio acordados
                // this.gameState.coins = 0;
                // this.gameState.stars = 0;
                
                console.log('🥚 Reset completo para huevo - Todo limpio');
            }
            
            
            // 🚨 FUNCIÓN updateCrisisFlags() ELIMINADA - AHORA EN needs-system.js
            
            updateTinyBubbles(deltaTime) {
                // Actualizar burbujas de respiración
                for (const b of this.tinyBubbles) {
                    b.y -= b.vy * deltaTime;
                    b.x += Math.sin((this.state?.time || Date.now() * 0.001) * b.wobSpd + b.wob) * b.wobAmp * deltaTime;
                    b.life -= deltaTime;
                    b.a = Math.max(0, b.life / 1.2);
                }
                
                // Eliminar burbujas muertas
                for (let i = this.tinyBubbles.length - 1; i >= 0; i--) {
                    const b = this.tinyBubbles[i];
                    if (b.life <= 0 || b.y < -12) {
                        this.tinyBubbles.splice(i, 1);
                    }
                }
            }
            
            updateFlyers(deltaTime) {
                if (!this.flyers) this.flyers = [];
                
                // VERSIÓN CHATGPT: Actualizar progreso de corazones
                for (const f of this.flyers) {
                    f.t += deltaTime / f.dur;
                }
                
                // Purgar completados y dar diversión
                for (let i = this.flyers.length - 1; i >= 0; i--) {
                    const f = this.flyers[i];
                    if (f.t >= 1) {
                        if (!f.given) {
                            // SUMAR DIVERSIÓN +0.25 (RESTAR para hacer feliz)
                            this.gameState.needs.fun = this.clamp(this.gameState.needs.fun - 25, 0, 100); // -25 = +0.25 diversión (menos rojo = más feliz)
                            this.needsSystem.updateNeedBars();
                            
                            // Efecto visual en la barra
                            const barF = document.getElementById('funBarHeader');
                            if (barF) {
                                barF.classList.remove('pulse'); 
                                void barF.offsetWidth; 
                                barF.classList.add('pulse');
                            }
                            
                            f.given = true;
                            console.log('💖 +25 diversión por tocar al pez');
                        }
                        this.flyers.splice(i, 1);
                    }
                }
            }
            
            // 💖 DIBUJAR CORAZONES VOLADORES (SOLO CUANDO TOCAS AL PEZ, NO CUANDO COME)
            drawFlyers() {
                if (!this.flyers) return;
                
                // VERSIÓN CHATGPT: Curva de Bezier para corazones cuando tocas al pez
                for (const f of this.flyers) {
                    const t = Math.min(1, f.t), u = 1 - t;
                    // curva de Bezier 2 puntos
                    const x = u*u*f.sx + 2*u*t*f.cx + t*t*f.ex;
                    const y = u*u*f.sy + 2*u*t*f.cy + t*t*f.ey;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.font = 'bold 18px system-ui, Segoe UI, Arial';
                    this.ctx.fillStyle = 'rgba(255,120,160,1)';
                    this.ctx.fillText('❤', x - 6, y);
                    this.ctx.restore();
                }
            }
        }
        
        // 🌐 game ya está expuesto globalmente arriba
        
        // 🚨 SISTEMA DE EMERGENCIA PARA MODALES
        setTimeout(() => {
            console.log('🚨 Activando sistema de emergencia para modales...');
            
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            const invBtn = document.getElementById('inventoryButton');
            const invModal = document.getElementById('inventoryModal');
            
            // Función para abrir modal de juegos
            window.openGamesModal = function() {
                console.log('🎮 Abriendo modal de juegos (función de emergencia)');
                if (gamesModal) {
                    gamesModal.style.display = 'flex';
                    gamesModal.style.opacity = '1';
                }
            };
            
            // Función para abrir modal de inventario
            window.openInventoryModal = function() {
                console.log('🎒 Abriendo modal de inventario (función de emergencia)');
                if (invModal) {
                    invModal.style.display = 'flex';
                    invModal.style.opacity = '1';
                }
            };
            
            
            // 🫧 VERSIÓN CORRECTA DEL JUEGO DE BURBUJAS
            window.startBubbleGameDirect = function() {
                console.log('🫧 Llamando a la versión correcta del juego de burbujas...');
                if (typeof startBubblesGameIntegrated === 'function') {
                    startBubblesGameIntegrated();
                        } else {
                    console.error('❌ startBubblesGameIntegrated no está definida todavía');
                    alert('🚧 El juego de burbujas no está disponible en este momento. Por favor, intenta más tarde.');
                }
            };
            
            // Event listeners de emergencia - ELIMINADO (YA EXISTE ARRIBA)
            
            if (invBtn) {
                invBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('🚨 CLICK DETECTADO - Abriendo inventario');
                    window.openInventoryModal();
                };
            }
            
            // Botones de cierre
            const closeGames = document.getElementById('closeGames');
            const closeInventory = document.getElementById('closeInventory');
            
            if (closeGames) {
                closeGames.onclick = function() {
                    gamesModal.style.display = 'none';
                };
            }
            
            if (closeInventory) {
                closeInventory.onclick = function() {
                    invModal.style.display = 'none';
                };
            }
            
            // Event listeners para las tarjetas de juegos cuadradas
            const gameCards = document.querySelectorAll('.game-card-square');
            gameCards.forEach(card => {
                card.onclick = function(e) {
                    e.preventDefault();
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    console.log(`🎮 Click en juego: ${gameId}, bloqueado: ${isLocked}`);
                    
                    if (!isLocked) {
                        console.log(`🚀 Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        gamesModal.style.display = 'none';
                        
                        // Iniciar juego usando window.game o función de emergencia
                        if (window.game && window.game.startGame) {
                            window.game.startGame(gameId);
                        } else if (gameId === 'bubbles') {
                            console.log('🚨 Usando función de emergencia para burbujas');
                            window.startBubbleGameDirect();
                        } else {
                            console.error('❌ window.game no disponible y no hay función de emergencia para:', gameId);
                            alert(`🚧 Juego ${gameId} no disponible temporalmente`);
                        }
                    } else {
                        console.log(`🔒 Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        alert(`🔒 Juego bloqueado. Necesitas más estrellas.`);
                    }
                };
            });
            
            console.log('✅ Sistema de emergencia activado');
        }, 1000);

        // 🎵 SISTEMA DE AUDIO COMPLETO
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.backgroundMusic = null;
                this.isMuted = localStorage.getItem('miPececito_muted') === 'true' || false;
                this.volume = parseFloat(localStorage.getItem('miPececito_volume')) || 0.7;
                this.musicVolume = 0.55; // Música de fondo bien audible
                this.effectsVolume = 0.4; // Efectos a volumen medio
                
                this.initAudioContext();
                this.loadSounds();
                this.createGeneratedSounds();
            }
            
            async initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('🎵 AudioContext creado correctamente');
                } catch (error) {
                    console.warn('⚠️ No se pudo crear AudioContext:', error);
                }
            }
            
            async loadSounds() {
                const soundFiles = {
                    background: './sound/fondo.mp3',
                    eat: './sound/comer.mp3',
                    hatch: './sound/eclosionar.mp3',
                    clean: './sound/limpiar.mp3',
                    fail: './sound/fallo.mp3',
                    levelComplete: './sound/nivelcompletado.mp3',
                    jugar: './sound/jugar.mp3',
                    acierto: './sound/comer.mp3',
                    dedo: './sound/dedo.mp3'
                };
                
                for (const [name, url] of Object.entries(soundFiles)) {
                    try {
                        const audio = new Audio(url);
                        audio.preload = 'auto';
                        this.sounds[name] = audio;
                        console.log(`🎵 Sonido cargado: ${name}`);
                    } catch (error) {
                        console.warn(`⚠️ Error cargando ${name}:`, error);
                    }
                }
                
                // Configurar música de fondo
                if (this.sounds.background) {
                    this.sounds.background.loop = true;
                    this.sounds.background.volume = this.musicVolume * this.volume;
                    this.backgroundMusic = this.sounds.background;
                }
            }
            
            createGeneratedSounds() {
                // Sonidos que crearemos con Web Audio API si no existen
                this.createHeartSound();
                this.createBirthSound();
                this.createClickSound();
                this.createAchievementSound();
                this.createEvolutionSound();
                this.createGameWinSound();
            }
            
            createHeartSound() {
                // Sonido de campanita suave para el corazón
                this.sounds.heart = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createBirthSound() {
                // Fanfarria suave para el nacimiento
                this.sounds.birth = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const notes = [523, 659, 784, 1047]; // Do, Mi, Sol, Do alto
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.2, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                            
                            oscillator.type = 'triangle';
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, i * 100);
                    });
                };
            }
            
            createClickSound() {
                // Sonido sutil de click/burbuja
                this.sounds.click = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.1, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }
            
            // 🔊 SONIDOS ADICIONALES PARA NUEVAS FUNCIONALIDADES
            createAchievementSound() {
                // Sonido épico para logros
                this.sounds.achievement = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    // Acorde triunfal
                    const frequencies = [523, 659, 784]; // Do, Mi, Sol
                    frequencies.forEach((freq, i) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        oscillator.type = 'triangle';
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.2, this.audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.0);
                        
                        oscillator.start(this.audioContext.currentTime + i * 0.1);
                        oscillator.stop(this.audioContext.currentTime + 1.0);
                    });
                };
            }
            
            createEvolutionSound() {
                // Sonido mágico para evolución
                this.sounds.evolution = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Subida mágica de frecuencia
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 1.0);
                    
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.4, this.audioContext.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 1.2);
                };
            }
            
            createGameWinSound() {
                // Sonido de victoria para juegos
                this.sounds.gamewin = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    // Melodía ascendente alegre
                    const notes = [523, 587, 659, 784]; // Do, Re, Mi, Sol
                    notes.forEach((freq, i) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        oscillator.type = 'square';
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.15, this.audioContext.currentTime + i * 0.1 + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + i * 0.1 + 0.3);
                        
                        oscillator.start(this.audioContext.currentTime + i * 0.1);
                        oscillator.stop(this.audioContext.currentTime + i * 0.1 + 0.3);
                    });
                };
            }
            
            playSound(soundName) {
                if (this.isMuted) return;
                
                const sound = this.sounds[soundName];
                if (!sound) {
                    console.warn(`⚠️ Sonido no encontrado: ${soundName}`);
                    return;
                }
                
                try {
                    if (typeof sound === 'function') {
                        // Sonido generado
                        sound();
                    } else {
                        // Archivo de audio
                        sound.currentTime = 0;
                        
                        // 🔊 VOLUMEN ESPECÍFICO PARA COMER (más bajo)
                        if (soundName === 'eat') {
                            sound.volume = (this.effectsVolume * 0.3) * this.volume; // 30% del volumen normal
                        } else {
                        sound.volume = this.effectsVolume * this.volume;
                        }
                        
                        sound.play();
                    }
                    console.log(`🔊 Reproduciendo: ${soundName}`);
                } catch (error) {
                    console.warn(`⚠️ Error reproduciendo ${soundName}:`, error);
                }
            }
            
            startBackgroundMusic() {
                if (this.isMuted || !this.backgroundMusic) return;
                
                this.backgroundMusic.volume = this.musicVolume * this.volume;
                
                const playPromise = this.backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('🎵 Música de fondo iniciada correctamente');
                        })
                        .catch(error => {
                            console.warn('⚠️ Autoplay bloqueado por el navegador:', error);
                            console.log('🎵 La música se iniciará tras la primera interacción del usuario');
                        });
                } else {
                    console.log('🎵 Música de fondo iniciada (navegador antiguo)');
                }
            }
            
            stopBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                    this.backgroundMusic.currentTime = 0;
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('miPececito_muted', this.isMuted.toString());
                
                if (this.isMuted) {
                    this.stopBackgroundMusic();
                } else {
                    this.startBackgroundMusic();
                }
                
                this.updateVolumeButton();
                console.log(`🔊 Audio ${this.isMuted ? 'silenciado' : 'activado'}`);
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                localStorage.setItem('miPececito_volume', this.volume.toString());
                
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume * this.volume;
                }
            }
            
            updateVolumeButton() {
                const volumeBtn = document.getElementById('volumeBtn');
                const volumeIcon = document.getElementById('volumeIcon');
                
                if (volumeBtn && volumeIcon) {
                    volumeIcon.src = this.isMuted ? './images/ui/sonidoOff.png' : './images/ui/sonidoOn.png';
                    volumeBtn.title = this.isMuted ? 'Activar sonido' : 'Silenciar sonido';
                    volumeBtn.classList.toggle('muted', this.isMuted);
                }
            }
        }
        
        
        // 🫧 JUEGO DE BURBUJAS INTEGRADO (OVERLAY)
        function startBubblesGameIntegrated() {
            console.log('🫧 Iniciando juego de burbujas integrado...');
            console.log('🫧 Creando iframe para games/bubbles/bubbles.html');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego encima del pez
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'bubblesGameOverlay';
            gameOverlay.style.cssText = `
                position: fixed !important;
                inset: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                backdrop-filter: blur(10px) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            // Crear iframe para cargar el juego correctamente
            const gameFrame = document.createElement('iframe');
            gameFrame.src = 'games/bubbles/bubbles.html';
            gameFrame.style.cssText = `
                width: 95% !important;
                height: 95vh !important;
                max-width: 500px !important;
                max-height: 800px !important;
                border: none !important;
                border-radius: 20px !important;
                box-shadow: rgba(0, 0, 0, 0.3) 0px 20px 40px !important;
            `;
            
            // Log cuando el iframe se carga
            gameFrame.onload = () => {
                console.log('🫧 IFRAME CARGADO: games/bubbles/bubbles.html');
            };
            
            gameFrame.onerror = () => {
                console.error('❌ ERROR CARGANDO IFRAME: games/bubbles/bubbles.html');
            };
            
            // Escuchar mensajes del juego para cerrar
            const messageHandler = (event) => {
                console.log('🔍 MENSAJE RECIBIDO:', event.data);
                if (event.data === 'closeBubblesGame') {
                    console.log('🔴 RECIBIDO MENSAJE DE CIERRE - ELIMINANDO OVERLAY');
                    console.log('🔍 Overlay antes:', gameOverlay);
                        gameOverlay.remove();
                    console.log('🔍 Overlay después:', gameOverlay);
                        document.getElementById('gamesModal').style.display = 'flex';
                    console.log('🔍 Modal de juegos mostrado');
                    window.removeEventListener('message', messageHandler);
                    console.log('🔍 Event listener removido');
                }
            };
            window.addEventListener('message', messageHandler);
            
            gameOverlay.appendChild(gameFrame);
            document.body.appendChild(gameOverlay);
        }
        
        // 💎 JUEGO DE BLOQUES (MAR MATCH-3) - CÓDIGO EXACTO DEL HTML QUE FUNCIONA
        function startBloquesGame() {
            console.log('💎 Iniciando juego Conecta 3 integrado...');
            
            // Verificar si ya existe el juego para evitar duplicados
            if (document.getElementById('bloquesGameOverlay')) {
                console.log('⚠️ Juego de bloques ya existe, eliminando duplicado...');
                document.getElementById('bloquesGameOverlay').remove();
            }
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'bloquesGameOverlay';
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                backdrop-filter: blur(10px) !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            gameOverlay.innerHTML = `
                <div class="bloques-game-container">
                    <div class="bloques-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🌊 Conecta 3</div>
                                <div class="header-controls">
                                    <button id="bloques-sound-toggle" class="sound-btn" style="
                                        background: rgba(255, 255, 255, 0.2);
                                        border: 2px solid rgba(255, 255, 255, 0.8);
                                        border-radius: 50%;
                                        width: 40px;
                                        height: 40px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                    ">
                                        <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                    </button>
                                    <button class="bloques-close-btn" style="
                                        background: rgba(255, 255, 255, 0.2);
                                        border: 2px solid rgba(255, 255, 255, 0.8);
                                        border-radius: 50%;
                                        width: 40px;
                                        height: 40px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                        color: white;
                                        font-size: 18px;
                                        font-weight: bold;
                                    ">✕</button>
                                </div>
                        </div>
                        
                        <!-- SEGUNDA LÍNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL 1</span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="bloques-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="bloques-best-display">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="bloques-timer-bar">
                        <div class="bloques-timer-fill" id="bloques-timer-fill"></div>
                    </div>
                    <div class="bloques-stage-container">
                        <div class="bloques-board" id="bloques-board"></div>
                    </div>
                    <div class="bloques-footer">
                        <button class="bloques-btn" id="bloques-restart">JUGAR</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'bloques');
            
            const closeBtn = gameOverlay.querySelector('.bloques-close-btn');
            const board = gameOverlay.querySelector('.bloques-board');
            const footer = gameOverlay.querySelector('.bloques-footer');
            const restartBtn = gameOverlay.querySelector('#bloques-restart');
            
            // Verificar que los elementos existen antes de usarlos
            if (!closeBtn || !board || !footer || !restartBtn) {
                console.error('❌ Elementos del juego no encontrados');
                return;
            }
            
            // Aplicar estilos del contenedor exterior (igual que burbujas)
            const stageContainer = gameOverlay.querySelector('.bloques-stage-container');
            if (stageContainer) {
                stageContainer.style.cssText = `
                    background: linear-gradient(135deg, 
                        rgba(79, 195, 247, 0.1) 0%, 
                        rgba(41, 182, 246, 0.05) 100%);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 14px;
                    padding: 10px;
                    margin: 10px;
                    flex: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            }
            
            // Aplicar estilos específicos del tablero (más pequeño, centrado)
            board.style.cssText = `
                position: relative;
                width: calc(6 * 48px + 5 * 2px);
                height: calc(9 * 48px + 8 * 2px);
                background: rgba(255, 255, 255, 0.05);
                padding: 8px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                overflow: visible;
            `;
            
            // Aplicar estilos específicos del footer
            footer.style.cssText = `
                padding: 20px !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                margin-top: auto !important;
                position: relative !important;
                background: rgba(255, 255, 255, 0.05) !important;
                border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
                min-height: 80px !important;
                width: 100% !important;
                visibility: visible !important;
                opacity: 1 !important;
                overflow: visible !important;
                z-index: 100 !important;
            `;
            
            // Aplicar estilos específicos del botón restart
            restartBtn.style.cssText = `
                background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
                border: 2px solid rgb(21, 101, 192) !important;
                border-radius: 20px !important;
                padding: 12px 30px !important;
                font-size: 18px !important;
                font-weight: bold !important;
                color: white !important;
                cursor: pointer !important;
                transition: 0.3s !important;
                text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
                box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
                text-transform: uppercase !important;
                letter-spacing: 1px !important;
                width: 80% !important;
                max-width: 250px !important;
                margin: 15px auto !important;
                display: block !important;
                position: relative !important;
                z-index: 1000 !important;
                visibility: visible !important;
                opacity: 1 !important;
                height: auto !important;
                min-height: 50px !important;
                overflow: visible !important;
                clip: auto !important;
                clip-path: none !important;
            `;
            
            // Aplicar estilos específicos de la barra de tiempo
            const timerBar = gameOverlay.querySelector('.bloques-timer-bar');
            const timerFill = gameOverlay.querySelector('.bloques-timer-fill');
            
            if (timerBar) {
                timerBar.style.cssText = `
                    width: 100%;
                    height: 8px;
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 4px;
                    overflow: hidden;
                    margin: 10px 0;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                `;
            }
            
            if (timerFill) {
                timerFill.style.cssText = `
                    height: 100%;
                    background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
                    width: 100%;
                    transition: width 1s linear;
                    border-radius: 3px;
                `;
            }

            // === CÓDIGO EXACTO DEL HTML QUE FUNCIONA ===
            const COLS = 6, ROWS = 9, TYPES = 6;
            const CELL = 48, GAP = 2; // Gap más pequeño para cartas más juntas
            const ICONS = ['🐚','🐟','🐙','🐠','🦀','🐬']; // tema marino

            let grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));
            let score = 0, moves = 0, level = 1;
            let drag = null; // {r,c, el}
            
            // 💾 CARGAR PROGRESO GUARDADO
            const savedLevel = localStorage.getItem('bloques-level');
            const savedScore = localStorage.getItem('bloques-score');
            if (savedLevel) level = parseInt(savedLevel);
            if (savedScore) score = parseInt(savedScore);

            // --- UTILS
            const posToXY = (r,c) => ({
                x: c * (CELL + GAP),
                y: r * (CELL + GAP)
            });
            function updateUI(){ 
                const scoreEl = gameOverlay.querySelector('#bloques-score');
                const timeEl = gameOverlay.querySelector('#bloques-time');
                const timerFill = gameOverlay.querySelector('#bloques-timer-fill');
                const levelEl = gameOverlay.querySelector('.level');
                
                if (scoreEl) scoreEl.textContent = score;
                if (timeEl) timeEl.textContent = timeLeft;
                if (timerFill) {
                    const percentage = (timeLeft / 60) * 100;
                    timerFill.style.width = percentage + '%';
                }
                if (levelEl) levelEl.textContent = `NIVEL ${level}`;
            }

            function makeCell(r,c,t){
                const el = document.createElement('div');
                el.className = `bloques-cell t${t}`;
                el.dataset.r = r; el.dataset.c = c; el.dataset.t = t;
                const {x,y} = posToXY(r,c);
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                // No agregar animación pop inicial

                const span = document.createElement('span');
                span.textContent = ICONS[t];
                el.appendChild(span);

                el.addEventListener('pointerdown', onPointerDown);
                el.addEventListener('pointerenter', onPointerEnter);

                return el;
            }

            function placeCell(r,c, cell){
                const {x,y} = posToXY(r,c);
                cell.style.left = x + 'px';
                cell.style.top = y + 'px';
                cell.dataset.r = r; cell.dataset.c = c;
            }

            function randomType(){ return Math.floor(Math.random()*TYPES); }

            function init(noCascades=true, showCards=false){
                score = 0; moves = 0; updateUI();
                // limpiar DOM y estado
                board.innerHTML = '';
                grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));

                for(let r=0;r<ROWS;r++){
                    for(let c=0;c<COLS;c++){
                        let t = randomType();
                        // evita nacimientos con match inmediato si noCascades=true
                        if(noCascades){
                            const left1 = c>0 ? grid[r][c-1]?.t : -1;
                            const left2 = c>1 ? grid[r][c-2]?.t : -2;
                            const up1 = r>0 ? grid[r-1][c]?.t : -1;
                            const up2 = r>1 ? grid[r-2][c]?.t : -2;
                            while((left1===t && left2===t) || (up1===t && up2===t)) t = randomType();
                        }
                        const el = makeCell(r,c,t);
                        grid[r][c] = { t, el };
                        board.appendChild(el);
                        
                        if (showCards) {
                            // Mostrar cartas con efecto
                            el.style.opacity = '1';
                            el.style.transform = 'scale(1)';
                        } else {
                            // Ocultar cartas inicialmente
                            el.style.opacity = '0';
                            el.style.transform = 'scale(0.8)';
                        }
                    }
                }
            }

            // --- INPUT (drag por celdas adyacentes)
            function onPointerDown(e){
                console.log('🎯 onPointerDown disparado!');
                e.preventDefault(); // Prevenir comportamiento por defecto
                const el = e.currentTarget;
                drag = { r: +el.dataset.r, c: +el.dataset.c, el };
                el.classList.add('ghost');
                console.log('✅ Drag iniciado:', drag);
                
                // Sonido sutil al tocar una celda
                if (window.audioManager) {
                    window.audioManager.playSound('clean'); // Sonido suave para feedback táctil
                }
                
                // Agregar event listeners globales para el drag
                document.addEventListener('pointermove', onPointerMove);
                document.addEventListener('pointerup', onPointerUp);
            }
            function onPointerEnter(e){
                console.log('🎯 onPointerEnter disparado!', {drag: drag});
                if(!drag) return; // solo si estamos arrastrando desde otra celda
                const target = e.currentTarget;
                const r2 = +target.dataset.r, c2 = +target.dataset.c;
                const {r,c} = drag;
                console.log('🔄 Intentando intercambio:', {from: {r,c}, to: {r2,c2}});
                if(isAdjacent(r,c,r2,c2)){
                    console.log('✅ Son adyacentes, intercambiando...');
                    doSwap(r,c,r2,c2, true);
                    const matches = findMatches();
                    if(matches.length>0){
                        console.log('🎉 Match encontrado!', matches.length);
                        moves++; updateUI();
                        removeMatches(matches);
                    } else {
                        console.log('❌ No hay match, revirtiendo...');
                        // revertir si no hay match
                        doSwap(r2,c2,r,c, true);
                    }
                    endDrag();
                } else {
                    console.log('❌ No son adyacentes');
                }
            }
            function onPointerMove(e){
                if(!drag) return;
                // Encontrar el elemento bajo el cursor
                const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
                if(elementBelow && elementBelow.classList.contains('bloques-cell')){
                    onPointerEnter({currentTarget: elementBelow});
                }
            }
            
            function onPointerUp(){ 
                console.log('🎯 onPointerUp disparado!', {drag: drag});
                if(drag) {
                    // Remover event listeners globales
                    document.removeEventListener('pointermove', onPointerMove);
                    document.removeEventListener('pointerup', onPointerUp);
                    endDrag(); 
                }
            }
            function endDrag(){ 
                console.log('🛑 endDrag llamado', {drag: drag});
                if(drag){ 
                    drag.el.classList.remove('ghost'); 
                    drag = null; 
                    console.log('✅ Drag terminado');
                } 
            }
            function isAdjacent(r1,c1,r2,c2){ return (Math.abs(r1-r2)+Math.abs(c1-c2))===1; }

            function doSwap(r1,c1,r2,c2, animate=false){
                const a = grid[r1][c1], b = grid[r2][c2];
                grid[r1][c1] = b; grid[r2][c2] = a;
                if(animate){
                    placeCell(r1,c1,b.el); placeCell(r2,c2,a.el);
                    a.el.classList.add('pulse'); b.el.classList.add('pulse');
                    setTimeout(()=>{a.el.classList.remove('pulse'); b.el.classList.remove('pulse');}, 250);
                } else {
                    placeCell(r1,c1,b.el); placeCell(r2,c2,a.el);
                }
            }

            // --- DETECCIÓN DE MATCHES (flood-fill 4 direcciones)
            function findMatches(){
                const seen = Array.from({length:ROWS},()=>Array(COLS).fill(false));
                const matches = [];
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

                for(let r=0;r<ROWS;r++){
                    for(let c=0;c<COLS;c++){
                        if(!grid[r][c] || seen[r][c]) continue;
                        const t = grid[r][c].t;
                        const stack=[[r,c]]; const group=[];
                        seen[r][c]=true;
                        while(stack.length){
                            const [rr,cc]=stack.pop(); group.push({r:rr,c:cc});
                            for(const [dr,dc] of dirs){
                                const nr=rr+dr,nc=cc+dc;
                                if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
                                if(seen[nr][nc]) continue;
                                if(grid[nr][nc] && grid[nr][nc].t===t){ seen[nr][nc]=true; stack.push([nr,nc]); }
                            }
                        }
                        if(group.length>=3) matches.push(...group);
                    }
                }

                // eliminar duplicados
                const key = p=>p.r+":"+p.c;
                const uniq = new Map();
                for(const m of matches) uniq.set(key(m), m);
                return [...uniq.values()];
            }

            // --- ELIMINACIÓN, GRAVEDAD Y RELLENO
            function removeMatches(matches){
                // Menos puntos por match (antes era 10, ahora 2)
                score += matches.length * 2;
                
                // Sistema de niveles: cada 200 perlas sube de nivel
                const newLevel = Math.floor(score / 200) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // Actualizar nivel en la UI
                    const levelEl = gameOverlay.querySelector('.level');
                    if (levelEl) {
                        levelEl.textContent = `NIVEL ${level}`;
                    }
                    console.log(`🎉 ¡Subiste al nivel ${level}!`);
                    
                    // 💾 GUARDAR PROGRESO EN LOCALSTORAGE
                    localStorage.setItem('bloques-level', level.toString());
                    localStorage.setItem('bloques-score', score.toString());
                    
                    // Sonido especial para subir de nivel
                    if (window.audioManager) {
                        window.audioManager.playSound('levelComplete');
                    }
                } else {
                    // Sonido de acierto normal
                    if (window.audioManager) {
                        window.audioManager.playSound('acierto');
                    }
                }
                
                updateUI();

                // Efecto de perlas volando al contador desde las posiciones de match
                createPearlEffectFromMatches(matches);

                // eliminar del DOM + marcar vacíos
                for(const {r,c} of matches){
                    const item = grid[r][c];
                    if(item && item.el){ item.el.style.opacity='0'; item.el.style.transform='scale(.6)'; setTimeout(()=>item.el.remove(),150); }
                    grid[r][c] = null;
                }

                // caída por columnas
                setTimeout(()=>{
                    for(let c=0;c<COLS;c++){
                        let write = ROWS-1;
                        for(let r=ROWS-1;r>=0;r--){
                            if(grid[r][c]){
                                if(write!==r){
                                    grid[write][c]=grid[r][c];
                                    placeCell(write,c, grid[write][c].el);
                                    grid[r][c]=null;
                                }
                                write--;
                            }
                        }
                        // generar nuevas arriba
                        for(let r=write;r>=0;r--){
                            const t = randomType();
                            const el = makeCell(r,c,t);
                            el.style.opacity='0'; el.style.transform='translateY(-24px)';
                            grid[r][c] = {t, el};
                            board.appendChild(el);
                            requestAnimationFrame(()=>{
                                el.style.transition='transform .35s ease, opacity .35s ease';
                                el.style.opacity='1'; el.style.transform='translateY(0)';
                            });
                        }
                    }

                    // cascada
                    setTimeout(()=>{
                        const again = findMatches();
                        if(again.length>0) removeMatches(again);
                    }, 120);
                }, 160);
            }

            let timerId = null, timeLeft = 60;
            function startTimer() {
                timerId = setInterval(() => {
                    timeLeft--;
                    updateUI();
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        console.log('⏰ Tiempo agotado!');
                        
                        // Sonido de fin de partida
                        if (window.audioManager) {
                            window.audioManager.playSound('fail');
                        }
                        
                        // Mostrar pantalla de fin de partida
                        showEndGameModal();
                    }
                }, 1000);
            }

            function showCardsEffect() {
                console.log('✨ Mostrando cartas con efecto...');
                
                // Obtener todas las cartas existentes
                const cells = board.querySelectorAll('.bloques-cell');
                
                // Hacer aparecer las cartas una por una con efecto suave
                cells.forEach((cell, index) => {
                    setTimeout(() => {
                        cell.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        cell.style.opacity = '1';
                        cell.style.transform = 'scale(1)';
                    }, index * 30); // Cada carta aparece con 30ms de diferencia
                });
                
                // Calcular tiempo total: (cells.length * 30ms) + 600ms (última animación)
                const totalTime = (cells.length * 30) + 600;
                return totalTime;
            }

            function createPearlEffectFromMatches(matches) {
                console.log(`💎 Creando efecto de perlas desde ${matches.length} matches...`);
                
                // Obtener posición del contador de perlas
                const pearlCounter = gameOverlay.querySelector('.perlas');
                if (!pearlCounter) return;
                
                const counterRect = pearlCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear perlas desde cada posición de match (máximo 5 para que no sea demasiado)
                const maxPearls = Math.min(matches.length, 5);
                for (let i = 0; i < maxPearls; i++) {
                    const match = matches[i];
                    const cell = grid[match.r][match.c];
                    
                    if (cell && cell.el) {
                        // Obtener posición de la celda que hizo match
                        const cellRect = cell.el.getBoundingClientRect();
                        const startX = cellRect.left + cellRect.width / 2;
                        const startY = cellRect.top + cellRect.height / 2;
                        
                        const pearl = document.createElement('div');
                        pearl.innerHTML = '<img src="images/ui/perlas.png" style="width: 24px; height: 24px;">';
                        pearl.style.cssText = `
                            position: fixed;
                            z-index: 10000;
                            pointer-events: none;
                            left: ${startX}px;
                            top: ${startY}px;
                            opacity: 0;
                            transform: scale(0.5);
                            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        `;
                        
                        document.body.appendChild(pearl);
                        
                        // Aparecer y volar hacia el contador
                        setTimeout(() => {
                            pearl.style.opacity = '1';
                            pearl.style.transform = 'scale(1)';
                            
                            setTimeout(() => {
                                pearl.style.left = targetX + 'px';
                                pearl.style.top = targetY + 'px';
                                pearl.style.transform = 'scale(0.3)';
                                pearl.style.opacity = '0.7';
                            }, 200);
                        }, i * 100);
                        
                        // Remover después de la animación
                        setTimeout(() => {
                            pearl.remove();
                        }, 1000 + (i * 100));
                    }
                }
            }

            function showEndGameModal() {
                console.log('🏁 Mostrando modal de fin de partida...');
                
                // Crear modal de fin de partida (igual que Burbujas)
                const endModal = document.createElement('div');
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">🌊 ¡Tiempo Agotado!</h2>
                        <p style="
                            font-size: 18px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">Puntuación: <strong>${score}</strong></p>
                        <button id="bloques-play-again" style="
                            background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210));
                            border: 2px solid rgb(21, 101, 192);
                            border-radius: 20px;
                            padding: 12px 30px;
                            font-size: 18px;
                            font-weight: bold;
                            color: white;
                            cursor: pointer;
                            transition: 0.3s;
                            text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                            box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">JUGAR</button>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listener para el botón
                const playAgainBtn = endModal.querySelector('#bloques-play-again');
                playAgainBtn.addEventListener('click', () => {
                    endModal.remove();
                    // Reiniciar juego
                    timeLeft = 60;
                    init(true, false);
                });
            }
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                if (timerId) clearInterval(timerId);
                gameOverlay.remove();
                // Volver a la ventana de juegos, no a la pecera
                document.getElementById('gamesModal').style.display = 'flex';
            });
            
            // Botón de sonido
            const soundBtn = gameOverlay.querySelector('#bloques-sound-toggle');
            if (soundBtn) {
                // Inicializar estado del botón
                const img = soundBtn.querySelector('img');
                if (img && window.audioManager) {
                    img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                }
                
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        // Usar el método correcto del AudioManager
                        window.audioManager.toggleMute();
                        const img = soundBtn.querySelector('img');
                        if (img) {
                            img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                        }
                    }
                });
            }
            
            // Actualizar UI inicial con progreso cargado
            updateUI();
            
            restartBtn.addEventListener('click', () => {
                console.log('🎮 ¡CLICK EN JUGAR DETECTADO!');
                if(timerId) clearInterval(timerId);
                
                // 🔧 ARREGLO: Resetear nivel y score de la partida
                level = 1;
                score = 0;
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                // Efecto de mostrar cartas
                const effectTime = showCardsEffect();
                
                setTimeout(() => {
                    startTimer();
                    console.log('🎮 ¡Juego iniciado!');
                }, effectTime); // Esperar a que termine el efecto
            });
            
            document.body.appendChild(gameOverlay);
            init(true, false); // No mostrar cartas inicialmente
            console.log('💎 Juego Conecta 3 iniciado');
        }
        
        // 🧠 JUEGO DE MEMORIA - PEZFLIP INFINITO
        function startMemoriaGame() {
            console.log('🧠 Iniciando PezFlip Infinito...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego (igual que los otros)
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'memoryGameOverlay';
            gameOverlay.className = 'game-modal-overlay';
            gameOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%) !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                z-index: 99999 !important;
                backdrop-filter: blur(10px) !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            gameOverlay.innerHTML = `
                <div class="memory-game-container">
                    <!-- 🧠 CABECERA DEL JUEGO (igual que los otros) -->
                    <div class="memory-game-header">
                        <div class="header-top">
                            <div class="game-title">🧠 PezFlip Infinito</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="game-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL <span id="memory-level">1</span></span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="memory-bubbles">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="memory-best">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ⏰ BARRA DE TIEMPO -->
                    <div class="memory-timer-bar" style="
                        width: 100%;
                        height: 8px;
                        background: rgba(255, 255, 255, 0.2);
                        border-radius: 4px;
                        overflow: hidden;
                        margin: 10px 0;
                        border: 1px solid rgba(255, 255, 255, 0.3);
                    ">
                        <div class="memory-timer-fill" id="memory-timer-fill" style="
                            height: 100%;
                            background: linear-gradient(90deg, #29b6f6, #0288d1);
                            width: 100%;
                            transition: width 1s linear;
                        "></div>
                    </div>
                    
                    <!-- 🎮 ÁREA DE JUEGO -->
                    <div class="memory-stage-container" style="
                        background: linear-gradient(135deg, 
                            rgba(79, 195, 247, 0.1) 0%, 
                            rgba(41, 182, 246, 0.05) 100%);
                        border: 2px solid rgba(255, 255, 255, 0.2);
                        border-radius: 14px;
                        padding: 10px;
                        margin: 10px;
                        flex: 1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div class="memory-board" id="memory-board" style="
                            display: grid;
                            grid-template-columns: repeat(5, 1fr);
                            grid-template-rows: repeat(4, 1fr);
                            gap: 8px;
                            width: 320px;
                            height: 256px;
                            background: rgba(255, 255, 255, 0.05);
                            padding: 10px;
                            border-radius: 10px;
                            border: 1px solid rgba(255, 255, 255, 0.1);
                        "></div>
                    </div>
                    
                    <!-- 🎮 BOTÓN JUGAR -->
                    <div class="memory-footer" style="
                        padding: 20px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    ">
                       <button class="memory-btn" id="memory-restart" style="
                           background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210)) !important;
                           border: 2px solid rgb(21, 101, 192) !important;
                           border-radius: 20px !important;
                           padding: 12px 30px !important;
                           font-size: 18px !important;
                           font-weight: bold !important;
                           color: white !important;
                           cursor: pointer !important;
                           transition: 0.3s !important;
                           text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px !important;
                           box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px !important;
                           text-transform: uppercase !important;
                           letter-spacing: 1px !important;
                           width: 80% !important;
                           max-width: 250px !important;
                           margin: 20px auto !important;
                           display: block !important;
                       ">JUGAR</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(gameOverlay);
            console.log('🧠 PezFlip overlay creado y añadido al DOM');
            
            // Variables del juego
            let cards = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let timeLeft = 120; // 2 minutos para que puedas jugar tranquilo
            let timerId = null;
            let gameActive = false;
            let bestScore = 0;
            let lockFlip = false; // Sistema de bloqueo mejorado
            let level = 1;
            let totalPairs = 2; // Empezar con 2 pares (4 cartas)
            let bubbles = 0; // Burbujas ganadas
            let baseTime = 90; // Tiempo base por nivel
            let closeDelay = 600; // Tiempo para cerrar cartas
            
            // Emojis marinos para las cartas (set expandido)
            const EMOJIS = [
                '🐟','🐠','🐡','🦈','🐬','🐳','🐋','🦀','🦞','🦑',
                '🦐','🐙','🐚','🪸','⭐','⚓','🪼','🦭','🐊','🌊'
            ];
            
            // Colores de nivel para los bordes de las cartas
            const LEVEL_COLORS = [
                'rgba(33, 150, 243, 0.8)',    // Nivel 1 - Azul
                'rgba(76, 175, 80, 0.8)',     // Nivel 2 - Verde
                'rgba(156, 39, 176, 0.8)',    // Nivel 3 - Púrpura
                'rgba(255, 152, 0, 0.8)',     // Nivel 4 - Naranja
                'rgba(244, 67, 54, 0.8)',     // Nivel 5 - Rojo
                'rgba(255, 193, 7, 0.8)',     // Nivel 6 - Amarillo
                'rgba(0, 188, 212, 0.8)',     // Nivel 7 - Cian
                'rgba(103, 58, 183, 0.8)',    // Nivel 8 - Índigo
                'rgba(255, 87, 34, 0.8)',     // Nivel 9 - Naranja oscuro
                'rgba(233, 30, 99, 0.8)'      // Nivel 10+ - Rosa
            ];
            
            // Función para obtener color del nivel
            function getLevelColor(level) {
                return LEVEL_COLORS[Math.min(level - 1, LEVEL_COLORS.length - 1)];
            }
            
            // Función para calcular dificultad según nivel
            function calculateDifficulty(level) {
                if (level <= 2) {
                    return { pairs: 2, time: 90, closeDelay: 600, grid: '2x2' };
                } else if (level <= 4) {
                    return { pairs: 4, time: 100, closeDelay: 500, grid: '2x4' };
                } else if (level <= 6) {
                    return { pairs: 6, time: 110, closeDelay: 400, grid: '3x4' };
                } else if (level <= 8) {
                    return { pairs: 8, time: 120, closeDelay: 350, grid: '4x4' };
                } else {
                    return { pairs: 10, time: 130, closeDelay: 300, grid: '4x5' };
                }
            }
            
            // Función para actualizar el layout del grid
            function updateGridLayout(gridType) {
                const board = gameOverlay.querySelector('#memory-board');
                if (!board) return;
                
                switch(gridType) {
                    case '2x2':
                        board.style.gridTemplateColumns = 'repeat(2, 1fr)';
                        board.style.gridTemplateRows = 'repeat(2, 1fr)';
                        board.style.width = '160px';
                        board.style.height = '160px';
                        break;
                    case '2x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(2, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '160px';
                        break;
                    case '3x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(3, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '240px';
                        break;
                    case '4x4':
                        board.style.gridTemplateColumns = 'repeat(4, 1fr)';
                        board.style.gridTemplateRows = 'repeat(4, 1fr)';
                        board.style.width = '320px';
                        board.style.height = '320px';
                        break;
                    case '4x5':
                        board.style.gridTemplateColumns = 'repeat(5, 1fr)';
                        board.style.gridTemplateRows = 'repeat(4, 1fr)';
                        board.style.width = '400px';
                        board.style.height = '320px';
                        break;
                }
            }
            
            // Elementos del DOM
            const board = gameOverlay.querySelector('#memory-board');
            const levelEl = gameOverlay.querySelector('#memory-level');
            const bubblesEl = gameOverlay.querySelector('#memory-bubbles');
            const bestEl = gameOverlay.querySelector('#memory-best');
            const timerFill = gameOverlay.querySelector('#memory-timer-fill');
            const restartBtn = gameOverlay.querySelector('#memory-restart');
            const closeBtn = gameOverlay.querySelector('.game-close-btn');
            const soundBtn = gameOverlay.querySelector('.sound-btn');
            
            // Función para crear las cartas
            function createCards() {
                board.innerHTML = '';
                cards = [];
                flippedCards = [];
                matchedPairs = 0;
                moves = 0;
                lockFlip = false; // Reiniciar bloqueo
                gameActive = false;
                
                // Calcular dificultad según nivel
                const difficulty = calculateDifficulty(level);
                totalPairs = difficulty.pairs;
                timeLeft = difficulty.time;
                closeDelay = difficulty.closeDelay;
                
                // Actualizar grid dinámicamente
                updateGridLayout(difficulty.grid);
                
                // Crear cartas según dificultad
                const availableEmojis = EMOJIS.slice(0, totalPairs);
                const cardData = [...availableEmojis, ...availableEmojis];
                for(let i = cardData.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardData[i], cardData[j]] = [cardData[j], cardData[i]];
                }
                
                cardData.forEach((emoji, index) => {
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.dataset.emoji = emoji;
                    card.dataset.index = index;
                    card.style.cssText = `
                        background: rgba(255, 255, 255, 0.1);
                        border: 3px solid ${getLevelColor(level)};
                        border-radius: 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        backdrop-filter: blur(10px);
                        opacity: 0;
                        transform: scale(0.8);
                        box-shadow: 0 0 15px ${getLevelColor(level)};
                    `;
                    
                    // Contenido de la carta (inicialmente oculto)
                    card.innerHTML = `
                        <div class="card-back" style="
                            width: 100%;
                            height: 100%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            background: linear-gradient(135deg, 
                                rgba(79, 195, 247, 0.3) 0%, 
                                rgba(41, 182, 246, 0.2) 100%);
                            border-radius: 6px;
                            font-size: 20px;
                        ">?</div>
                        <div class="card-front" style="
                            width: 100%;
                            height: 100%;
                            display: none;
                            align-items: center;
                            justify-content: center;
                            background: rgba(255, 255, 255, 0.9);
                            border-radius: 6px;
                            font-size: 24px;
                        ">${emoji}</div>
                    `;
                    
                    card.addEventListener('click', () => flipCard(card));
                    board.appendChild(card);
                    cards.push(card);
                });
                
                updateUI();
            }
            
            // Función para voltear carta (sistema mejorado)
            function flipCard(card) {
                if (lockFlip || !gameActive || card.classList.contains('flipped') || card.classList.contains('matched')) {
                    return;
                }
                
                const open = Array.from(board.querySelectorAll('.memory-card.flipped:not(.matched)'));
                if (open.length >= 2) return; // Prevenir más de 2 cartas abiertas
                
                card.classList.add('flipped');
                
                // Efecto de giro rápido
                card.style.transform = 'rotateY(180deg)';
                card.style.transition = 'transform 0.3s ease-in-out';
                
                // Mostrar el emoji después del giro
                setTimeout(() => {
                    const cardBack = card.querySelector('.card-back');
                    const cardFront = card.querySelector('.card-front');
                    cardBack.style.display = 'none';
                    cardFront.style.display = 'flex';
                }, 150);
                
                // Sonido de voltear (siempre)
                if (window.audioManager) {
                    window.audioManager.playSound('acierto');
                }
                
                const newlyOpen = [...open, card];
                if (newlyOpen.length === 2) {
                    moves++;
                    updateUI();
                    lockFlip = true;
                    
                    const [a, b] = newlyOpen;
                    const isMatch = a.dataset.emoji === b.dataset.emoji;
                    
                    setTimeout(() => {
                        if (isMatch) {
                            a.classList.add('matched');
                            b.classList.add('matched');
                            matchedPairs++;
                            
                            // 🎮 DAR DIVERSIÓN INMEDIATA POR CADA PAR ACERTADO
                            if (window.game && window.game.gameState) {
                                const funIncrease = 2; // +2 diversión por cada par acertado
                                window.game.gameState.needs.fun = Math.min(100, window.game.gameState.needs.fun + funIncrease);
                                window.game.needsSystem.updateCrisisFlags();
                                window.game.needsSystem.updateNeedBars();
                                console.log(`🎮 +${funIncrease} diversión por acertar par (total: ${matchedPairs} pares)`);
                            }
                            
                            // Efecto visual verde para aciertos
                            a.style.background = 'linear-gradient(135deg, #4CAF50, #8BC34A)';
                            b.style.background = 'linear-gradient(135deg, #4CAF50, #8BC34A)';
                            a.style.transform = 'scale(1.1)';
                            b.style.transform = 'scale(1.1)';
                            
                            setTimeout(() => {
                                a.style.transform = 'scale(1)';
                                b.style.transform = 'scale(1)';
                            }, 300);
                            
                            // Añadir burbujas por acierto
                            bubbles += 2;
                            
                            // Guardar burbujas
                            localStorage.setItem('memory-bubbles', bubbles.toString());
                            
                            // Sonido de acierto
                            if (window.audioManager) {
                                window.audioManager.playSound('nivelcompletado');
                            }
                            
                            // Efecto de perlas
                            createPearlEffect(a);
                            
                            if (matchedPairs === totalPairs) {
                                setTimeout(() => {
                                    // Sonido de nivel completado
                                    if (window.audioManager) {
                                        window.audioManager.playSound('levelComplete');
                                    }
                                    
                                    // Subir nivel
                                    level++;
                                    
                                    // Guardar progreso
                                    localStorage.setItem('memory-level', level.toString());
                                    localStorage.setItem('memory-bubbles', bubbles.toString());
                                    
                                    // Regenerar tablero (sistema infinito)
                                    createCards();
                                    showCardsEffect(); // Mostrar cartas con efecto
                                    updateUI();
                                    
                                    // Reiniciar timer para nueva ronda
                                    if (timerId) clearInterval(timerId);
                                    const newDifficulty = calculateDifficulty(level);
                                    timeLeft = newDifficulty.time; // Tiempo dinámico según nuevo nivel
                                    gameActive = true; // Reactivar el juego
                                    lockFlip = false; // Resetear bloqueo
                                    startTimer(); // Iniciar nuevo timer
                                }, 600);
                            }
                        } else {
                            // Voltear de vuelta con efecto de giro rápido
                            setTimeout(() => {
                                a.style.transform = 'rotateY(0deg)';
                                b.style.transform = 'rotateY(0deg)';
                                
                                setTimeout(() => {
                                    const cardBack1 = a.querySelector('.card-back');
                                    const cardFront1 = a.querySelector('.card-front');
                                    const cardBack2 = b.querySelector('.card-back');
                                    const cardFront2 = b.querySelector('.card-front');
                                    
                                    cardBack1.style.display = 'flex';
                                    cardFront1.style.display = 'none';
                                    cardBack2.style.display = 'flex';
                                    cardFront2.style.display = 'none';
                                    
                                    a.classList.remove('flipped');
                                    b.classList.remove('flipped');
                                }, 150);
                            }, 300);
                        }
                        lockFlip = false;
                    }, isMatch ? 250 : closeDelay);
                }
            }
            
            
            // Función para crear efecto de burbujas volando al contador
            function createPearlEffect(card) {
                const rect = card.getBoundingClientRect();
                
                // Obtener posición del contador de burbujas
                const bubbleCounter = gameOverlay.querySelector('.perlas');
                if (!bubbleCounter) return;
                
                const counterRect = bubbleCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear 3 burbujas que vuelen al contador
                for (let i = 0; i < 3; i++) {
                    const pearl = document.createElement('div');
                    pearl.style.cssText = `
                        position: fixed;
                        left: ${rect.left + rect.width/2 + (i - 1) * 10}px;
                        top: ${rect.top + rect.height/2 + (i - 1) * 5}px;
                        width: 20px;
                        height: 20px;
                        background: url('images/ui/perlas.png') center/contain no-repeat;
                        pointer-events: none;
                        z-index: 99999;
                        animation: bubbleFly 1.2s ease-out forwards;
                    `;
                    
                    // Añadir keyframes para la animación
                    if (!document.getElementById('bubbleFlyKeyframes')) {
                        const style = document.createElement('style');
                        style.id = 'bubbleFlyKeyframes';
                        style.textContent = `
                            @keyframes bubbleFly {
                                0% {
                                    transform: scale(0.5) rotate(0deg);
                                    opacity: 1;
                                }
                                50% {
                                    transform: scale(1.2) rotate(180deg);
                                    opacity: 0.8;
                                }
                                100% {
                                    transform: scale(0.3) rotate(360deg);
                                    opacity: 0;
                                    left: ${targetX}px;
                                    top: ${targetY}px;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    document.body.appendChild(pearl);
                    setTimeout(() => pearl.remove(), 1200);
                }
            }
            
            // Función para actualizar UI
            function updateUI() {
                if (levelEl) levelEl.textContent = level; // Nivel por rondas completadas
                if (bubblesEl) bubblesEl.textContent = bubbles;
                if (bestEl) bestEl.textContent = bestScore;
                const difficulty = calculateDifficulty(level);
                if (timerFill) timerFill.style.width = `${(timeLeft / difficulty.time) * 100}%`;
            }
            
            // Función para iniciar timer
            function startTimer() {
                if (timerId) clearInterval(timerId); // Limpiar timer anterior
                timerId = setInterval(() => {
                    timeLeft--;
                    updateUI();
                    
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        endGame(false);
                    }
                }, 1000);
            }
            
            // Función para mostrar cartas con efecto
            function showCardsEffect() {
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        card.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1)';
                    }, index * 50);
                });
            }
            
            // Función para terminar juego
            function endGame(won) {
                if (!gameActive) return; // Evitar múltiples llamadas
                
                // 🎮 LLAMAR A LA FUNCIÓN DE FINALIZACIÓN DEL JUEGO PRINCIPAL
                if (window.game && window.game.endGame) {
                    window.game.endGame(won, won ? '¡Memoria perfecta!' : '¡Inténtalo de nuevo!');
                }
                
                gameActive = false;
                if (timerId) clearInterval(timerId);
                
                // Actualizar récord si es mejor
                if (won && moves < bestScore || bestScore === 0) {
                    bestScore = moves;
                    localStorage.setItem('memory-best', bestScore.toString());
                }
                
                // Sonido de fin
                if (window.audioManager) {
                    window.audioManager.playSound(won ? 'nivelcompletado' : 'fail');
                }
                
                // Verificar si ya existe un modal de fin
                if (gameOverlay.querySelector('.end-modal')) return;
                
                // Mostrar modal de fin (igual que Burbujas y Conecta 3)
                const endModal = document.createElement('div');
                endModal.className = 'end-modal';
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">
                            ${won ? '🧠 ¡Felicidades!' : '🧠 ¡Inténtalo de nuevo!'}
                        </h2>
                        <p style="
                            font-size: 18px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">
                            ${won ? '¡Completaste todas las parejas!' : 'Sigue practicando'}
                        </p>
                        <p style="
                            font-size: 16px;
                            margin-bottom: 20px;
                            color: #fff;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">
                            Nivel alcanzado: <strong>${level}</strong><br>
                            Burbujas: <strong>${bubbles}</strong><br>
                            Movimientos: <strong>${moves}</strong>
                        </p>
                       <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                           <button class="restart-btn" style="
                               background: linear-gradient(135deg, rgb(33, 150, 243), rgb(25, 118, 210));
                               border: 2px solid rgb(21, 101, 192);
                               border-radius: 20px;
                               padding: 12px 30px;
                               font-size: 18px;
                               font-weight: bold;
                               color: white;
                               cursor: pointer;
                               transition: 0.3s;
                               text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                               box-shadow: rgba(33, 150, 243, 0.4) 0px 6px 20px;
                               text-transform: uppercase;
                               letter-spacing: 1px;
                               flex: 1;
                               min-width: 120px;
                           ">CONTINUAR</button>
                           <button class="reset-btn" style="
                               background: linear-gradient(135deg, rgb(244, 67, 54), rgb(211, 47, 47));
                               border: 2px solid rgb(183, 28, 28);
                               border-radius: 20px;
                               padding: 12px 20px;
                               font-size: 16px;
                               font-weight: bold;
                               color: white;
                               cursor: pointer;
                               transition: 0.3s;
                               text-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
                               box-shadow: rgba(244, 67, 54, 0.4) 0px 6px 20px;
                               text-transform: uppercase;
                               letter-spacing: 1px;
                               flex: 1;
                               min-width: 120px;
                           ">EMPEZAR DE CERO</button>
                       </div>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listeners del modal de fin
                endModal.querySelector('.restart-btn').addEventListener('click', () => {
                    endModal.remove();
                    startGame();
                });
                
                endModal.querySelector('.reset-btn').addEventListener('click', () => {
                    // Resetear progreso
                    level = 1;
                    bubbles = 0;
                    localStorage.removeItem('memory-level');
                    localStorage.removeItem('memory-bubbles');
                    endModal.remove();
                    startGame();
                });
                
                // Cerrar modal al hacer clic fuera
                endModal.addEventListener('click', (e) => {
                    if (e.target === endModal) {
                        endModal.remove();
                        gameOverlay.remove();
                        document.getElementById('gamesModal').style.display = 'flex';
                    }
                });
            }
            
            // Función para iniciar juego
            function startGame() {
                // 🔧 ARREGLO: Resetear nivel y burbujas de la partida
                level = 1;
                bubbles = 0;
                const difficulty = calculateDifficulty(level);
                timeLeft = difficulty.time; // Tiempo dinámico según nivel
                lockFlip = false; // Reiniciar bloqueo
                createCards();
                showCardsEffect();
                
                setTimeout(() => {
                    gameActive = true;
                    startTimer();
                }, 2000);
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
            }
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                if (timerId) clearInterval(timerId);
                gameOverlay.remove();
                document.getElementById('gamesModal').style.display = 'flex';
            });
            
            restartBtn.addEventListener('click', startGame);
            
            // Botón de sonido
            if (soundBtn) {
                const img = soundBtn.querySelector('img');
                if (img && window.audioManager) {
                    img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                }
                
                soundBtn.addEventListener('click', () => {
                    if (window.audioManager) {
                        window.audioManager.toggleMute();
                        const img = soundBtn.querySelector('img');
                        if (img) {
                            img.src = window.audioManager.isMuted ? 'images/ui/sonidoOff.png' : 'images/ui/sonidoOn.png';
                        }
                    }
                });
            }
            
            // Cargar récord y progreso
            const savedBest = localStorage.getItem('memory-best');
            if (savedBest) bestScore = parseInt(savedBest);
            
            // Cargar nivel guardado
            const savedLevel = localStorage.getItem('memory-level');
            if (savedLevel) level = parseInt(savedLevel);
            
            // Cargar burbujas guardadas
            const savedBubbles = localStorage.getItem('memory-bubbles');
            if (savedBubbles) bubbles = parseInt(savedBubbles);
            
            // Inicializar juego
            createCards();
            updateUI();
            console.log('🧠 PezFlip iniciado correctamente');
            console.log('🧠 Overlay visible:', gameOverlay.style.display);
            console.log('🧠 Overlay en DOM:', document.body.contains(gameOverlay));
        }
        
        // 🎵 JUEGO DE SIMÓN MARINO - INTEGRADO COMPLETO
        function startSimonGame() {
            console.log('🎵 Iniciando juego Simón Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            console.log('🎵 Modal de juegos cerrado');
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'simonGameOverlay';
            gameOverlay.innerHTML = `
                <div class="simon-game-container">
                    <div class="simon-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🎵 Simón Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="game-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: NIVEL + PERLAS + MEJOR -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <span class="level">NIVEL <span id="simon-game-level">1</span></span>
                                <span class="perlas">
                                    <img src="images/ui/perlas.png" style="width: 28px; height: 28px; margin-bottom: 2px; vertical-align: middle;">
                                    <span class="score" id="simon-score">0</span>
                                </span>
                                <span class="best-score-display">
                                    <span class="best-label">Mejor:</span>
                                    <span class="best-value" id="simon-best">0</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="simon-board-wrap">
                        <div class="simon-board" id="simon-board">
                            <button class="simon-pad" id="simon-p1">🐟</button>
                            <button class="simon-pad" id="simon-p2">🐚</button>
                            <button class="simon-pad" id="simon-p3">⭐</button>
                            <button class="simon-pad" id="simon-p4">🌊</button>
                        </div>
                    </div>
                    <div class="simon-footer">
                        <button class="simon-btn" id="simon-start">JUGAR</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'simon');
            console.log('🎵 Diseño aplicado');
            
            const boardWrap = gameOverlay.querySelector('.simon-board-wrap');
            boardWrap.style.cssText = `
                flex: 1; display: flex; align-items: center; justify-content: center; padding: 30px;
            `;
            
            const board = gameOverlay.querySelector('.simon-board');
            board.style.cssText = `
                display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);
                gap: 15px; width: 100%; max-width: 300px; aspect-ratio: 1;
            `;
            
            const pads = gameOverlay.querySelectorAll('.simon-pad');
            const padColors = ['#1e88e5', '#43a047', '#f4511e', '#fdd835'];
            pads.forEach((pad, i) => {
                pad.style.cssText = `
                    border: none; border-radius: 18px; font-size: 32px; font-weight: 900;
                    background: linear-gradient(145deg, ${padColors[i]}, ${padColors[i]}dd);
                    color: #062130; cursor: pointer; user-select: none;
                    box-shadow: 0 8px 16px rgba(0,0,0,0.3); transition: all 0.15s ease;
                    aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
                    opacity: 0; transform: scale(0.8);
                `;
            });
            
            // Variables del juego
            let sequence = [], playerSequence = [], round = 1, score = 0, best = 0;
            let isShowing = false, isPlayerTurn = false, gameActive = false;
            let speed = 600; // Velocidad inicial (ms entre pads)
            
            // Cargar progreso guardado
            const savedBest = localStorage.getItem('simon-best');
            if (savedBest) {
                best = parseInt(savedBest);
                console.log('🎵 Simon: Mejor récord cargado:', best);
            } else {
                console.log('🎵 Simon: No hay récord guardado, empezando con 0');
            }
            
            // Función para calcular velocidad basada en el nivel
            function updateSpeed() {
                // Cada 3 niveles, la velocidad aumenta (tiempo disminuye)
                const speedLevel = Math.floor(round / 3);
                speed = Math.max(300, 600 - (speedLevel * 50)); // Mínimo 300ms, máximo 600ms
            }
            
            // Funciones del juego
            function initSimonGame() {
                // Mostrar las cartas con efecto
                pads.forEach((pad, index) => {
                    setTimeout(() => {
                        pad.style.opacity = '1';
                        pad.style.transform = 'scale(1)';
                    }, index * 100);
                });
                
                sequence = [];
                playerSequence = [];
                round = 1; // 🔧 ARREGLO: Empezar en nivel 1
                score = 0; // 🔧 ARREGLO: Resetear perlas de la partida
                speed = 600; // Resetear velocidad inicial
                isShowing = false;
                isPlayerTurn = false;
                gameActive = true;
                updateUI();
                
                // Sonido de inicio
                if (window.audioManager) {
                    window.audioManager.playSound('jugar');
                }
                
                addToSequence();
            }
            
            function addToSequence() {
                const nextPad = Math.floor(Math.random() * 4);
                sequence.push(nextPad);
                round++;
                score += 5; // +5 perlas por ronda completada
                
                console.log('🎵 Simon: Nueva ronda! Round:', round, 'Score:', score);
                
                // Actualizar velocidad basada en el nivel
                updateSpeed();
                
                updateUI();
                
                // Efecto de perlas volando al contador
                createPearlEffect();
                
                showSequence();
            }
            
            function showSequence() {
                isShowing = true;
                isPlayerTurn = false;
                let i = 0;
                
                const showNext = () => {
                    if (i < sequence.length) {
                        lightUpPad(sequence[i]);
                        setTimeout(() => {
                            i++;
                            setTimeout(showNext, Math.max(150, speed - 200)); // Pausa entre pads
                        }, Math.max(400, speed - 100)); // Duración del pad encendido
                    } else {
                        isShowing = false;
                        isPlayerTurn = true;
                        playerSequence = [];
                    }
                };
                
                setTimeout(showNext, 800);
            }
            
            function lightUpPad(padIndex) {
                const pad = pads[padIndex];
                
                // 🔧 ARREGLO: Guardar solo los estilos que vamos a cambiar
                const originalFilter = pad.style.filter;
                const originalTransform = pad.style.transform;
                
                pad.style.filter = 'brightness(1.4) contrast(1.1)';
                pad.style.transform = 'scale(1.05)';
                
                // Sonido simple
                playSimonSound(padIndex);
                
                setTimeout(() => {
                    // 🔧 ARREGLO: Restaurar solo los estilos específicos
                    pad.style.filter = originalFilter;
                    pad.style.transform = 'scale(1)'; // Siempre volver a escala normal
                }, 400);
            }
            
            function playSimonSound(padIndex) {
                // 🎵 Simon: Solo sonido musical único, NO sonido de burbujita
                // Crear AudioContext para sonidos únicos
                if (!window.audioContext) {
                    try {
                        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch(e) {
                        console.log('AudioContext no disponible');
                        return;
                    }
                }
                
                try {
                    const oscillator = window.audioContext.createOscillator();
                    const gainNode = window.audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(window.audioContext.destination);
                    
                    const frequencies = [330, 415, 523, 659]; // Notas musicales
                    oscillator.frequency.setValueAtTime(frequencies[padIndex], window.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(window.audioContext.currentTime + 0.3);
                } catch(e) {
                    console.log('Audio no disponible');
                }
            }
            
            function handlePadClick(padIndex) {
                if (!isPlayerTurn || isShowing || !gameActive) return;
                
                // 🎵 Simon: Solo efecto visual, no sonido de clic (ya tiene sonido musical)
                lightUpPad(padIndex);
                playerSequence.push(padIndex);
                
                // Verificar si es correcto
                const currentIndex = playerSequence.length - 1;
                if (playerSequence[currentIndex] !== sequence[currentIndex]) {
                    // Error - fin del juego
                    gameOver();
                    return;
                }
                
                // Si completó la secuencia
                if (playerSequence.length === sequence.length) {
                    console.log('🎵 Simon: ¡Ronda completada! Llamando addToSequence...');
                    isPlayerTurn = false;
                    setTimeout(() => {
                        addToSequence();
                    }, 1000);
                }
            }
            
            function gameOver() {
                gameActive = false;
                isPlayerTurn = false;
                
                // Guardar el nivel más alto alcanzado (no las perlas)
                if (round > best) {
                    best = round;
                    localStorage.setItem('simon-best', best.toString());
                    console.log('🎵 Simon: Nuevo récord de nivel:', best);
                }
                
                // Dar recompensas basadas en el score (perlas ganadas)
                const bubbles = Math.floor(score / 6);  // Burbujas cada 6 perlas
                const stars = Math.floor(score / 8);    // Estrellas cada 8 perlas
                
                if (window.game && (bubbles > 0 || stars > 0)) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                updateUI();
                
                // Mostrar modal de fin de juego unificado
                setTimeout(() => {
                    showEndGameModal();
                }, 500);
            }
            
            function showEndGameModal() {
                // Evitar múltiples modales
                if (gameOverlay.querySelector('.end-modal')) return;
                
                const bubbles = Math.floor(score / 6);  // Burbujas cada 6 perlas
                const stars = Math.floor(score / 8);    // Estrellas cada 8 perlas
                
                const endModal = document.createElement('div');
                endModal.className = 'end-modal';
                endModal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg,
                        rgba(13, 71, 161, 0.6) 0%,
                        rgba(21, 101, 192, 0.5) 50%,
                        rgba(25, 118, 210, 0.6) 100%);
                    backdrop-filter: blur(15px) saturate(150%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: fadeIn 0.4s ease;
                `;
                
                endModal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, 
                            rgba(33, 150, 243, 0.2) 0%, 
                            rgba(25, 118, 210, 0.15) 50%,
                            rgba(21, 101, 192, 0.2) 100%);
                        backdrop-filter: blur(30px);
                        border: 2px solid rgba(33, 150, 243, 0.4);
                        border-radius: 20px;
                        padding: 25px;
                        text-align: center;
                        color: #fff;
                        max-width: 400px;
                        width: 70%;
                        box-shadow: 
                            0 20px 60px rgba(33, 150, 243, 0.4),
                            0 0 40px rgba(25, 118, 210, 0.3),
                            inset 0 2px 0 rgba(255, 255, 255, 0.2);
                        animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        position: relative;
                    ">
                        <!-- BOTÓN X EN ESQUINA SUPERIOR DERECHA -->
                        <button class="close-btn" style="
                            position: absolute;
                            top: 15px;
                            right: 15px;
                            background: rgba(255, 255, 255, 0.2);
                            border: 2px solid rgba(255, 255, 255, 0.8);
                            border-radius: 50%;
                            width: 35px;
                            height: 35px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            color: white;
                            font-size: 16px;
                            font-weight: bold;
                            z-index: 10;
                        ">✕</button>
                        
                        <h2 style="
                            font-size: 20px;
                            font-weight: 800;
                            margin-bottom: 15px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            color: #fff;
                        ">🎵 ¡Fin del juego!</h2>
                        
                        <div style="margin: 15px 0; font-size: 16px;">
                            <p style="margin: 8px 0;"><strong>Nivel alcanzado:</strong> ${round}</p>
                            <p style="margin: 8px 0;"><strong>Perlas conseguidas:</strong> ${score}</p>
                            <p style="margin: 8px 0;"><strong>Mejor récord:</strong> ${best}</p>
                            <p style="margin: 8px 0;"><strong>Burbujas ganadas:</strong> +${bubbles}</p>
                            <p style="margin: 8px 0;"><strong>Estrellas ganadas:</strong> +${stars}</p>
                        </div>
                        
                        <div style="margin-top: 25px;">
                            <button class="restart-btn" style="
                                background: linear-gradient(135deg, #4CAF50, #45a049);
                                color: white;
                                border: none;
                                padding: 12px 24px;
                                border-radius: 25px;
                                font-size: 16px;
                                font-weight: bold;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
                            ">JUGAR DE NUEVO</button>
                        </div>
                    </div>
                `;
                
                gameOverlay.appendChild(endModal);
                
                // Event listeners
                endModal.querySelector('.restart-btn').addEventListener('click', () => {
                    endModal.remove();
                    initSimonGame();
                });
                
                endModal.querySelector('.close-btn').addEventListener('click', () => {
                    gameOverlay.remove();
                    document.getElementById('gamesModal').style.display = 'flex';
                });
            }
            
            function updateUI() {
                const levelEl = document.getElementById('simon-game-level'); // 🔧 ARREGLO: ID correcto
                const scoreEl = document.getElementById('simon-score');
                const bestEl = document.getElementById('simon-best');
                
                console.log('🎵 Simon: updateUI - Round:', round, 'Score:', score, 'Best:', best);
                
                if (levelEl) {
                    levelEl.textContent = round; // Mostrar nivel actual (ronda completada)
                    console.log('🎵 Simon: Nivel actualizado a:', round);
                } else {
                    console.log('🎵 Simon: ERROR - No se encontró simon-game-level');
                }
                if (scoreEl) scoreEl.textContent = score;
                if (bestEl) bestEl.textContent = best;
            }
            
            // Función para crear efecto de perlas volando al contador
            function createPearlEffect() {
                // Obtener posición del contador de perlas
                const pearlCounter = gameOverlay.querySelector('.perlas');
                if (!pearlCounter) return;
                
                const counterRect = pearlCounter.getBoundingClientRect();
                const targetX = counterRect.left + counterRect.width / 2;
                const targetY = counterRect.top + counterRect.height / 2;
                
                // Crear 3 perlas que vuelen al contador desde el centro del tablero
                const board = gameOverlay.querySelector('#simon-board');
                const boardRect = board.getBoundingClientRect();
                const startX = boardRect.left + boardRect.width / 2;
                const startY = boardRect.top + boardRect.height / 2;
                
                for (let i = 0; i < 3; i++) {
                    const pearl = document.createElement('div');
                    pearl.style.cssText = `
                        position: fixed;
                        left: ${startX + (i - 1) * 15}px;
                        top: ${startY + (i - 1) * 10}px;
                        width: 20px;
                        height: 20px;
                        background: url('images/ui/perlas.png') center/contain no-repeat;
                        pointer-events: none;
                        z-index: 99999;
                        animation: bubbleFly 1.2s ease-out forwards;
                    `;
                    
                    // Añadir keyframes para la animación
                    if (!document.getElementById('bubbleFlyKeyframes')) {
                        const style = document.createElement('style');
                        style.id = 'bubbleFlyKeyframes';
                        style.textContent = `
                            @keyframes bubbleFly {
                                0% {
                                    transform: scale(0.5) rotate(0deg);
                                    opacity: 1;
                                }
                                50% {
                                    transform: scale(1.2) rotate(180deg);
                                    opacity: 0.8;
                                }
                                100% {
                                    transform: scale(0.3) rotate(360deg);
                                    opacity: 0;
                                    left: ${targetX}px;
                                    top: ${targetY}px;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    document.body.appendChild(pearl);
                    setTimeout(() => pearl.remove(), 1200);
                }
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.game-close-btn');
            console.log('🎵 Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameOverlay.remove();
                    document.getElementById('gamesModal').style.display = 'flex';
                    console.log('🎵 Juego Simón Marino cerrado');
                });
            } else {
                console.error('🎵 ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#simon-start');
            console.log('🎵 Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initSimonGame();
                });
            } else {
                console.error('🎵 ERROR: No se encontró el botón JUGAR');
            }
            
            pads.forEach((pad, index) => {
                pad.addEventListener('click', () => handlePadClick(index));
            });
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🎵 Juego Simón Marino iniciado');
            console.log('🎵 Overlay visible:', gameOverlay.style.display);
            console.log('🎵 Overlay en DOM:', document.body.contains(gameOverlay));
            console.log('🎵 Overlay z-index:', gameOverlay.style.zIndex);
        }
        
        // 🐬 JUEGO DEL CARRIL DEL DELFÍN - INTEGRADO COMPLETO
        function startCarrilGame() {
            console.log('🐬 Iniciando juego Carril del Delfín integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            console.log('🐬 Modal de juegos cerrado');
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'carrilGameOverlay';
            gameOverlay.innerHTML = `
                <div class="carril-game-container">
                    <div class="carril-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🐬 Carril del Delfín</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="carril-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: ESTADÍSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Tiempo:</span>
                                    <span class="best-value" id="carril-time">60</span>s
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="carril-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Récord:</span>
                                    <span class="best-value" id="carril-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="carril-stage" id="carril-stage">
                        <div class="carril-lanes">
                            <div class="carril-lane" id="carril-lane-0"></div>
                            <div class="carril-lane" id="carril-lane-1"></div>
                            <div class="carril-lane" id="carril-lane-2"></div>
                        </div>
                    </div>
                    <div class="carril-footer">
                        <div class="carril-controls">
                            <button class="carril-move-btn" data-lane="0">◀ Izq</button>
                            <button class="carril-move-btn" data-lane="1">● Centro</button>
                            <button class="carril-move-btn" data-lane="2">Dcha ▶</button>
                        </div>
                        <button class="carril-btn" id="carril-start">▶️ Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'carril');
            console.log('🐬 Diseño aplicado');
            
            const stage = gameOverlay.querySelector('.carril-stage');
            stage.style.cssText = `
                flex: 1; position: relative; background: linear-gradient(#0a3d66, #0e5a92);
                border-radius: 14px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.15);
                margin: 10px;
            `;
            
            const lanes = gameOverlay.querySelector('.carril-lanes');
            lanes.style.cssText = `
                position: absolute; inset: 0; display: grid; grid-template-columns: repeat(3, 1fr);
                gap: 6px; padding: 6px;
            `;
            
            const laneElements = gameOverlay.querySelectorAll('.carril-lane');
            laneElements.forEach(lane => {
                lane.style.cssText = `
                    border-radius: 10px; background: rgba(255, 255, 255, 0.06);
                    position: relative; overflow: hidden;
                `;
            });
            
            // Variables del juego
            let gameActive = false, timeLeft = 60, score = 0, best = 0;
            let playerLane = 1, entities = [], gameLoop = null, spawnTimer = 0;
            
            // Cargar récord
            const savedBest = localStorage.getItem('carril-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCarrilGame() {
                gameActive = true;
                timeLeft = 60;
                score = 0;
                playerLane = 1;
                entities = [];
                spawnTimer = 0;
                updateUI();
                createPlayer();
                startGameLoop();
                startTimer();
            }
            
            function createPlayer() {
                const player = document.createElement('div');
                player.className = 'carril-player';
                player.innerHTML = '🐬';
                player.style.cssText = `
                    position: absolute; width: 50px; height: 50px; border-radius: 12px;
                    background: #5bd0ff; color: #072a44; font-size: 30px; font-weight: 900;
                    display: flex; align-items: center; justify-content: center;
                    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.22), 0 6px 12px rgba(0,0,0,0.35);
                    bottom: 20px; left: 50%; transform: translateX(-50%);
                    transition: all 0.2s ease;
                `;
                
                const currentLane = laneElements[playerLane];
                currentLane.appendChild(player);
            }
            
            function movePlayer(newLane) {
                if (!gameActive || newLane === playerLane) return;
                
                // Remover jugador del carril actual
                const oldPlayer = laneElements[playerLane].querySelector('.carril-player');
                if (oldPlayer) oldPlayer.remove();
                
                // Cambiar carril
                playerLane = newLane;
                createPlayer();
            }
            
            function spawnEntity() {
                const lane = Math.floor(Math.random() * 3);
                const isGood = Math.random() < 0.3; // 30% bueno, 70% malo
                
                const entity = document.createElement('div');
                entity.className = isGood ? 'carril-good' : 'carril-bad';
                entity.innerHTML = isGood ? '⭐' : '💥';
                entity.style.cssText = `
                    position: absolute; width: 50px; height: 50px; border-radius: 12px;
                    background: ${isGood ? '#ff9a3c' : '#ff7a6e'}; color: #072a44;
                    font-size: 30px; font-weight: 900; display: flex; align-items: center; justify-content: center;
                    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.22), 0 6px 12px rgba(0,0,0,0.35);
                    top: -60px; left: 50%; transform: translateX(-50%);
                `;
                
                entity.dataset.lane = lane;
                entity.dataset.good = isGood;
                entity.dataset.y = -60;
                
                laneElements[lane].appendChild(entity);
                entities.push(entity);
            }
            
            function updateEntities() {
                for (let i = entities.length - 1; i >= 0; i--) {
                    const entity = entities[i];
                    let y = parseInt(entity.dataset.y);
                    y += 4; // Velocidad de caída
                    entity.dataset.y = y;
                    entity.style.top = y + 'px';
                    
                    // Verificar colisión con jugador
                    const entityLane = parseInt(entity.dataset.lane);
                    if (entityLane === playerLane && y > stage.offsetHeight - 120 && y < stage.offsetHeight - 60) {
                        // Colisión!
                        const isGood = entity.dataset.good === 'true';
                        if (isGood) {
                            score += 10;
                            // Efecto visual positivo
                            entity.style.background = '#1bb37a';
                            entity.innerHTML = '✨';
                        } else {
                            // Game over
                            gameOver();
                            return;
                        }
                        
                        // Remover entidad
                        entity.remove();
                        entities.splice(i, 1);
                        updateUI();
                    }
                    // Remover si sale de pantalla
                    else if (y > stage.offsetHeight + 60) {
                        entity.remove();
                        entities.splice(i, 1);
                    }
                }
            }
            
            function startGameLoop() {
                gameLoop = setInterval(() => {
                    if (!gameActive) return;
                    
                    updateEntities();
                    
                    // Spawn nuevas entidades
                    spawnTimer++;
                    if (spawnTimer >= 30) { // Cada ~500ms
                        spawnEntity();
                        spawnTimer = 0;
                    }
                }, 16); // ~60fps
            }
            
            function startTimer() {
                const timer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(timer);
                        return;
                    }
                    
                    timeLeft--;
                    updateUI();
                    
                    if (timeLeft <= 0) {
                        clearInterval(timer);
                        gameOver();
                    }
                }, 1000);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameLoop) clearInterval(gameLoop);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('carril-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 3);  // Más burbujas
                const stars = Math.floor(score / 8);    // Más estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`🐬 ¡Fin de partida!\\n🌊 Puntuación: ${score}\\n🏆 Récord: ${best}\\n🫧 +${bubbles} burbujas\\n⭐ +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('carril-time').textContent = timeLeft;
                document.getElementById('carril-score').textContent = score;
                document.getElementById('carril-best').textContent = best;
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.carril-close-btn');
            console.log('🐬 Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                    console.log('🐬 Juego Carril del Delfín cerrado');
                });
            } else {
                console.error('🐬 ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#carril-start');
            console.log('🐬 Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCarrilGame();
                });
            } else {
                console.error('🐬 ERROR: No se encontró el botón JUGAR');
            }
            
            // Controles de movimiento
            gameOverlay.querySelectorAll('.carril-move-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const lane = parseInt(btn.dataset.lane);
                    movePlayer(lane);
                });
            });
            
            // Controles de teclado
            document.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer(Math.max(0, playerLane - 1));
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer(Math.min(2, playerLane + 1));
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer(1); // Centro
                        break;
                }
            });
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🐬 Juego Carril del Delfín iniciado');
            console.log('🐬 Overlay visible:', gameOverlay.style.display);
            console.log('🐬 Overlay en DOM:', document.body.contains(gameOverlay));
            console.log('🐬 Overlay z-index:', gameOverlay.style.zIndex);
        }
        
        // 🐉 JUEGO DEL DRAGÓN MARINO - INTEGRADO BÁSICO
        function startCorrerGame() {
            console.log('🐉 Iniciando juego Dragón Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'correrGameOverlay';
            gameOverlay.innerHTML = `
                <div class="correr-game-container">
                    <div class="correr-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🐉 Dragón Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="correr-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: ESTADÍSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="correr-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Récord:</span>
                                    <span class="best-value" id="correr-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="correr-stage">
                        <canvas id="correr-canvas" width="400" height="300"></canvas>
                        <div class="correr-hint">Toca o pulsa ESPACIO para saltar</div>
                    </div>
                    <div class="correr-footer">
                        <button class="correr-btn" id="correr-jump">⬆️ Saltar</button>
                        <button class="correr-btn" id="correr-start">▶️ Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'correr');
            
            const stage = gameOverlay.querySelector('.correr-stage');
            stage.style.cssText = `
                flex: 1; position: relative; background: linear-gradient(#083457, #0b4e7b);
                border-radius: 14px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.15);
                margin: 10px; display: flex; align-items: center; justify-content: center;
            `;
            
            const canvas = gameOverlay.querySelector('#correr-canvas');
            canvas.style.cssText = `
                border-radius: 10px; background: linear-gradient(#083457, #0b4e7b);
                max-width: 100%; max-height: 100%;
            `;
            
            const hint = gameOverlay.querySelector('.correr-hint');
            hint.style.cssText = `
                position: absolute; bottom: 8px; left: 0; right: 0; text-align: center;
                opacity: 0.7; font-size: 14px;
            `;
            
            // Variables del juego
            let gameActive = false, score = 0, best = 0;
            let player = { x: 50, y: 200, vy: 0, grounded: true, size: 30 };
            let obstacles = [], gameSpeed = 2, spawnTimer = 0;
            let gameLoop = null, ctx = canvas.getContext('2d');
            
            // Cargar récord
            const savedBest = localStorage.getItem('correr-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCorrerGame() {
                gameActive = true;
                score = 0;
                gameSpeed = 2;
                spawnTimer = 0;
                obstacles = [];
                player = { x: 50, y: 200, vy: 0, grounded: true, size: 30 };
                updateUI();
                startGameLoop();
            }
            
            function jump() {
                if (gameActive && player.grounded) {
                    player.vy = -12;
                    player.grounded = false;
                }
            }
            
            function updateGame() {
                if (!gameActive) return;
                
                // Física del jugador
                player.vy += 0.6; // Gravedad
                player.y += player.vy;
                
                // Suelo
                if (player.y >= 200) {
                    player.y = 200;
                    player.vy = 0;
                    player.grounded = true;
                }
                
                // Spawn obstáculos
                spawnTimer++;
                if (spawnTimer >= 120) { // Cada ~2 segundos
                    obstacles.push({
                        x: canvas.width,
                        y: 200,
                        width: 20,
                        height: 40,
                        passed: false
                    });
                    spawnTimer = 0;
                }
                
                // Actualizar obstáculos
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    obs.x -= gameSpeed;
                    
                    // Colisión
                    if (obs.x < player.x + player.size && 
                        obs.x + obs.width > player.x &&
                        obs.y < player.y + player.size && 
                        obs.y + obs.height > player.y) {
                        gameOver();
                        return;
                    }
                    
                    // Puntuación
                    if (!obs.passed && obs.x + obs.width < player.x) {
                        obs.passed = true;
                        score += 10;
                        updateUI();
                    }
                    
                    // Remover si sale de pantalla
                    if (obs.x + obs.width < 0) {
                        obstacles.splice(i, 1);
                    }
                }
                
                // Aumentar velocidad gradualmente
                gameSpeed += 0.001;
            }
            
            function drawGame() {
                // Limpiar canvas
                ctx.fillStyle = '#083457';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar suelo
                ctx.fillStyle = '#0d4670';
                ctx.fillRect(0, 230, canvas.width, 70);
                
                // Dibujar jugador (dragón)
                ctx.fillStyle = '#5bd0ff';
                ctx.fillRect(player.x, player.y, player.size, player.size);
                ctx.fillStyle = '#072a44';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🐉', player.x + player.size/2, player.y + player.size/2 + 7);
                
                // Dibujar obstáculos
                ctx.fillStyle = '#ff7a6e';
                obstacles.forEach(obs => {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.fillStyle = '#072a44';
                    ctx.fillText('🪨', obs.x + obs.width/2, obs.y + obs.height/2 + 7);
                    ctx.fillStyle = '#ff7a6e';
                });
            }
            
            function startGameLoop() {
                gameLoop = setInterval(() => {
                    updateGame();
                    drawGame();
                }, 16); // ~60fps
            }
            
            function gameOver() {
                gameActive = false;
                if (gameLoop) clearInterval(gameLoop);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('correr-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 6);  // Más burbujas
                const stars = Math.floor(score / 12);   // Más estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`🐉 ¡Fin de partida!\\n🌊 Puntuación: ${score}\\n🏆 Récord: ${best}\\n🫧 +${bubbles} burbujas\\n⭐ +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('correr-score').textContent = score;
                document.getElementById('correr-best').textContent = best;
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.correr-close-btn');
            console.log('🐉 Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    gameOverlay.remove();
                    console.log('🐉 Juego Dragón Marino cerrado');
                });
            } else {
                console.error('🐉 ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#correr-start');
            console.log('🐉 Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCorrerGame();
                });
            } else {
                console.error('🐉 ERROR: No se encontró el botón JUGAR');
            }
            
            const jumpBtn = gameOverlay.querySelector('#correr-jump');
            console.log('🐉 Botón SALTAR encontrado:', jumpBtn);
            if (jumpBtn) {
                jumpBtn.addEventListener('click', jump);
            } else {
                console.error('🐉 ERROR: No se encontró el botón SALTAR');
            }
            
            // Controles de teclado
            const keyHandler = (e) => {
                if (!gameActive) return;
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    jump();
                }
            };
            document.addEventListener('keydown', keyHandler);
            
            // Canvas click para saltar
            canvas.addEventListener('click', jump);
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameLoop) clearInterval(gameLoop);
                    document.removeEventListener('keydown', keyHandler);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🐉 Juego Dragón Marino iniciado');
        }
        
        // 🎯 JUEGO DE CAZA DE PECES - INTEGRADO COMPLETO
        function startCazaGame() {
            console.log('🎯 Iniciando juego Caza de Peces integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'cazaGameOverlay';
            gameOverlay.innerHTML = `
                <div class="caza-game-container">
                    <div class="caza-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🎯 Caza de Peces</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="caza-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: ESTADÍSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="caza-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Ronda:</span>
                                    <span class="best-value" id="caza-round">1</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Récord:</span>
                                    <span class="best-value" id="caza-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="caza-game-area">
                        <div class="caza-timebar">
                            <div class="caza-fill" id="caza-fill"></div>
                            <div class="caza-tick" id="caza-tick">100%</div>
                        </div>
                        <div class="caza-main">
                            <div class="caza-objective">
                                Objetivo: <span class="caza-token" id="caza-obj-token">
                                    <span id="caza-obj-emoji">🐟</span>
                                </span>
                            </div>
                            <div class="caza-board" id="caza-board"></div>
                        </div>
                    </div>
                    <div class="caza-footer">
                        <button class="caza-btn" id="caza-start">▶️ Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'caza');
            
            const gameArea = gameOverlay.querySelector('.caza-game-area');
            gameArea.style.cssText = `
                flex: 1; display: flex; gap: 10px; padding: 10px;
            `;
            
            const timebar = gameOverlay.querySelector('.caza-timebar');
            timebar.style.cssText = `
                width: 32px; background: #0a2f4f; border-radius: 8px; overflow: hidden;
                position: relative; border: 1px solid rgba(255, 255, 255, 0.18);
            `;
            
            const fill = gameOverlay.querySelector('.caza-fill');
            fill.style.cssText = `
                position: absolute; bottom: 0; left: 0; right: 0; height: 100%;
                background: linear-gradient(#25c3ea, #0ea5c6); transition: height 0.18s ease;
            `;
            
            const main = gameOverlay.querySelector('.caza-main');
            main.style.cssText = `
                flex: 1; display: flex; flex-direction: column; gap: 10px;
            `;
            
            const objective = gameOverlay.querySelector('.caza-objective');
            objective.style.cssText = `
                display: flex; align-items: center; gap: 8px; padding: 8px;
                background: rgba(255, 255, 255, 0.06); border-radius: 12px; font-weight: 800;
            `;
            
            const objToken = gameOverlay.querySelector('.caza-token');
            objToken.style.cssText = `
                width: 32px; height: 32px; border-radius: 50%; display: flex;
                align-items: center; justify-content: center; font-size: 20px;
                background: #e9d8a6;
            `;
            
            const board = gameOverlay.querySelector('.caza-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(6, 1fr); gap: 4px; background: transparent;
            `;
            
            // Variables del juego
            const EMOJIS = ["🐟", "⭐", "🐙", "🪸", "🦀"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, round = 1, best = 0;
            let timeLeft = 100, currentTarget = 0, gameTimer = null;
            
            // Cargar récord
            const savedBest = localStorage.getItem('caza-best');
            if (savedBest) best = parseInt(savedBest);
            
            // Funciones del juego
            function initCazaGame() {
                gameActive = true;
                score = 0;
                round = 1;
                timeLeft = 100;
                currentTarget = Math.floor(Math.random() * EMOJIS.length);
                updateUI();
                createBoard();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                
                // Crear 36 celdas (6x6)
                for (let i = 0; i < 36; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'caza-cell';
                    
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    cell.innerHTML = `
                        <div class="caza-token" data-type="${tokenType}">
                            ${EMOJIS[tokenType]}
                        </div>
                    `;
                    
                    cell.style.cssText = `
                        position: relative; display: flex; align-items: center; justify-content: center;
                        cursor: pointer; aspect-ratio: 1; background: transparent;
                    `;
                    
                    const token = cell.querySelector('.caza-token');
                    token.style.cssText = `
                        width: 100%; height: 100%; border-radius: 50%; display: flex;
                        align-items: center; justify-content: center; font-size: 20px;
                        background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    `;
                    
                    cell.addEventListener('click', () => handleClick(tokenType, token));
                    board.appendChild(cell);
                }
                
                // Asegurar que hay al menos 3 del tipo objetivo
                const targetCells = board.querySelectorAll(`[data-type="${currentTarget}"]`);
                if (targetCells.length < 3) {
                    for (let i = 0; i < 3; i++) {
                        const randomCell = board.children[Math.floor(Math.random() * 36)];
                        const token = randomCell.querySelector('.caza-token');
                        token.dataset.type = currentTarget;
                        token.innerHTML = EMOJIS[currentTarget];
                        token.style.background = COLORS[currentTarget];
                    }
                }
            }
            
            function handleClick(tokenType, tokenElement) {
                if (!gameActive) return;
                
                if (tokenType === currentTarget) {
                    // Correcto!
                    score += 10;
                    tokenElement.style.boxShadow = '0 0 12px rgba(27, 179, 122, 0.6)';
                    tokenElement.style.transform = 'scale(0.8)';
                    tokenElement.style.opacity = '0.3';
                    
                    // Verificar si quedan más objetivos
                    setTimeout(() => {
                        const remaining = board.querySelectorAll(`[data-type="${currentTarget}"]`).length - 1;
                        if (remaining <= 0) {
                            nextRound();
                        }
                    }, 100);
                    
                } else {
                    // Incorrecto
                    tokenElement.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    tokenElement.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        tokenElement.style.transform = 'scale(1)';
                        tokenElement.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                    }, 200);
                    
                    // Penalizar tiempo
                    timeLeft -= 5;
                    if (timeLeft <= 0) {
                        gameOver();
                    }
                }
                
                updateUI();
            }
            
            function nextRound() {
                round++;
                currentTarget = Math.floor(Math.random() * EMOJIS.length);
                timeLeft = Math.min(100, timeLeft + 15); // Bonus tiempo
                createBoard();
                updateUI();
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    
                    timeLeft -= 0.5;
                    if (timeLeft <= 0) {
                        gameOver();
                    }
                    updateUI();
                }, 50); // Actualización suave
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('caza-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 5);  // Más burbujas
                const stars = Math.floor(score / 10);   // Más estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`🎯 ¡Fin de caza!\\n🌊 Puntuación: ${score}\\n🏆 Récord: ${best}\\n🫧 +${bubbles} burbujas\\n⭐ +${stars} estrellas`);
                }, 300);
                
                updateUI();
            }
            
            function updateUI() {
                document.getElementById('caza-score').textContent = score;
                document.getElementById('caza-round').textContent = round;
                document.getElementById('caza-best').textContent = best;
                document.getElementById('caza-obj-emoji').textContent = EMOJIS[currentTarget];
                document.getElementById('caza-obj-token').style.background = COLORS[currentTarget];
                document.getElementById('caza-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('caza-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.caza-close-btn');
            console.log('🎯 Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('🎯 Juego Caza de Peces cerrado');
                });
            } else {
                console.error('🎯 ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#caza-start');
            console.log('🎯 Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initCazaGame();
                });
            } else {
                console.error('🎯 ERROR: No se encontró el botón JUGAR');
            }
            
            gameOverlay.addEventListener('click', (e) => {
                if (e.target === gameOverlay) {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                }
            });
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🎯 Juego Caza de Peces iniciado');
        }
        
        // 🌊 JUEGO DE SECUENCIA DE MAREAS - INTEGRADO COMPLETO
        function startSecuenciaGame() {
            console.log('🌊 Iniciando juego Secuencia de Mareas integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'secuenciaGameOverlay';
            gameOverlay.innerHTML = `
                <div class="secuencia-game-container">
                    <div class="secuencia-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🌊 Secuencia de Mareas</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="secuencia-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: ESTADÍSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Ronda:</span>
                                    <span class="best-value" id="secuencia-round">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="secuencia-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Récord:</span>
                                    <span class="best-value" id="secuencia-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="secuencia-game-area">
                        <div class="secuencia-timebar">
                            <div class="secuencia-fill" id="secuencia-fill"></div>
                            <div class="secuencia-tick" id="secuencia-tick">100%</div>
                        </div>
                        <div class="secuencia-main">
                            <div class="secuencia-hint" id="secuencia-hint">Mira la secuencia...</div>
                            <div class="secuencia-board" id="secuencia-board"></div>
                        </div>
                    </div>
                    <div class="secuencia-footer">
                        <button class="secuencia-btn" id="secuencia-start">▶️ Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'secuencia');
            
            const gameArea = gameOverlay.querySelector('.secuencia-game-area');
            gameArea.style.cssText = `flex: 1; display: flex; gap: 10px; padding: 10px;`;
            
            const board = gameOverlay.querySelector('.secuencia-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(4, 1fr); gap: 6px; background: transparent;
            `;
            
            // Variables del juego - versión simplificada
            const EMOJIS = ["🐟", "⭐", "🐙", "🪸", "🦀"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, round = 0, best = 0;
            let sequence = [], playerInput = [], timeLeft = 100;
            let showingSequence = false, gameTimer = null;
            
            // Cargar récord
            const savedBest = localStorage.getItem('secuencia-best');
            if (savedBest) best = parseInt(savedBest);
            
            function initSecuenciaGame() {
                gameActive = true;
                score = 0;
                round = 0;
                timeLeft = 100;
                sequence = [];
                playerInput = [];
                showingSequence = false;
                updateUI();
                createBoard();
                nextRound();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    cell.innerHTML = `<div class="secuencia-token" data-type="${tokenType}" data-index="${i}">${EMOJIS[tokenType]}</div>`;
                    cell.style.cssText = `
                        display: flex; align-items: center; justify-content: center; cursor: pointer;
                        aspect-ratio: 1; background: transparent;
                    `;
                    const token = cell.querySelector('.secuencia-token');
                    token.style.cssText = `
                        width: 100%; height: 100%; border-radius: 50%; display: flex;
                        align-items: center; justify-content: center; font-size: 24px;
                        background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    `;
                    cell.addEventListener('click', () => handleTokenClick(i));
                    board.appendChild(cell);
                }
            }
            
            function nextRound() {
                round++;
                const randomIndex = Math.floor(Math.random() * 16);
                sequence.push(randomIndex);
                playerInput = [];
                document.getElementById('secuencia-hint').textContent = 'Mira la secuencia...';
                showSequence();
            }
            
            function showSequence() {
                showingSequence = true;
                let i = 0;
                const showNext = () => {
                    if (i < sequence.length) {
                        const token = board.children[sequence[i]].querySelector('.secuencia-token');
                        token.style.boxShadow = '0 0 20px rgba(255,255,255,0.8)';
                        token.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            token.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                            token.style.transform = 'scale(1)';
                            i++;
                            setTimeout(showNext, 300);
                        }, 500);
                    } else {
                        showingSequence = false;
                        document.getElementById('secuencia-hint').textContent = '¡Repite la secuencia!';
                    }
                };
                setTimeout(showNext, 800);
            }
            
            function handleTokenClick(index) {
                if (!gameActive || showingSequence) return;
                
                playerInput.push(index);
                const token = board.children[index].querySelector('.secuencia-token');
                
                // Verificar si es correcto
                const currentStep = playerInput.length - 1;
                if (playerInput[currentStep] === sequence[currentStep]) {
                    // Correcto
                    token.style.boxShadow = '0 0 12px rgba(27, 179, 122, 0.6)';
                    score += 5;
                    
                    if (playerInput.length === sequence.length) {
                        // Secuencia completa
                        setTimeout(() => {
                            nextRound();
                        }, 800);
                    }
                } else {
                    // Error
                    token.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    gameOver();
                }
                
                updateUI();
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    timeLeft -= 0.3;
                    if (timeLeft <= 0) gameOver();
                    updateUI();
                }, 50);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('secuencia-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 4);  // Más burbujas
                const stars = Math.floor(score / 8);    // Más estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`🌊 ¡Fin de secuencia!\\n🌊 Ronda: ${round}\\n🏆 Récord: ${best}\\n🫧 +${bubbles} burbujas\\n⭐ +${stars} estrellas`);
                }, 300);
            }
            
            function updateUI() {
                document.getElementById('secuencia-round').textContent = round;
                document.getElementById('secuencia-score').textContent = score;
                document.getElementById('secuencia-best').textContent = best;
                document.getElementById('secuencia-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('secuencia-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.secuencia-close-btn');
            console.log('🌊 Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('🌊 Juego Secuencia de Mareas cerrado');
                });
            } else {
                console.error('🌊 ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#secuencia-start');
            console.log('🌊 Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initSecuenciaGame();
                });
            } else {
                console.error('🌊 ERROR: No se encontró el botón JUGAR');
            }
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🌊 Juego Secuencia de Mareas iniciado');
        }
        
        // 🏖️ JUEGO DE TOCA-3 MARINO - INTEGRADO COMPLETO
        function startToca3Game() {
            console.log('🏖️ Iniciando juego Toca-3 Marino integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear overlay del juego
            const gameOverlay = document.createElement('div');
            gameOverlay.id = 'toca3GameOverlay';
            gameOverlay.innerHTML = `
                <div class="toca3-game-container">
                    <div class="toca3-game-header">
                        <!-- PRIMERA LÍNEA: TÍTULO + ALTAVOZ + X -->
                        <div class="header-top">
                            <div class="game-title">🏖️ Toca-3 Marino</div>
                            <div class="header-controls">
                                <button class="sound-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">
                                    <img src="images/ui/sonidoOn.png" style="width: 20px; height: 20px;">
                                </button>
                                <button class="toca3-close-btn" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 2px solid rgba(255, 255, 255, 0.8);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    color: white;
                                    font-size: 18px;
                                    font-weight: bold;
                                ">✕</button>
                            </div>
                        </div>
                        <!-- SEGUNDA LÍNEA: ESTADÍSTICAS -->
                        <div class="header-bottom">
                            <div class="game-stats">
                                <div class="best-score-display">
                                    <span class="best-label">Puntos:</span>
                                    <span class="best-value" id="toca3-score">0</span>
                                </div>
                                <div class="best-score-display">
                                    <span class="best-label">Récord:</span>
                                    <span class="best-value" id="toca3-best">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="toca3-game-area">
                        <div class="toca3-timebar">
                            <div class="toca3-fill" id="toca3-fill"></div>
                            <div class="toca3-tick" id="toca3-tick">100%</div>
                        </div>
                        <div class="toca3-main">
                            <div class="toca3-board" id="toca3-board"></div>
                        </div>
                    </div>
                    <div class="toca3-footer">
                        <button class="toca3-btn" id="toca3-start">▶️ Empezar</button>
                    </div>
                </div>
            `;
            
            // Aplicar diseño perfecto unificado (igual que Burbujas)
            applyPerfectUnifiedDesign(gameOverlay, 'toca3');
            
            const board = gameOverlay.querySelector('.toca3-board');
            board.style.cssText = `
                flex: 1; display: grid; grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(8, 1fr); gap: 4px; background: transparent; padding: 10px;
            `;
            
            // Variables del juego - versión simplificada de match-3
            const EMOJIS = ["🐟", "⭐", "🐙", "🪸", "🦀"];
            const COLORS = ["#e9d8a6", "#0b5cab", "#5a4d8a", "#20c5c9", "#2a9d65"];
            let gameActive = false, score = 0, best = 0, timeLeft = 100;
            let grid = [], selectedCells = [], gameTimer = null;
            
            // Cargar récord
            const savedBest = localStorage.getItem('toca3-best');
            if (savedBest) best = parseInt(savedBest);
            
            function initToca3Game() {
                gameActive = true;
                score = 0;
                timeLeft = 100;
                selectedCells = [];
                grid = [];
                updateUI();
                createBoard();
                startTimer();
            }
            
            function createBoard() {
                board.innerHTML = '';
                grid = [];
                
                // Crear tablero 6x8
                for (let r = 0; r < 8; r++) {
                    grid[r] = [];
                    for (let c = 0; c < 6; c++) {
                        const tokenType = Math.floor(Math.random() * EMOJIS.length);
                        const cell = document.createElement('div');
                        cell.innerHTML = `<div class="toca3-token" data-type="${tokenType}" data-r="${r}" data-c="${c}">${EMOJIS[tokenType]}</div>`;
                        cell.style.cssText = `
                            display: flex; align-items: center; justify-content: center; cursor: pointer;
                            aspect-ratio: 1; background: transparent;
                        `;
                        const token = cell.querySelector('.toca3-token');
                        token.style.cssText = `
                            width: 100%; height: 100%; border-radius: 50%; display: flex;
                            align-items: center; justify-content: center; font-size: 18px;
                            background: ${COLORS[tokenType]}; transition: all 0.12s ease;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                        
                        cell.addEventListener('click', () => handleCellClick(r, c, tokenType, token));
                        board.appendChild(cell);
                        grid[r][c] = { type: tokenType, element: token };
                    }
                }
            }
            
            function handleCellClick(r, c, type, token) {
                if (!gameActive) return;
                
                const cellKey = `${r}-${c}`;
                const index = selectedCells.findIndex(cell => cell.key === cellKey);
                
                if (index >= 0) {
                    // Deseleccionar
                    selectedCells.splice(index, 1);
                    token.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                    token.style.transform = 'scale(1)';
                } else if (selectedCells.length < 3) {
                    // Seleccionar
                    selectedCells.push({ key: cellKey, r, c, type, token });
                    token.style.boxShadow = '0 0 12px rgba(255,255,255,0.6)';
                    token.style.transform = 'scale(1.1)';
                    
                    if (selectedCells.length === 3) {
                        checkMatch();
                    }
                }
            }
            
            function checkMatch() {
                const types = selectedCells.map(cell => cell.type);
                const allSame = types.every(type => type === types[0]);
                
                if (allSame) {
                    // Match correcto!
                    score += 15;
                    
                    // 🎮 DAR DIVERSIÓN INMEDIATA POR CADA LÍNEA COMPLETADA
                    if (window.game && window.game.gameState) {
                        const funIncrease = 2; // +2 diversión por cada línea completada
                        window.game.gameState.needs.fun = Math.min(100, window.game.gameState.needs.fun + funIncrease);
                        window.game.needsSystem.updateCrisisFlags();
                        window.game.needsSystem.updateNeedBars();
                        console.log(`🎮 +${funIncrease} diversión por completar línea (total: ${score} puntos)`);
                    }
                    
                    selectedCells.forEach(cell => {
                        cell.token.style.background = '#1bb37a';
                        cell.token.innerHTML = '✨';
                        cell.token.style.transform = 'scale(0.8)';
                        cell.token.style.opacity = '0.7';
                    });
                    
                    setTimeout(() => {
                        // Remover tokens matched y hacer caer los de arriba
                        selectedCells.forEach(cell => {
                            fillFromTop(cell.c);
                        });
                        selectedCells = [];
                        timeLeft += 5; // Bonus tiempo
                    }, 500);
                    
                } else {
                    // No match
                    selectedCells.forEach(cell => {
                        cell.token.style.boxShadow = '0 0 12px rgba(240, 68, 56, 0.6)';
                    });
                    
                    setTimeout(() => {
                        selectedCells.forEach(cell => {
                            cell.token.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            cell.token.style.transform = 'scale(1)';
                        });
                        selectedCells = [];
                    }, 400);
                    
                    timeLeft -= 3; // Penalización
                }
                
                updateUI();
            }
            
            function fillFromTop(col) {
                // Simplificado: regenerar columna
                for (let r = 0; r < 8; r++) {
                    const tokenType = Math.floor(Math.random() * EMOJIS.length);
                    const cell = board.children[r * 6 + col];
                    const token = cell.querySelector('.toca3-token');
                    token.innerHTML = EMOJIS[tokenType];
                    token.style.background = COLORS[tokenType];
                    token.dataset.type = tokenType;
                    grid[r][col] = { type: tokenType, element: token };
                }
            }
            
            function startTimer() {
                gameTimer = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(gameTimer);
                        return;
                    }
                    timeLeft -= 0.2;
                    if (timeLeft <= 0) gameOver();
                    updateUI();
                }, 50);
            }
            
            function gameOver() {
                gameActive = false;
                if (gameTimer) clearInterval(gameTimer);
                
                if (score > best) {
                    best = score;
                    localStorage.setItem('toca3-best', best.toString());
                }
                
                // Dar recompensas
                const bubbles = Math.floor(score / 5);  // Más burbujas
                const stars = Math.floor(score / 10);   // Más estrellas
                
                if (window.game && bubbles > 0) {
                    window.game.gameState.bubbles += bubbles;
                    window.game.gameState.stars += stars;
                    window.game.saveGame();
                    
                    // 🎆 ANIMACIÓN ESPECIAL SI ES RECOMPENSA EXTRA
                    window.game.createRewardAnimation(stars, bubbles);
                }
                
                setTimeout(() => {
                    alert(`🏖️ ¡Fin del juego!\\n🌊 Puntuación: ${score}\\n🏆 Récord: ${best}\\n🫧 +${bubbles} burbujas\\n⭐ +${stars} estrellas`);
                }, 300);
            }
            
            function updateUI() {
                document.getElementById('toca3-score').textContent = score;
                document.getElementById('toca3-best').textContent = best;
                document.getElementById('toca3-fill').style.height = Math.max(0, timeLeft) + '%';
                document.getElementById('toca3-tick').textContent = Math.floor(timeLeft) + '%';
            }
            
            // Event listeners
            const closeBtn = gameOverlay.querySelector('.toca3-close-btn');
            console.log('🏖️ Botón cerrar encontrado:', closeBtn);
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    gameActive = false;
                    if (gameTimer) clearInterval(gameTimer);
                    gameOverlay.remove();
                    console.log('🏖️ Juego Toca-3 Marino cerrado');
                });
            } else {
                console.error('🏖️ ERROR: No se encontró el botón de cerrar');
            }
            
            const startBtn = gameOverlay.querySelector('#toca3-start');
            console.log('🏖️ Botón JUGAR encontrado:', startBtn);
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    initToca3Game();
                });
            } else {
                console.error('🏖️ ERROR: No se encontró el botón JUGAR');
            }
            
            document.body.appendChild(gameOverlay);
            updateUI();
            console.log('🏖️ Juego Toca-3 Marino iniciado');
        }
        
        // 🎨 FUNCIÓN AUXILIAR PARA APLICAR ESTILOS A IFRAMES DE JUEGOS
        function applyGameIframeStyles(gameModal) {
            gameModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, 
                    rgba(25, 30, 40, 0.9) 0%, 
                    rgba(15, 20, 30, 0.95) 100%);
                backdrop-filter: blur(15px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.3s ease;
            `;
            
            const container = gameModal.querySelector('.game-iframe-container');
            container.style.cssText = `
                background: rgba(35, 40, 50, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                width: 95vw;
                height: 95vh;
                max-width: 800px;
                max-height: 700px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            `;
            
            const header = gameModal.querySelector('.game-iframe-header');
            header.style.cssText = `
                background: rgba(79, 195, 247, 0.2);
                padding: 15px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            `;
            
            const title = header.querySelector('h2');
            title.style.cssText = `
                color: white;
                margin: 0;
                font-size: 20px;
                font-weight: 800;
            `;
            
            const closeBtn = gameModal.querySelector('.game-close-btn');
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                color: white;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            `;
            
            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                closeBtn.style.transform = 'scale(1.1)';
            });
            
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                closeBtn.style.transform = 'scale(1)';
            });
            
            const iframe = gameModal.querySelector('.game-iframe');
            iframe.style.cssText = `
                flex: 1;
                border: none;
                width: 100%;
                background: white;
            `;
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                gameModal.remove();
            });
            
            gameModal.addEventListener('click', (e) => {
                if (e.target === gameModal) {
                    gameModal.remove();
                }
            });
        }
    </script>
    
    <!-- 🐠 SISTEMAS REFACTORIZADOS -->
    <script src="fish-system.js"></script>
    <script src="needs-system.js"></script>
    
    <script>
        // 🫧 FUNCIONES DE BURBUJAS Y CORAZONES
        if (window.CompleteGame) {
            CompleteGame.prototype.updateTinyBubbles = function(deltaTime) {
                // Actualizar burbujas de respiración
                for (const b of this.tinyBubbles) {
                    b.y -= b.vy * deltaTime;
                    b.x += Math.sin((this.state?.time || Date.now() * 0.001) * b.wobSpd + b.wob) * b.wobAmp * deltaTime;
                    b.life -= deltaTime;
                    b.a = Math.max(0, b.life / 1.2);
                }
                
                // Eliminar burbujas muertas
                for (let i = this.tinyBubbles.length - 1; i >= 0; i--) {
                    const b = this.tinyBubbles[i];
                    if (b.life <= 0 || b.y < -12) {
                        this.tinyBubbles.splice(i, 1);
                    }
                }
            };
            
            CompleteGame.prototype.updateFlyers = function(deltaTime) {
                if (!this.flyers) this.flyers = [];
                
                // Actualizar progreso de corazones
                for (const f of this.flyers) {
                    f.t += deltaTime / f.dur;
                }
                
                // Purgar completados y dar diversión
                for (let i = this.flyers.length - 1; i >= 0; i--) {
                    const f = this.flyers[i];
                    if (f.t >= 1) {
                        if (!f.given) {
                            // SUMAR DIVERSIÓN +25
                            this.gameState.needs.fun = Math.min(100, this.gameState.needs.fun + 25);
                            this.needsSystem.updateNeedBars();
                            f.given = true;
                        }
                        this.flyers.splice(i, 1);
                    }
                }
            };
        }
    </script>
</body>
</html>



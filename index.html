<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üê† Mi Pececito - Tamagotchi Virtual</title>
    
    <!-- üé® CSS INTEGRADO PARA EVITAR PROBLEMAS DE CARGA -->
    
    <style>
        /* üé® VARIABLES CSS GLOBALES */
        :root {
          --bg-primary: #08243a;
          --bg-secondary: #1d4b6b;
          --bg-accent: #2a6287;
          --text-primary: #e9f6ff;
          --text-secondary: rgba(233, 246, 255, 0.8);
          --fish-baby-body: #d9ccff;
          --fish-baby-tail: #ff9ecf;
          --fish-baby-fin: #ffd0e2;
          --fish-baby-stripe: #ffba7a;
          --fish-young-body: #b1a1ff;
          --fish-young-tail: #f191cd;
          --fish-young-fin: #f1c4e4;
          --fish-young-stripe: #ffa960;
          --fish-adult-body: #5a48c8;
          --fish-adult-tail: #d073c6;
          --fish-adult-fin: #e2a8d6;
          --fish-adult-stripe: #ff9745;
          --button-primary: #205b86;
          --button-hover: #2a6287;
          --button-active: #1a4a73;
          --button-radius: 12px;
          --button-size: 80px;
          --badge-size: 64px;
          --bubble-size: 48px;
          --good-item: #4CAF50;
          --bad-item: #F44336;
          --star-color: #FFD700;
          --coin-color: #FF8C42;
          --fish-baby-size: 46px;
          --fish-young-size: 52px;
          --fish-adult-size: 60px;
            --egg-size: 130px; /* Tama√±o ajustado para m√≥vil */
          --pellet-size: 16px;
          --star-size: 32px;
          --transition-fast: 0.15s ease;
          --transition-smooth: 0.3s ease;
          --transition-slow: 0.6s ease;
          --bounce-animation: cubic-bezier(0.68, -0.55, 0.265, 1.55);
          --mobile-padding: 12px;
          --desktop-padding: 20px;
          --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.25);
          --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.4);
          --blur-light: blur(4px);
          --blur-strong: blur(10px);
          --rank-bronze: #CD7F32;
          --rank-silver: #C0C0C0;
          --rank-gold: #FFD700;
          --rank-diamond: #B9F2FF;
        }

        /* üîò COMPONENTES UNIVERSALES */
        .universal-btn {
          width: var(--button-size);
          height: var(--button-size);
          background: var(--button-primary);
          color: var(--text-primary);
          border: none;
          border-radius: var(--button-radius);
          box-shadow: var(--shadow-soft);
          transition: all var(--transition-fast);
          cursor: pointer;
          font-weight: 600;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
          font-size: 14px;
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }

        .universal-btn:hover {
          background: var(--button-hover);
          transform: translateY(-2px);
          box-shadow: var(--shadow-strong);
        }

        .universal-btn:active {
          background: var(--button-active);
          transform: translateY(0);
          box-shadow: var(--shadow-soft);
        }

        .fade-in {
          animation: fadeIn var(--transition-smooth) ease;
        }

        .bounce-in {
          animation: bounceIn 0.5s var(--bounce-animation);
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes bounceIn {
          0% { transform: scale(0.3); opacity: 0; }
          50% { transform: scale(1.05); }
          70% { transform: scale(0.9); }
          100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }

        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-6px); }
        }
        /* üì± Estilos base m√≥vil-first */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
        }
        
        /* üèÜ CABECERA DEL JUEGO */
        #gameHeader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(13, 71, 161, 0.4);
            z-index: 1000;
            border-bottom: 3px solid #0d47a1;
            backdrop-filter: blur(10px);
        }
        
        .fish-info-expanded {
            flex: 1;
            text-align: center;
            color: #fff;
            padding: 0 20px;
        }
        
        #fishAge {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        
        #fishName {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: linear-gradient(45deg, #26c6da, #4fc3f7);
            border: 3px solid #81d4fa;
            color: white;
            padding: 8px;
            border-radius: 50%;
            font-size: 18px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(38, 198, 218, 0.3);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(38, 198, 218, 0.4);
            border-color: #4fc3f7;
        }
        
        .action-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéí MODAL DE INVENTARIO */
        #inventoryModal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 600px;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255,255,255,0.3);
        }
        
        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(255, 82, 82, 0.3);
        }
        
        .close-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(255, 82, 82, 0.4);
        }
        
        .inventory-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
        }
        
        .tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            padding: 15px 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 4px solid transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .tab-btn.active {
            color: white;
            border-bottom-color: white;
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }
        
        .inventory-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .item-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .item-card:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4fc3f7;
        }
        
        .item-card.selected {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .item-preview {
            width: 80px;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin: 0 auto 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .item-name {
            color: #fff;
            font-size: 10px;
            font-weight: bold;
        }
        
        .item-cost {
            color: #4fc3f7;
            font-size: 9px;
            margin-top: 2px;
        }
        
        .coming-soon {
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-style: italic;
            padding: 40px 20px;
        }
        
        .locked-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        /* üé® MODALES BONITOS */
        @keyframes modalPop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes bubbleFloat {
            from {
                top: 100%;
                opacity: 0.8;
            }
            to {
                top: -10%;
                opacity: 0;
            }
        }
        
        /* üéÆ MODALES DE JUEGO MEJORADAS */
        .game-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-modal-overlay[style*="block"] {
            opacity: 1;
        }
        
        .game-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 650px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.4s ease-out;
            position: relative;
        }
        
        .games-modal {
            max-width: 700px;
        }
        
        .game-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .game-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 82, 82, 0.3);
        }
        
        .game-close-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 15px rgba(255, 82, 82, 0.5);
        }
        
        .game-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            padding: 16px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 4px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .game-tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-2px);
        }
        
        .game-tab-btn.active {
            color: white;
            border-bottom-color: #ffffff;
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .tab-text {
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-modal-body {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-tab-content {
            display: none;
        }
        
        .game-tab-content.active {
            display: block;
            animation: fadeInUp 0.3s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .game-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        
        .game-item-card {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-item-card:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .game-item-card.available {
            border-color: #4caf50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .game-item-card.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-item-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 12px;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }
        
        .game-item-info {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .game-item-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-reward {
            color: #4caf50;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-unlock {
            color: #ff9800;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-play-btn {
            width: 100%;
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 12px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .game-play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 18px rgba(76, 175, 80, 0.4);
            background: linear-gradient(45deg, #66bb6a, #4caf50);
        }
        
        .game-play-btn:active {
            transform: scale(0.98);
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-locked-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
        }
        
        .lock-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        .lock-text {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .coming-soon-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .coming-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .coming-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .coming-desc {
            font-size: 14px;
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* üì± MODALES M√ìVILES SIMPLES */
        .mobile-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .mobile-modal-overlay[style*="flex"] {
            opacity: 1;
        }
        
        .mobile-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 3px solid #ffffff;
            border-radius: 20px;
            width: 95%;
            max-width: 400px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.3s ease-out;
        }
        
        .mobile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mobile-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .mobile-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .mobile-close-btn:active {
            transform: scale(0.95);
        }
        
        /* üéÆ GRID DE JUEGOS 3x3 */
        .games-grid-3x3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-card-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .game-card-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }
        
        .game-card-square:active {
            transform: scale(0.98);
        }
        
        .game-card-square.available {
            border-color: #4caf50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .game-card-square.available:hover {
            border-color: #66bb6a;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }
        
        .game-card-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .game-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .game-card-square.locked .game-lock-overlay {
            opacity: 1;
        }
        
        .lock-icon-small {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .lock-stars {
            color: #ffa726;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* üéí INVENTARIO SIMPLE */
        .inventory-grid-simple {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .inventory-item-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .inventory-item-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }
        
        .inventory-item-square:active {
            transform: scale(0.98);
        }
        
        .inventory-item-square.available {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }
        
        .inventory-item-square.available:hover {
            border-color: #42a5f5;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }
        
        .inventory-item-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .inventory-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .inventory-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .inventory-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .inventory-item-square.locked .inventory-lock-overlay {
            opacity: 1;
        }
        
        /* üì± RESPONSIVE PARA MODALES M√ìVILES */
        @media (max-width: 480px) {
            .mobile-modal-content {
                width: 98%;
                max-width: 350px;
                border-radius: 16px;
            }
            
            .mobile-modal-header {
                padding: 14px 18px;
            }
            
            .mobile-modal-header h2 {
                font-size: 16px;
            }
            
            .mobile-close-btn {
                width: 36px;
                height: 36px;
                font-size: 20px;
            }
            
            .games-grid-3x3 {
                gap: 10px;
                padding: 16px;
            }
            
            .game-card-square {
                border-radius: 10px;
            }
            
            .game-square-icon {
                font-size: 28px;
                margin-bottom: 4px;
            }
            
            .game-square-name {
                font-size: 10px;
            }
            
            .lock-icon-small {
                font-size: 18px;
            }
            
            .lock-stars {
                font-size: 9px;
            }
        }
        
        @media (max-width: 360px) {
            .games-grid-3x3 {
                gap: 8px;
                padding: 14px;
            }
            
            .game-square-icon {
                font-size: 24px;
            }
            
            .game-square-name {
                font-size: 9px;
            }
        }
        
        /* üìä BARRAS DE NECESIDADES */
        .needs-bars {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .need-bar {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-icon {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        
        .bar-container {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .bar-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .bar-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .bar-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üìä BARRA DE NECESIDADES COMPACTA DEBAJO DE CABECERA */
        .needs-header-bar {
            background: linear-gradient(135deg, rgba(100, 150, 200, 0.8), rgba(130, 180, 230, 0.8)) !important;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 15px;
            display: none; /* OCULTA POR DEFECTO - SOLO VISIBLE CON PEZ */
            justify-content: center;
            align-items: center;
            gap: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 999;
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            height: 0; /* ALTURA 0 CUANDO EST√Å OCULTA */
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        /* CUANDO SE MUESTRA, TIENE ALTURA */
        .needs-header-bar[style*="flex"] {
            height: 35px !important;
        }
        
        .need-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .need-emoji {
            font-size: 16px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }
        
        .need-bar-mini {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .need-fill-mini {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        
        .need-fill-mini.hunger {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE‚ÜíNARANJA‚ÜíROJO */
        }
        
        .need-fill-mini.dirt {
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336); /* VERDE‚ÜíNARANJA‚ÜíROJO (como hambre) */
        }
        
        .need-fill-mini.fun {
            background: linear-gradient(90deg, #f44336, #ff9800, #4caf50); /* ROJO‚ÜíNARANJA‚ÜíVERDE */
        }
        
        /* üéÆ CANVAS CON FONDO COMPLETO (SIN ESPACIO AZUL) */
        #gameCanvas {
            background: radial-gradient(ellipse at center, #1e3a5f 0%, #0f2a44 100%) !important;
            z-index: 1;
        }
        
        /* üìä BARRAS FLOTANTES COMPACTAS (OCULTAS) */
        .needs-overlay {
            display: none; /* OCULTAR las flotantes */
            position: absolute;
            top: 70px;
            right: 15px;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .need-mini {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-mini span {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .mini-bar {
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .mini-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .mini-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .mini-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .mini-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üì± RESPONSIVE PARA M√ìVILES */
        @media (max-width: 768px) {
            .game-modal-content {
                width: 98%;
                max-height: 95vh;
                border-radius: 20px;
            }
            
            .game-modal-header {
                padding: 16px 20px;
            }
            
            .game-modal-header h2 {
                font-size: 18px;
            }
            
            .game-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .game-tabs {
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .game-tabs::-webkit-scrollbar {
                display: none;
            }
            
            .game-tab-btn {
                padding: 12px 8px;
                min-width: 80px;
            }
            
            .tab-icon {
                font-size: 18px;
            }
            
            .tab-text {
                font-size: 11px;
            }
            
            .game-modal-body {
                padding: 16px;
                max-height: 400px;
            }
            
            .game-items-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .game-item-card {
                padding: 16px;
            }
            
            .game-item-icon {
                font-size: 40px;
            }
            
            .game-item-name {
                font-size: 16px;
            }
            
            .game-item-description {
                font-size: 13px;
            }
            
            .game-play-btn {
                padding: 10px 14px;
                font-size: 13px;
            }
            
            .coming-soon-card {
                padding: 30px 16px;
            }
            
            .coming-icon {
                font-size: 40px;
            }
            
            .coming-text {
                font-size: 16px;
            }
            
            .coming-desc {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .game-modal-content {
                border-radius: 16px;
            }
            
            .game-modal-header {
                padding: 12px 16px;
            }
            
            .game-modal-header h2 {
                font-size: 16px;
            }
            
            .game-modal-body {
                padding: 12px;
                max-height: 350px;
            }
            
            .game-item-card {
                padding: 12px;
            }
            
            .game-item-icon {
                font-size: 36px;
            }
            
            .tab-icon {
                font-size: 16px;
            }
            
            .tab-text {
                font-size: 10px;
            }
        }
        
        .custom-modal h2 {
            color: white;
            font-size: 18px;
            margin: 0 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .custom-modal p {
            color: white;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .custom-input {
            width: 100%;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 16px;
            text-align: center;
            margin: 10px 0;
            background: rgba(255,255,255,0.9);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .custom-input:focus {
            outline: none;
            border-color: #81d4fa;
            box-shadow: 0 0 10px rgba(129, 212, 250, 0.5);
        }
        
        .custom-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .custom-btn {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .confirm-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            color: white;
        }
        
        .cancel-btn {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
            color: white;
        }
        
        .custom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .custom-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéÆ TARJETAS DE JUEGOS */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .game-card {
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .game-card.available {
            cursor: pointer;
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: white;
            box-shadow: 0 8px 20px rgba(255,255,255,0.2);
        }
        
        .game-card.locked {
            filter: grayscale(70%);
            opacity: 0.6;
        }
        
        .game-icon {
            font-size: 40px;
            margin-bottom: 15px;
        }
        
        .game-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .game-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-reward {
            color: #81d4fa;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .game-unlock {
            color: #ffab91;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .play-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(76, 175, 80, 0.4);
        }
        
        /* üì∏ √ÅLBUM/DIARIO */
        .album-modal {
            max-width: 700px;
            max-height: 85%;
        }
        
        .album-content {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .album-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .stat-item span {
            display: block;
            font-size: 16px;
            color: #81d4fa;
            margin-top: 5px;
        }
        
        .album-timeline {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .album-entry {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .album-entry:hover {
            transform: translateY(-2px);
            border-color: white;
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
        }
        
        .album-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .album-entry-title {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        .album-entry-date {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .album-entry-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .album-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: rgba(255,255,255,0.6);
        }
        
        .album-entry-age {
            background: rgba(129, 212, 250, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        #gameCanvas {
            position: fixed;
            top: 100px; /* Header (60px) + Barra necesidades (40px) */
            left: 0;
            right: 0;
            bottom: 90px; /* Espacio para barra inferior */
            touch-action: none;
            background: var(--bg-primary);
        }
        
        /* üéÆ UI Overlay */
        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        /* üí∞ CONTADORES FLOTANTES */
        #currencyOverlay {
            position: absolute;
            top: 85px; /* M√°s cerca de la cabecera */
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px; /* M√°s compacto */
        }
        
        .currency-float {
            display: flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(38, 198, 218, 0.95), rgba(79, 195, 247, 0.95));
            border: 2px solid rgba(255,255,255,0.9);
            padding: 4px 6px;
            border-radius: 18px;
            box-shadow: 0 2px 6px rgba(38, 198, 218, 0.4);
            backdrop-filter: blur(6px);
            transition: all 0.3s ease;
            min-width: 55px;
        }
        
        .currency-float:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(38, 198, 218, 0.4);
        }
        
        .currency-float .currency-icon {
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .currency-float span:last-child {
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            min-width: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Animaci√≥n cuando cambia el valor */
        .currency-float.updated {
            animation: currencyPulse 0.5s ease-out;
        }
        
        @keyframes currencyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 8px 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }
        
        /* üí® Badge Turbo */
        #turboBadge {
            position: fixed;
            right: var(--mobile-padding);
            top: var(--mobile-padding);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: var(--blur-light);
            font-weight: 700;
            font-size: 14px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
        }
        
        #turboBadge.active {
            opacity: 1;
        }
        
        /* üéØ Loading Screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity var(--transition-smooth);
            color: white;
            text-align: center;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content h2 {
            margin: 20px 0 10px 0;
            font-size: 24px;
            font-weight: bold;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            animation: logoFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .loading-dots {
            font-size: 30px;
            animation: loadingPulse 1.5s infinite;
        }

        .loading-dots span {
            animation: dotBounce 1.4s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes dotBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-20px); }
        }

        /* üéÜ EFECTOS DE RECOMPENSA */
        .reward-bubble {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(100,200,255,0.6));
            border: 3px solid rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 2000;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(100,200,255,0.6);
            animation: rewardBubbleFloat 2s ease-out forwards;
        }

        @keyframes rewardBubbleFloat {
            0% {
                transform: scale(0.5) translateY(0);
                opacity: 0;
            }
            20% {
                transform: scale(1.2) translateY(-20px);
                opacity: 1;
            }
            50% {
                transform: scale(1) translateY(-60px);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-100px);
                opacity: 0;
            }
        }

        .reward-explosion {
            position: fixed;
            width: 70px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8), transparent);
            z-index: 1999;
            pointer-events: none;
            animation: rewardExplosion 0.8s ease-out forwards;
        }

        @keyframes rewardExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(233, 246, 255, 0.3);
            border-top: 3px solid var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes floatBubble {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            25% {
                transform: translateY(-8px) scale(1.05);
            }
            50% {
                transform: translateY(-3px) scale(0.98);
            }
            75% {
                transform: translateY(-12px) scale(1.02);
            }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.8;
        }
        
        /* üö® Error Screen */
        #errorScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: var(--mobile-padding);
            text-align: center;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .error-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .error-message {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 24px;
        }
        
        .retry-button {
            padding: 12px 24px;
            border: none;
            border-radius: var(--button-radius);
            background: var(--button-primary);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        
        .retry-button:hover {
            background: var(--button-hover);
        }
        
        /* üîß Barra de Debug (solo en desarrollo) */
        #debugBar {
            position: fixed;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15); /* BLANQUECINO CRISTAL */
            backdrop-filter: blur(10px); /* EFECTO CRISTAL */
            border-radius: 12px;
            padding: 6px 4px;
            display: none;
            flex-direction: column;
            gap: 3px;
            z-index: 1002;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* SOMBRA SUAVE */
            width: 80px; /* Ancho fijo m√°s peque√±o */
        }
        
        #debugInfo {
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 7px;
            text-align: center;
            margin-bottom: 4px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-btn {
            padding: 4px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            font-size: 16px; /* Solo emoji */
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .debug-btn.danger {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .debug-btn.primary {
            border-color: #4488ff;
            color: #4488ff;
        }
        
        .debug-btn.warning {
            border-color: #ffaa44;
            color: #ffaa44;
        }
        
        .debug-btn.success {
            border-color: #4caf50;
            color: #4caf50;
        }
        
        .debug-btn.info {
            border-color: #00bcd4;
            color: #00bcd4;
        }
        
        .debug-btn.purple {
            border-color: #9c27b0;
            color: #9c27b0;
        }
        
        /* üéÆ BARRA DE HERRAMIENTAS COMPACTA COMO CABECERA */
        .action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px; /* M√ÅS COMPACTA (era 90px) */
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2); /* IGUAL QUE CABECERA */
            box-shadow: 0 -4px 20px rgba(13, 71, 161, 0.4); /* SOMBRA HACIA ARRIBA */
            border-top: 3px solid #0d47a1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #0d47a1, #1565c0);
            backdrop-filter: blur(20px);
            border-radius: 0; /* SIN ESQUINAS REDONDEADAS */
            padding: 8px 15px;
            z-index: 40;
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: none; /* SIN BORDES */
        }
        
        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none; /* SIN BORDES OSCUROS */
            border-radius: 13px; /* RADIO PERSONALIZADO */
            padding: 2px; /* PADDING REDUCIDO */
            cursor: pointer;
            transition: all 0.2s ease; /* TRANSICI√ìN NORMAL Y SUAVE */
            width: 48px;
            height: 48px;
            overflow: hidden;
        }
        
        .menu-btn:hover:not(.disabled) {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px); /* EFECTO SUAVE NORMAL */
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4); /* SOMBRA SUAVE */
        }
        
        .menu-btn.disabled {
            background: linear-gradient(135deg, #bbb, #999);
            border: none; /* SIN BORDES EN DESHABILITADOS TAMBI√âN */
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .menu-btn.disabled:hover {
            transform: none;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        
        .menu-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .menu-btn:hover:not(.disabled) .menu-icon {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3)) brightness(1.1); /* EFECTO M√ÅS SUAVE */
        }
        
        .menu-btn.disabled .menu-icon {
            filter: grayscale(100%) drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        /* üé® LOGO DE LA WEB */
        .logo-container {
            display: flex;
            align-items: center;
        }
        
        .game-logo {
            height: 40px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .game-logo:hover {
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.4)) brightness(1.1);
            transform: scale(1.05);
        }
        
        /* üìù INFO EN DOS L√çNEAS */
        .fish-info-stacked {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            text-align: center;
        }
        
        .fish-info-stacked #fishAge {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .fish-info-stacked #fishName {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* üí∞ CONTADORES VERTICALES */
        .header-currency-vertical {
            display: flex;
            align-items: center;
        }
        
        .currency-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .currency-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .currency-row .currency-icon {
            font-size: 12px;
        }
        
        .currency-row span {
            color: white;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* üéØ ICONOS DE NECESIDADES FLOTANTES (SOLO VISUALES) */
        .need-bubble-game {
            position: absolute;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* NO clickeables */
            animation: needPulse 2s infinite ease-in-out;
            z-index: 90;
            opacity: 0.4; /* M√ÅS TRANSPARENTE Y SUTIL */
        }
        
        .need-icon {
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
        }
        
        /* üé≠ TRANSICIONES SUAVES PARA MOVIMIENTO DE ICONOS */
        .need-bubble-game {
            transition: opacity 1.8s ease, transform 1.8s ease;
        }
        
        /* üçΩÔ∏è ICONO DE COMIDA CON EFECTO ROJO */
        .need-bubble-game.hunger .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 50, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 50, 50, 0.6))
                hue-rotate(-15deg) 
                saturate(1.5) 
                brightness(1.2);
        }
        
        /* üßΩ ICONO DE LIMPIEZA CON EFECTO AZUL */
        .need-bubble-game.dirty .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 150, 255, 0.8))
                drop-shadow(0 0 12px rgba(50, 150, 255, 0.6))
                hue-rotate(20deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üíä ICONO DE MEDICINA CON EFECTO VERDE */
        .need-bubble-game.medicine .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 255, 100, 0.8))
                drop-shadow(0 0 12px rgba(50, 255, 100, 0.6))
                hue-rotate(30deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üéÆ ICONO DE JUEGO CON EFECTO NARANJA */
        .need-bubble-game.play .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 150, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 150, 50, 0.6))
                hue-rotate(-30deg) 
                saturate(1.3) 
                brightness(1.1);
        }
        
        @keyframes needPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* üéâ Pantalla de bienvenida - ESTILO MARINO BONITO */
        #welcomeScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
            padding: var(--mobile-padding);
            overflow: hidden;
        }

        /* üåä EFECTOS MARINOS DE FONDO */
        #welcomeScreen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255,255,255,0.1) 2px, transparent 2px),
                radial-gradient(circle at 80% 30%, rgba(255,255,255,0.08) 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, rgba(255,255,255,0.06) 3px, transparent 3px),
                radial-gradient(circle at 90% 80%, rgba(255,255,255,0.1) 2px, transparent 2px);
            background-size: 100px 100px, 150px 150px, 200px 200px, 120px 120px;
            animation: float-bubbles 20s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes float-bubbles {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-20px, -30px) rotate(5deg); }
            50% { transform: translate(30px, -20px) rotate(-3deg); }
            75% { transform: translate(-10px, 40px) rotate(2deg); }
        }

        /* üì± Ocultar header durante bienvenida */
        #welcomeScreen:not([style*="display: none"]) + * #gameHeader,
        #welcomeScreen[style*="flex"] ~ #gameHeader {
            display: none !important;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.15);
            padding: 32px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .welcome-content h1 {
            font-size: 28px;
            margin-bottom: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .welcome-content p {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 24px;
        }
        
        /* üéì TUTORIAL STEPS */
        .welcome-tutorial {
            margin: 20px 0;
            text-align: left;
        }
        
        .tutorial-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 14px;
            opacity: 0.9;
            animation: tutorial-fade-in 0.6s ease-out forwards;
        }
        
        .tutorial-step:nth-child(1) { animation-delay: 0.2s; opacity: 0; }
        .tutorial-step:nth-child(2) { animation-delay: 0.4s; opacity: 0; }
        .tutorial-step:nth-child(3) { animation-delay: 0.6s; opacity: 0; }
        .tutorial-step:nth-child(4) { animation-delay: 0.8s; opacity: 0; }
        .tutorial-step:nth-child(5) { animation-delay: 1.0s; opacity: 0; }
        
        .tutorial-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }
        
        .tutorial-text {
            flex: 1;
            font-weight: 500;
        }
        
        @keyframes tutorial-fade-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 0.9; transform: translateX(0); }
        }
        
        /* ü•ö MENSAJE SIMPLE DEL HUEVITO */
        .welcome-info {
            margin: 20px 0;
        }
        
        .egg-message {
            font-size: 16px;
            opacity: 0.9;
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.1);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 12px;
        }
        
        .games-tip {
            font-size: 14px;
            opacity: 0.85;
            line-height: 1.4;
            background: rgba(76, 175, 80, 0.15); /* Verde suave */
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            animation: tip-glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes tip-glow {
            from { box-shadow: 0 0 5px rgba(76, 175, 80, 0.3); }
            to { box-shadow: 0 0 15px rgba(76, 175, 80, 0.5); }
        }
        
        /* üíñ EFECTO PULSE PARA BARRA DE DIVERSI√ìN */
        @keyframes ping {
            0% { box-shadow: 0 0 0 0 rgba(155,231,255,.9) }
            100% { box-shadow: 0 0 0 14px rgba(155,231,255,0) }
        }
        .pulse { animation: ping 1.1s ease-out; }

        /* üéÆ MODAL DE JUEGOS HERMOSO */
        .games-modal-content {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .games-info {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .star-system {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .star-rule {
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            color: #ffd700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .game-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .game-card.available {
            border-color: rgba(76, 175, 80, 0.4);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.1),
                0 0 20px rgba(76, 175, 80, 0.1);
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(76, 175, 80, 0.6);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 0 30px rgba(76, 175, 80, 0.3);
        }
        
        .game-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .game-icon {
            font-size: 32px;
            margin-bottom: 10px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .game-description {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-stats {
            font-size: 11px;
            color: #ffd700;
            font-weight: 600;
        }
        
        .game-lock {
            font-size: 12px;
            color: #999;
            font-weight: 500;
        }
        
        /* üîä BOT√ìN DE VOLUMEN SIMPLE */
        .volume-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            margin-top: 8px;
            margin-left: 12px; /* Separaci√≥n de los contadores */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .volume-button:hover {
            transform: scale(1.1);
        }

        .volume-button:active {
            transform: scale(0.95);
        }

        #volumeIcon {
            width: 28px;
            height: 28px;
            opacity: 0.75; /* Transl√∫cido para que pegue con el resto */
            transition: all 0.3s ease;
        }
        
        .volume-button:hover #volumeIcon {
            opacity: 1; /* Completamente opaco al hover */
        }
        
        .volume-icon {
            pointer-events: none;
        }
        
        .start-button {
            padding: 16px 32px;
            border: 3px solid #01579b;
            border-radius: 25px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: white;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.6);
        }
        
        .start-button:hover {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.8);
        }
        
        /* üîÑ BOT√ìN DE RESET BONITO */
        .reset-button {
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
        }
        
        /* üé® LOGO ANIMADO */
        .logo-animated {
            margin-bottom: 20px;
        }
        
        .logo-bounce {
            width: 80px;
            height: 60px;
            animation: logoBounce 3s ease-in-out infinite;
            filter: drop-shadow(0 4px 15px rgba(79, 195, 247, 0.6));
        }
        
        @keyframes logoBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-10px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.02); }
            75% { transform: translateY(-15px) scale(1.08); }
        }
        
        /* üåä BURBUJAS ANIMADAS DE FONDO */
        .welcome-bubbles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .bubble {
            position: absolute;
            font-size: 20px;
            opacity: 0.7;
            animation: bubbleFloat 4s ease-in-out infinite;
        }
        
        .bubble-1 { left: 10%; animation-delay: 0s; }
        .bubble-2 { left: 20%; animation-delay: 1s; }
        .bubble-3 { left: 80%; animation-delay: 2s; }
        .bubble-4 { left: 90%; animation-delay: 0.5s; }
        .bubble-5 { left: 60%; animation-delay: 1.5s; }
        
        @keyframes bubbleFloat {
            0% { transform: translateY(100vh) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20px) scale(1.2); opacity: 0; }
        }
        
        /* üéÆ GRID DE JUEGOS COMPACTO MARINO */
        .games-grid-simple {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .game-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(240,248,255,0.9) 100%);
            border: 2px solid rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #0066cc;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,150,255,0.2);
            backdrop-filter: blur(15px);
        }
        
        .game-card.locked {
            background: linear-gradient(135deg, rgba(200,200,200,0.6) 0%, rgba(180,180,180,0.5) 100%);
            border-color: rgba(150,150,150,0.6);
            color: #999;
            opacity: 0.8;
        }
        
        .game-card:hover:not(.locked) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(0,150,255,0.25);
            border-color: rgba(0,200,255,0.9);
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(230,248,255,0.9) 100%);
        }
        
        .game-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .game-name {
            font-weight: bold;
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1.1;
        }
        
        .game-requirement {
            font-size: 11px;
            opacity: 0.8;
        }
        
        /* üéì Pantalla de tutorial - ESTILO MARINO BONITO */
        #tutorialScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 998;
            padding: var(--mobile-padding);
        }
        
        .tutorial-content {
            text-align: center;
            max-width: 350px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 24px;
            border-radius: 16px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        .tutorial-content h2 {
            margin-bottom: 16px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .tutorial-hint {
            background: #f0f8ff;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-size: 14px;
        }
        
        /* Eliminado - Ya no hay bot√≥n saltar */
        
        /* üéÆ Responsive ajustes */
        @media (max-width: 480px) {
            #turboBadge {
                font-size: 12px;
                padding: 4px 8px;
            }
        }
    </style>
</head>
<body>
    <!-- üèÜ CABECERA CON LOGO -->
    <div id="gameHeader">
        <!-- üé® LOGO DE LA WEB -->
        <div class="logo-container">
            <img src="./images/ui/logo.png" alt="Mi Pececito" class="game-logo">
        </div>
        
        <!-- üìù INFO EN DOS L√çNEAS -->
        <div class="fish-info-stacked">
            <div id="fishAge">Huevo</div>
            <div id="fishName">Mi Pececito</div>
        </div>
        
        <!-- üí∞ CONTADORES VERTICALES -->
        <div class="header-currency-vertical">
            <div class="currency-stack">
                <div class="currency-row">
                    <span class="currency-icon">ü´ß</span>
                    <span id="bubblesCount">0</span>
                </div>
                <div class="currency-row">
                    <span class="currency-icon">‚≠ê</span>
                    <span id="starsCount">0</span>
                </div>
            </div>
            <!-- üîä BOT√ìN DE VOLUMEN BONITO -->
            <button id="volumeBtn" class="volume-button" title="Controlar sonido">
                <img id="volumeIcon" src="./images/ui/sonidoOn.png" alt="Sonido" class="volume-icon">
            </button>
        </div>
    </div>
    
    <!-- üìä BARRA DE NECESIDADES (SIEMPRE VISIBLE) -->
    <div id="needsHeaderBar" class="needs-header-bar">
        <div class="need-compact" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <img src="./images/ui/barra_comida.png" alt="Hambre" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini hunger" id="hungerBarHeader" style="width: 80%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Suciedad: M√ÅS ROJO = M√ÅS SUCIO">
            <img src="./images/ui/barra_limpieza.png" alt="Limpieza" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini dirt" id="dirtBarHeader" style="width: 65%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <img src="./images/ui/barra_diversion.png" alt="Diversi√≥n" class="need-icon" style="width: 22px; height: 22px;">
            <div class="need-bar-mini">
                <div class="need-fill-mini fun" id="funBarHeader" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üéÆ BARRA DE MEN√ö LIMPIA SIN TEXTO -->
    <div class="action-bar">
        <button class="menu-btn disabled" id="feedBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_hunger.png" alt="Comida" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn disabled" id="cleanBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_dirty.png" alt="Limpiar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="playButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_play.png" alt="Jugar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="inventoryButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_inventario.png" alt="Inventario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="albumButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_fotos.png" alt="√Ålbum" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="resetButton" title="Cuidar otro pececito">
            <div class="btn-icon">
                <img src="./images/ui/badge_caravera.png" alt="Reset" class="menu-icon">
            </div>
        </button>
    </div>

    <!-- üéÆ Canvas principal del juego -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- üìä BARRAS DE NECESIDADES FLOTANTES -->
    <div class="needs-overlay">
        <div class="need-mini" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <span>üçé</span>
            <div class="mini-bar">
                <div class="mini-fill hunger" id="hungerBar" style="width: 80%"></div>
            </div>
        </div>
        <div class="need-mini" title="Suciedad: M√ÅS VERDE = M√ÅS SUCIO">
            <span>üßπ</span>
            <div class="mini-bar">
                <div class="mini-fill dirt" id="dirtBar" style="width: 65%"></div>
            </div>
        </div>
        <div class="need-mini" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <span>üéâ</span>
            <div class="mini-bar">
                <div class="mini-fill fun" id="funBar" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üê† CONTENEDOR LOTTIE PARA EL PEZ -->
    <div id="lottieContainer" style="
        position: absolute;
        width: 60px;
        height: 60px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        pointer-events: none;
        display: none;
        /* filter: brightness(1.3) contrast(1.1) saturate(1.2); */ /* DESHABILITADO - conflicto con JS din√°mico */
    "></div>
    
    <!-- üéØ UI Overlay -->
    <div class="ui-overlay">
        <!-- üí® Badge de turbo -->
        <div id="turboBadge">TURBO üí®</div>
        
        
        <!-- üéØ ICONOS DE NECESIDADES (SOLO VISUALES - NO CLICKEABLES) -->
        <!-- ICONOS FLOTANTES ELIMINADOS - ERAN MOLESTOS -->
    </div>
    
    <!-- üì± Pantalla de carga ELIMINADA -->
    
    <!-- üéâ Pantalla de bienvenida (primera vez) -->
    <div id="welcomeScreen" style="display: none;">
        <div class="welcome-content">
            <!-- üé® LOGO ANIMADO -->
            <div class="logo-animated">
                <img src="./images/ui/logo.png" alt="Mi Pececito" class="logo-bounce">
            </div>
            
            <h1>Mi Pececito</h1>
            <p>Tu mascota virtual</p>
            
            <!-- MENSAJE SIMPLE DEL HUEVITO -->
            <div class="welcome-info">
                <p class="egg-message">
                    Tu huevo nacer√° en <strong>5 minutos</strong><br>
                    Juega mientras esperas
                </p>
            </div>
            
            <!-- üåä BURBUJAS SUTILES (MENOS ICONOS) -->
            <div class="welcome-bubbles">
                <div class="bubble bubble-1">ü´ß</div>
                <div class="bubble bubble-2">ü´ß</div>
                <div class="bubble bubble-3">ü´ß</div>
            </div>
            
            <button id="startGameBtn" class="start-button">Empezar</button>
            
            <!-- Bot√≥n de reset eliminado - Solo aparece en men√∫ si ya tienes pez -->
        </div>
    </div>
    
    <!-- üéì Pantalla de tutorial -->
    <div id="tutorialScreen" style="display: none;">
        <div class="tutorial-content">
            <h2>ü•ö Tu Primer Huevo</h2>
            <p>Toca la pantalla para colocar tu huevo en el acuario</p>
            <div class="tutorial-hint">üí° El huevo tardar√° 24 horas en eclosionar</div>
        </div>
    </div>

    <!-- üéÆ MODAL DE JUEGOS MODERNO -->
    <div id="gamesModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content games-modal-content">
            <div class="mobile-modal-header">
                <h2>üéÆ Juegos</h2>
                <button id="closeGames" class="mobile-close-btn">√ó</button>
            </div>
            
            <!-- üèÜ SISTEMA DE ESTRELLAS -->
            <div class="games-info">
                <div class="star-system">
                    <div class="star-rule">‚≠ê Jugar = 1 estrella</div>
                    <div class="star-rule">‚≠ê‚≠ê Logro = 2 estrellas</div>
                    <div class="star-rule">‚≠ê‚≠ê‚≠ê Record = 3 estrellas</div>
                </div>
            </div>
            
            <!-- üéØ GRID DE JUEGOS -->
            <div class="games-grid">
                <div class="game-card available" data-game="bubbles">
                    <div class="game-icon">ü´ß</div>
                    <div class="game-title">Atrapa Burbujas</div>
                    <div class="game-description">Revienta las burbujas buenas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bubbles-best">0</span></span>
                        <span class="stars">‚≠ê <span id="bubbles-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="bloques">
                    <div class="game-icon">üíé</div>
                    <div class="game-title">Mar Match-3</div>
                    <div class="game-description">Conecta 3 gemas marinas</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="bloques-best">0</span></span>
                        <span class="stars">‚≠ê <span id="bloques-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="memoria">
                    <div class="game-icon">üß†</div>
                    <div class="game-title">Memoflip</div>
                    <div class="game-description">Encuentra las parejas</div>
                    <div class="game-stats">
                        <span class="best-score">Partidas: <span id="memoria-best">0</span></span>
                        <span class="stars">‚≠ê <span id="memoria-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="simon">
                    <div class="game-icon">üéµ</div>
                    <div class="game-title">Sim√≥n Marino</div>
                    <div class="game-description">Repite la secuencia</div>
                    <div class="game-stats">
                        <span class="best-score">R√©cord: <span id="simon-best">0</span></span>
                        <span class="stars">‚≠ê <span id="simon-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="carril">
                    <div class="game-icon">üê¨</div>
                    <div class="game-title">Carril del Delf√≠n</div>
                    <div class="game-description">Runner de 3 carriles</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="carril-best">0</span></span>
                        <span class="stars">‚≠ê <span id="carril-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="correr">
                    <div class="game-icon">üêâ</div>
                    <div class="game-title">Drag√≥n Marino</div>
                    <div class="game-description">Corre y salta obst√°culos</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="correr-best">0</span></span>
                        <span class="stars">‚≠ê <span id="correr-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="caza">
                    <div class="game-icon">üéØ</div>
                    <div class="game-title">Caza de Peces</div>
                    <div class="game-description">Toca el objetivo</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="caza-best">0</span></span>
                        <span class="stars">‚≠ê <span id="caza-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="secuencia">
                    <div class="game-icon">üåä</div>
                    <div class="game-title">Secuencia de Mareas</div>
                    <div class="game-description">Memoriza y repite</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="secuencia-best">0</span></span>
                        <span class="stars">‚≠ê <span id="secuencia-stars">0</span></span>
                    </div>
                </div>
                
                <div class="game-card available" data-game="toca3">
                    <div class="game-icon">üèñÔ∏è</div>
                    <div class="game-title">Toca-3 Marino</div>
                    <div class="game-description">Pez en la arena</div>
                    <div class="game-stats">
                        <span class="best-score">Mejor: <span id="toca3-best">0</span></span>
                        <span class="stars">‚≠ê <span id="toca3-stars">0</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- üéí MODAL DE INVENTARIO SIMPLE -->
    <div id="inventoryModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üéí Inventario</h2>
                <button id="closeInventory" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="inventory-grid-simple">
                <!-- Fondos disponibles -->
                <div class="inventory-item-square available" data-item="bg-default">
                    <div class="inventory-square-icon">üåä</div>
                    <div class="inventory-square-name">Oc√©ano</div>
            </div>
            
                <div class="inventory-item-square locked" data-item="bg-coral">
                    <div class="inventory-square-icon">ü™∏</div>
                    <div class="inventory-square-name">Coral</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">5‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="bg-deep">
                    <div class="inventory-square-icon">üåå</div>
                    <div class="inventory-square-name">Abismo</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">15‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="bg-tropical">
                    <div class="inventory-square-icon">üèùÔ∏è</div>
                    <div class="inventory-square-name">Tropical</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">25‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="food-special">
                    <div class="inventory-square-icon">üçé</div>
                    <div class="inventory-square-name">Comida</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">30‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="decoration">
                    <div class="inventory-square-icon">üè∫</div>
                    <div class="inventory-square-name">Deco</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">40‚≠ê</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- üéÆ MODAL DE JUEGOS SIMPLE -->
    <div id="gamesModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üéÆ Juegos</h2>
                <button id="closeGames" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="games-grid-3x3">
                <!-- Fila 1 -->
                <div class="game-card-square available" data-game="bubbles">
                    <div class="game-square-icon">ü´ß</div>
                    <div class="game-square-name">Burbujas</div>
            </div>
            
                <div class="game-card-square available" data-game="memory">
                    <div class="game-square-icon">üß†</div>
                    <div class="game-square-name">Memoria</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">10‚≠ê</div>
                    </div>
                        </div>
                        
                <div class="game-card-square available" data-game="snake">
                    <div class="game-square-icon">üêç</div>
                    <div class="game-square-name">Serpiente</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">25‚≠ê</div>
                        </div>
                </div>
                
                <!-- Fila 2 -->
                <div class="game-card-square locked" data-game="puzzle">
                    <div class="game-square-icon">üß©</div>
                    <div class="game-square-name">Puzzle</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">50‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="race">
                    <div class="game-square-icon">üèÉ</div>
                    <div class="game-square-name">Carrera</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">75‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="target">
                    <div class="game-square-icon">üéØ</div>
                    <div class="game-square-name">Punter√≠a</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">100‚≠ê</div>
                        </div>
                    </div>
                
                <!-- Fila 3 -->
                <div class="game-card-square locked" data-game="adventure">
                    <div class="game-square-icon">üó∫Ô∏è</div>
                    <div class="game-square-name">Aventura</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">150‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="tower">
                    <div class="game-square-icon">üèóÔ∏è</div>
                    <div class="game-square-name">Torre</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">200‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="boss">
                    <div class="game-square-icon">üëæ</div>
                    <div class="game-square-name">Jefe Final</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">300‚≠ê</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- üì∏ MODAL DE √ÅLBUM -->
    <div id="albumModal" style="display: none;">
        <div class="modal-content album-modal">
            <div class="modal-header">
                <h2>üì∏ √Ålbum de Mi Pececito</h2>
                <button id="closeAlbum" class="close-btn">‚ùå</button>
            </div>
            
            <div class="album-content">
                <div class="album-stats">
                    <div class="stat-item">üìÖ D√≠as juntos: <span id="albumDays">0</span></div>
                    <div class="stat-item">üì∏ Recuerdos: <span id="albumEvents">0</span></div>
                    <div class="stat-item">üéâ Hitos: <span id="albumMilestones">0</span></div>
                </div>
                
                <div class="album-timeline" id="albumTimeline">
                    <!-- Se llenar√° din√°micamente -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- üö® Pantalla de error -->
    <div id="errorScreen">
        <div class="error-icon">üò¢</div>
        <div class="error-title">¬°Oops! Algo sali√≥ mal</div>
        <div class="error-message">No se pudo cargar el juego. Verifica tu conexi√≥n.</div>
        <button class="retry-button" onclick="location.reload()">Reintentar</button>
    </div>
    
    <!-- üîß Barra de Debug (solo desarrollo) -->
    <div id="debugBar">
        <div id="debugInfo">
            --fps
        </div>
        <button class="debug-btn danger" id="debugResetBtn" title="Reset juego">üîÑ</button>
        <button class="debug-btn primary" id="forceHatchBtn" title="Forzar eclosi√≥n">üê£</button>
        <button class="debug-btn warning" id="timeAdvanceBtn" title="Avanzar tiempo">‚è∞</button>
        <button class="debug-btn success" id="maxFoodBtn" title="M√°xima comida">üçé</button>
        <button class="debug-btn info" id="maxCleanBtn" title="M√°xima limpieza">üßπ</button>
        <button class="debug-btn warning" id="maxDirtBtn" title="M√°xima suciedad">ü¶†</button>
        <button class="debug-btn danger" id="minFunBtn" title="M√≠nima diversi√≥n">üò¢</button>
        <button class="debug-btn purple" id="simulatePlayBtn" title="Simular juego">üéÆ</button>
        <button class="debug-btn" id="addBubblesBtn" title="A√±adir burbujas">ü´ß</button>
        <button class="debug-btn" id="addStarsBtn" title="A√±adir estrellas">‚≠ê</button>
    </div>
    
    <!-- üé® Librer√≠a Lottie -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- üöÄ Script principal -->
    <!-- ü•ö MODAL ELIMINADA - YA NO SE NECESITA -->

    <script>
        // VERSI√ìN CON LOTTIE REAL
        // import { createGame } from './src/core/Game.js';
        
        // üéÆ Variables globales
        let game = null;
        let audioManager = null;
        
        // üöÄ Inicializar juego
        async function initializeGame() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const errorScreen = document.getElementById('errorScreen');
            
            try {
                console.log('üéÆ Iniciando Mi Pececito...');
                console.log('üîß Creando CompleteGame...');
                
                // Crear juego completo
                game = new CompleteGame();
                console.log('‚úÖ CompleteGame creado correctamente');
                
                // Crear AudioManager
                console.log('üéµ Iniciando AudioManager...');
                audioManager = new AudioManager();
                window.audioManager = audioManager; // Hacer disponible globalmente
                console.log('‚úÖ AudioManager creado correctamente');
                
                // üìä FORZAR ACTUALIZACI√ìN DE BARRAS DE NECESIDADES
                setTimeout(() => {
                    if (game && game.updateNeedBars) {
                        game.updateNeedBars();
                        console.log('üìä Barras de necesidades actualizadas');
                    }
                }, 500);
                
                // Configurar eventos globales
                setupGlobalEvents();
                
                // Verificar si es primera vez (sin huevo colocado)
                const savedData = localStorage.getItem('miPececito_gameState');
                const hasPlayed = localStorage.getItem('miPececito_hasPlayed');
                const isFirstTime = !savedData || !hasPlayed;
                console.log('üîç DEBUG PRIMERA VEZ:');
                console.log('   savedData:', !!savedData);
                console.log('   hasPlayed:', hasPlayed);
                console.log('   isFirstTime:', isFirstTime);
                
                // IR DIRECTO (sin pantalla de carga)
                
                // L√ìGICA CORRECTA: Solo bienvenida si NO hay pez
                if (isFirstTime) {
                    // Primera vez: mostrar bienvenida
                    console.log('ü™ü Mostrando bienvenida (primera vez)...');
                    console.log('ü™ü welcomeScreen encontrado:', !!welcomeScreen);
                    if (welcomeScreen) {
                        welcomeScreen.style.display = 'flex';
                        welcomeScreen.style.visibility = 'visible';
                        welcomeScreen.style.opacity = '1';
                        welcomeScreen.style.zIndex = '9999';
                        console.log('ü™ü Modal forzada a visible');
                    }
                    setupWelcomeFlow();
                } else {
                    // Ya tiene pez: mostrar pantalla de carga personalizada
                    game.showLoadingWithFishName();
                    // A√±adir bot√≥n reset al men√∫
                    game.addResetButtonToMenu();
                }
                
                console.log('‚úÖ ¬°Juego listo!', isFirstTime ? '(Primera vez)' : '(Jugador veterano)');
                
            } catch (error) {
                console.error('‚ùå Error inicializando juego:', error);
                
                // Mostrar pantalla de error
                errorScreen.style.display = 'flex';
            }
        }
        
        // üéâ Configurar flujo de bienvenida
        function setupWelcomeFlow() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const tutorialScreen = document.getElementById('tutorialScreen');
            const startGameBtn = document.getElementById('startGameBtn');
            
            // Bot√≥n "Empezar Aventura"
            startGameBtn.addEventListener('click', () => {
                console.log('üöÄ Empezar aventura clickeado - OCULTANDO MODAL');
                welcomeScreen.style.display = 'none';
                
                // üéµ INICIAR M√öSICA DE FONDO INMEDIATAMENTE
                if (audioManager && !audioManager.isMuted) {
                    audioManager.startBackgroundMusic();
                    console.log('üéµ M√∫sica de fondo iniciada al empezar el juego');
                }
                
                // Marcar como jugado
                localStorage.setItem('miPececito_hasPlayed', 'true');
                
                // IR DIRECTO A COLOCAR HUEVO (sin modal intermedia)
                if (game && game.startEggPlacement) {
                    game.startEggPlacement();
                } else {
                    // Fallback si game no est√° listo
                    setTimeout(() => {
                        if (game && game.startEggPlacement) {
                            game.startEggPlacement();
                        }
                    }, 500);
                }
            });
            
            // ü•ö EVENT LISTENER ELIMINADO - YA NO SE NECESITA
            
            // Bot√≥n "Cuidar otro pececito" ELIMINADO - Solo aparece en men√∫ din√°micamente
            /*
            const resetGameBtn = document.getElementById('resetGameBtn');
            if (false) { // DESHABILITADO
                resetGameBtn.addEventListener('click', () => {
                    if (game) {
                        game.showCustomModal({
                            title: 'üåä Despedida de tu Pececito',
                            message: `üê†üí≠ "¬øDe verdad me vas a dejar libre?"\n\nüè† Volver√© al oc√©ano y ser√© feliz\nüíï Siempre recordar√© nuestros momentos\nüéÆ Podr√°s cuidar a un nuevo compa√±ero\n\n‚ö†Ô∏è Se perder√° todo el progreso actual`,
                            confirmText: 'üåä ¬°S√© libre y feliz!',
                            cancelText: 'üíï ¬°No, te quiero!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            },
                            onCancel: () => {
                                game.showCustomModal({
                                    title: 'üíï ¬°Qu√© alegr√≠a!',
                                    message: 'üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos jugando juntos! üéÆ',
                                    confirmText: 'ü•∞ ¬°Siempre!',
                                    onConfirm: () => {}
                                });
                            }
                        });
                    }
                });
            }
            */
        }
        
        // üéì Configurar handler del tutorial
        function setupTutorialHandler() {
            const tutorialScreen = document.getElementById('tutorialScreen');
            
            // Tutorial: Toque ANYWHERE para colocar huevo
            const tutorialHandler = (e) => {
                console.log('üëÜ Toque detectado en tutorial');
                
                // Cerrar tutorial inmediatamente
                tutorialScreen.style.display = 'none';
                
                // Colocar huevo en el centro (o donde toc√≥ si es en canvas)
                let x = window.innerWidth / 2;
                let y = window.innerHeight / 2;
                
                // Si toc√≥ en el canvas, usar esa posici√≥n
                if (e.target.id === 'gameCanvas') {
                    const rect = e.target.getBoundingClientRect();
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                if (game) {
                    game.placeFirstEgg(x, y);
                }
                
                // Remover listener del tutorial
                document.removeEventListener('click', tutorialHandler);
                
                console.log('ü•ö Primer huevo colocado - Tutorial cerrado');
            };
            
            // Escuchar toques en TODA la pantalla
            document.addEventListener('click', tutorialHandler);
        }
        
        // ‚öôÔ∏è Configurar eventos globales
        function setupGlobalEvents() {
            // Badge de turbo
            const turboBadge = document.getElementById('turboBadge');
            
            // Escuchar eventos del juego
            document.addEventListener('turboStart', () => {
                turboBadge.classList.add('active');
            });
            
            document.addEventListener('turboEnd', () => {
                turboBadge.classList.remove('active');
            });
            
            // Prevenir zoom en m√≥viles
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            
            // Debug info (solo en desarrollo)
            if (window.location.hostname === 'localhost') {
                setupDebugInfo();
            }
            
            // üîä BOT√ìN DE VOLUMEN
            const volumeBtn = document.getElementById('volumeBtn');
            if (volumeBtn && audioManager) {
                volumeBtn.addEventListener('click', () => {
                    audioManager.toggleMute();
                    console.log('üîä Bot√≥n de volumen clickeado');
                });
                
                // Inicializar estado del bot√≥n
                audioManager.updateVolumeButton();
                
                // üéµ M√öSICA SE INICIA AUTOM√ÅTICAMENTE AL HACER CLICK EN "¬°Cuidar mi huevo!"
                // (Ya no necesitamos listeners gen√©ricos)
            }
            
        // Event listeners de la cabecera
        setupHeaderEvents();
        }
        
        // üèÜ Configurar eventos de cabecera
        function setupHeaderEvents() {
            console.log('üîß Configurando eventos de cabecera...');
            
            // Verificar que el bot√≥n existe
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            
            console.log('üéÆ Bot√≥n de jugar encontrado:', !!playBtn);
            console.log('üéÆ Modal de juegos encontrada:', !!gamesModal);
            
            if (!playBtn) {
                console.error('‚ùå Bot√≥n playButton no encontrado!');
                return;
            }
            
            if (!gamesModal) {
                console.error('‚ùå Modal gamesModal no encontrada!');
                return;
            }
            
            // Bot√≥n de jugar
            playBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('üéÆ ¬°CLICK EN BOT√ìN JUGAR DETECTADO!');
                
                // Abrir modal directamente
                console.log('üéÆ Abriendo modal de juegos...');
                gamesModal.style.display = 'flex';
                
                // Forzar la animaci√≥n
                requestAnimationFrame(() => {
                    gamesModal.style.opacity = '1';
                });
                
                console.log('üéÆ Modal abierta, display:', gamesModal.style.display);
            });
            
            // Bot√≥n de inventario
            document.getElementById('inventoryButton').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de items
                if (window.game) {
                    window.game.updateInventoryAvailability?.();
                }
            });
            
            // Cerrar inventario con animaci√≥n
            document.getElementById('closeInventory').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar juegos con animaci√≥n
            document.getElementById('closeGames').addEventListener('click', () => {
                const modal = document.getElementById('gamesModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Event listeners para las tarjetas de juegos cuadradas
            document.querySelectorAll('.game-card-square').forEach(card => {
                card.addEventListener('click', () => {
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('gamesModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            window.game.startGame(gameId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showGameLocked(starsNeeded);
                    }
                });
            });
            
            // Event listeners para las tarjetas de inventario cuadradas
            document.querySelectorAll('.inventory-item-square').forEach(card => {
                card.addEventListener('click', () => {
                    const itemId = card.dataset.item;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéí Usando item: ${itemId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('inventoryModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            // Aqu√≠ puedes a√±adir la l√≥gica para usar el item
                            window.game.useInventoryItem?.(itemId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Item bloqueado: ${itemId}`);
                        // Mostrar mensaje de item bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showItemLocked?.(starsNeeded);
                    }
                });
            });
            
            // Bot√≥n de √°lbum
            document.getElementById('albumButton').addEventListener('click', () => {
                if (game) {
                    game.showAlbum();
                }
            });

            // Bot√≥n de reset (calavera)
            document.getElementById('resetButton').addEventListener('click', () => {
                if (game) {
                    game.showResetModal();
                }
            });
            
            // üçé BOT√ìN DE ALIMENTACI√ìN (UNA BOLITA COMO EN ORIGINAL)
            document.getElementById('feedBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('‚ùå Bot√≥n de comida DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish && !game.fish.isDepressed) {
                    game.dropFood(); // UNA SOLA BOLITA
                    console.log('üçé Una bolita peque√±a soltada');
                }
            });
            
            // üßπ BOT√ìN DE LIMPIEZA
            document.getElementById('cleanBtn').addEventListener('click', (e) => {
                const button = e.target.closest('.menu-btn');
                if (button && button.classList.contains('disabled')) {
                    console.log('‚ùå Bot√≥n de limpieza DESHABILITADO - No hacer nada');
                    return;
                }
                if (game && game.fish && !game.fish.isDepressed) {
                    game.startCleaning();
                    console.log('üßπ Limpiando la pecera...');
                }
            });
            
            // üíä BOT√ìN DE MEDICINA
            // üíä BOT√ìN DE MEDICINA - ELIMINADO (YA NO SE USA)
            
            // Bot√≥n de reset se a√±ade din√°micamente
            
            // Cerrar √°lbum
            document.getElementById('closeAlbum').addEventListener('click', () => {
                document.getElementById('albumModal').style.display = 'none';
            });
            
            // üéÆ MODAL DE JUEGOS
            document.getElementById('playButton').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'flex';
                console.log('üéÆ Modal de juegos abierta');
            });
            
            document.getElementById('closeGames').addEventListener('click', () => {
                document.getElementById('gamesModal').style.display = 'none';
                console.log('üéÆ Modal de juegos cerrada');
            });
            
            // ü´ß JUEGO DE BURBUJAS
            document.querySelector('[data-game="bubbles"]').addEventListener('click', () => {
                startBubbleGame();
            });
            
            // üíé JUEGO DE BLOQUES (MAR MATCH-3)
            document.querySelector('[data-game="bloques"]').addEventListener('click', () => {
                startBloquesGame();
            });
            
            // üß† JUEGO DE MEMORIA
            document.querySelector('[data-game="memoria"]').addEventListener('click', () => {
                startMemoriaGame();
            });
            
            // üéµ JUEGO DE SIM√ìN MARINO
            document.querySelector('[data-game="simon"]').addEventListener('click', () => {
                startSimonGame();
            });
            
            // üê¨ JUEGO DEL CARRIL DEL DELF√çN
            document.querySelector('[data-game="carril"]').addEventListener('click', () => {
                startCarrilGame();
            });
            
            // üêâ JUEGO DEL DRAG√ìN MARINO
            document.querySelector('[data-game="correr"]').addEventListener('click', () => {
                startCorrerGame();
            });
            
            // üéØ JUEGO DE CAZA DE PECES
            document.querySelector('[data-game="caza"]').addEventListener('click', () => {
                startCazaGame();
            });
            
            // üåä JUEGO DE SECUENCIA DE MAREAS
            document.querySelector('[data-game="secuencia"]').addEventListener('click', () => {
                startSecuenciaGame();
            });
            
            // üèñÔ∏è JUEGO DE TOCA-3 MARINO
            document.querySelector('[data-game="toca3"]').addEventListener('click', () => {
                startToca3Game();
            });
            
            // Tabs del inventario y juegos (sistema unificado)
            document.querySelectorAll('.game-tab-btn, .tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    const modalContainer = btn.closest('.game-modal-content') || btn.closest('.modal-content');
                    
                    if (modalContainer) {
                        // Cambiar tab activo en el modal espec√≠fico
                        modalContainer.querySelectorAll('.game-tab-btn, .tab-btn').forEach(b => b.classList.remove('active'));
                        modalContainer.querySelectorAll('.game-tab-content, .tab-content').forEach(c => c.classList.remove('active'));
                    
                    btn.classList.add('active');
                        const targetTab = document.getElementById(tab + '-tab');
                        if (targetTab) {
                            targetTab.classList.add('active');
                        }
                    }
                });
            });
            
            // Botones de jugar en las modales mejoradas
            document.querySelectorAll('.game-play-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const gameId = btn.dataset.game;
                    if (gameId && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        window.game.startGame(gameId);
                    }
                });
            });
        }
        
        // üîß Configurar barra de debug
        function setupDebugInfo() {
            const debugBar = document.getElementById('debugBar');
            const debugInfo = document.getElementById('debugInfo');
            debugBar.style.display = 'flex';
            
            // Actualizar info cada segundo
            setInterval(() => {
                if (game) {
                    const info = game.getGameInfo();
                    const elapsed = info.eggTime || 0;
                    const hours = Math.floor(elapsed / (1000 * 60 * 60));
                    const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
                    
                    // Debug expandido con necesidades y edad
                    const hungerHours = Math.floor((Date.now() - game.gameState.lastFeed) / (1000 * 60 * 60));
                    const playHours = Math.floor((Date.now() - game.gameState.lastPlay) / (1000 * 60 * 60));
                    const cleanHours = Math.floor((Date.now() - game.gameState.lastClean) / (1000 * 60 * 60));
                    
                    debugInfo.innerHTML = `${Math.round(1 / (game.deltaTime || 0.016))}fps`;
                }
            }, 1000);
            
            // BOTONES DE DEBUG
            document.getElementById('debugResetBtn').addEventListener('click', () => {
                if (confirm('üîÑ ¬øResetear todo el juego?')) {
                    console.log('üîÑ Reseteando juego completo...');
                    
                    // Limpiar TODO el localStorage AGRESIVAMENTE
                    console.log('üßπ LIMPIEZA TOTAL del localStorage...');
                    localStorage.removeItem('miPececito_gameState');
                    localStorage.removeItem('miPececito_gameData');
                    localStorage.removeItem('miPececito_hasPlayed');
                    localStorage.removeItem('bubbleGame_personalRecord');
                    localStorage.removeItem('bubbleGame_globalRecord');
                    localStorage.clear(); // Por si hay m√°s
                    console.log('‚úÖ localStorage completamente limpio');
                    
                    // Recargar p√°gina para volver al inicio
                    setTimeout(() => {
                        location.reload();
                    }, 100);
                }
            });
            
            document.getElementById('forceHatchBtn').addEventListener('click', () => {
                if (game) {
                    game.setEggTimeToFinalSeconds(); // Ir a los √∫ltimos 5 segundos
                    console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
                }
            });
            
            
            document.getElementById('addBubblesBtn').addEventListener('click', () => {
                if (game) {
                    game.addCurrency('bubbles', 100);
                    console.log('üí∞ +100 burbujas');
                }
            });
            
            document.getElementById('addStarsBtn').addEventListener('click', () => {
                if (game) {
                    game.addCurrency('stars', 10);
                    console.log('‚≠ê +10 estrellas');
                }
            });
            
            document.getElementById('timeAdvanceBtn').addEventListener('click', () => {
                if (game) {
                    // Simular el paso de 1 hora (3600 segundos) de necesidades
                    const oneHourInSeconds = 3600;
                    game.updateAutoNeeds(oneHourInSeconds);
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('‚è∞ Simulado +1 hora de necesidades');
                    console.log('üìä Nuevos valores:', 
                        'Hambre:', game.gameState.needs.hunger.toFixed(1),
                        'Suciedad:', game.gameState.needs.dirt.toFixed(1), 
                        'Diversi√≥n:', game.gameState.needs.fun.toFixed(1));
                }
            });
            
            // üçé M√ÅXIMA COMIDA
            document.getElementById('maxFoodBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.hunger = 0; // Sin hambre
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üçé Pez alimentado al M√ÅXIMO (hambre = 0)');
                }
            });
            
            // üßπ M√ÅXIMA LIMPIEZA
            document.getElementById('maxCleanBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.dirt = 0; // S√∫per limpio
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üßπ Pecera S√öPER LIMPIA (suciedad = 0)');
                }
            });
            
            // ü¶† M√ÅXIMA SUCIEDAD
            document.getElementById('maxDirtBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.dirt = 100; // S√∫per sucio
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('ü¶† Pecera S√öPER SUCIA (suciedad = 100) - Deber√≠a verse efecto visual');
                }
            });
            
            // üò¢ M√çNIMA DIVERSI√ìN
            document.getElementById('minFunBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.fun = 0; // S√∫per aburrido
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üò¢ Pez S√öPER ABURRIDO (diversi√≥n = 0)');
                }
            });
            
            // üéÆ SIMULAR JUEGO
            document.getElementById('simulatePlayBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.fun = Math.min(100, game.gameState.needs.fun + 30); // +30 diversi√≥n
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    // Sin recompensas autom√°ticas - solo por jugar realmente
                    // game.addCurrency('bubbles', 5);
                    // game.addCurrency('stars', 1);
                    console.log('üéÆ SIMULADO: Pez ha jugado (+30 diversi√≥n, +5 burbujas, +1 estrella)');
                }
            });
        }
        
        // üéØ Manejar errores globales
        window.addEventListener('error', (e) => {
            console.error('‚ùå Error global:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('‚ùå Promesa rechazada:', e.reason);
        });
        
        // üöÄ Iniciar cuando la p√°gina est√© lista
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // üéÆ SISTEMA COMPLETO DE JUEGO
        class CompleteGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // ü´ß CAPA OFFSCREEN PARA BURBUJAS (FIX DPR)
                this.bubLayer = null;
                this.bubCtx = null;
                
                this.setupCanvas();
                this.ensureBubLayer(); // INICIALIZAR CAPA OFFSCREEN
                
                // Estado del juego
                this.gameState = {
                    stage: 'waiting', // NUEVO: Esperando a colocar huevo
                    eggStartTime: null, // NO hay tiempo hasta colocar huevo
                    bubbles: 0,   // EMPEZAR SIN BURBUJAS
                    stars: 0,     // Sin estrellas al inicio
                    currentBackground: 'basic',
                    bubblesCreated: false,
                    
                    // üìä SISTEMA DE NECESIDADES REALISTA (0-100)
                    needs: {
                        hunger: 80,  // Beb√© nace con hambre (normal)
                        dirt: 0,     // PANTALLA LIMPIA AL INICIAR 
                        fun: 95      // EMPIEZA FELIZ
                    },
                    
                    // üö® FLAGS DE CRISIS (75+ es crisis)
                    crisis: {
                        hunger: false,
                        dirt: false, 
                        bored: false
                    },
                    
                    // Sistema de edad
                    birthDate: null,
                    ageInDays: 0,
                    // Nombre del pez
                    fishName: null,
                    hasAskedForName: false,
                    // Sistema de √°lbum/diario
                    album: [],
                    lastEventTime: Date.now()
                };
                
                // üö´ VARIABLES DE CONTROL ELIMINADAS - YA NO SE NECESITAN
                
                // Sistema de huevo
                this.egg = {
                    x: 0, y: 0,
                    floatTime: 0,
                    bobSpeed: 2,
                    bobAmount: 8
                };
                
                // Im√°genes del huevo
                this.eggImages = {};
                this.bgImage = null;
                this.loadAssets();
                
                // Efectos
                this.bgBubbles = [];
                this.explosionBubbles = [];
                this.lightRays = [];
                this.explosionHappened = false;
                
                // üçé ARRAYS DEL SISTEMA REALISTA
                this.food = [];           // Comida que cae
                this.cleanBubbles = [];   // Burbujas de limpieza  
                this.tinyBubbles = [];    // Burbujas de respiraci√≥n
                this.flyers = [];         // Corazones voladores
                this.ripples = [];        // Ondas de click
                this.labels = [];         // Textos flotantes
                
                // üßπ ESTADO DE LIMPIEZA
                this.cleaningActive = false;
                this.cleanEmitT = 0;
                this.cleanDur = 2.6;
                this.dirtStart = 0;
                
                // ‚è∞ TIEMPO DEL JUEGO (para animaciones)
                this.gameTime = 0;
                
                // Burbujas de necesidades
                this.needBubbles = [];
                
                // Pez
                this.fish = null;
                this.lottieAnimation = null;
                
                this.setupBubbles();
                
                // NUNCA cargar datos en primera vez
                const isFirstTime = !localStorage.getItem('miPececito_hasPlayed');
                if (isFirstTime) {
                    console.log('üéâ Primera vez - Empezar completamente limpio');
                    // NO cargar nada, mantener estado inicial 'waiting'
                } else {
                    // Solo cargar si es veterano
                    if (!this.loadGame()) {
                        console.log('üÜï Veterano sin datos - empezar nuevo');
                    }
                }
                
                // Cargar fondos disponibles
                this.availableBackgrounds = [];
                this.loadAvailableBackgrounds();
                
                this.startLoop();
                this.startAutoSave();
                this.updateUI();
            }
            
            setupCanvas() {
                const resize = () => {
                    // VERSI√ìN SIMPLE QUE FUNCIONABA
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 130; // 70px header + 60px botones
                    
                    // CANVAS SIEMPRE DESDE EL HEADER (SIN ESPACIO AZUL)
                    this.canvas.style.top = '70px'; // SIEMPRE PEGADO AL HEADER
                    this.canvas.style.position = 'fixed';
                    this.canvas.style.left = '0';
                    this.canvas.style.right = '0';
                    this.canvas.style.bottom = '60px'; // Espacio para botones compactos
                };
                window.addEventListener('resize', resize);
                resize();
                
                // A√ëADIR EVENT LISTENER PARA CLICK EN CANVAS
                this.canvas.addEventListener('click', (event) => {
                    this.handleCanvasClick(event);
                });
                
                console.log('üëÜ Click en canvas habilitado - El pez vendr√° a tu dedo');
            }
            
            async loadAssets() {
                console.log('üìÅ Cargando assets...');
                
                // Cargar im√°genes del huevo
                const eggStages = ['00', '01', '02', '03', '04'];
                for (const stage of eggStages) {
                    try {
                        const img = new Image();
                        img.src = `./images/fish/egg_${stage}_clean.png`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                        });
                        this.eggImages[stage] = img;
                        console.log(`‚úÖ Cargado: egg_${stage}_clean.png`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar egg_${stage}_clean.png`);
                    }
                }
                
                // Cargar fondo
                try {
                    this.bgImage = new Image();
                    this.bgImage.src = './images/backgrounds/bg_basic.png';
                    await new Promise((resolve, reject) => {
                        this.bgImage.onload = resolve;
                        this.bgImage.onerror = reject;
                    });
                    console.log('‚úÖ Fondo cargado: bg_basic.png');
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo cargar bg_basic.png');
                }
            }
            
            setupBubbles() {
                // Burbujas de fondo
                for (let i = 0; i < 15; i++) {
                    this.bgBubbles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        r: 1 + Math.random() * 4,
                        speed: 20 + Math.random() * 30,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            startLoop() {
                let lastTime = 0;
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
            
            update(deltaTime) {
                this.gameTime += deltaTime; // Actualizar tiempo del juego
                
                // Posici√≥n del huevo (centro de la pantalla)
                this.egg.x = this.canvas.width / 2;
                this.egg.y = this.canvas.height * 0.6;
                this.egg.floatTime += deltaTime;
                
                // Burbujas de fondo
                for (const bubble of this.bgBubbles) {
                    bubble.y -= bubble.speed * deltaTime;
                    if (bubble.y < 0) {
                        bubble.y = this.canvas.height + 10;
                        bubble.x = Math.random() * this.canvas.width;
                    }
                }
                
                // Actualizar burbujas de explosi√≥n
                for (let i = this.explosionBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.explosionBubbles[i];
                    bubble.x += bubble.vx * deltaTime;
                    bubble.y += bubble.vy * deltaTime;
                    bubble.life -= deltaTime;
                    
                    if (bubble.life <= 0) {
                        this.explosionBubbles.splice(i, 1);
                    }
                }
                
                // Actualizar rayos de luz
                for (let i = this.lightRays.length - 1; i >= 0; i--) {
                    const ray = this.lightRays[i];
                    ray.length = Math.min(ray.length + 200 * deltaTime, ray.maxLength);
                    ray.life -= deltaTime;
                    
                    if (ray.life <= 0) {
                        this.lightRays.splice(i, 1);
                    }
                }
                
                // L√≥gica de eclosi√≥n (solo si hay huevo colocado)
                if (this.gameState.stage === 'egg' && this.gameState.eggStartTime) {
                    const elapsed = Date.now() - this.gameState.eggStartTime;
                    const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                    
                    if (elapsed >= total) {
                        this.startHatching();
                    }
                }
                
                // Movimiento del pez (todas las etapas)
                if (this.fish && (this.gameState.stage === 'baby' || this.gameState.stage === 'young' || this.gameState.stage === 'adult')) {
                    // üöÄ SISTEMA REALISTA COMPLETO
                    this.updateAutoNeeds(deltaTime);      // Necesidades autom√°ticas
                    this.updateCrisisFlags();             // Flags de crisis
                    this.updateFood(deltaTime);           // üçé COMIDA DEL DOCUMENTO
                    this.updateCleaning(deltaTime);       // üßπ LIMPIEZA ESPECTACULAR
                    this.updateFishMovement(deltaTime);    // Movimiento realista
                    this.updateTinyBubbles(deltaTime);     // Burbujas de respiraci√≥n
                    this.updateFlyers(deltaTime);          // Corazones voladores
                    this.updateLabels(deltaTime);          // üçé LABELS ("√ëam")
                    
                    // Actualizar UI cada pocos segundos
                    if (Math.random() < 0.05) { // M√ÅS FRECUENTE PARA DEBUG (era 0.01)
                        this.updateUI();
                        this.checkForAlbumEvents(); // Verificar eventos del √°lbum
                        this.checkEvolution(); // Verificar evoluci√≥n
                    }
                }
                
                // Actualizar burbujas de necesidades (DESACTIVADO - ICONOS SOBRAN)
                // for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                //     const bubble = this.needBubbles[i];
                //     bubble.life -= deltaTime;
                //     bubble.y += Math.sin(bubble.life * 3) * 10 * deltaTime;
                //     
                //     if (bubble.life <= 0) {
                //         this.needBubbles.splice(i, 1);
                //     }
                // }
            }
            
        render() {
            // üéØ VOLVER AL SISTEMA SIMPLE QUE FUNCIONABA
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.globalCompositeOperation = 'source-over';
                
                // Fondo (coordenadas f√≠sicas normales)
                if (this.bgImage && this.bgImage.complete) {
                    this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo degradado como fallback
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#0b1b2b');
                    gradient.addColorStop(1, '#133754');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // ‚ú® EFECTOS M√ÅGICOS: MUCHAS BURBUJITAS QUE TAPAN EL HUEVO
                if (this.gameState.stage === 'egg' && this.gameState.showMagicBubbles) {
                    this.ctx.save();
                    
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const time = Date.now() * 0.001;
                    const effectTime = time - (this.gameState.magicStartTime || time);
                    
                    // FASE 1: MUCH√çSIMAS burbujitas peque√±as que TAPAN todo (primeros 2 segundos)
                    if (effectTime < 2) {
                        const density = Math.max(0, 1 - effectTime / 2); // Se reduce con el tiempo
                        const numBubbles = Math.floor(800 * density); // 800 ‚Üí 0 burbujas (EXPLOSI√ìN MASIVA)
                        
                        // CAPA 1: Burbujas grandes de fondo
                        for (let i = 0; i < Math.floor(numBubbles * 0.3); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 140;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 15 + Math.random() * 10; // Grandes (15-25px)
                            
                            this.ctx.globalAlpha = 0.3 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${180 + Math.random() * 60}, 70%, ${70 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 12;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 2: Burbujas medianas
                        for (let i = 0; i < Math.floor(numBubbles * 0.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 100;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 8 + Math.random() * 8; // Medianas (8-16px)
                            
                            this.ctx.globalAlpha = 0.5 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${190 + Math.random() * 40}, 80%, ${65 + Math.random() * 25}%)`;
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 3: Burbujitas peque√±as (las que m√°s tapan)
                        for (let i = 0; i < Math.floor(numBubbles * 0.7); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 3 + Math.random() * 6; // Peque√±itas (3-9px)
                            
                            this.ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${60 + Math.random() * 30}%)`;
                            
                            // Muchas con brillo
                            if (Math.random() > 0.5) {
                                this.ctx.shadowBlur = 4;
                                this.ctx.shadowColor = this.ctx.fillStyle;
                            } else {
                                this.ctx.shadowBlur = 0;
                            }
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 4: Micro-burbujas como las del agua (MUCH√çSIMAS)
                        for (let i = 0; i < Math.floor(numBubbles * 1.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance + (Math.random() - 0.5) * 30;
                            const y = centerY + Math.sin(angle) * distance + (Math.random() - 0.5) * 30;
                            const size = 0.5 + Math.random() * 2; // Micro-burbujas (0.5-2.5px)
                            
                            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${75 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 1;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 5: Espuma densa (como burbujas de jab√≥n)
                        for (let i = 0; i < Math.floor(numBubbles * 2); i++) {
                            const x = centerX + (Math.random() - 0.5) * 160;
                            const y = centerY + (Math.random() - 0.5) * 160;
                            const size = 0.3 + Math.random() * 1.5; // S√∫per micro (0.3-1.8px)
                            
                            this.ctx.globalAlpha = 0.4 + Math.random() * 0.3;
                            this.ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#f0f8ff';
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    // FASE 2: Burbujas decorativas flotantes (despu√©s de 1.5s)
                    if (effectTime > 1.5) {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + time * 0.3;
                            const distance = 100 + Math.sin(time * 2 + i) * 40;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance + Math.sin(time * 1.5 + i) * 25;
                            const size = 8 + Math.sin(time * 4 + i) * 4;
                            
                            this.ctx.globalAlpha = 0.5 + Math.sin(time * 3 + i) * 0.3;
                            this.ctx.fillStyle = i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#add8e6' : '#b0e0e6';
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // ü´ß BURBUJITAS SUTILES DEL AGUA (AMBIENTE)
                this.drawAmbientBubbles();
                
                // üçé DIBUJAR COMIDA ANTES DEL PEZ (COMO DICE CHAT)
                this.drawFood();
                
                // Burbujas de fondo (sistema original - REACTIVADO)
                this.drawBackgroundBubbles();
                
                // Haces de luz ocasionales durante el juego
                this.drawOccasionalLightRays();
                
                // Efecto de suciedad en toda la pecera
                this.drawDirtyEffect();
                
                // Huevo (solo si est√° en stage 'egg')
                if (this.gameState.stage === 'egg') {
                    this.drawEgg();
                    this.drawEggTimer(); // Timer bonito en pantalla
                } else if (this.gameState.stage === 'waiting') {
                    // ESPERANDO: No hacer nada, solo esperar click del usuario
                }
                
                // Burbujas de explosi√≥n
                this.drawExplosionBubbles();
                
                // Pez (solo si no es Lottie)
                if (this.fish && !this.fish.isLottie) {
                    this.drawFish();
                }
                
                // Actualizar posici√≥n del Lottie
                if (this.fish && this.fish.isLottie) {
                    this.updateLottiePosition();
                }
                
                // Part√≠culas de comida (DESACTIVADO - CONFLICTO)
                // this.drawFoodParticles();
                
                // Comida cayendo (DESACTIVADO - CONFLICTO)  
                // this.drawFallingFood();
                
                // Burbujas de limpieza
                this.drawCleaningBubbles();
                
                // Burbujas de necesidades (DESACTIVADAS)
                // this.drawNeedBubbles();
                
                // Efectos de comer (DESACTIVADOS)
                // this.drawEatingEffects();
                
                // Textos flotantes (DESACTIVADOS)
                // this.drawFloatingTexts();
                
                // Burbujas de necesidades (DESACTIVADAS)  
                // this.drawNeedBubbles();
                
                // üßπ DIBUJAR BURBUJAS SIMPLE (REVERTIR A VERSI√ìN QUE FUNCIONABA)
                this.drawCleanBubbles();
                
                // üíñ DIBUJAR CORAZONES VOLADORES
                this.drawFlyers();
                
                // üçé DIBUJAR LABELS ("√ëam") ENCIMA DE TODO
                this.drawLabels();
                
                // üçé COMIDA YA SE DIBUJA ANTES DEL PEZ (L√çNEA 3743)
            }
            
            // üñåÔ∏è M√âTODOS DE RENDERIZADO
            
            drawBackgroundBubbles() {
                // SISTEMA SIMPLE Y FUNCIONAL
                this.ctx.save();
                
                for (let i = this.bgBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bgBubbles[i];
                    
                    // ü´ß TODAS LAS BURBUJAS (TEST + NUEVAS + EFECTOS)
                    if (bubble.isTestBubble || bubble.type) {
                        // Actualizar posici√≥n
                        bubble.x += bubble.vx * 0.016; // deltaTime aproximado
                        bubble.y += bubble.vy * 0.016;
                        
                        // Actualizar vida (compatible con ambos sistemas)
                        if (bubble.maxLife) {
                            bubble.life += 0.016; // Incrementar para nuevas burbujas
                        } else {
                            bubble.life--; // Decrementar para burbujas viejas
                        }
                        
                        // Eliminar si se acab√≥ la vida (compatible con ambos sistemas)
                        const shouldRemove = bubble.maxLife ? 
                            (bubble.life >= bubble.maxLife) : // Nuevas: life >= maxLife
                            (bubble.life <= 0); // Viejas: life <= 0
                            
                        if (shouldRemove) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar burbuja
                        this.ctx.save();
                        
                        if (bubble.sparkle) {
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = bubble.color;
                        }
                        
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 0.8;
                        this.ctx.fillStyle = bubble.color;
                        this.ctx.beginPath();
                        this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                        continue;
                    }
                    
                    // üéÜ SISTEMA VIEJO (APARICI√ìN)
                    if (bubble.isAppearanceEffect) {
                        bubble.x += bubble.vx;
                        bubble.y += bubble.vy;
                        bubble.life -= 16.67; // ~60fps
                        
                        // Eliminar si se acab√≥ la vida (EXCEPTO inmortales)
                        if (bubble.life <= 0 && !bubble.immortal) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Calcular alpha basado en vida restante
                        const maxLife = bubble.maxLife || 3000; // Fallback
                        const lifeRatio = bubble.life / maxLife;
                        bubble.opacity = (bubble.alpha || 1) * lifeRatio;
                    }
                    
                    this.ctx.save();
                    
                    // üéÜ EFECTO DE BRILLO PARA PART√çCULAS M√ÅGICAS
                    if (bubble.sparkle) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = bubble.color || '#ffd700';
                        
                        // Brillo pulsante
                        const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                        this.ctx.globalAlpha = (bubble.alpha || bubble.opacity || 1) * pulse;
                    } else {
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 1;
                    }
                    
                    this.ctx.fillStyle = bubble.color || '#87ceeb';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size || bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // DEBUG: Log de burbujas rojas de aparici√≥n (DESACTIVADO)
                    // if (bubble.isAppearanceEffect && bubble.color === '#ff0000') {
                    //     console.log(`üî¥ DIBUJANDO burbuja roja en (${bubble.x.toFixed(0)}, ${bubble.y.toFixed(0)}) tama√±o ${bubble.r}`);
                    // }
                    this.ctx.restore();
                }
                
                this.ctx.restore(); // CERRAR SAVE INICIAL
            }
            
            drawEgg() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 horas
                const progress = Math.min(elapsed / total, 1);
                
                // üéÜ ANIMACI√ìN SUAVE: SOLO FADE (SIN ESCALA BRUSCA)
                if (this.egg.appearing) {
                    // Solo fade in gradual (sin escala)
                    if (this.egg.alpha < this.egg.targetAlpha) {
                        this.egg.alpha += this.egg.fadeSpeed * 0.016; // Suave y controlado
                    }
                    
                    // Terminar animaci√≥n cuando est√© opaco
                    if (this.egg.alpha >= this.egg.targetAlpha) {
                        this.egg.appearing = false;
                        this.egg.alpha = 1;
                        console.log('‚ú® Animaci√≥n suave completada');
                    }
                }
                
                // Obtener imagen correcta del huevo CON TRANSICI√ìN
                const currentImage = this.getCurrentEggImage(progress);
                
                // üé≠ DETECTAR CAMBIO DE HUEVO Y HACER TRANSICI√ìN
                if (!this.egg.lastImage) this.egg.lastImage = currentImage;
                if (currentImage !== this.egg.lastImage) {
                    console.log('ü•ö ¬°Huevo evolucionando! Transici√≥n suave...');
                    this.egg.lastImage = currentImage;
                    this.createEggTransitionEffect();
                }
                
                if (currentImage) {
                    // Animaci√≥n de flotaci√≥n
                    const floatOffset = Math.sin(this.egg.floatTime * this.egg.bobSpeed) * this.egg.bobAmount;
                    const drawY = this.egg.y + floatOffset;
                    
                    // TEMBLOR cuando se acerca la eclosi√≥n
                    let shakeX = 0;
                    let shakeY = 0;
                    
                    if (progress > 0.85) { // √öltimos 15% = 3.6 horas
                        const shakeIntensity = (progress - 0.85) / 0.15; // 0 a 1
                        const maxShake = 6;
                        
                        shakeX = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        shakeY = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        
                        // Temblor INTENSO en los √∫ltimos segundos
                        if (progress > 0.98) { // √öltimos 2%
                            shakeX *= 2.5;
                            shakeY *= 2.5;
                        }
                    }
                    
                    // Dibujar huevo M√ÅS GRANDE - USAR CSS VARIABLE
                    const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                    const eggWidth = eggSize; // Usar variable CSS
                    const eggHeight = eggSize; // Cuadrado perfecto
                    
                    this.ctx.save();
                    
                    // üéÜ APLICAR ANIMACI√ìN DE APARICI√ìN
                    const scale = this.egg.scale || 1;
                    const alpha = this.egg.alpha || 1;
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.translate(this.egg.x + shakeX, drawY + shakeY);
                    this.ctx.scale(scale, scale);
                    
                    this.ctx.drawImage(
                        currentImage,
                        -eggWidth/2,
                        -eggHeight/2,
                        eggWidth,
                        eggHeight
                    );
                    
                    // ü´ß BURBUJITAS SUTILES DE GESTACI√ìN
                    this.drawEggGestationBubbles();
                    
                    // üéÜ CHISPORROTEO ALREDEDOR (COMO HIRVIENDO)
                    this.drawEggSizzleEffect();
                    
                    this.ctx.restore();
                } else {
                    // Fallback: huevo dibujado M√ÅS GRANDE
                    this.ctx.fillStyle = '#8ad7ff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(this.egg.x, this.egg.y, 50, 60, 0, 0, Math.PI * 2); // M√°s grande
                    this.ctx.fill();
                }
            }
            
            getCurrentEggImage(progress) {
                // ü•ö CADA MINUTO CAMBIA DE HUEVO (5 huevos en 5 minutos)
                if (progress < 0.2) return this.eggImages['00']; // Minuto 0-1
                if (progress < 0.4) return this.eggImages['01']; // Minuto 1-2  
                if (progress < 0.6) return this.eggImages['02']; // Minuto 2-3
                if (progress < 0.8) return this.eggImages['03']; // Minuto 3-4
                return this.eggImages['04']; // Minuto 4-5 (eclosi√≥n)
            }
            
            // ‚ú® EFECTOS SUAVES PARA APARICI√ìN DEL HUEVO
            createSoftEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // üåà PART√çCULAS DE COLORES SUAVES (como nacimiento del pez pero diferentes)
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (20 + Math.random() * 30),
                        vy: Math.sin(angle) * (20 + Math.random() * 30),
                        r: 3 + Math.random() * 4,
                        life: 0,
                        maxLife: 3 + Math.random() * 2,
                        opacity: 0.7 + Math.random() * 0.3,
                        color: i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#b0e0e6' : '#e0f6ff', // Azules suaves
                        type: 'soft-magic'
                    });
                }
                
                console.log('‚ú® 50 part√≠culas suaves creadas para el huevo');
            }
            
            // üé≠ EFECTO DE TRANSICI√ìN CUANDO CAMBIA EL HUEVO
            createEggTransitionEffect() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                // üåü PART√çCULAS DORADAS DE EVOLUCI√ìN (diferentes a las azules)
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * (10 + Math.random() * 15),
                        vy: Math.sin(angle) * (10 + Math.random() * 15) - 20, // Hacia arriba
                        r: 2 + Math.random() * 3,
                        life: 0,
                        maxLife: 1.5 + Math.random() * 1,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: i % 2 === 0 ? '#ffd700' : '#ffec8b', // Dorado suave
                        type: 'egg-evolution'
                    });
                }
                
                console.log('üåü Efecto de evoluci√≥n del huevo creado');
            }
            
            // üéÜ EXPLOSI√ìN DE BURBUJAS PARA APARICI√ìN DEL HUEVO (COMO NACIMIENTO)
            createEggExplosionBubbles() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('‚ú® Creando efecto de aparici√≥n del huevo (estilo nacimiento)');
                
                // LIMPIAR explosionBubbles para el huevo
                this.explosionBubbles.length = 0;
                
                // EXPLOSI√ìN DE BURBUJAS - VERSI√ìN HUEVO (colores diferentes)
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 80; // Velocidad variada
                    const size = 3 + Math.random() * 8; // Tama√±os variados
                    const life = 3 + Math.random() * 2; // Duraderas
                    
                    // Colores DORADOS y BLANCOS (diferentes al nacimiento)
                    const colors = ['#FFFFFF', '#FFF8DC', '#FFEBCD', '#F0E68C', '#FFD700', '#FFA500', '#FFEC8B'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: size,
                        life: life, // VIDA INICIAL
                        maxLife: life,
                        opacity: 0.8 + Math.random() * 0.2,
                        color: color,
                        type: 'egg-birth'
                    });
                }
                
                console.log('üéÜ 100 burbujas doradas creadas para aparici√≥n del huevo');
            }
            
            // üéÜ EFECTO CHISPORROTEO ALREDEDOR DEL HUEVO (COMO HIRVIENDO)
            drawEggSizzleEffect() {
                const time = Date.now() * 0.003; // Tiempo r√°pido para chispas
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                const radius = eggSize * 0.6; // Alrededor del huevo
                
                // üéá 8 CHISPAS ROTANDO ALREDEDOR
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time; // Rotaci√≥n
                    const sparkRadius = radius + Math.sin(time * 3 + i) * 8; // Vibraci√≥n
                    const x = Math.cos(angle) * sparkRadius;
                    const y = Math.sin(angle) * sparkRadius;
                    
                    // Chispa con transparencia variable
                    const opacity = 0.3 + Math.sin(time * 4 + i * 0.5) * 0.3;
                    const size = 2 + Math.sin(time * 5 + i) * 1;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = i % 2 === 0 ? '#ffeb3b' : '#ff9800'; // Amarillo/naranja
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // üî• PART√çCULAS ASCENDENTES (como vapor)
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const startRadius = radius * 0.8;
                    const x = Math.cos(angle) * startRadius;
                    const y = Math.sin(angle) * startRadius;
                    
                    this.bgBubbles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -20 - Math.random() * 15, // Hacia arriba
                        r: 1 + Math.random() * 2,
                        life: 0,
                        maxLife: 1 + Math.random() * 0.5,
                        opacity: 0.4 + Math.random() * 0.3,
                        color: '#fff8e1', // Vapor blanquecino
                        type: 'egg-sizzle'
                    });
                }
            }
            
            drawEggTimer() {
                if (this.gameState.stage !== 'egg' || !this.gameState.eggStartTime) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.gameState.eggStartTime;
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING // 24 HORAS
                const remaining = Math.max(0, total - elapsed);
                
                // DEBUG: Verificar que el tiempo avanza
                if (Math.random() < 0.02) { // Log m√°s frecuente para debug
                    console.log(`‚è∞ Timer Debug:`);
                    console.log(`   Current: ${new Date(currentTime).toLocaleTimeString()}`);
                    console.log(`   EggStart: ${new Date(this.gameState.eggStartTime).toLocaleTimeString()}`);
                    console.log(`   Elapsed: ${(elapsed/1000/60).toFixed(1)}min`);
                    console.log(`   Remaining: ${(remaining/1000/60).toFixed(1)}min`);
                }
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                // Progreso para efectos del cron√≥metro
                const timerProgress = elapsed / total;
                
                // CRON√ìMETRO BONITO EN PANTALLA
                const centerX = this.canvas.width / 2;
                const timerY = 80; // M√°s arriba y visible
                
                this.ctx.save();
                
                // CRON√ìMETRO SUTIL SIN FONDO NEGRO
                this.ctx.textAlign = 'center';
                
                // Sombra sutil para el texto
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 8;
                this.ctx.shadowOffsetY = 2;
                
                // T√≠tulo m√°s sutil SIN EMOJI
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 16px system-ui'; // Reducido para m√≥vil
                this.ctx.fillText('Nacer√° en:', centerX, timerY - 20);
                
                // Countdown principal
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 20px system-ui'; // Reducido para m√≥vil
                
                let timeText;
                if (hours > 0) {
                    timeText = `${hours}h ${minutes}m ${seconds}s`; // SIEMPRE mostrar segundos
                } else if (minutes > 0) {
                    timeText = `${minutes}m ${seconds}s`;
                } else {
                    // √öltimos segundos - MUY dram√°tico
                    this.ctx.fillStyle = remaining < 10000 ? '#ff6b6b' : '#ffeb3b';
                    timeText = `${seconds}s`;
                }
                
                this.ctx.fillText(timeText, centerX, timerY);
                
                this.ctx.restore();
            }
            
            drawLightRays() {
                for (const ray of this.lightRays) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height * 0.6;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.opacity * (ray.life / ray.maxLife);
                    this.ctx.strokeStyle = '#ffdd44';
                    this.ctx.lineWidth = ray.width;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffdd44';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(ray.angle) * ray.length,
                        centerY + Math.sin(ray.angle) * ray.length
                    );
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            // ‚ú® HACES DE LUZ OCASIONALES
            drawOccasionalLightRays() {
                // Inicializar timer de rayos si no existe
                if (!this.lightRayTimer) this.lightRayTimer = 0;
                if (!this.occasionalRays) this.occasionalRays = [];
                
                this.lightRayTimer += 1/60; // Asumiendo 60fps
                
                // Crear rayos ocasionalmente (cada 20-40 segundos)
                if (this.lightRayTimer > 20 + Math.random() * 20) {
                    this.createOccasionalLightRay();
                    this.lightRayTimer = 0;
                }
                
                // Dibujar y actualizar rayos existentes
                for (let i = this.occasionalRays.length - 1; i >= 0; i--) {
                    const ray = this.occasionalRays[i];
                    
                    // Actualizar rayo
                    ray.life -= 1/60;
                    ray.alpha = Math.max(0, ray.life / ray.maxLife);
                    
                    // Eliminar si expir√≥
                    if (ray.life <= 0) {
                        this.occasionalRays.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar REFLEJO SUTIL como luz real del sol
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.alpha * 0.08; // S√öPER sutil
                    this.ctx.globalCompositeOperation = 'lighter';
                    
                    const gradient = this.ctx.createLinearGradient(ray.x1, ray.y1, ray.x2, ray.y2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(0.2, 'rgba(255, 255, 240, 0.3)'); // Amarillo muy suave
                    gradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.4)'); // Azul casi transparente
                    gradient.addColorStop(0.8, 'rgba(255, 255, 240, 0.2)'); // Amarillo suave otra vez
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = ray.width * 0.8; // M√°s finos
                    this.ctx.shadowBlur = 1;
                    this.ctx.shadowColor = 'rgba(255, 255, 240, 0.2)';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(ray.x1, ray.y1);
                    this.ctx.lineTo(ray.x2, ray.y2);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
            }
            
            createOccasionalLightRay() {
                // Crear 2-4 REFLEJOS DEL SOL desde arriba
                const numRays = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numRays; i++) {
                    // Rayos vienen desde arriba con √°ngulos naturales
                    const startX = Math.random() * this.canvas.width;
                    const startY = -50; // Empiezan fuera de la pantalla arriba
                    
                    // √Ångulo hacia abajo con ligera inclinaci√≥n
                    const angle = Math.PI/2 + (Math.random() - 0.5) * 0.6; // 90¬∞ ¬± 30¬∞
                    const length = this.canvas.height + 100; // Atraviesan toda la pantalla
                    
                    const ray = {
                        x1: startX,
                        y1: startY,
                        x2: startX + Math.cos(angle) * length,
                        y2: startY + Math.sin(angle) * length,
                        width: 2 + Math.random() * 3,
                        life: 5 + Math.random() * 4, // M√°s duraderos
                        maxLife: 5 + Math.random() * 4,
                        alpha: 1
                    };
                    
                    this.occasionalRays.push(ray);
                }
                
                console.log(`‚òÄÔ∏è Reflejos del sol creados (${numRays} rayos desde arriba)`);
            }
            
            // ü¶† EFECTO DE SUCIEDAD UNIFICADO (BASADO EN BARRAS)
            drawDirtyEffect() {
                // USAR EL MISMO SISTEMA QUE LAS BARRAS
                const dirtValue = this.gameState.needs.dirt; // 0-100
                
                if (dirtValue > 15) { // Efecto visual m√°s temprano (era 30)
                    // Calcular nivel de suciedad (0 a 1)
                    const dirtLevel = Math.min((dirtValue - 15) / 85, 1); // Escala desde 15-100
                    
                    // Crear overlay de suciedad M√ÅS SUTIL
                    this.ctx.save();
                    this.ctx.globalAlpha = dirtLevel * 0.15; // M√°ximo 15% opacidad (m√°s sutil)
                    this.ctx.globalCompositeOperation = 'multiply';
                    
                    // Gradiente de suciedad
                    const gradient = this.ctx.createRadialGradient(
                        this.canvas.width / 2, this.canvas.height / 2, 0,
                        this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                    );
                    gradient.addColorStop(0, 'rgba(139, 115, 85, 0.2)'); // Marr√≥n claro centro
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)'); // Marr√≥n medio
                    gradient.addColorStop(1, 'rgba(62, 39, 35, 0.6)'); // Marr√≥n oscuro bordes
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Part√≠culas de suciedad flotando
                    if (!this.dirtParticles) this.dirtParticles = [];
                    
                    // Crear part√≠culas ocasionalmente
                    if (Math.random() < 0.02 * dirtLevel) {
                        this.dirtParticles.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            size: 1 + Math.random() * 3,
                            life: 5 + Math.random() * 5,
                            maxLife: 5 + Math.random() * 5,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10
                        });
                    }
                    
                    // Dibujar part√≠culas de suciedad
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = Math.min(0.9, dirtLevel * 2.0); // MUCHO M√ÅS OPACO
                    
                    for (let i = this.dirtParticles.length - 1; i >= 0; i--) {
                        const particle = this.dirtParticles[i];
                        
                        // Actualizar part√≠cula
                        particle.x += particle.vx * (1/60);
                        particle.y += particle.vy * (1/60);
                        particle.life -= 1/60;
                        
                        // Eliminar si expir√≥
                        if (particle.life <= 0) {
                            this.dirtParticles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar part√≠cula sucia
                        const alpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha = alpha * dirtLevel * 1.5; // MUCHO M√ÅS DENSA
                        this.ctx.fillStyle = '#8b7355';
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                    
                    // OVERLAY GENERAL DE SUCIEDAD (agua SUPER turbia como algas)
                    this.ctx.globalAlpha = Math.min(0.8, dirtLevel * 1.5); // MUCHO m√°s denso
                    
                    // Gradiente marr√≥n-verde como algas
                    const dirtGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    dirtGradient.addColorStop(0, 'rgba(139, 115, 85, 0.6)'); // Marr√≥n arriba
                    dirtGradient.addColorStop(0.5, 'rgba(101, 67, 33, 0.8)'); // Marr√≥n oscuro medio
                    dirtGradient.addColorStop(1, 'rgba(46, 125, 50, 0.7)'); // Verde algas abajo
                    
                    this.ctx.fillStyle = dirtGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.globalAlpha = 1;
                    
                    // Log ocasional
                    if (Math.random() < 0.005) {
                        console.log(`ü¶† Pecera sucia - Nivel: ${dirtValue.toFixed(1)}% (barra unificada)`);
                    }
                } else {
                    // Limpiar part√≠culas cuando no est√° sucio
                    if (this.dirtParticles) {
                        this.dirtParticles = [];
                    }
                }
            }
            
            drawExplosionBubbles() {
                for (const bubble of this.explosionBubbles) {
                    this.ctx.save();
                    
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha;
                    
                    if (bubble.isLight) {
                        // Part√≠culas de luz
                        this.ctx.fillStyle = '#ffeb3b';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#ffeb3b';
                    } else {
                        // Burbujas normales
                        this.ctx.fillStyle = `hsl(${200 + Math.random() * 60}, 70%, 80%)`;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(bubble.x - 1, bubble.y - 1, 2, 2);
                    }
                    
                    this.ctx.restore();
                }
            }
            
            drawFish() {
                if (!this.fish) return;
                
                const fish = this.fish;
                const size = fish.size;
                const colors = this.getFishColors();
                
                this.ctx.save();
                this.ctx.translate(fish.x, fish.y);
                this.ctx.rotate(-25 * Math.PI / 180); // Inclinaci√≥n del Lottie
                
                // ü´Å APLICAR RESPIRACI√ìN
                this.ctx.scale(fish.breatheScale, fish.breatheScale);
                
                // üêü COLA PRINCIPAL (forma exacta del Lottie)
                this.ctx.save();
                this.ctx.translate(-size * 0.8, 0);
                this.ctx.rotate(fish.finRotation); // Ondulaci√≥n -36¬∞ a +4¬∞
                
                this.ctx.fillStyle = colors.tail;
                this.ctx.beginPath();
                // Forma de cola del Lottie (m√°s org√°nica)
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.3, -size * 0.4, -size * 0.6, -size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.7, 0, -size * 0.6, size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.3, size * 0.4, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üê† CUERPO PRINCIPAL (forma org√°nica del Lottie)
                this.ctx.fillStyle = colors.body;
                this.ctx.beginPath();
                // Forma de pez m√°s realista basada en el JSON
                this.ctx.moveTo(size * 0.6, 0);
                this.ctx.quadraticCurveTo(size * 0.4, -size * 0.5, 0, -size * 0.4);
                this.ctx.quadraticCurveTo(-size * 0.6, -size * 0.3, -size * 0.7, 0);
                this.ctx.quadraticCurveTo(-size * 0.6, size * 0.3, 0, size * 0.4);
                this.ctx.quadraticCurveTo(size * 0.4, size * 0.5, size * 0.6, 0);
                this.ctx.fill();
                
                // üé® FRANJAS (patr√≥n del Lottie)
                this.ctx.fillStyle = colors.stripes;
                this.ctx.beginPath();
                // Franja superior
                this.ctx.moveTo(size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(0, -size * 0.25, -size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(-size * 0.2, -size * 0.05, size * 0.4, -size * 0.15);
                this.ctx.fill();
                
                // Franja inferior (solo para beb√©)
                if (this.gameState.stage === 'baby') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(0, size * 0.25, -size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(-size * 0.2, size * 0.05, size * 0.4, size * 0.15);
                    this.ctx.fill();
                }
                
                // üêü ALETA SUPERIOR (forma del Lottie)
                this.ctx.save();
                this.ctx.translate(size * 0.1, -size * 0.4);
                this.ctx.rotate(fish.finRotation * 0.6); // Ondulaci√≥n sutil
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                // Forma de aleta org√°nica
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.15, -size * 0.3, size * 0.05, -size * 0.35);
                this.ctx.quadraticCurveTo(size * 0.2, -size * 0.25, size * 0.15, -size * 0.1);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üêü ALETA INFERIOR
                this.ctx.save();
                this.ctx.translate(size * 0.2, size * 0.5);
                this.ctx.rotate(-fish.finRotation * 0.4);
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.1, size * 0.2, size * 0.05, size * 0.25);
                this.ctx.quadraticCurveTo(size * 0.15, size * 0.15, size * 0.1, size * 0.05);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üëÅÔ∏è OJO EXACTO DEL LOTTIE
                if (fish.eyeOpen > 0) {
                    // Ojo blanco (forma org√°nica del Lottie)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.3, -size * 0.05, size * 0.2, size * 0.15 * fish.eyeOpen, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pupila negra
                    this.ctx.fillStyle = '#323232'; // Color exacto [0.1961,0.1961,0.1961]
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.32, -size * 0.05, size * 0.08, size * 0.1 * fish.eyeOpen, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo en el ojo (peque√±o punto blanco)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.34, -size * 0.08, size * 0.03, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // üëÑ BOCA PEQUE√ëA (del Lottie)
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.ellipse(size * 0.5, size * 0.05, size * 0.05, size * 0.03, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // üçº CHUPETE (solo para beb√©)
                if (this.gameState.stage === 'baby' && colors.pacifier) {
                    // Chupete principal
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.12, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Anillo del chupete
                    this.ctx.strokeStyle = colors.pacifier;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.16, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Mango del chupete
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.fillRect(size * 0.72, size * 0.08, size * 0.08, size * 0.04);
                }
                
                this.ctx.restore();
            }
            
            // üé® COLORES EXACTOS DEL LOTTIE
            getFishColors() {
                const stage = this.gameState.stage;
                const ageInDays = this.gameState.ageInDays || 0;
                
                // Beb√© (0-2 d√≠as) - Colores Lottie + chupete
                if (stage === 'baby' || ageInDays < 3) {
                    return {
                        body: '#978bd8',      // Color exacto Lottie [0.5922,0.5451,0.8471]
                        stripes: '#9f8cb9',   // Franjas Lottie [0.6235,0.549,0.7255]
                        tail: '#d14444',      // Cola roja Lottie [0.8196,0.2667,0.2667]
                        fins: '#d78383',      // Aletas rosa Lottie [0.8431,0.5137,0.5137]
                        pacifier: '#ff9ecf'   // Chupete rosa para beb√©
                    };
                }
                
                // Joven (3-7 d√≠as) - Variaci√≥n m√°s intensa
                if (stage === 'young' || ageInDays < 8) {
                    return {
                        body: '#8a7bd8',      // Morado m√°s intenso
                        stripes: '#8f7cb9',   // Franjas m√°s marcadas
                        tail: '#c13434',      // Cola m√°s intensa
                        fins: '#c77373',      // Aletas m√°s fuertes
                        pacifier: null        // Sin chupete
                    };
                }
                
                // Adulto (8+ d√≠as) - Colores maduros
                return {
                    body: '#7d6bd8',        // Morado profundo
                    stripes: '#7f6cb9',     // Franjas sutiles
                    tail: '#b12424',        // Cola madura
                    fins: '#b76363',        // Aletas elegantes
                    pacifier: null          // Sin chupete
                };
            }
            
            // üìè ANCHO DE FRANJA POR EDAD
            getStripeWidth() {
                const ageInDays = this.gameState.ageInDays || 0;
                
                if (ageInDays < 3) return 0.25;      // Beb√©: franja ancha
                if (ageInDays < 8) return 0.18;      // Joven: franja media
                return 0.12;                          // Adulto: franja fina
            }
            
            // ü´ß CREAR BURBUJA DEL PEZ
            createFishBubble() {
                if (!this.fish) return;
                
                // Crear burbuja peque√±a que sale de la boca
                this.bgBubbles.push({
                    x: this.fish.x + this.fish.size * 0.5,
                    y: this.fish.y,
                    r: 2 + Math.random() * 3,
                    speed: 30 + Math.random() * 20,
                    opacity: 0.6 + Math.random() * 0.3,
                    life: 3 + Math.random() * 2,
                    maxLife: 3 + Math.random() * 2,
                    fromFish: true
                });
            }
            
            drawNeedBubbles() {
                for (const bubble of this.needBubbles) {
                    this.ctx.save();
                    this.ctx.globalAlpha = Math.min(bubble.life / 2, 1);
                    
                    // Burbuja de fondo
                    this.ctx.fillStyle = bubble.urgent ? '#ff6b6b' : '#4ecdc4';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Icono (emoji simple)
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px system-ui';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bubble.icon, bubble.x, bubble.y + 7);
                    
                    this.ctx.restore();
                }
            }
            
            // üê£ SISTEMA DE ECLOSI√ìN
            
            startHatching() {
                if (this.gameState.stage !== 'egg') return;
                
                console.log('üê£ ¬°ECLOSI√ìN SIMULT√ÅNEA!');
                
                // üîä SONIDO DE ECLOSI√ìN
                if (window.audioManager) {
                    window.audioManager.playSound('hatch');
                }
                
                // CREAR PEZ INMEDIATAMENTE (simult√°neo con burbujas)
                this.createFish();
                this.gameState.stage = 'baby';
                
                // Burbujas de eclosi√≥n al mismo tiempo
                this.createExplosionBubbles();
                
                console.log('ü•ö‚û°Ô∏èüêü Huevo desaparece y pez aparece AL MISMO TIEMPO');
            }
            
            createEggBubbles() {
                console.log('ü•ö Creando burbujitas blancas para el huevo');
                
                this.explosionBubbles.length = 0;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // BURBUJITAS BLANCAS SUAVES (COMO LAS DE NACIMIENTO PERO M√ÅS BLANCAS)
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 15 + Math.random() * 40; // M√°s suaves
                    const size = 2 + Math.random() * 8; // M√°s peque√±as
                    const life = 3 + Math.random() * 2;
                    
                    // COLORES M√ÅS BLANCOS
                    const colors = ['#FFFFFF', '#F8FCFF', '#F0F8FF', '#E8F4FF', '#E0F0FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 30,
                        y: centerY + (Math.random() - 0.5) * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20,
                        r: size,
                        life: life,
                        maxLife: life,
                        color: color,
                        alpha: 0.8
                    });
                }
                
                console.log('ü•ö 80 burbujitas blancas creadas para el huevo');
            }
            
            createExplosionBubbles() {
                if (this.explosionHappened) return;
                
                this.explosionBubbles.length = 0;
                this.lightRays.length = 0;
                this.explosionHappened = true;
                
                console.log('‚ú® Creando efecto suave de nacimiento');
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // EXPLOSI√ìN MASIVA DE BURBUJAS - LLENAR TODA LA PANTALLA
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 100; // Velocidad variada
                    const size = 3 + Math.random() * 12; // Tama√±os muy variados
                    const life = 4 + Math.random() * 3; // M√°s duraderas
                    
                    // Colores azules brillantes y blancos
                    const colors = ['#FFFFFF', '#E6F3FF', '#CCE7FF', '#99D6FF', '#66C7FF', '#33B8FF', '#00A9FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 30, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.3, // M√°s brillo
                        isLight: false
                    });
                }
                
                // ONDAS MASIVAS: 4 ondas consecutivas
                for (let wave = 0; wave < 4; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            const speed = 50 + Math.random() * 80;
                            const size = 2 + Math.random() * 8;
                            
                            this.explosionBubbles.push({
                                x: centerX + (Math.random() - 0.5) * 20,
                                y: centerY + (Math.random() - 0.5) * 20,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: size,
                                life: 3 + Math.random() * 2,
                                maxLife: 3 + Math.random() * 2,
                                sparkle: Math.random() < 0.4,
                                isLight: false
                            });
                        }
                    }, wave * 200);
                }
                
                console.log(`‚ú® Efecto suave creado: ${this.explosionBubbles.length} burbujas delicadas (sin rayos amarillos)`);
            }
            
            async createFish() {
                // Crear pez Lottie REAL
                await this.createLottieFish();
                
                // üîä SONIDO DE NACIMIENTO BONITO (solo eclosi√≥n)
                if (window.audioManager) {
                    setTimeout(() => {
                        window.audioManager.playSound('hatch'); // SOLO eclosi√≥n, sin bipbip
                    }, 200); // M√°s r√°pido para sincronizar mejor
                }
                
                this.fish = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height * 0.6,
                    size: 80, // Tama√±o del contenedor Lottie (m√°s peque√±o)
                    birthTime: Date.now(),
                    isLottie: true,
                    scale: 0.1, // Empezar muy peque√±o
                    targetScale: 1.0, // Crecer hasta tama√±o normal
                    growing: true,
                    
                    // üöÄ PROPIEDADES DEL SISTEMA REALISTA (EXACTAS DEL C√ìDIGO)
                    vx: 0, vy: 0, // Velocidades actuales
                    facing: 1, // Direcci√≥n (-1 izquierda, 1 derecha)
                    baseSpeed: 140, // Velocidad base EXACTA
                    maxSpeed: 300, // Velocidad m√°xima EXACTA
                    maxAccel: 1100, // Aceleraci√≥n m√°xima MEJORADA (era 900)
                    wanderTimer: 0, // Timer para cambio de direcci√≥n
                    wanderDir: {x: 1, y: 0}, // Direcci√≥n de vagabundeo
                    swimPhase: 0, // Fase de nataci√≥n para ondulaci√≥n
                    desire: null, // Objetivo al que ir (click)
                    happyBurst: 0, // Tiempo de celebraci√≥n
                    spinKind: "eat", // Tipo de giro (eat/clean)
                    blinkT: 0, // Tiempo de parpadeo
                    nextBlink: 2 + Math.random() * 4, // Pr√≥ximo parpadeo
                    breathT: 2 + Math.random() * 3 // Pr√≥xima respiraci√≥n
                };
                
                // Establecer fecha de nacimiento
                this.gameState.birthDate = Date.now();
                this.gameState.ageInDays = 0;
                
                // üçé NACER CON HAMBRE (ES UN BEB√â)
                this.gameState.needs.hunger = 80; // Beb√© nace con hambre
                this.gameState.needs.dirt = 0;    // Limpio al nacer
                this.gameState.needs.fun = 95;    // Feliz al nacer
                this.updateCrisisFlags(); // Activar flags
                this.updateNeedBars(); // Actualizar barras
                
                console.log('üçé Beb√© naci√≥ con hambre - Crisis activada');
                
                // üìä MOSTRAR BARRAS DE NECESIDADES CUANDO NACE EL PEZ
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'flex';
                    this.setupCanvas(); // REAJUSTAR CANVAS CON BARRAS
                    console.log('üìä Barras de necesidades activadas + Canvas reajustado');
                }
                
                // Sin bonus de bienvenida - empezar desde cero
                // this.gameState.bubbles += 0; // Empezar sin burbujas
                // this.gameState.stars += 0;   // Empezar sin estrellas
                
                // üéÜ BURBUJAS ANTES DEL PEZ (INMEDIATAS)
                this.explosionHappened = false; // RESETEAR FLAG
                this.createExplosionBubbles(); // BURBUJAS PRIMERO
                
                console.log('üéÜ Burbujas de nacimiento creadas ANTES del pez');
                
                console.log('üê† ¬°PEZ LOTTIE NACIDO! +5 ü´ß +1 ‚≠ê de regalo');
                this.updateUI();
                
                // Forzar actualizaci√≥n inmediata de necesidades (beb√© nace con hambre)
                setTimeout(() => {
                    // this.updateAllNeedBubbles(); // DESHABILITADO - iconos eliminados
                    this.updateButtonStates();
                    console.log('üçΩÔ∏è Verificando necesidades del beb√© reci√©n nacido...');
                }, 1000); // Despu√©s de 1 segundo para asegurar que todo est√© inicializado
                
                // Pedir nombre despu√©s de 3 segundos
                setTimeout(() => {
                    this.askForFishName();
                }, 3000);
                
                // A√±adir evento de nacimiento al √°lbum
                this.addAlbumEvent('birth', 'üê£ ¬°He nacido!', 'Mi primer d√≠a en el mundo. Todo es nuevo y emocionante.');
            }
            
            async createLottieFish() {
                try {
                    // Cargar JSON del pez
                    const response = await fetch('./ejemplos/bebe.json');
                    const animationData = await response.json();
                    
                    const container = document.getElementById('lottieContainer');
                    container.style.display = 'block';
                    
                    // Crear animaci√≥n Lottie
                    this.lottieAnimation = lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: animationData
                    });
                    
                    console.log('üé® Pez Lottie cargado correctamente');
                    
                    // Posicionar el contenedor
                    this.updateLottiePosition();
                    
                } catch (error) {
                    console.error('‚ùå Error cargando Lottie:', error);
                    // Fallback al pez Canvas
                    this.createCanvasFish();
                }
            }
            
            updateLottiePosition() {
                if (!this.fish || !this.lottieAnimation) return;
                
                const container = document.getElementById('lottieContainer');
                const rect = this.canvas.getBoundingClientRect();
                
                // CRECIMIENTO GRADUAL del pez reci√©n nacido
                if (this.fish.growing && this.fish.scale < this.fish.targetScale) {
                    this.fish.scale += 0.02; // Crecimiento visible
                    
                    if (this.fish.scale >= this.fish.targetScale) {
                        this.fish.scale = this.fish.targetScale;
                        this.fish.growing = false;
                        console.log('üê† Pez alcanz√≥ tama√±o completo');
                    }
                }
                
                // Posici√≥n relativa al canvas
                const x = this.fish.x;
                const y = this.fish.y;
                const currentScale = this.fish.scale || 1;
                const facing = this.fish.facing || 1;
                
                container.style.left = (rect.left + x - 30) + 'px'; // Centrar (60px/2 = 30)
                container.style.top = (rect.top + y - 30) + 'px';
                
                // üîÑ ORIENTACI√ìN CORREGIDA: Lottie mira IZQUIERDA por defecto
                // facing = 1 (derecha) ‚Üí scaleX(-1)
                // facing = -1 (izquierda) ‚Üí scaleX(1) 
                const scaleX = facing > 0 ? -1 : 1; // INVERTIDO para corregir orientaci√≥n
                
                // APLICAR INCLINACI√ìN Y EFECTOS DE ESTADO DE √ÅNIMO
                const tilt = this.fish.tilt || 0;
                const tiltDegrees = tilt * (180 / Math.PI); // Convertir a grados
                
                // üé® COLOR FIJO - NO M√ÅS CAMBIOS RAROS
                const fixedFilter = 'brightness(1.2) contrast(1.1) saturate(1.2)'; // Color fijo y bonito
                
                container.style.transform = `translate(-50%, -50%) scaleX(${scaleX}) scale(${currentScale}) rotate(${tiltDegrees}deg)`;
                container.style.filter = fixedFilter; // SIEMPRE EL MISMO
                container.style.opacity = 1; // Siempre visible
                
                // Reducir felicidad gradualmente
                if (this.fish.happyTime > 0) {
                    this.fish.happyTime -= 1/60;
                    if (this.fish.happyTime <= 0) {
                        this.fish.excited = false;
                    }
                }
            }
            
            createCanvasFish() {
                // Fallback al pez Canvas original
                this.fish = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height * 0.6,
                    size: 45,
                    birthTime: Date.now(),
                    isLottie: false
                };
                console.log('üê† Pez Canvas creado (fallback)');
            }
            
            
            // üê† L√ìGICA SIMPLE DE PEZ REAL
            updateNaturalFishMovement(deltaTime) {
                const fish = this.fish;
                const currentStage = this.gameState.stage;
                
                // Inicializar pez m√°s r√°pido y variado
                if (!fish.direction) fish.direction = 1; // 1 = derecha, -1 = izquierda
                if (!fish.baseSpeed) fish.baseSpeed = currentStage === 'baby' ? 60 : 45; // Velocidad base
                if (!fish.speed) fish.speed = fish.baseSpeed; // Velocidad actual
                if (!fish.swimPhase) fish.swimPhase = 0;
                if (!fish.facing) fish.facing = 1;
                if (!fish.changeTimer) fish.changeTimer = 0;
                if (!fish.verticalDirection) fish.verticalDirection = 0; // -1 arriba, 0 medio, 1 abajo
                if (!fish.verticalTimer) fish.verticalTimer = 0;
                // BEB√â NACE CON HAMBRE - Configurar tiempo anterior para que tenga hambre inmediatamente
                if (!fish.lastFeedTime) {
                    // Hacer que el beb√© nazca con hambre (4 horas + 1 minuto atr√°s)
                    const hungerTime = 4 * 60 * 60 * 1000 + 60 * 1000; // 4h 1min atr√°s
                    fish.lastFeedTime = Date.now() - hungerTime;
                    console.log('üçº ¬°Beb√© nace con HAMBRE! Necesita comer inmediatamente');
                }
                
                // INICIALIZAR SISTEMA DE BURBUJAS DE NECESIDADES
                if (!fish.needBubbleTimer) fish.needBubbleTimer = 0;
                if (!this.needBubbles) this.needBubbles = [];
                
                // Inicializar otros tiempos si no existen
                if (!this.gameState.lastClean) this.gameState.lastClean = Date.now();
                if (!this.gameState.lastMedicine) this.gameState.lastMedicine = Date.now();
                if (!this.gameState.lastPlay) this.gameState.lastPlay = Date.now();
                
                // Fase de nataci√≥n para ondulaci√≥n
                fish.swimPhase += deltaTime * (currentStage === 'baby' ? 2 : 1.2);
                fish.changeTimer += deltaTime;
                
                // CAMBIOS M√ÅS FRECUENTES para m√°s variedad
                // Beb√©: cada 4-8 segundos, Adulto: cada 6-10 segundos
                const changeInterval = currentStage === 'baby' ? 4 + Math.random() * 4 : 6 + Math.random() * 4;
                fish.verticalTimer += deltaTime;
                
                if (fish.changeTimer > changeInterval) {
                    // 50% chance de cambiar direcci√≥n horizontal
                    if (Math.random() < 0.5) {
                        fish.direction *= -1;
                        console.log(`üê† Cambio horizontal: ${fish.direction === 1 ? 'DERECHA ‚Üí' : 'IZQUIERDA ‚Üê'}`);
                    }
                    
                    // 60% chance de cambiar direcci√≥n vertical
                    if (Math.random() < 0.6) {
                        const options = [-1, 0, 1]; // arriba, medio, abajo
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                        const verticalNames = ['ARRIBA ‚Üë', 'MEDIO ‚Üí', 'ABAJO ‚Üì'];
                        console.log(`üê† Cambio vertical: ${verticalNames[fish.verticalDirection + 1]}`);
                    }
                    
                    fish.changeTimer = 0;
                }
                
                // Cambios verticales independientes (m√°s frecuentes)
                if (fish.verticalTimer > 3 + Math.random() * 3) {
                    if (Math.random() < 0.4) {
                        const options = [-1, 0, 1];
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                    }
                    fish.verticalTimer = 0;
                }
                
                // ‚úÖ SISTEMA ELIMINADO - SOLO USAMOS EL SISTEMA ORIGINAL DEL DOCUMENTO
                if (fish.isChasing) {
                    // 2. PRIORIDAD: Perseguir comida
                    // Durante persecuci√≥n, usar la velocidad ya calculada en makeFishChaseFood
                    // No sobreescribir fish.vx y fish.vy
                } else if (fish.isCleaning) {
                    // 3. PRIORIDAD: Movimiento de tirabuzones durante limpieza
                    fish.cleaningTime += deltaTime;
                    
                    // MOVIMIENTO EN TIRABUZONES (COSQUILLAS)
                    const spiralSpeed = fish.baseSpeed * 1.5;
                    const spiralRadius = 40 + Math.sin(fish.cleaningTime * 3) * 20;
                    const spiralAngle = fish.cleaningTime * 4; // 4 vueltas por segundo
                    
                    fish.vx = Math.cos(spiralAngle) * spiralRadius * 0.1 + Math.sin(fish.cleaningTime * 8) * spiralSpeed * 0.3;
                    fish.vy = Math.sin(spiralAngle) * spiralRadius * 0.1 + Math.cos(fish.cleaningTime * 6) * spiralSpeed * 0.2;
                    
                    // Movimiento err√°tico como si tuviera cosquillas
                    fish.vx += (Math.random() - 0.5) * spiralSpeed * 0.4;
                    fish.vy += (Math.random() - 0.5) * spiralSpeed * 0.3;
                    
                    console.log(`üåÄ Pez haciendo tirabuzones - tiempo: ${fish.cleaningTime.toFixed(1)}s`);
                } else if (fish.goingToCorner) {
                    // 4. PRIORIDAD: Pez triste va a esquina (SIN desire)
                    const dx = fish.cornerTargetX - fish.x;
                    const dy = fish.cornerTargetY - fish.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 15) {
                        // Movimiento LENTO hacia esquina
                        const slowSpeed = fish.baseSpeed * 0.5; // MUY lento
                        fish.vx = (dx / distance) * slowSpeed;
                        fish.vy = (dy / distance) * slowSpeed;
                        fish.direction = dx > 0 ? 1 : -1;
                    } else {
                        // Lleg√≥ a la esquina - quedarse quieto
                        fish.goingToCorner = false;
                        fish.vx = 0;
                        fish.vy = 0;
                        console.log('üò¢ Pez lleg√≥ a esquina - Se queda quieto');
                    }
                } else {
                    // 5. COMPORTAMIENTO NORMAL: Movimiento libre
                    fish.vx = fish.direction * fish.speed;
                    
                    // Movimiento vertical combinado
                    let baseVerticalMovement = Math.sin(fish.swimPhase) * (currentStage === 'baby' ? 12 : 8); // Ondulaci√≥n natural
                    let directionalVertical = fish.verticalDirection * (fish.speed * 0.4); // Movimiento direccional vertical
                    
                    fish.vy = baseVerticalMovement + directionalVertical;
                }
                
                // Aplicar movimiento
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;
                
                // GIRO SIMPLE: Solo cuando llega al borde
                this.handleSimpleFishBoundaries();
                
                // Orientaci√≥n simple
                this.updateFishOrientation();
                
                // SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
                this.updateNeedBubbles(deltaTime);
                
                // Sistema de necesidades - Solo botones (iconos flotantes eliminados)
                // this.updateAllNeedBubbles(); // DESHABILITADO - iconos molestos
                
                // Sistema de apat√≠a y tristeza
                this.updateFishMood();
                
                // Actualizar estado de botones
                this.updateButtonStates();
            }
            
            // üëÜ CLICK EN PANTALLA - PEZ VIENE AL DEDO (SISTEMA DEL DEMO)
            handleCanvasClick(event) {
                console.log('üëÜ CLICK DETECTADO - Pez:', !!this.fish, 'Stage:', this.gameState.stage);
                if (!this.fish || this.gameState.stage === 'egg' || this.fish.isDepressed) {
                    console.log('‚ùå Click ignorado - Sin pez o en huevo');
                    return;
                }
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // üö® GUARDACOSTAS: Solo ignorar si est√° MUY aburrido (no por hambre)
                if (this.gameState.crisis.bored) {
                    console.log('üòî Click ignorado - Pez muy aburrido (necesita jugar)');
                    return;
                }
                
                // üëÜ DEDO CON COORDENADAS CSS Y TURBO
                this.fish.desire = {
                    x: this.clamp(x, 24, this.viewW() - 24),
                    y: this.clamp(y, 24, this.viewH() - 24)
                };
                this.fish.fingerBoostT = 1.6;   // turbo temporal de dedo
                this.fish.returnToBottom = false; // apagar cualquier regreso al fondo
                this.fish.shouldLaunchHeart = true; // Marcar para lanzar coraz√≥n cuando llegue
                
                console.log(`üëÜ ¬°TURBO AL DEDO! (${x.toFixed(0)}, ${y.toFixed(0)}) - Boost: 1.6s`);
            }
            
            // üíñ LANZAR CORAZ√ìN QUE AUMENTA DIVERSI√ìN
            launchHeartToFun(x, y) {
                // Si no se pasan coordenadas, usar posici√≥n del pez
                const startX = x !== undefined ? x : this.fish.x;
                const startY = y !== undefined ? y : this.fish.y;
                
                // Crear coraz√≥n visual
                const heart = {
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 50, // Velocidad horizontal aleatoria
                    vy: -80, // Velocidad hacia arriba
                    life: 2.0, // 2 segundos de vida
                    maxLife: 2.0,
                    size: 20 + Math.random() * 10,
                    color: ['üíñ', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú'][Math.floor(Math.random() * 7)]
                };
                
                if (!this.flyers) this.flyers = [];
                this.flyers.push(heart);
                
                // üéâ AUMENTAR DIVERSI√ìN
                this.gameState.needs.fun = Math.max(0, this.gameState.needs.fun - 5); // -5 diversi√≥n (menos rojo = m√°s feliz)
                this.updateCrisisFlags();
                this.updateNeedBars();
                
                console.log(`üíñ Coraz√≥n lanzado! Diversi√≥n: ${this.gameState.needs.fun}`);
            }
            
            // YA NO NECESITAMOS CAMBIOS DE COMPORTAMIENTO
            // El pez simplemente NADA en una direcci√≥n hasta llegar al borde
            
            // üçΩÔ∏è SISTEMA DE HAMBRE
            updateHunger() {
                if (!this.fish || !this.fish.lastFeedTime) return;
                
                const currentTime = Date.now();
                const timeSinceLastFeed = currentTime - this.fish.lastFeedTime;
                // CONFIGURACI√ìN REAL: Beb√© tiene hambre cada 4 horas
                const currentStage = this.gameState.stage;
                let hungerThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000; // Default beb√©
                }
                
                const hungerBubble = document.getElementById('hungerBubble');
                if (!hungerBubble) return;
                
                if (timeSinceLastFeed > hungerThreshold) {
                    // Mostrar burbuja de hambre cerca del pez
                    this.showHungerBubble();
                } else {
                    // Ocultar burbuja
                    hungerBubble.style.display = 'none';
                }
            }
            
            showHungerBubble() {
                this.showNeedBubble('hungerBubble', 'hunger', 15, -45);
            }
            
            // üéØ MOSTRAR BURBUJA DE NECESIDAD GEN√âRICA
            showNeedBubble(bubbleId, needType, offsetX, offsetY) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Posicionar la burbuja cerca del pez
                bubble.style.display = 'block';
                bubble.style.left = (this.fish.x + offsetX) + 'px';
                bubble.style.top = (this.fish.y + offsetY) + 'px';
                
                const needNames = {
                    'hunger': 'COMIDA üçΩÔ∏è',
                    'dirty': 'LIMPIEZA üßΩ', 
                    'medicine': 'MEDICINA üíä',
                    'play': 'JUGAR üéÆ'
                };
                console.log(`üéØ Pez necesita: ${needNames[needType] || needType}`);
                
                // DEBUG: Verificar que se muestra el icono, no texto
                console.log(`üìç Burbuja ${bubbleId} posicionada en (${this.fish.x + offsetX}, ${this.fish.y + offsetY})`);
            }
            
            // üéØ MOSTRAR ICONO QUE SE MUEVE (APARECE/DESAPARECE/CAMBIA LUGAR)
            showFixedNeedIcon(bubbleId, needType) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Inicializar timer de movimiento si no existe
                if (!bubble.moveTimer) bubble.moveTimer = 0;
                if (!bubble.currentPosition) bubble.currentPosition = 0;
                
                bubble.moveTimer += 1/60;
                
                // Cambiar posici√≥n cada 8-15 segundos (M√ÅS LENTO)
                if (bubble.moveTimer > 8 + Math.random() * 7) {
                    bubble.currentPosition = (bubble.currentPosition + 1) % 4; // Rotar entre 4 posiciones
                    bubble.moveTimer = 0;
                    
                    // DESAPARECER MUY LENTAMENTE (1.5 segundos)
                    bubble.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
                    bubble.style.opacity = '0';
                    bubble.style.transform = 'scale(0.7)';
                    
                    setTimeout(() => {
                        // Cambiar posici√≥n mientras est√° invisible
                        this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                        
                        // APARECER MUY LENTAMENTE (2 segundos)
                        setTimeout(() => {
                            bubble.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
                            bubble.style.opacity = '1';
                            bubble.style.transform = 'scale(1)';
                        }, 200);
                        
                    }, 1500); // Esperar a que termine de desaparecer
                    
                    console.log(`üéØ Icono ${needType} se mueve SUAVEMENTE a nueva posici√≥n`);
                } else {
                    // Mantener posici√≥n actual
                    this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                }
                
                bubble.style.display = 'block';
            }
            
            updateIconPosition(bubble, bubbleId, positionIndex) {
                // 4 posiciones diferentes para cada icono
                const allPositions = [
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.25 }, // Superior izquierda
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.25 }, // Superior derecha
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.75 }, // Inferior derecha
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.75 }  // Inferior izquierda
                ];
                
                const pos = allPositions[positionIndex] || allPositions[0];
                
                bubble.style.left = pos.x + 'px';
                bubble.style.top = pos.y + 'px';
            }
            
            // üò¢ SISTEMA DE APAT√çA Y TRISTEZA
            updateFishMood() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Calcular tiempo sin atender necesidades
                const timeSinceFood = this.fish.lastFeedTime ? currentTime - this.fish.lastFeedTime : 0;
                const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                const timeSinceClean = this.gameState.lastClean ? currentTime - this.gameState.lastClean : 0;
                
                // Umbrales de descuido (8 horas sin atender)
                const neglectThreshold = 8 * 60 * 60 * 1000; // 8 horas
                
                const isNeglected = timeSinceFood > neglectThreshold || 
                                  timeSincePlay > neglectThreshold || 
                                  timeSinceClean > neglectThreshold;
                
                if (isNeglected) {
                    // PEZ TRISTE Y AP√ÅTICO - L√ìGICA MEJORADA
                    this.fish.baseSpeed = (currentStage === 'baby' ? 60 : 45) * 0.3; // MUY lento
                    this.fish.isDepressed = true;
                    this.fish.hideTimer = (this.fish.hideTimer || 0) + 1/60;
                    
                    // Se va a una esquina y se queda quieto M√ÅS TIEMPO
                    if (!this.fish.isInCorner && this.fish.hideTimer > 3) {
                        // Ir a una esquina aleatoria
                        const corners = [
                            { x: 100, y: this.canvas.height * 0.2 }, // Esquina superior izquierda
                            { x: this.canvas.width - 100, y: this.canvas.height * 0.2 }, // Superior derecha
                            { x: 100, y: this.canvas.height * 0.8 }, // Inferior izquierda
                            { x: this.canvas.width - 100, y: this.canvas.height * 0.8 } // Inferior derecha
                        ];
                        
                        const corner = corners[Math.floor(Math.random() * corners.length)];
                        this.fish.targetX = corner.x;
                        this.fish.targetY = corner.y;
                        // Pez triste va LENTO a esquina (SIN desire para evitar conflictos)
                        this.fish.cornerTargetX = corner.x;
                        this.fish.cornerTargetY = corner.y;
                        this.fish.goingToCorner = true;
                        this.fish.isInCorner = true;
                        this.fish.cornerTime = 8 + Math.random() * 12; // 8-20 segundos en esquina
                        console.log('üò¢ Pez triste va a esconderse en esquina...');
                    }
                    
                    // Quedarse quieto en la esquina
                    if (this.fish.isInCorner) {
                        this.fish.cornerTime -= 1/60;
                        
                        // Movimiento MUY reducido en la esquina
                        if (this.fish.cornerTime > 0) {
                            this.fish.vx *= 0.95; // Casi inm√≥vil
                            this.fish.vy *= 0.95;
                        } else {
                            this.fish.isInCorner = false;
                            this.fish.hideTimer = 0;
                            console.log('üê† Pez sale de la esquina');
                        }
                    }
                    
                    // No responde al dedo cuando est√° muy triste
                    if (this.fish.isGoingToTarget && !this.fish.isInCorner && Math.random() < 0.8) {
                        this.fish.isGoingToTarget = false;
                        this.fish.targetX = null;
                        this.fish.targetY = null;
                        console.log('üò¢ Pez demasiado triste para venir al dedo');
                    }
                    
                } else {
                    // PEZ NORMAL Y FELIZ
                    this.fish.baseSpeed = currentStage === 'baby' ? 60 : 45; // Velocidad normal
                    this.fish.isDepressed = false;
                    this.fish.isInCorner = false;
                    this.fish.hideTimer = 0;
                }
            }
            
            // üéÆ ACTUALIZAR TODAS LAS BURBUJAS DE NECESIDADES
            updateAllNeedBubbles() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales (mismos que en updateButtonStates)
                let hungerThreshold, cleanThreshold, medicineThreshold, playThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        playThreshold = 5 * 60 * 60 * 1000; // 5 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000;
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 14 * 60 * 60 * 1000;
                        playThreshold = 8 * 60 * 60 * 1000;
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000;
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 26 * 60 * 60 * 1000;
                        playThreshold = 10 * 60 * 60 * 1000;
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                        playThreshold = 5 * 60 * 60 * 1000;
                }
                
                // Verificar y mostrar/ocultar burbujas
                const needsFood = this.fish.lastFeedTime && (currentTime - this.fish.lastFeedTime) > hungerThreshold;
                const needsCleaning = this.gameState.lastClean && (currentTime - this.gameState.lastClean) > cleanThreshold;
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                const needsPlay = this.gameState.lastPlay && (currentTime - this.gameState.lastPlay) > playThreshold;
                
                // ICONOS APARECEN/DESAPARECEN en posiciones fijas
                if (needsFood) {
                    this.showFixedNeedIcon('hungerBubble', 'hunger');
                } else {
                    document.getElementById('hungerBubble').style.display = 'none';
                }
                
                if (needsCleaning) {
                    this.showFixedNeedIcon('dirtyBubble', 'dirty');
                } else {
                    document.getElementById('dirtyBubble').style.display = 'none';
                }
                
                if (needsMedicine) {
                    this.showFixedNeedIcon('medicineBubble', 'medicine');
                } else {
                    document.getElementById('medicineBubble').style.display = 'none';
                }
                
                if (needsPlay) {
                    this.showFixedNeedIcon('playBubble', 'play');
                } else {
                    document.getElementById('playBubble').style.display = 'none';
                }
            }
            
            // üìç ACTUALIZAR POSICIONES DE BURBUJAS QUE SIGUEN AL PEZ
            updateVisibleBubblesPositions() {
                if (!this.fish) return;
                
                const bubbles = [
                    { id: 'hungerBubble', offsetX: 15, offsetY: -45 },
                    { id: 'dirtyBubble', offsetX: -60, offsetY: -30 },
                    { id: 'medicineBubble', offsetX: 60, offsetY: -30 },
                    { id: 'playBubble', offsetX: 0, offsetY: -70 }
                ];
                
                bubbles.forEach(bubbleInfo => {
                    const bubble = document.getElementById(bubbleInfo.id);
                    if (bubble && bubble.style.display !== 'none') {
                        // Actualizar posici√≥n para que siga al pez
                        bubble.style.left = (this.fish.x + bubbleInfo.offsetX) + 'px';
                        bubble.style.top = (this.fish.y + bubbleInfo.offsetY) + 'px';
                    }
                });
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BOT√ìN (SISTEMA ANTIGUO - DESACTIVADO)
            startFeeding() {
                console.log('üçΩÔ∏è startFeeding() DESACTIVADO - Usar dropFood() en su lugar');
                return;
                
                // Crear 3 bolitas con MEJOR ESPACIADO
                setTimeout(() => {
                    this.createFallingFood(1); // Primera comida
                }, 0);
                
                setTimeout(() => {
                    this.createFallingFood(2); // Segunda comida
                }, 800); // Despu√©s de 800ms
                
                setTimeout(() => {
                    this.createFallingFood(3); // Tercera comida
                }, 1600); // Despu√©s de 1.6s
                
                // Activar modo persecuci√≥n del pez (velocidad m√°s suave)
                this.fish.isChasing = true;
                this.fish.chaseSpeed = this.fish.speed * 1.5; // Solo 50% m√°s r√°pido
                
                // Desactivar persecuci√≥n despu√©s de 15 segundos
                setTimeout(() => {
                    if (this.fish) {
                        this.fish.isChasing = false;
                        console.log('üê† Pez dej√≥ de perseguir comida - Volviendo a comportamiento normal');
                    }
                }, 15000);
                
                // Actualizar tiempo de alimentaci√≥n
                this.fish.lastFeedTime = Date.now();
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üèÉ ¬°Pez activado en modo persecuci√≥n! Velocidad x1.5 (m√°s natural)');
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BURBUJA (MODO ORIGINAL)
            feedFish() {
                if (!this.fish) return;
                
                // Actualizar tiempo de √∫ltima comida
                this.fish.lastFeedTime = Date.now();
                
                // Ocultar burbuja
                const hungerBubble = document.getElementById('hungerBubble');
                if (hungerBubble) {
                    hungerBubble.style.display = 'none';
                }
                
                // Efectos de alimentaci√≥n
                this.createFeedingEffects();
                
                // Aumentar felicidad
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üçΩÔ∏è Pez alimentado - Felicidad:', this.gameState.happiness);
            }
            
            createFeedingEffects() {
                // Crear part√≠culas de comida cayendo
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.createFoodParticle();
                    }, i * 100);
                }
            }
            
            createFoodParticle() {
                if (!this.fish) return;
                
                const particle = {
                    x: this.fish.x + (Math.random() - 0.5) * 40,
                    y: this.fish.y - 50,
                    vy: 30 + Math.random() * 20,
                    life: 2,
                    maxLife: 2,
                    size: 3 + Math.random() * 3
                };
                
                // A√±adir a array de part√≠culas (DESACTIVADO - SISTEMA ANTIGUO)
                // if (!this.foodParticles) this.foodParticles = [];
                // this.foodParticles.push(particle);
            }
            
            // üçñ CREAR COMIDA CON POSICIONES ESTRAT√âGICAS
            createFallingFood(foodNumber) {
                // SISTEMA ANTIGUO - DESACTIVADO
                return;
                
                let startX;
                if (this.fish) {
                    const fishX = this.fish.x;
                    const canvasWidth = this.canvas.width;
                    
                    // POSICIONES ESTRAT√âGICAS para cada comida
                    switch(foodNumber) {
                        case 1:
                            // Primera: A la izquierda del pez
                            startX = Math.max(80, fishX - 80 - Math.random() * 60);
                            break;
                        case 2:
                            // Segunda: A la derecha del pez
                            startX = Math.min(canvasWidth - 80, fishX + 80 + Math.random() * 60);
                            break;
                        case 3:
                            // Tercera: Cerca del pez (arriba o centro)
                            startX = fishX + (Math.random() - 0.5) * 100;
                            startX = Math.max(80, Math.min(canvasWidth - 80, startX));
                            break;
                        default:
                            startX = 100 + Math.random() * (canvasWidth - 200);
                    }
                } else {
                    // Si no hay pez, usar posici√≥n aleatoria
                    startX = 100 + Math.random() * (this.canvas.width - 200);
                }
                
                const food = {
                    x: startX,
                    y: this.canvas.height * 0.25, // Un poco m√°s abajo
                    vy: 18 + Math.random() * 8, // Velocidad m√°s lenta para dar tiempo
                    size: 9 + Math.random() * 3, // Tama√±o m√°s visible
                    life: 18, // M√°s tiempo para comer
                    maxLife: 18,
                    eaten: false,
                    type: Math.random() > 0.8 ? 'premium' : 'normal',
                    number: foodNumber
                };
                
                this.fallingFood.push(food);
                console.log(`üçñ Comida #${foodNumber} creada en x:${startX.toFixed(0)} (${foodNumber === 1 ? 'IZQUIERDA' : foodNumber === 2 ? 'DERECHA' : 'CENTRO'})`);
            }
            
            drawFoodParticles() {
                if (!this.foodParticles) return;
                
                // Actualizar y dibujar part√≠culas
                for (let i = this.foodParticles.length - 1; i >= 0; i--) {
                    const particle = this.foodParticles[i];
                    
                    // Actualizar posici√≥n
                    particle.y += particle.vy * (1/60); // Asumiendo 60fps
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.foodParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula de comida
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    // Color marr√≥n/dorado para la comida
                    this.ctx.fillStyle = '#D2691E';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Peque√±o brillo
                    this.ctx.fillStyle = '#F4A460';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x - 1, particle.y - 1, particle.size * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üçñ DIBUJAR Y ACTUALIZAR COMIDA CAYENDO
            drawFallingFood() {
                if (!this.fallingFood) return;
                
                // Actualizar y dibujar comida cayendo
                for (let i = this.fallingFood.length - 1; i >= 0; i--) {
                    const food = this.fallingFood[i];
                    
                    if (food.eaten) continue;
                    
                    // Actualizar posici√≥n
                    food.y += food.vy * (1/60);
                    food.life -= 1/60;
                    
                    // Eliminar si expir√≥ o sali√≥ de pantalla
                    if (food.life <= 0 || food.y > this.canvas.height + 50) {
                        this.fallingFood.splice(i, 1);
                        continue;
                    }
                    
                    // Verificar si el pez la alcanz√≥
                    if (this.fish && !food.eaten) {
                        const distance = Math.sqrt(
                            Math.pow(this.fish.x - food.x, 2) + 
                            Math.pow(this.fish.y - food.y, 2)
                        );
                        
                        if (distance < 30) { // Pez alcanz√≥ la comida (√°rea m√°s grande)
                            food.eaten = true;
                            this.createEatingEffect(food.x, food.y);
                            this.createBigEatingEffect(food.x, food.y, food.type);
                            console.log(`üçΩÔ∏è ¬°Pez comi√≥ comida ${food.type}! ¬°√ëAM √ëAM!`);
                            
                            // ACTUALIZAR TIEMPO DE COMIDA Y ESTADO
                            this.fish.lastFeedTime = Date.now();
                            this.fish.excited = true; // ¬°FELIZ AL COMER!
                            console.log('üòä ¬°Pez feliz despu√©s de comer!');
                            
                            // Quitar felicidad despu√©s de 3 segundos
                            setTimeout(() => {
                                this.fish.excited = false;
                            }, 3000);
                            
                            // Quitar comida despu√©s de un momento
                            setTimeout(() => {
                                const index = this.fallingFood.indexOf(food);
                                if (index > -1) this.fallingFood.splice(index, 1);
                            }, 100);
                            continue;
                        }
                        
                    }
                    
                    // Dibujar comida
                    this.ctx.save();
                    
                    // Color seg√∫n tipo
                    const color = food.type === 'premium' ? '#FFD700' : '#D2691E';
                    const highlightColor = food.type === 'premium' ? '#FFF8DC' : '#F4A460';
                    
                    // Sombra
                    this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetY = 2;
                    
                    // Comida principal
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo
                    this.ctx.fillStyle = highlightColor;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x - 2, food.y - 2, food.size * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Si el pez est√° persiguiendo, encontrar la comida m√°s cercana
                if (this.fish && this.fish.isChasing && this.fallingFood.length > 0) {
                    this.findAndChaseClosestFood();
                }
            }
            
            // üîç ENCONTRAR Y PERSEGUIR LA COMIDA M√ÅS CERCANA
            findAndChaseClosestFood() {
                if (!this.fallingFood || this.fallingFood.length === 0) return;
                
                const fish = this.fish;
                let closestFood = null;
                let closestDistance = Infinity;
                
                // Encontrar la comida m√°s cercana
                for (const food of this.fallingFood) {
                    if (food.eaten) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(fish.x - food.x, 2) + 
                        Math.pow(fish.y - food.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
                
                // Si encontramos comida, perseguirla
                if (closestFood) {
                    this.makeFishChaseFood(closestFood);
                }
            }
            
            // üèÉ HACER QUE EL PEZ PERSIGA LA COMIDA (SIN GIROS LOCOS)
            makeFishChaseFood(food) {
                const fish = this.fish;
                
                // Calcular direcci√≥n hacia la comida
                const dx = food.x - fish.x;
                const dy = food.y - fish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Velocidad de persecuci√≥n m√°s natural
                    const chaseSpeed = fish.chaseSpeed || (fish.speed * 1.5); // 50% m√°s r√°pido
                    
                    // Normalizar y aplicar velocidad
                    fish.vx = (dx / distance) * chaseSpeed;
                    fish.vy = (dy / distance) * chaseSpeed;
                    
                    // SOLO cambiar orientaci√≥n si hay un cambio SIGNIFICATIVO
                    const significantChange = Math.abs(dx) > 20; // Solo si est√° a m√°s de 20px
                    if (significantChange) {
                        const newDirection = dx > 0 ? 1 : -1;
                        // Solo cambiar si es realmente diferente
                        if (newDirection !== fish.direction) {
                            fish.direction = newDirection;
                            console.log(`üîÑ Pez cambi√≥ orientaci√≥n: ${fish.direction === 1 ? 'DERECHA' : 'IZQUIERDA'}`);
                        }
                    }
                    
                    // Log menos spam
                    if (Math.random() < 0.1) { // Solo 10% de las veces
                        console.log(`üèÉ Persiguiendo comida: ${distance.toFixed(0)}px`);
                    }
                }
            }
            
            // ‚ú® EFECTO AL COMER
            createEatingEffect(x, y) {
                // Peque√±as part√≠culas al comer
                for (let i = 0; i < 5; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 30,
                        vy: (Math.random() - 0.5) * 30,
                        life: 0.5,
                        maxLife: 0.5,
                        size: 2 + Math.random() * 2,
                        color: '#FFD700'
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
            }
            
            // üí• EFECTO GRANDE AL COMER
            createBigEatingEffect(x, y, type) {
                // Crear muchas part√≠culas espectaculares
                const particleCount = type === 'premium' ? 15 : 10;
                const colors = type === 'premium' 
                    ? ['#FFD700', '#FFF8DC', '#FFFF00', '#FFE55C'] 
                    : ['#D2691E', '#F4A460', '#DEB887', '#CD853F'];
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 40 + Math.random() * 30;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 3 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
                
                // Texto "√ëAM √ëAM" flotante
                this.createFloatingText(x, y, type === 'premium' ? '¬°√ëAM √ëAM!' : '√±am √±am', 
                                       type === 'premium' ? '#FFD700' : '#D2691E');
            }
            
            // üìù TEXTO FLOTANTE
            createFloatingText(x, y, text, color) {
                const textEffect = {
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 2,
                    maxLife: 2,
                    vy: -30 // Flota hacia arriba
                };
                
                if (!this.floatingTexts) this.floatingTexts = [];
                this.floatingTexts.push(textEffect);
            }
            
            // üé® DIBUJAR EFECTOS DE COMER
            drawEatingEffects() {
                if (!this.eatingEffects) return;
                
                for (let i = this.eatingEffects.length - 1; i >= 0; i--) {
                    const particle = this.eatingEffects[i];
                    
                    // Actualizar part√≠cula
                    particle.x += particle.vx * (1/60);
                    particle.y += particle.vy * (1/60);
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.eatingEffects.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üìù DIBUJAR TEXTOS FLOTANTES
            drawFloatingTexts() {
                if (!this.floatingTexts) return;
                
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    // Actualizar texto
                    text.y += text.vy * (1/60);
                    text.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar texto
                    const alpha = text.life / text.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.fillStyle = text.color;
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.textAlign = 'center';
                    
                    // Contorno blanco
                    this.ctx.strokeText(text.text, text.x, text.y);
                    // Texto principal
                    this.ctx.fillText(text.text, text.x, text.y);
                    
                    this.ctx.restore();
                }
            }
            
            // ‚è∞ AVANZAR TIEMPO DEL JUEGO (DEBUG)
            advanceGameTime(hours) {
                if (!this.fish) return;
                
                const timeAdvance = hours * 60 * 60 * 1000; // Convertir horas a milisegundos
                
                // Avanzar TODOS los tiempos del juego
                if (this.fish.lastFeedTime) {
                    this.fish.lastFeedTime -= timeAdvance; // Retroceder = como si hubiera pasado tiempo
                }
                
                if (this.gameState.lastPlay) {
                    this.gameState.lastPlay -= timeAdvance;
                }
                
                if (this.gameState.lastClean) {
                    this.gameState.lastClean -= timeAdvance;
                }
                
                if (this.gameState.birthDate) {
                    this.gameState.birthDate -= timeAdvance; // Hacer m√°s viejo
                }
                
                // Actualizar edad
                this.updateAgeDisplay();
                
                console.log(`‚è∞ Tiempo del juego avanzado +${hours} hora(s)`);
                console.log(`üçΩÔ∏è √öltima comida: hace ${Math.round((Date.now() - this.fish.lastFeedTime) / (60*60*1000))} horas`);
            }
            
            // üéÆ ACTUALIZAR ESTADO DE BOTONES
            updateButtonStates() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales seg√∫n la edad
                let hungerThreshold, cleanThreshold, medicineThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas descuido
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000; // 2 d√≠as
                        medicineThreshold = 14 * 60 * 60 * 1000; // 14 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000; // 3 d√≠as
                        medicineThreshold = 26 * 60 * 60 * 1000; // 26 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                }
                
                // Verificar necesidades BASADAS EN LOS VALORES REALES
                const needsFood = this.gameState.needs.hunger > 20; // Si hambre > 20%, activar bot√≥n (AJUSTADO)
                const needsCleaning = true; // LIMPIEZA SIEMPRE DISPONIBLE
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                
                // Actualizar botones (MEDICINA ELIMINADA) - M√ÅS DEBUG
                console.log('üîò BOTONES DEBUG:', 
                    'Hambre:', this.gameState.needs.hunger.toFixed(1) + '% ‚Üí needsFood:', needsFood,
                    'Suciedad:', this.gameState.needs.dirt.toFixed(1) + '% ‚Üí needsCleaning:', needsCleaning,
                    'Umbral limpieza: >10%');
                    
                // DEBUG EXTRA para limpieza
                if (this.gameState.needs.dirt > 50) {
                    console.log('üßπ LIMPIEZA DEBUG EXTRA:', 
                        'dirt:', this.gameState.needs.dirt,
                        'needsCleaning:', needsCleaning,
                        'cleanBtn existe:', !!document.getElementById('cleanBtn'));
                }
                this.toggleButton('feedBtn', needsFood);
                this.toggleButton('cleanBtn', needsCleaning);
                // this.toggleButton('medicineBtn', needsMedicine); // ELIMINADO
            }
            
            // üîò HABILITAR/DESHABILITAR BOT√ìN
            toggleButton(buttonId, enabled) {
                const button = document.getElementById(buttonId);
                if (!button) {
                    console.log(`‚ùå toggleButton: Bot√≥n ${buttonId} NO ENCONTRADO`);
                    return;
                }
                
                console.log(`üîò toggleButton: ${buttonId} ‚Üí ${enabled ? 'HABILITADO' : 'DESHABILITADO'}`);
                
                if (enabled) {
                    button.classList.remove('disabled');
                    console.log(`‚úÖ ${buttonId}: Clase 'disabled' REMOVIDA`);
                    button.onclick = () => {
                        switch(buttonId) {
                            case 'feedBtn': this.dropFood(); break; // USAR SISTEMA NUEVO
                            case 'cleanBtn': this.startCleaning(); break;
                            // case 'medicineBtn': this.giveMedicine(); break; // ELIMINADO
                        }
                    };
                } else {
                    button.classList.add('disabled');
                    console.log(`‚ùå ${buttonId}: Clase 'disabled' A√ëADIDA`);
                    button.onclick = () => {
                        console.log(`‚ùå ${buttonId}: El pez no necesita esto ahora`);
                    };
                }
            }
            
            // üßΩ FUNCI√ìN DUPLICADA ELIMINADA - SE USA LA DEL EFECTO ESPECTACULAR
            
            // ü´ß SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
            updateNeedBubbles(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;
                
                const fish = this.fish;
                fish.needBubbleTimer += deltaTime;
                
                // Crear burbuja cada 3-5 segundos si tiene necesidades
                if (fish.needBubbleTimer > 3 + Math.random() * 2) {
                    fish.needBubbleTimer = 0;
                    
                    const currentTime = Date.now();
                    const currentStage = this.gameState.stage;
                    
                    // Verificar necesidades
                    const timeSinceFood = fish.lastFeedTime ? currentTime - fish.lastFeedTime : 0;
                    const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                    const timeSinceMedicine = this.gameState.lastMedicine ? currentTime - this.gameState.lastMedicine : 0;
                    
                    // Umbrales
                    const hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                    const playThreshold = 5 * 60 * 60 * 1000;   // 5 horas
                    const medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                    
                    // Crear burbujas seg√∫n necesidades (en orden de prioridad)
                    if (timeSinceFood > hungerThreshold) {
                        this.createNeedBubble('./images/ui/badge_hunger.png', '#ff5555');
                        console.log('ü´ß Burbuja de HAMBRE creada');
                    }
                    
                    if (timeSinceMedicine > medicineThreshold) {
                        this.createNeedBubble('./images/ui/badge_medicine.png', '#55ff55');
                        console.log('ü´ß Burbuja de MEDICINA creada');
                    }
                    
                    if (timeSincePlay > playThreshold) {
                        this.createNeedBubble('./images/ui/badge_play.png', '#ffaa55');
                        console.log('ü´ß Burbuja de JUEGO creada');
                    }
                }
                
                // Actualizar burbujas existentes
                this.updateExistingNeedBubbles(deltaTime);
            }
            
            createNeedBubble(icon, color) {
                if (!this.fish) return;
                
                // Posici√≥n desde la boca del pez
                const fish = this.fish;
                const direction = fish.direction || 1;
                const mouthX = fish.x + (direction > 0 ? 30 : -30); // Boca del pez
                const mouthY = fish.y;
                
                this.needBubbles.push({
                    x: mouthX,
                    y: mouthY,
                    vx: (Math.random() - 0.5) * 3, // MUY lento horizontal
                    vy: -8 - Math.random() * 5, // MUY lento hacia arriba
                    size: 22, // Tama√±o para ver bien el icono
                    life: 5 + Math.random() * 2, // Duran m√°s tiempo
                    maxLife: 5 + Math.random() * 2,
                    iconPath: icon, // Ruta de la imagen PNG
                    color: color,
                    alpha: 1,
                    iconImage: null // Se cargar√° din√°micamente
                });
            }
            
            updateExistingNeedBubbles(deltaTime) {
                if (!this.needBubbles) return;
                
                for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.needBubbles[i];
                    
                    // Actualizar posici√≥n (COMO BURBUJAS NORMALES)
                    bubble.x += bubble.vx; // Sin deltaTime - movimiento frame por frame
                    bubble.y += bubble.vy;
                    bubble.life -= deltaTime;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.needBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Actualizar alpha
                    bubble.alpha = bubble.life / bubble.maxLife;
                }
            }
            
            drawNeedBubbles() {
                if (!this.needBubbles || this.needBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (const bubble of this.needBubbles) {
                    this.ctx.globalAlpha = bubble.alpha * 0.7; // M√ÅS TRANSL√öCIDA
                    
                    // Dibujar burbuja base (m√°s transl√∫cida)
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.strokeStyle = bubble.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = bubble.color;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Cargar y dibujar icono PNG
                    if (!bubble.iconImage) {
                        bubble.iconImage = new Image();
                        bubble.iconImage.src = bubble.iconPath;
                    }
                    
                    if (bubble.iconImage && bubble.iconImage.complete) {
                        this.ctx.globalAlpha = bubble.alpha;
                        const iconSize = bubble.size * 0.7;
                        this.ctx.drawImage(
                            bubble.iconImage,
                            bubble.x - iconSize/2,
                            bubble.y - iconSize/2,
                            iconSize,
                            iconSize
                        );
                    }
                    
                    this.ctx.shadowBlur = 0; // Limpiar sombra
                }
                
                this.ctx.restore();
            }
            
            // ‚ú® DIBUJAR BURBUJAS DE LIMPIEZA
            drawCleaningBubbles() {
                if (!this.cleaningBubbles || this.cleaningBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (let i = this.cleaningBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cleaningBubbles[i];
                    
                    // Actualizar burbuja
                    bubble.x += bubble.vx * (1/60);
                    bubble.y += bubble.vy * (1/60);
                    bubble.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.cleaningBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar burbuja de limpieza
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha * 0.8;
                    
                    // Color azul brillante para limpieza
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#ffffff'; // Burbujas brillantes
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00bfff';
                    } else {
                        this.ctx.fillStyle = '#87ceeb'; // Burbujas normales azul cielo
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#4169e1';
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo interno
                    this.ctx.globalAlpha = alpha * 0.4;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // üéÆ FUNCIONES DE JUEGOS
            playBubbleGame() {
                this.showCustomModal({
                    title: 'ü´ß Juego de Burbujas',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüéÆ ¬°Ser√° s√∫per divertido!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            playMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüß† ¬°Ser√° s√∫per desafiante!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            showGameLocked(starsNeeded) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesitamos m√°s estrellas para este juego!"\n\n‚≠ê Tienes: ${this.gameState.stars || 0} estrellas\n‚≠ê Necesitas: ${starsNeeded} estrellas\n\nüéÆ ¬°Juega otros juegos para ganar estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            startGame(gameId) {
                // Cerrar modal de juegos
                document.getElementById('gamesModal').style.display = 'none';
                
                switch(gameId) {
                    case 'bubbles':
                        this.startBubbleGame();
                        break;
                    case 'memory':
                        this.startMemoryGame();
                        break;
                    default:
                        this.showCustomModal({
                            title: 'üöß En Desarrollo',
                            message: `üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\n‚ú® Pr√≥ximamente disponible...`,
                            confirmText: 'üëç ¬°Esperar√©!',
                            onConfirm: () => {}
                        });
                }
            }

            showGameLocked(starsRequired) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesito m√°s estrellas para jugar!"\n\n‚≠ê Necesitas: ${starsRequired} estrellas\n‚≠ê Tienes: ${this.gameState.stars}\n\nüéÆ ¬°Juega m√°s para conseguir estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // üåä MODAL DE RESET EMOTIVO
            showResetModal() {
                const fishName = this.gameState.fishName || 'tu pececito';
                
                this.showCustomModal({
                    title: 'üåä Despedida de tu Pececito',
                    message: `üê†üí≠ "${fishName === 'tu pececito' ? 'Hola' : 'Soy ' + fishName}... ¬øde verdad me vas a dejar libre?"

üè† Volver√© al oc√©ano infinito y ser√© feliz
üíï Siempre recordar√© nuestros momentos juntos
üéÆ Podr√°s cuidar a un nuevo compa√±ero
üì∏ Nuestros recuerdos quedar√°n en mi coraz√≥n

‚ö†Ô∏è **Se perder√° todo el progreso actual**
ü´ß Burbujas: ${this.gameState.bubbles || 0}
‚≠ê Estrellas: ${this.gameState.stars || 0}
üìÖ D√≠as juntos: ${this.gameState.ageInDays || 0}`,
                    confirmText: 'üåä ¬°S√© libre y feliz!',
                    cancelText: 'üíï ¬°No, te quiero!',
                    onConfirm: () => {
                        this.showCustomModal({
                            title: 'üåä ¬°Hasta siempre!',
                            message: `üê†üíï "¬°Gracias por todo! ¬°Fui muy feliz contigo!"\n\nüåä *Nada hacia el oc√©ano infinito*\n\n‚ú® Tu nueva aventura comenzar√° en un momento...`,
                            confirmText: 'üëã ¬°Adi√≥s!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            }
                        });
                    },
                    onCancel: () => {
                        this.showCustomModal({
                            title: 'üíï ¬°Qu√© alegr√≠a!',
                            message: `üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos siendo los mejores amigos! üéÆ\n\nüí™ ¬°Vamos a vivir m√°s aventuras juntos!`,
                            confirmText: 'ü•∞ ¬°Siempre juntos!',
                            onConfirm: () => {}
                        });
                    }
                });
            }

            // üéÆ Pantalla de carga ELIMINADA (ya no se usa)
            showLoadingWithFishName() {
                console.log('üéÆ showLoadingWithFishName() ELIMINADO - Ya no hay pantalla de carga');
                // M√©todo eliminado - ir directo al juego
            }

            // üíÄ A√±adir bot√≥n reset al men√∫ solo si ya tienes pez
            addResetButtonToMenu() {
                const actionBar = document.querySelector('.action-bar');
                if (!document.getElementById('resetButton')) {
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'menu-btn';
                    resetBtn.id = 'resetButton';
                    resetBtn.title = 'Cuidar otro pececito';
                    resetBtn.innerHTML = '<div class="btn-icon">üíÄ</div>';
                    
                    resetBtn.addEventListener('click', () => {
                        this.showResetModal();
                    });
                    
                    actionBar.appendChild(resetBtn);
                    console.log('üíÄ Bot√≥n reset a√±adido al men√∫');
                }
            }
            
            // ü´ß JUEGO DE BURBUJAS - DIRECTO
            startBubbleGame() {
                console.log('ü´ß Iniciando juego de burbujas...');
                // Ir directo al juego sin modal previo
                this.runBubbleGame();
            }
            
            runBubbleGame() {
                // Crear overlay del juego completo
                const gameOverlay = document.createElement('div');
                gameOverlay.id = 'bubbleGameOverlay';
                gameOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                    z-index: 2000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    padding: 20px;
                    font-family: 'Comic Sans MS', cursive;
                    overflow: hidden;
                `;

                // UI del juego
                const gameUI = document.createElement('div');
                gameUI.style.cssText = `
                    color: white;
                    text-align: center;
                    margin-bottom: 15px;
                    font-size: 20px;
                    font-weight: bold;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                    background: rgba(255,255,255,0.1);
                    padding: 10px 20px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.3);
                `;
                gameUI.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                        <div>‚è±Ô∏è Tiempo: <span id="bubbleTimer">20</span>s</div>
                        <div>ü´ß Puntos: <span id="bubbleScore">0</span></div>
                        <button id="exitGameBtn" style="
                            background: rgba(255,255,255,0.2);
                            border: 2px solid rgba(255,255,255,0.5);
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            color: white;
                            font-size: 18px;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">‚ùå</button>
                    </div>
                    <div style="
                        color: rgba(255,255,255,0.8);
                        font-size: 12px;
                        text-align: center;
                        margin-top: 8px;
                        line-height: 1.3;
                    ">
                        üîµ Toca burbujas azules (+3 pts +tiempo) üî¥ Evita rojas (-2 pts)<br>
                        ‚≠ê 1 estrella por jugar ‚Ä¢ 2 por r√©cord personal ‚Ä¢ 3 por r√©cord global
                    </div>
                `;

                const gameArea = document.createElement('div');
                gameArea.id = 'bubbleGameArea';
                gameArea.style.cssText = `
                    position: relative;
                    width: 100%;
                    max-width: 350px;
                    height: 450px;
                    border-radius: 20px;
                    overflow: hidden;
                    cursor: pointer;
                    background: rgba(255,255,255,0.05);
                    border: 3px solid rgba(255,255,255,0.2);
                `;

                gameOverlay.appendChild(gameUI);
                gameOverlay.appendChild(gameArea);
                document.body.appendChild(gameOverlay);

                // Bot√≥n de salir
                document.getElementById('exitGameBtn').addEventListener('click', () => {
                    gameActive = false;
                    clearInterval(gameTimer);
                    clearInterval(bubbleSpawner);
                    document.body.removeChild(gameOverlay);
                    if (document.head.contains(style)) {
                        document.head.removeChild(style);
                    }
                });

                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                let baseSpawnRate = 800; // Velocidad base de aparici√≥n
                let currentSpawnRate = baseSpawnRate;
                let gameStartTime = Date.now();
                
                // Sistema de r√©cords
                const personalRecord = parseInt(localStorage.getItem('bubbleGame_personalRecord') || '0');
                const globalRecord = parseInt(localStorage.getItem('bubbleGame_globalRecord') || '50'); // R√©cord global inicial

                // Actualizar UI
                const updateUI = () => {
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    document.getElementById('bubbleScore').textContent = score;
                };

                // Crear burbuja
                const createBubble = () => {
                    if (!gameActive) return;

                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35; // 65% buenas, 35% malas
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        border-radius: 50%;
                        background: ${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid ${isGood ? '#ffffff' : '#ffdddd'};
                        box-shadow: 0 0 12px ${isGood ? 'rgba(135,206,235,0.8)' : 'rgba(255,107,107,0.8)'};
                        cursor: pointer;
                        animation: bubbleFloat 3.5s linear;
                        top: 100%;
                        left: ${Math.random() * (350 - size)}px;
                        z-index: 1001;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${size * 0.4}px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                    `;

                    bubble.innerHTML = isGood ? 'üîµ' : 'üî¥';
                    bubble.dataset.good = isGood;
                    
                    bubble.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!gameActive) return;

                        if (isGood) {
                            score += 3;
                            // ‚è∞ A√ëADIR TIEMPO POR BURBUJA BUENA
                            timeLeft += 1; // +1 segundo por burbuja buena
                            bubble.style.background = 'radial-gradient(circle, #00ff88, #32cd32)';
                            bubble.innerHTML = '+3 +1s';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                            
                            // üöÄ AUMENTAR DIFICULTAD PROGRESIVAMENTE
                            if (score > 0 && score % 15 === 0) { // Cada 15 puntos
                                currentSpawnRate = Math.max(300, currentSpawnRate - 50); // M√°s r√°pido, m√≠nimo 300ms
                                console.log(`üöÄ Dificultad aumentada: ${currentSpawnRate}ms`);
                            }
                        } else {
                            score = Math.max(0, score - 2);
                            bubble.style.background = 'radial-gradient(circle, #ff4444, #dc143c)';
                            bubble.innerHTML = '-2';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                        }
                        
                        updateUI();
                        
                        setTimeout(() => {
                            if (bubble.parentNode) bubble.remove();
                        }, 600);
                    });

                    gameArea.appendChild(bubble);
                    bubbles.push(bubble);

                    // Remover burbuja despu√©s de la animaci√≥n
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                        const index = bubbles.indexOf(bubble);
                        if (index > -1) bubbles.splice(index, 1);
                    }, 3500);
                };

                // A√±adir CSS de animaci√≥n
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes bubbleFloat {
                        0% { 
                            transform: translateY(0) rotate(0deg) scale(0.8);
                            opacity: 0.7;
                        }
                        10% { 
                            opacity: 1;
                            transform: translateY(-40px) rotate(20deg) scale(1);
                        }
                        100% { 
                            transform: translateY(-500px) rotate(360deg) scale(0.9);
                            opacity: 0.8;
                        }
                    }
                `;
                document.head.appendChild(style);

                // Timer del juego
                const gameTimer = setInterval(() => {
                    timeLeft--;
                    updateUI();

                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        clearInterval(bubbleSpawner);
                        
                        // Finalizar juego
                        setTimeout(() => {
                            document.body.removeChild(gameOverlay);
                            document.head.removeChild(style);
                            
                            // Actualizar burbujas del jugador
                            const finalScore = Math.max(0, score);
                            this.gameState.bubbles += finalScore;
                            
                            // ‚≠ê SISTEMA DE ESTRELLAS SEG√öN RENDIMIENTO
                            let starsEarned = 1; // 1 estrella por jugar
                            let achievement = 'Partida completada';
                            
                            if (finalScore > personalRecord) {
                                starsEarned = 2; // 2 estrellas por r√©cord personal
                                achievement = '¬°Nuevo r√©cord personal!';
                                localStorage.setItem('bubbleGame_personalRecord', finalScore.toString());
                            }
                            
                            if (finalScore > globalRecord) {
                                starsEarned = 3; // 3 estrellas por r√©cord global
                                achievement = '¬°R√âCORD GLOBAL! ¬°Eres incre√≠ble!';
                                localStorage.setItem('bubbleGame_globalRecord', finalScore.toString());
                            }
                            
                            this.gameState.stars += starsEarned;
                            
                            // üéÜ EFECTOS VISUALES DE RECOMPENSA
                            if (finalScore > 0) {
                                this.showRewardEffect('bubbles', finalScore);
                                setTimeout(() => {
                                    this.showRewardEffect('stars', starsEarned);
                                }, 800);
                            }
                            
                            this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                            this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                            this.saveGame();

                            // Mostrar resultado
                            this.showCustomModal({
                                title: starsEarned === 3 ? 'üèÜ ¬°R√âCORD GLOBAL!' : starsEarned === 2 ? 'üéâ ¬°Nuevo R√©cord!' : 'üéÆ ¬°Bien Jugado!',
                                message: `üê†üí≠ "${achievement}"\n\nü´ß Puntos: ${finalScore}\n‚≠ê Estrellas ganadas: ${starsEarned}\nüìä R√©cord personal: ${Math.max(personalRecord, finalScore)}\nüèÜ R√©cord global: ${Math.max(globalRecord, finalScore)}\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                                confirmText: 'üéÆ ¬°Genial!'
                            });
                        }, 1000);
                    }
                }, 1000);

                // Spawner de burbujas din√°mico
                const bubbleSpawner = setInterval(() => {
                    if (gameActive) {
                        createBubble();
                    }
                }, currentSpawnRate);

                // Actualizar spawner din√°micamente
                const updateSpawner = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(updateSpawner);
                        return;
                    }
                    clearInterval(bubbleSpawner);
                    const newSpawner = setInterval(() => {
                        if (gameActive) createBubble();
                    }, currentSpawnRate);
                }, 1000);

                // Crear burbujas iniciales
                setTimeout(() => createBubble(), 300);
                setTimeout(() => createBubble(), 800);
                setTimeout(() => createBubble(), 1200);
            }
            
            // üß† JUEGO DE MEMORIA
            startMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: `üê†üí≠ "¬°A ejercitar la mente!"\n\nüéØ **Objetivo:**\nEncuentra todas las parejas de cartas\nRecuerda d√≥nde est√°n las im√°genes\n\nüèÜ **Recompensas:**\n+3 burbujas por pareja encontrada\nBonus de velocidad\n\nüÉè Cartas: 8 parejas (16 cartas)`,
                    confirmText: 'üß† ¬°Empezar!',
                    cancelText: '‚ùå Cancelar',
                    onConfirm: () => {
                        this.runMemoryGame();
                    }
                });
            }
            
            runMemoryGame() {
                // Implementaci√≥n del juego de memoria
                this.showCustomModal({
                    title: 'üß† ¬°Jugando Memoria!',
                    message: `üéÆ **DEMO DEL JUEGO**\n\nüÉè Parejas encontradas: 6/8\nüëÅÔ∏è Cartas volteadas: 18\n‚è±Ô∏è Tiempo: 45s\n\nüèÜ Puntuaci√≥n actual: +18 burbujas`,
                    confirmText: '‚úÖ Terminar',
                    onConfirm: () => {
                        // Dar recompensa
                        this.gameState.bubbles += 18;
                        this.gameState.stars += 3;
                        this.updateUI();
                        
                        this.showCustomModal({
                            title: 'üèÜ ¬°Excelente Memoria!',
                            message: `üê†üí≠ "¬°Tienes una memoria incre√≠ble!"\n\nüéâ **Recompensas obtenidas:**\nü´ß +18 burbujas\n‚≠ê +3 estrellas\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                            confirmText: 'ü•∞ ¬°Gracias!',
                            onConfirm: () => {}
                        });
                    }
                });
            }
            
            // üíä DAR MEDICINA (PLACEHOLDER)
            giveMedicine() {
                console.log('üíä Dando medicina al pez...');
                this.gameState.lastMedicine = Date.now();
                this.gameState.health = Math.min(100, this.gameState.health + 40);
                console.log('üè• Pez curado - Salud:', this.gameState.health);
            }

            // üí∞ SISTEMA DE COSTOS PROGRESIVOS
            getBackgroundCost(bgName) {
                const costs = {
                    'cartoon': 15,   // Primer fondo - f√°cil de conseguir
                    'coral': 25,     // Segundo fondo
                    'mario': 40,     // M√°s caro
                    'minecraft': 60  // El m√°s caro
                };
                return costs[bgName] || 30; // Costo por defecto
            }

            // üéÜ EFECTOS DE RECOMPENSA
            showRewardEffect(type, amount, sourceElement = null) {
                const emoji = type === 'bubbles' ? 'ü´ß' : '‚≠ê';
                const color = type === 'bubbles' ? 'rgba(100,200,255,0.6)' : 'rgba(255,215,0,0.6)';
                
                // Posici√≥n de origen (elemento fuente o centro de pantalla)
                let startX, startY;
                if (sourceElement) {
                    const rect = sourceElement.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                } else {
                    startX = window.innerWidth / 2;
                    startY = window.innerHeight / 2;
                }

                // Crear m√∫ltiples burbujas seg√∫n la cantidad
                const bubbleCount = Math.min(amount, 5); // M√°ximo 5 burbujas
                for (let i = 0; i < bubbleCount; i++) {
                    setTimeout(() => {
                        this.createRewardBubble(emoji, color, startX, startY, i);
                    }, i * 150); // Delay escalonado
                }

                // Explosi√≥n dorada al final
                setTimeout(() => {
                    this.createRewardExplosion(startX, startY);
                }, bubbleCount * 150 + 500);
            }

            createRewardBubble(emoji, color, startX, startY, index) {
                const bubble = document.createElement('div');
                bubble.className = 'reward-bubble';
                bubble.textContent = emoji;
                bubble.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), ${color})`;
                bubble.style.boxShadow = `0 0 20px ${color}`;
                
                // Posici√≥n inicial con variaci√≥n
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 50;
                bubble.style.left = (startX + offsetX - 30) + 'px';
                bubble.style.top = (startY + offsetY - 30) + 'px';
                
                document.body.appendChild(bubble);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                }, 2000);
            }

            createRewardExplosion(x, y) {
                const explosion = document.createElement('div');
                explosion.className = 'reward-explosion';
                explosion.style.left = (x - 50) + 'px';
                explosion.style.top = (y - 50) + 'px';
                
                document.body.appendChild(explosion);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.remove();
                    }
                }, 800);
            }

            // üéì MODAL DE TUTORIAL BONITO
            showTutorialModal() {
                this.showCustomModal({
                    title: 'Tu Primera Aventura Marina',
                    message: `"¬°Hola! Soy tu nuevo compa√±ero virtual."\n\nü•ö Primero aparecer√© como un huevito\n‚è∞ En 24 horas eclosionar√© y nadar√© contigo\nüéÆ Mientras tanto, puedes jugar minijuegos\n\n¬°Clica aqu√≠ y aparecer√° tu huevito de pez!`,
                    confirmText: '¬°Colocar mi huevo!',
                    onConfirm: () => {
                        // CERRAR MODAL PRIMERO para ver el efecto
                        const customModal = document.querySelector('.custom-modal');
                        if (customModal) {
                            customModal.remove();
                        }
                        
                        // Peque√±o delay para que se vea el cierre
                        setTimeout(() => {
                            this.startEggPlacement();
                        }, 300);
                    }
                });
            }

            // ü•ö INICIAR COLOCACI√ìN DEL HUEVO
            startEggPlacement() {
                console.log('‚ú® INICIANDO MAGIA DEL HUEVO...');
                
                // CERRAR MODAL INMEDIATAMENTE para que no se vea el huevo
                const modals = document.querySelectorAll('.custom-modal, .modal-overlay, .game-modal-overlay');
                modals.forEach(modal => {
                    modal.remove();
                    console.log('üö™ Modal eliminada');
                });
                
                // Tambi√©n ocultar cualquier modal por CSS
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 100);
                
                // üéµ INICIAR M√öSICA DE FONDO AL APARECER EL HUEVO (si no est√° ya sonando)
                if (window.audioManager && !window.audioManager.isMuted && !window.audioManager.backgroundMusic?.played?.length) {
                    window.audioManager.startBackgroundMusic();
                    console.log('üéµ M√∫sica de fondo iniciada con el huevo');
                }
                
                // ASEGURAR que NO hay huevo todav√≠a
                this.gameState.stage = 'waiting';
                this.gameState.eggStartTime = null;
                
                // üè∑Ô∏è RESETEAR NOMBRE PARA NUEVO PEZ
                this.gameState.hasAskedForName = false;
                this.gameState.fishName = null;
                console.log('üè∑Ô∏è Estado de nombre reseteado para nuevo pez');
                
                // üßº RESETEAR SOLO PANTALLA Y BURBUJAS AL INICIAR HUEVO
                this.gameState.needs.dirt = 0;     // Pantalla limpia
                this.gameState.bubbles = 0;        // Sin burbujas
                console.log('üßº Pantalla reseteada: limpia, sin burbujas');
                
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                // PASO 1: USAR EL MISMO EFECTO QUE EL NACIMIENTO DEL PEZ
                console.log('üöÄ LLAMANDO createEggExplosionBubbles()...');
                this.createEggExplosionBubbles();
                console.log('üöÄ createEggExplosionBubbles() EJECUTADO');
                    
                console.log('‚ú® Burbujas de aparici√≥n del huevo (como nacimiento)...');
                
                // PASO 2: Colocar huevo y EMPEZAR CRON√ìMETRO (2.2s)
                    setTimeout(() => {
                    const now = Date.now();
                    
                    // Colocar huevo Y empezar cron√≥metro AL MISMO TIEMPO
                    this.gameState.stage = 'egg';
                    this.gameState.eggStartTime = now;
                    this.egg.x = centerX;
                    this.egg.y = centerY;
                    
                    // Iniciar animaci√≥n de aparici√≥n del huevo
                    this.startEggAppearanceAnimation();
                    
                    console.log('ü•ö ¬°Huevo + cron√≥metro iniciados!');
                }, 800); // MUCHO M√ÅS R√ÅPIDO (era 2200ms)
                
                // PASO 3: Desactivar efectos gradualmente (6s total)
                setTimeout(() => {
                    this.gameState.showMagicBubbles = false;
                    console.log('‚ú® Magia completada');
                }, 6000);
            }

            // ü´ß BURBUJAS COPIADAS DEL TEST QUE FUNCIONA
            createSimpleBubbles() {
                console.log('‚ú® COPIANDO SISTEMA DEL TEST...');
                
                // LIMPIAR COMPLETAMENTE
                this.bgBubbles = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // EXACTAMENTE como en el test que funciona
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 150;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const burbuja = {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        r: 8 + Math.random() * 12,
                        alpha: 0.6 + Math.random() * 0.4,
                        color: `hsl(${190 + Math.random() * 40}, 70%, 70%)`,
                        life: 120, // 2 segundos a 60fps
                        sparkle: Math.random() > 0.5,
                        isTestBubble: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(burbuja);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas TEST creadas`);
            }

            // üå´Ô∏è EFECTOS ANTES DEL HUEVO - SISTEMA PERSISTENTE (VIEJO)
            createPreEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('‚ú® TEST BURBUJAS INMORTALES...');
                
                // LIMPIAR burbujas existentes
                this.bgBubbles = [];
                
                // TEST: 10 burbujas INMORTALES que NUNCA se eliminen
                for (let i = 0; i < 10; i++) {
                    const x = 50 + i * 35;
                    const y = 150;
                    
                    const bubble = {
                        x: x,
                        y: y,
                        vx: 0, // SIN MOVIMIENTO
                        vy: 0, // EST√ÅTICAS
                        r: 25, // GRANDES
                        alpha: 1, // OPACAS
                        color: '#ff0000', // ROJO BRILLANTE
                        life: 999999, // VIDA INFINITA
                        maxLife: 999999,
                        sparkle: false,
                        isAppearanceEffect: true,
                        immortal: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(bubble);
                    console.log(`üî¥ Burbuja INMORTAL ${i+1} en (${x}, ${y})`);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas INMORTALES creadas`);
            }

            // üí¨ MENSAJE TEMPORAL EN PANTALLA
            showTemporaryMessage(text, duration) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 40%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 50, 100, 0.8);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 12px;
                    font-size: 14px;
                    font-weight: bold;
                    text-align: center;
                    z-index: 1500;
                    border: 2px solid rgba(255,255,255,0.4);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    animation: messageFloat 0.5s ease-out;
                `;
                messageDiv.textContent = text;
                
                // A√±adir CSS de animaci√≥n si no existe
                if (!document.getElementById('messageFloatStyle')) {
                    const style = document.createElement('style');
                    style.id = 'messageFloatStyle';
                    style.textContent = `
                        @keyframes messageFloat {
                            from { 
                                transform: translate(-50%, -50%) scale(0.8);
                                opacity: 0;
                            }
                            to { 
                                transform: translate(-50%, -50%) scale(1);
                                opacity: 1;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageDiv);
                
                // Remover despu√©s del tiempo especificado
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, duration);
            }
            
            // üéÆ MOSTRAR JUEGOS - MODAL SIMPLE Y FUNCIONAL
            showGames() {
                console.log('üéÆ Abriendo modal de juegos simple...');
                
                // Usar la nueva modal simple
                const modal = document.getElementById('gamesModal');
                modal.style.display = 'flex';
                
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de juegos din√°micamente
                this.updateGameAvailabilitySquare();
            }
            
            // üéØ ACTUALIZAR DISPONIBILIDAD DE JUEGOS CUADRADOS
            updateGameAvailabilitySquare() {
                const stars = this.gameState.stars || 0;
                
                const gameRequirements = {
                    'bubbles': 0,
                    'memory': 10,
                    'snake': 25,
                    'puzzle': 50,
                    'race': 75,
                    'target': 100,
                    'adventure': 150,
                    'tower': 200,
                    'boss': 300
                };
                
                // Actualizar cada juego seg√∫n las estrellas disponibles
                Object.entries(gameRequirements).forEach(([gameId, requiredStars]) => {
                    const card = document.querySelector(`[data-game="${gameId}"]`);
                    if (card) {
                        if (stars >= requiredStars) {
                            card.classList.remove('locked');
                            card.classList.add('available');
                        } else {
                            card.classList.add('locked');
                            card.classList.remove('available');
                        }
                    }
                });
                
                console.log(`üéÆ Juegos cuadrados actualizados. Estrellas: ${stars}`);
            }
            
            // Funci√≥n temporal para mantener compatibilidad
            populateGamesGrid() {
                // Esta funci√≥n ya no es necesaria con el nuevo dise√±o
                console.log('üéÆ populateGamesGrid() - Ya no es necesaria con el nuevo dise√±o');

                const buttonsHTML = gameButtons.map(game => {
                    if (game.available) {
                        return `<button onclick="game.startGame('${game.id}')" style="
                            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
                            border: 2px solid #0277bd;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: white;
                            font-size: 16px;
                            cursor: pointer;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                        </button>`;
                    } else {
                        return `<button style="
                            background: linear-gradient(135deg, #bbb, #999);
                            border: 2px solid #666;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: #666;
                            font-size: 16px;
                            cursor: not-allowed;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                            opacity: 0.6;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                            <div style="font-size: 10px;">‚≠ê ${game.stars}</div>
                        </button>`;
                    }
                }).join('');

                this.showCustomModal({
                    title: 'üéÆ Minijuegos',
                    message: `üê†üí≠ "¬°Elige un juego para divertirnos!"\n\n<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 5px;">${buttonsHTML}</div>`,
                    confirmText: '‚ùå Cerrar',
                    onConfirm: () => {}
                });
            }
            
            populateGamesGrid() {
                const gamesGrid = document.getElementById('gamesGrid');
                if (!gamesGrid) return;
                
                const games = [
                    { id: 'bubbles', icon: 'ü´ß', name: 'Burbujas', available: true, stars: 0 },
                    { id: 'memory', icon: 'üß†', name: 'Memoria', available: this.gameState.stars >= 10, stars: 10 },
                    { id: 'target', icon: 'üéØ', name: 'Punter√≠a', available: false, stars: 25 },
                    { id: 'race', icon: 'üèÉ', name: 'Carrera', available: false, stars: 50 },
                    { id: 'puzzle', icon: 'üß©', name: 'Puzzle', available: false, stars: 75 },
                    { id: 'adventure', icon: 'üó∫Ô∏è', name: 'Aventura', available: false, stars: 100 }
                ];
                
                gamesGrid.innerHTML = games.map(game => {
                    const isAvailable = game.available;
                    
                    return `
                        <div class="game-card ${isAvailable ? 'available' : 'locked'}" 
                             data-game-id="${game.id}" 
                             data-available="${isAvailable}"
                             data-stars="${game.stars}">
                            <div class="game-icon">${game.icon}</div>
                            <div class="game-name">${game.name}</div>
                            ${!isAvailable ? `<div class="game-requirement">‚≠ê ${game.stars}</div>` : ''}
                        </div>
                    `;
                }).join('');

                // A√±adir event listeners a las cartas de juego
                setTimeout(() => {
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.addEventListener('click', (e) => {
                            const gameId = card.dataset.gameId;
                            const isAvailable = card.dataset.available === 'true';
                            const stars = parseInt(card.dataset.stars);

                            console.log(`üéÆ Click en juego: ${gameId}, disponible: ${isAvailable}`);

                            if (isAvailable) {
                                console.log(`üöÄ Iniciando juego: ${gameId}`);
                                // CERRAR MODAL ANTES DE INICIAR JUEGO
                                const customModal = document.querySelector('.custom-modal');
                                if (customModal) {
                                    customModal.remove();
                                }
                                this.startGame(gameId);
                            } else {
                                console.log(`üîí Juego bloqueado: ${gameId}, necesita ${stars} estrellas`);
                                this.showGameLocked(stars);
                            }
                        });
                    });
                }, 100);
            }
            
            // üéí MOSTRAR INVENTARIO (PLACEHOLDER)
            showInventory() {
                console.log('üéí Abriendo inventario...');
                
                this.showCustomModal({
                    title: 'üéí Mi Inventario',
                    message: `üê†üí≠ "¬°Mira todas mis cosas!"

üí∞ Tienes: ü´ß ${this.gameState.bubbles || 0} burbujas | ‚≠ê ${this.gameState.stars || 0} estrellas

üåä **Fondos de Pecera** - DISPONIBLE
Cambia el fondo de tu acuario
üñºÔ∏è ${this.availableBackgrounds ? this.availableBackgrounds.length : 5} fondos disponibles

üé® **Decoraciones** - PR√ìXIMAMENTE
Rocas, plantas, castillos...
üöß En desarrollo

üçΩÔ∏è **Comida Especial** - PR√ìXIMAMENTE  
Comida premium y de cumplea√±os
üöß En desarrollo`,
                    confirmText: 'üåä Ver Fondos',
                    cancelText: '‚ùå Cerrar',
                    onConfirm: () => {
                        // Abrir selector de fondos (funci√≥n existente)
                        document.getElementById('inventoryModal').style.display = 'flex';
                    },
                    onCancel: () => {
                        console.log('üéí Inventario cerrado');
                    }
                });
            }
            
            // üì∏ MOSTRAR √ÅLBUM (PLACEHOLDER)
            showAlbum() {
                console.log('üì∏ Abriendo √°lbum...');
                
                this.showCustomModal({
                    title: 'üì∏ √Ålbum de Mi Pececito',
                    message: `
                        <div style="text-align: center; padding: 20px;">
                            <div style="margin-bottom: 15px; font-size: 16px;">üìÖ Momentos Especiales</div>
                            <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <div style="font-weight: bold; margin-bottom: 5px;">üê£ ¬°He nacido!</div>
                                <div style="font-size: 12px; color: #666;">Mi primer d√≠a en el mundo</div>
                                <div style="font-size: 11px; color: #999;">Hace unos momentos</div>
                            </div>
                            <div style="color: #666; font-style: italic;">M√°s recuerdos aparecer√°n aqu√≠...</div>
                        </div>
                    `,
                    confirmText: '‚ùå Cerrar',
                    showCancel: false,
                    onConfirm: () => {
                        console.log('üì∏ √Ålbum cerrado');
                    }
                });
            }
            
            // üîÑ DETECCI√ìN MUY TEMPRANA DE BORDES
            handleSimpleFishBoundaries() {
                const fish = this.fish;
                const fishSize = 60; // Tama√±o aproximado del pez Lottie
                const padding = fishSize + 40; // MARGEN MUY GRANDE (100px total)
                
                // DETECCI√ìN TEMPRANA: Antes de que se salga del borde
                
                // BORDE IZQUIERDO
                if (fish.x <= padding && fish.direction === -1) {
                    fish.direction = 1; // Girar a la derecha
                    fish.x = padding + 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana IZQUIERDO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la DERECHA`);
                }
                
                // BORDE DERECHO  
                if (fish.x >= this.canvas.width - padding && fish.direction === 1) {
                    fish.direction = -1; // Girar a la izquierda
                    fish.x = this.canvas.width - padding - 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana DERECHO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la IZQUIERDA`);
                }
                
                // BORDE SUPERIOR - M√°s margen
                if (fish.y <= this.canvas.height * 0.2 && fish.verticalDirection === -1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : 1;
                    fish.y = this.canvas.height * 0.2 + 10;
                    console.log(`üê† Detecci√≥n MUY temprana SUPERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ABAJO ‚Üì'}`);
                }
                
                // BORDE INFERIOR - M√°s margen
                if (fish.y >= this.canvas.height * 0.8 && fish.verticalDirection === 1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : -1;
                    fish.y = this.canvas.height * 0.8 - 10;
                    console.log(`üê† Detecci√≥n MUY temprana INFERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ARRIBA ‚Üë'}`);
                }
                
                // SEGURIDAD SILENCIOSA: Solo reposicionar sin spam de logs
                const safetyMargin = 80;
                if (fish.x < safetyMargin) {
                    fish.x = safetyMargin;
                    fish.direction = 1; // Forzar direcci√≥n hacia la derecha
                }
                if (fish.x > this.canvas.width - safetyMargin) {
                    fish.x = this.canvas.width - safetyMargin;
                    fish.direction = -1; // Forzar direcci√≥n hacia la izquierda
                }
                if (fish.y < safetyMargin) {
                    fish.y = safetyMargin;
                    fish.verticalDirection = 1; // Forzar hacia abajo
                }
                if (fish.y > this.canvas.height - safetyMargin) {
                    fish.y = this.canvas.height - safetyMargin;
                    fish.verticalDirection = -1; // Forzar hacia arriba
                }
            }
            
            // üîÑ ORIENTACI√ìN CORREGIDA
            updateFishOrientation() {
                const fish = this.fish;
                const container = document.getElementById('lottieContainer');
                if (!container) return;
                
                // EL PEZ LOTTIE MIRA HACIA LA IZQUIERDA POR DEFECTO
                // Para que vaya a la DERECHA necesitamos invertirlo
                // direction = 1 (derecha) ‚Üí scaleX(-1) invertido
                // direction = -1 (izquierda) ‚Üí scaleX(1) normal
                
                const scaleX = fish.direction === 1 ? -1 : 1;
                
                // Solo cambiar si es diferente
                if (fish.facing !== scaleX) {
                    fish.facing = scaleX;
                    container.style.transform = `translate(-50%, -50%) scaleX(${scaleX})`;
                    
                    console.log(`üîÑ Pez orientado: ${fish.direction === 1 ? 'DERECHA ‚Üí (scaleX -1)' : 'IZQUIERDA ‚Üê (scaleX 1)'}`);
                }
            }
            
            updateCanvasFishAnimations(deltaTime) {
                const fish = this.fish;
                
                // Actualizar timers de animaci√≥n
                if (!fish.breatheTime) fish.breatheTime = 0;
                if (!fish.blinkTime) fish.blinkTime = 0;
                if (!fish.finTime) fish.finTime = 0;
                if (!fish.bubbleTime) fish.bubbleTime = 0;
                if (!fish.floatTime) fish.floatTime = 0;
                if (!fish.baseY) fish.baseY = this.canvas.height * 0.6;
                
                fish.breatheTime += deltaTime * 1.5;
                fish.blinkTime += deltaTime;
                fish.finTime += deltaTime * 2;
                fish.bubbleTime += deltaTime;
                fish.floatTime += deltaTime * 0.8;
                
                // Animaciones Canvas
                const breatheCycle = fish.breatheTime % (2.5 * Math.PI);
                fish.breatheScale = 1 + Math.sin(breatheCycle) * 0.06;
                
                if (fish.blinkTime > 4 + Math.random() * 3) {
                    fish.eyeOpen = 0;
                    setTimeout(() => {
                        if (this.fish) this.fish.eyeOpen = 1;
                    }, 200);
                    fish.blinkTime = 0;
                }
                
                const finCycle = (fish.finTime % (2.5 * Math.PI)) / (2.5 * Math.PI);
                const minRotation = -36 * Math.PI / 180;
                const maxRotation = 4 * Math.PI / 180;
                fish.finRotation = minRotation + (maxRotation - minRotation) * (Math.sin(finCycle * Math.PI * 2) * 0.5 + 0.5);
                
                const floatCycle = fish.floatTime % (2.5 * Math.PI);
                const floatAmount = 10;
                fish.y = fish.baseY + Math.sin(floatCycle) * floatAmount;
                
                if (fish.bubbleTime > 4 + Math.random() * 6) {
                    this.createFishBubble();
                    fish.bubbleTime = 0;
                }
            }
            
            // üîÑ EVOLUCI√ìN AUTOM√ÅTICA
            checkEvolution() {
                if (!this.fish) return;
                
                const ageInDays = this.gameState.ageInDays || 0;
                const currentStage = this.gameState.stage;
                
                // Beb√© ‚Üí Joven (3 d√≠as)
                if (currentStage === 'baby' && ageInDays >= 3) {
                    this.gameState.stage = 'young';
                    this.addAlbumEvent('evolution', 'üå± ¬°He crecido!', 'Ya no soy un beb√©. ¬°Ahora soy un pez joven!');
                    console.log('üå± Evoluci√≥n: Beb√© ‚Üí Joven');
                }
                
                // Joven ‚Üí Adulto (8 d√≠as)
                if (currentStage === 'young' && ageInDays >= 8) {
                    this.gameState.stage = 'adult';
                    this.addAlbumEvent('evolution', 'üëë ¬°Soy adulto!', 'He crecido completamente. ¬°Ahora soy un pez adulto!');
                    console.log('üëë Evoluci√≥n: Joven ‚Üí Adulto');
                }
            }
            
            // üçé SISTEMA DE NECESIDADES
            
            // FUNCI√ìN VIEJA DESHABILITADA - Usamos updateAllNeedBubbles ahora
            // updateNeeds(deltaTime) {
            //     // Esta funci√≥n vieja estaba mostrando texto en lugar de iconos
            //     // Ahora usamos updateAllNeedBubbles() que muestra los iconos correctamente
            // }
            
            // FUNCI√ìN VIEJA DESHABILITADA - Mostraba texto en lugar de iconos
            // showNeedBubble(icon, urgent = false) {
            //     // Esta funci√≥n vieja est√° comentada porque mostraba texto
            //     // Usamos la nueva showNeedBubble(bubbleId, needType, offsetX, offsetY)
            // }
            
            // üé® SISTEMA DE FONDOS
            
            async loadAvailableBackgrounds() {
                // Lista de fondos conocidos (se expandir√° autom√°ticamente)
                const knownBackgrounds = [
                    'bg_basic.png',
                    'bg_cartoon.png', 
                    'bg_coral.png',
                    'bg_mario.png',
                    'bg_minecraft.png'
                ];
                
                for (const bgFile of knownBackgrounds) {
                    const bgName = bgFile.replace('bg_', '').replace('.png', '');
                    try {
                        const img = new Image();
                        img.src = `./images/backgrounds/${bgFile}`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            setTimeout(reject, 2000); // Timeout de 2s
                        });
                        
                        this.availableBackgrounds.push({
                            name: bgName,
                            file: bgFile,
                            image: img,
                            cost: bgName === 'basic' ? 0 : this.getBackgroundCost(bgName), // Costos progresivos
                            unlocked: bgName === 'basic' // Solo basic desbloqueado
                        });
                        
                        console.log(`‚úÖ Fondo cargado: ${bgName}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar: ${bgFile}`);
                    }
                }
                
                console.log(`üé® ${this.availableBackgrounds.length} fondos disponibles`);
                this.populateBackgroundsGrid();
            }
            
            populateBackgroundsGrid() {
                const grid = document.getElementById('backgroundsGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                for (const bg of this.availableBackgrounds) {
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    if (this.gameState.currentBackground === bg.name) {
                        card.classList.add('selected');
                    }
                    
                    const isLocked = bg.cost > 0 && this.gameState.bubbles < bg.cost;
                    
                    card.innerHTML = `
                        <div class="item-preview" style="background-image: url('./images/backgrounds/${bg.file}')${isLocked ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="item-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="item-cost">${bg.cost === 0 ? 'Gratis' : bg.cost + ' ü´ß'}</div>
                        ${isLocked ? '<div class="locked-overlay">üîí</div>' : ''}
                    `;
                    
                    card.addEventListener('click', () => {
                        this.selectBackground(bg.name);
                    });
                    
                    grid.appendChild(card);
                }
            }
            
            selectBackground(bgName) {
                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                if (!bg) return;
                
                // Si ya est√° seleccionado, no hacer nada
                if (this.gameState.currentBackground === bgName) {
                    console.log('üé® Ya tienes este fondo seleccionado');
                    return;
                }
                
                // Si cuesta burbujas, pedir confirmaci√≥n
                if (bg.cost > 0) {
                    // Verificar si tiene suficientes burbujas
                    if (this.gameState.bubbles < bg.cost) {
                        const needed = bg.cost - this.gameState.bubbles;
                        this.showCustomModal({
                            title: 'üê†üí≠ ¬°Me encanta este fondo!',
                            message: `Pero necesitamos m√°s burbujas...\n\nü´ß Necesitas: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n‚ùå Te faltan: ${needed} burbujas\n\nüéÆ ¬°Juega minijuegos para ganar m√°s burbujas!`,
                            confirmText: 'üéÆ ¬°Vamos a jugar!',
                            onConfirm: () => {}
                        });
                        return;
                    }
                    
                    // Mensajes personalizados por fondo
                    const bgDisplayName = bg.name.charAt(0).toUpperCase() + bg.name.slice(1);
                    const fishMessages = {
                        'cartoon': 'üê†üí≠ "¬°Wow! Este lugar parece s√∫per divertido!"',
                        'coral': 'üê†üí≠ "¬°Me encanta nadar entre corales!"',
                        'mario': 'üê†üí≠ "¬°Como en los videojuegos! ¬°Genial!"',
                        'minecraft': 'üê†üí≠ "¬°Un mundo de bloques para explorar!"'
                    };
                    
                    const fishMessage = fishMessages[bg.name] || 'üê†üí≠ "¬°Este lugar se ve genial para nadar!"';
                    
                    this.showCustomModal({
                        title: 'üè† ¬°Tu pececito quiere un nuevo hogar!',
                        message: `üé® Fondo: ${bgDisplayName}\nü´ß Cuesta: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n\n${fishMessage}`,
                        confirmText: '‚ú® ¬°Desbloquear fondo!',
                        cancelText: 'üö´ Mejor no',
                        onConfirm: () => {
                            // Proceder con la compra
                            this.completePurchase(bg);
                        },
                        onCancel: () => {
                            console.log('üö´ Compra cancelada');
                        }
                    });
                    return; // Salir aqu√≠, la compra se completa en completePurchase
                }
                
                // Si es gratis, comprar directamente
                this.completePurchase(bg);
            }
            
            completePurchase(bg) {
                // Cobrar
                if (bg.cost > 0) {
                    this.gameState.bubbles -= bg.cost;
                    console.log(`üí≥ Pagado: ${bg.cost} burbujas`);
                }
                
                // Cambiar fondo
                this.gameState.currentBackground = bg.name;
                this.bgImage = bg.image;
                
                // Mensaje de √©xito
                if (bg.cost > 0) {
                    const successMessages = {
                        'cartoon': 'üéâ ¬°Tu pececito est√° s√∫per feliz en su nuevo hogar cartoon!',
                        'coral': 'üéâ ¬°Tu pececito nada feliz entre los corales!',
                        'mario': 'üéâ ¬°Tu pececito se siente como en un videojuego!',
                        'minecraft': 'üéâ ¬°Tu pececito explora su mundo de bloques!'
                    };
                    
                    const successMsg = successMessages[bg.name] || 'üéâ ¬°Tu pececito ama su nuevo hogar!';
                    
                    // Mostrar mensaje de √©xito con modal bonito
                    this.showCustomModal({
                        title: 'üéâ ¬°Fondo desbloqueado!',
                        message: `${successMsg}\n\nüê†üí≠ "¬°Gracias! ¬°Me encanta!"`,
                        confirmText: 'ü•∞ ¬°De nada!',
                        onConfirm: () => {}
                    });
                }
                
                // A√±adir evento al √°lbum
                this.addAlbumEvent('background', `üé® Nuevo hogar: ${bg.name}`, `He cambiado mi acuario por uno ${bg.name}. ¬°Me encanta mi nuevo hogar!`);
                
                console.log(`üé® Fondo cambiado a: ${bg.name}`);
                this.populateBackgroundsGrid(); // Actualizar selecci√≥n
                this.updateUI();
                this.saveGame();
            }
            
            // üñ•Ô∏è ACTUALIZACI√ìN DE UI
            
            updateUI() {
                // Actualizar contadores con animaci√≥n
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                
                // Actualizar edad y nombre
                this.updateAgeDisplay();
            }
            
            updateCurrencyDisplay(elementId, newValue) {
                const element = document.getElementById(elementId);
                const currentValue = parseInt(element.textContent) || 0;
                
                if (newValue !== currentValue) {
                    element.textContent = newValue;
                    
                    // A√±adir animaci√≥n
                    const floatContainer = element.closest('.currency-float');
                    if (floatContainer) {
                        floatContainer.classList.add('updated');
                        setTimeout(() => {
                            floatContainer.classList.remove('updated');
                        }, 500);
                    }
                }
            }
            
            updateAgeDisplay() {
                const fishAge = document.getElementById('fishAge');
                const fishName = document.getElementById('fishName');
                
                if (this.gameState.stage === 'waiting') {
                    fishAge.textContent = 'Esperando...';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.gameState.stage === 'egg') {
                    fishAge.textContent = 'Huevo';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.fish && this.gameState.birthDate) {
                    // Calcular edad en d√≠as
                    const now = Date.now();
                    const ageInMs = now - this.gameState.birthDate;
                    const ageInDays = Math.floor(ageInMs / (24 * 60 * 60 * 1000));
                    this.gameState.ageInDays = ageInDays;
                    
                    // Mostrar etapa y edad
                    const stageEmojis = {
                        'baby': 'üçº',
                        'young': 'üå±', 
                        'adult': 'üëë'
                    };
                    
                    const stageNames = {
                        'baby': 'Beb√©',
                        'young': 'Joven',
                        'adult': 'Adulto'
                    };
                    
                    const stageName = stageNames[this.gameState.stage] || 'Pez';
                    
                    fishAge.textContent = `${stageName} - ${ageInDays} d√≠a${ageInDays !== 1 ? 's' : ''}`;
                    
                    // Nombre del juego con el nombre del pez
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                } else {
                    fishAge.textContent = 'üçº Beb√©';
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                }
            }
            
            // üê† SISTEMA DE NOMBRE
            
            askForFishName() {
                console.log('üè∑Ô∏è DEBUG NOMBRE:', {
                    hasAskedForName: this.gameState.hasAskedForName,
                    fishName: this.gameState.fishName,
                    shouldAsk: !this.gameState.hasAskedForName && !this.gameState.fishName
                });
                
                if (this.gameState.hasAskedForName || this.gameState.fishName) {
                    console.log('‚ùå No preguntar nombre - Ya preguntado o ya tiene nombre');
                    return;
                }
                
                this.gameState.hasAskedForName = true;
                console.log('üè∑Ô∏è Preguntando nombre del pez...');
                
                // Mostrar burbuja de nombre
                this.showNameBubble();
            }
            
            showNameBubble() {
                if (!this.fish) return;
                
                // Crear modal bonito para el nombre
                this.showCustomModal({
                    title: 'Hola! Soy tu nuevo pececito',
                    message: 'Como quieres llamarme?\n\nSi no escribes nada, elegir√© un nombre bonito para mi',
                    input: true,
                    inputPlaceholder: 'Mi nombre...',
                    confirmText: 'Confirmar',
                    onConfirm: (name) => {
                        if (name && name.trim()) {
                            this.gameState.fishName = name.trim();
                            console.log(`üè∑Ô∏è Pez nombrado: ${this.gameState.fishName}`);
                        } else {
                            this.setRandomName();
                            console.log(`üè∑Ô∏è Nombre aleatorio elegido: ${this.gameState.fishName}`);
                        }
                        this.updateUI();
                        this.saveGame();
                    }
                });
            }
            
            setRandomName() {
                const randomNames = ['Burbuj√≠n', 'Nadador', 'Azulito', 'Brillante', 'Saltar√≠n', 'Coralito'];
                this.gameState.fishName = randomNames[Math.floor(Math.random() * randomNames.length)];
                
                this.showCustomModal({
                    title: 'üé≤ ¬°Sorpresa!',
                    message: `üê†üí≠ "¬°Me llamar√© ${this.gameState.fishName}!"\n\n¬°Espero que te guste mi nombre! üòä`,
                    confirmText: 'üíï ¬°Me encanta!',
                    onConfirm: () => {}
                });
            }
            
            // üé® MODAL PERSONALIZADO BONITO
            showCustomModal(options) {
                // Crear modal din√°micamente
                const modal = document.createElement('div');
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <div class="custom-modal-content">
                        <div class="custom-modal-header">
                            <h2>${options.title}</h2>
                        </div>
                        <div class="custom-modal-body">
                            <p>${options.message.replace(/\n/g, '<br>')}</p>
                            ${options.input ? `<input type="text" class="custom-input" placeholder="${options.inputPlaceholder}" maxlength="15">` : ''}
                        </div>
                        <div class="custom-modal-buttons">
                            <button class="custom-btn confirm-btn">${options.confirmText}</button>
                            ${options.cancelText ? `<button class="custom-btn cancel-btn">${options.cancelText}</button>` : ''}
                        </div>
                    </div>
                `;
                
                // A√±adir estilos inline para que funcione inmediatamente
                modal.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 3000;
                `;
                
                const content = modal.querySelector('.custom-modal-content');
                content.style.cssText = `
                    background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
                    border: 4px solid #ffffff;
                    border-radius: 25px;
                    padding: 25px;
                    max-width: 350px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    animation: modalPop 0.3s ease-out;
                `;
                
                // Event listeners
                const confirmBtn = modal.querySelector('.confirm-btn');
                const cancelBtn = modal.querySelector('.cancel-btn');
                const input = modal.querySelector('.custom-input');
                
                confirmBtn.addEventListener('click', () => {
                    const value = input ? input.value : null;
                    document.body.removeChild(modal);
                    options.onConfirm(value);
                });
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        options.onCancel();
                    });
                }
                
                // Focus en input si existe
                document.body.appendChild(modal);
                if (input) {
                    input.focus();
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmBtn.click();
                        }
                    });
                }
            }
            
            // üì∏ MOSTRAR √ÅLBUM
            
            showAlbum() {
                this.populateAlbum();
                document.getElementById('albumModal').style.display = 'flex';
            }
            
            populateAlbum() {
                const albumTimeline = document.getElementById('albumTimeline');
                const albumDays = document.getElementById('albumDays');
                const albumEvents = document.getElementById('albumEvents');
                const albumMilestones = document.getElementById('albumMilestones');
                
                // Estad√≠sticas
                const daysSinceBirth = this.gameState.birthDate ? 
                    Math.floor((Date.now() - this.gameState.birthDate) / (24 * 60 * 60 * 1000)) : 0;
                const totalEvents = this.gameState.album?.length || 0;
                const milestones = this.gameState.album?.filter(e => 
                    ['birth', 'naming', 'background'].includes(e.type)).length || 0;
                
                albumDays.textContent = daysSinceBirth;
                albumEvents.textContent = totalEvents;
                albumMilestones.textContent = milestones;
                
                // Timeline
                albumTimeline.innerHTML = '';
                
                if (!this.gameState.album || this.gameState.album.length === 0) {
                    albumTimeline.innerHTML = `
                        <div class="album-entry">
                            <div class="album-entry-title">üìù Diario vac√≠o</div>
                            <div class="album-entry-description">¬°Los recuerdos aparecer√°n aqu√≠ mientras juegas!</div>
                        </div>
                    `;
                    return;
                }
                
                // Mostrar eventos m√°s recientes primero
                const sortedEvents = [...this.gameState.album].reverse();
                
                sortedEvents.forEach(event => {
                    const entry = document.createElement('div');
                    entry.className = 'album-entry';
                    entry.innerHTML = `
                        <div class="album-entry-header">
                            <div class="album-entry-title">${event.title}</div>
                            <div class="album-entry-date">${event.date} ${event.time}</div>
                        </div>
                        <div class="album-entry-description">${event.description}</div>
                        <div class="album-entry-meta">
                            <div class="album-entry-age">D√≠a ${event.fishAge}</div>
                            <div>${event.fishName}</div>
                        </div>
                    `;
                    albumTimeline.appendChild(entry);
                });
            }
            
            // üì∏ SISTEMA DE √ÅLBUM/DIARIO
            
            addAlbumEvent(type, title, description, photo = null) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type, // 'birth', 'naming', 'feeding', 'playing', 'background', 'milestone'
                    title: title,
                    description: description,
                    photo: photo, // URL de la foto o null
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                
                // Mantener solo los √∫ltimos 50 eventos para no saturar
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                
                console.log(`üì∏ Evento a√±adido al √°lbum: ${title}`);
                this.saveGame();
            }
            
            checkForAlbumEvents() {
                const now = Date.now();
                const hoursSinceLastEvent = (now - this.gameState.lastEventTime) / (1000 * 60 * 60);
                
                // Solo generar eventos cada 2+ horas para no spam
                if (hoursSinceLastEvent < 2) return;
                
                // Eventos aleatorios basados en el estado del pez
                if (this.fish && Math.random() < 0.1) { // 10% chance cada check
                    const randomEvents = [
                        { type: 'swimming', title: 'üèä Nadando feliz', desc: 'Hoy he nadado mucho y me siento muy activo.' },
                        { type: 'exploring', title: 'üîç Explorando', desc: 'He descubierto un rinc√≥n nuevo de mi acuario.' },
                        { type: 'playing', title: 'üéà Jugando', desc: 'He estado jugando con las burbujas. ¬°Qu√© divertido!' },
                        { type: 'resting', title: 'üò¥ Descansando', desc: 'He encontrado un lugar c√≥modo para relajarme.' }
                    ];
                    
                    const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                    this.addAlbumEvent(event.type, event.title, event.desc);
                    this.gameState.lastEventTime = now;
                }
            }
            
            // üíæ SISTEMA DE GUARDADO
            
            saveGame() {
                const saveData = {
                    version: '1.0.0',
                    gameState: this.gameState,
                    egg: this.egg,
                    fish: this.fish,
                    explosionHappened: this.explosionHappened,
                    availableBackgrounds: this.availableBackgrounds?.map(bg => ({
                        name: bg.name,
                        cost: bg.cost,
                        unlocked: bg.unlocked
                    })),
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('miPececito_gameData', JSON.stringify(saveData));
                    console.log('üíæ Juego guardado correctamente');
                    console.log('üìä Guardado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                } catch (error) {
                    console.error('‚ùå Error guardando:', error);
                }
            }
            
            loadGame() {
                try {
                    const savedData = localStorage.getItem('miPececito_gameData');
                    if (!savedData) return false;
                    
                    const data = JSON.parse(savedData);
                    
                    // Restaurar estado del juego
                    if (data.gameState) {
                        this.gameState = { ...this.gameState, ...data.gameState };
                    }
                    
                    // Restaurar huevo y pez
                    if (data.egg) {
                        this.egg = { ...this.egg, ...data.egg };
                    }
                    
                    if (data.fish) {
                        this.fish = { ...this.fish, ...data.fish };
                    }
                    
                    // Restaurar explosi√≥n
                    this.explosionHappened = data.explosionHappened || false;
                    
                    // Restaurar fondos desbloqueados
                    if (data.availableBackgrounds && this.availableBackgrounds) {
                        data.availableBackgrounds.forEach(savedBg => {
                            const bg = this.availableBackgrounds.find(b => b.name === savedBg.name);
                            if (bg) {
                                bg.unlocked = savedBg.unlocked;
                            }
                        });
                    }
                    
                    console.log('üìÅ Juego cargado correctamente');
                    console.log('üìä Cargado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Error cargando:', error);
                    return false;
                }
            }
            
            // Auto-guardado cada 30 segundos
            startAutoSave() {
                setInterval(() => {
                    this.saveGame();
                }, 30000);
            }
            
            // üîß M√âTODOS DE DEBUG
            
            placeFirstEgg(x, y) {
                const now = Date.now();
                
                // CAMBIAR STAGE A 'EGG' Y INICIAR TIEMPO
                this.gameState.stage = 'egg';
                this.gameState.eggStartTime = now;
                
                // üìä OCULTAR BARRAS DE NECESIDADES CON HUEVO
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'none';
                    this.setupCanvas(); // REAJUSTAR CANVAS SIN BARRAS
                    console.log('üìä Barras ocultas con huevo + Canvas reajustado');
                }
                
                // üéÜ BURBUJITAS BLANCAS PRIMERO, LUEGO HUEVO
                this.createEggBubbles();
                
                // ESPERAR 1 SEGUNDO PARA QUE SE VEAN LAS BURBUJAS PRIMERO
                setTimeout(() => {
                    this.egg.x = x || this.canvas.width / 2;
                    this.egg.y = y || this.canvas.height * 0.6;
                    this.startEggAppearanceAnimation();
                    console.log('ü•ö Huevo aparece DESPU√âS de las burbujas');
                }, 1000);
                
                this.saveGame(); // Guardar al colocar huevo
                console.log(`ü•ö Huevo colocado - Stage cambiado a 'egg'`);
                console.log(`ü•ö Tiempo inicio: ${new Date(now).toLocaleTimeString()}`);
                console.log(`‚è∞ EggStartTime configurado: ${this.gameState.eggStartTime}`);
            }

            // üéÜ ANIMACI√ìN DE APARICI√ìN DEL HUEVO (SOLO APARICI√ìN)
            startEggAppearanceAnimation() {
                // EFECTO SUAVE: Solo fade, sin escala brusca
                this.egg.appearing = true;
                this.egg.scale = 1; // TAMA√ëO NORMAL DESDE EL INICIO
                this.egg.targetScale = 1;
                this.egg.alpha = 0; // EMPEZAR TRANSPARENTE
                this.egg.targetAlpha = 1; // IR A OPACO
                this.egg.fadeSpeed = 0.8; // VELOCIDAD SUAVE
                
                console.log('ü•ö Iniciando aparici√≥n SUAVE del huevo (fade)...');
            }

            // üå´Ô∏è BURBUJAS DE APARICI√ìN - TEST VISUAL DIRECTO
            createEggAppearanceBubbles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`üå´Ô∏è Creando burbujas de aparici√≥n en (${centerX}, ${centerY})`);
                console.log(`üîç bgBubbles array actual: ${this.bgBubbles.length} burbujas`);
                
                // LIMPIAR burbujas existentes para evitar conflictos
                this.bgBubbles = [];
                
                // Crear 10 burbujas GRANDES y VISIBLES para test
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = 50 + i * 20; // Distancias variadas
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const testBubble = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2 - 3, // Hacia arriba
                        r: 20, // TAMA√ëO FIJO GRANDE
                        size: 20,
                        opacity: 1,
                        alpha: 1,
                        life: 5000, // 5 segundos fijos
                        maxLife: 5000,
                        color: i % 2 === 0 ? '#ff0000' : '#00ff00', // ROJO/VERDE ALTERNADO para ver
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(testBubble);
                    console.log(`üî¥üü¢ Burbuja TEST ${i+1}/10 creada: ${testBubble.color} en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
                
                console.log(`üéØ TEST: ${this.bgBubbles.length} burbujas grandes creadas`);
            }

            // ‚ú® PART√çCULAS M√ÅGICAS - TEST VISUAL
            createMagicParticles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`‚ú® Creando part√≠culas m√°gicas en (${centerX}, ${centerY})`);
                
                // Crear 5 part√≠culas ENORMES y DORADAS para test
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 80 + i * 15;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const magicParticle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1 - 2,
                        r: 25, // ENORMES para test
                        size: 25,
                        opacity: 1,
                        alpha: 1,
                        life: 6000, // 6 segundos
                        maxLife: 6000,
                        color: '#ffff00', // AMARILLO PURO
                        sparkle: true,
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(magicParticle);
                    console.log(`‚≠ê Part√≠cula TEST ${i+1}/5 creada: AMARILLA 25px en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
            }
            
            setEggTimeToFinalSeconds() {
                const total = 5 * 60 * 1000; // 5 MINUTOS PARA TESTING
                this.gameState.eggStartTime = Date.now() - (total - 5000);
                console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
            }
            
            addTime(ms) {
                this.gameState.eggStartTime -= ms;
                console.log(`‚è∞ +${ms/1000/60/60}h a√±adidas`);
            }
            
            toggleBackground() {
                // Por ahora solo tenemos basic
                console.log('üñºÔ∏è Fondo cambiado (solo basic disponible)');
            }
            
            addCurrency(type, amount) {
                if (type === 'bubbles') {
                    this.gameState.bubbles += amount;
                } else if (type === 'stars') {
                    this.gameState.stars += amount;
                }
                console.log(`üí∞ +${amount} ${type} a√±adidas`);
                this.updateUI(); // ACTUALIZAR UI INMEDIATAMENTE
            }
            
            getGameInfo() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                return {
                    stage: this.gameState.stage,
                    eggTime: elapsed,
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars
                };
            }
            
            // üîß FUNCIONES HELPER COPIADAS DEL C√ìDIGO REALISTA
            clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }
            
            dist(x1, y1, x2, y2) {
                return Math.hypot(x2 - x1, y2 - y1);
            }
            
            // === Helpers de canvas/DPR (CSS px coherentes) ===
            getDPR() { 
                return window.devicePixelRatio || 1; 
            }
            
            viewW() { 
                return this.canvas.width / this.getDPR(); // ancho en CSS px
            }
            
            viewH() { 
                return this.canvas.height / this.getDPR(); // alto en CSS px
            }
            
            // ‚Äî‚Äî‚Äî SUELO √öNICO COHERENTE CON LA BARRA INFERIOR ‚Äî‚Äî‚Äî
            getFloorY() {
                // Si quieres medir la barra real:
                // const bar = document.querySelector('.bottom-bar');
                // const uiBottom = bar ? bar.getBoundingClientRect().height : 100;

                const uiBottom = 100;  // ‚Üê ajusta si tu barra real es otra
                const safeGap  = 12;   // margen para no pisar la UI
                return this.viewH() - (uiBottom + safeGap);
            }
            
            // Llamar al principio de cada render()
            beginFrame() {
                const ctx = this.ctx;
                // limpiar en p√≠xeles f√≠sicos
                ctx.setTransform(1,0,0,1,0,0);
                ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
                // reescalar a CSS px
                const r = this.getDPR();
                ctx.setTransform(r,0,0,r,0,0);
            }
            
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            vary(val, amt, min, max) {
                const v = val + (Math.random() * 2 - 1) * amt;
                return this.clamp(v, min, max);
            }
            
            // üçé SISTEMA DE COMIDA SEG√öN CHAT
            pelletColors() {
                const PELLET_FAMILIES = [
                    {h:38,s:85,l:62},{h:30,s:80,l:58},{h:46,s:68,l:70},
                    {h:28,s:60,l:55},{h:60,s:35,l:65},{h:22,s:55,l:54}
                ];
                const b = PELLET_FAMILIES[Math.floor(Math.random() * PELLET_FAMILIES.length)];
                const h = this.vary(b.h, 5, 10, 70);
                const s = this.vary(b.s, 10, 20, 95);
                const l = this.vary(b.l, 8, 35, 85);
                const strokeL = Math.max(10, l - 22);
                const strokeS = Math.max(25, Math.round(s * 0.85));
                return { 
                    fill: `hsl(${Math.round(h)} ${Math.round(s)}% ${Math.round(l)}%)`, 
                    stroke: `hsl(${Math.round(h)} ${Math.round(strokeS)}% ${Math.round(strokeL)}%)` 
                };
            }
            
            dropFood() {
                console.log('üçé dropFood() llamado - Array food existe:', !!this.food);
                
                // ZONA ACCESIBLE PARA EL PEZ (evitar extremos)
                const fishSize = 80;
                const fishHalfSize = fishSize / 2;
                const leftLimit = fishHalfSize + 15; // 55px
                const rightLimit = this.canvas.width - fishHalfSize - 15; // W-55px
                const accessibleWidth = rightLimit - leftLimit;
                
                const x = leftLimit + Math.random() * accessibleWidth; // Solo en zona accesible
                const col = this.pelletColors();
                const r = 2.6 + Math.random() * 1.2;
                
                const pellet = {
                    x: x,
                    y: 120, // M√ÅS ABAJO para que est√© cerca del pez
                    vx: 0,
                    vy: 4 + Math.random() * 4, // CA√çDA M√ÅS LENTA
                    bottomT: 0,
                    colorFill: col.fill,
                    colorStroke: col.stroke,
                    r: r
                };
                
                this.food.push(pellet);
                console.log('üçé Pellet a√±adido en ZONA SEGURA:', 
                    `x=${x.toFixed(1)} (rango: ${leftLimit}-${rightLimit})`,
                    'Total food:', this.food.length);
            }
            
            // üßπ LIMPIEZA CON M√ÅQUINA DE ESTADOS SINCRONIZADA
            startCleaning() {
                console.log('üßπ ¬°INICIANDO LIMPIEZA SINCRONIZADA!');
                
                // üéØ INICIALIZAR ESTADO DE LIMPIEZA
                this.cleaningState = 'burst'; // burst -> fade -> settle
                this.cleaningTimer = 0;
                this._time = this._time || 0;
                this.cleanBubbles = this.cleanBubbles || [];
                
                // üêü EFECTO EN EL PEZ
                if (this.fish) { 
                    this.fish.happyBurst = 3.2; 
                    this.fish.spinKind = "clean"; 
                }
                
                // ü´ß CREAR BURBUJAS INMEDIATAMENTE (R√ÅFAGA INICIAL)
                this.emitCleanBubblesBurst();
                console.log(`ü´ß R√ÅFAGA INICIAL: ${this.cleanBubbles.length} burbujas creadas`);
                
                // üîä SONIDO SINCRONIZADO
                if (window.audioManager) {
                    window.audioManager.playSound('clean');
                }
                
                // üßπ CONFIGURAR LIMPIEZA
                this.dirtStart = this.gameState.needs.dirt;
            }
            
            // ü´ß R√ÅFAGA INTENSA DE BURBUJAS PARA SINCRONIZACI√ìN
            emitCleanBubblesBurst() {
                const W = this.viewW();
                const H = this.viewH();
                
                // üéØ CREAR MUCHAS BURBUJAS DE UNA VEZ (R√ÅFAGA)
                for (let wave = 0; wave < 3; wave++) {
                    for (let i = 0; i < 25; i++) {
                        const b = {
                            x0: 30 + Math.random() * (W - 60),
                            y0: H * 0.8 + Math.random() * (H * 0.15),
                            t: wave * 0.1, // Escalonar ligeramente las ondas
                            dur: 2.0 + Math.random() * 0.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 2,
                            wobAmp: 8 + Math.random() * 12,
                            r: 4 + Math.random() * 6
                        };
                        b.x = b.x0;
                        b.y = b.y0;
                        this.cleanBubbles.push(b);
                    }
                }
                
                console.log(`ü´ß R√°faga creada: ${this.cleanBubbles.length} burbujas totales`);
            }
            
            emitCleanBubbles() {
                const W = this.viewW();   // CSS px
                const H = this.viewH();   // CSS px
                const vents = Math.max(16, Math.floor(W / 24));
                const perVent = 2;

                for (let i = 0; i < vents; i++) {
                    const baseX = (i + 0.5) * (W / vents) + (Math.random() - 0.5) * 8;

                    for (let k = 0; k < perVent; k++) {
                        const vy  = 260 + Math.random() * 120;     // velocidad vertical (CSS px/s)
                        const y0  = H - 1 + Math.random() * 0.5;   // nacen pegadas al fondo
                        const dur = (H + 24) / vy;                 // tiempo exacto hasta salir por arriba
                        const x0  = this.clamp(baseX + (Math.random() - 0.5) * 6, 2, W - 2);

                        this.cleanBubbles.push({
                            // guardo origen (x0,y0) y movimiento param√©trico por tiempo
                            x: x0, y: y0,
                            x0, y0, dur, t: 0,
                            r: 1.5 + Math.random() * 2.8,
                            wobble: Math.random() * Math.PI * 2,
                            wobSpd: 1.5 + Math.random() * 1.2,
                            wobAmp: 6 + Math.random() * 10,
                            from: 'clean'
                        });
                    }
                }

                // L√≠mite de memoria
                if (this.cleanBubbles.length > 1400) {
                    this.cleanBubbles.splice(0, this.cleanBubbles.length - 1400);
                }
            }
            
            updateCleaning(deltaTime) {
                this._time = (this._time || 0) + deltaTime;

                // üéØ M√ÅQUINA DE ESTADOS DE LIMPIEZA
                if (this.cleaningState) {
                    this.cleaningTimer += deltaTime;
                    
                    switch (this.cleaningState) {
                        case 'burst':
                            // FASE 1: R√°faga inicial (0.5s)
                            if (this.cleaningTimer >= 0.5) {
                                this.cleaningState = 'fade';
                                this.cleaningTimer = 0;
                                console.log('üßπ FASE: burst ‚Üí fade');
                            }
                            break;
                            
                        case 'fade':
                            // FASE 2: Reducir suciedad gradualmente (2s)
                            const progress = Math.min(this.cleaningTimer / 2.0, 1.0);
                            this.gameState.needs.dirt = this.clamp((1 - progress) * this.dirtStart, 0, 100);
                            this.updateNeedBars();
                            
                            if (this.cleaningTimer >= 2.0) {
                                this.cleaningState = 'settle';
                                this.cleaningTimer = 0;
                                console.log('üßπ FASE: fade ‚Üí settle');
                            }
                            break;
                            
                        case 'settle':
                            // FASE 3: Finalizar cuando no queden burbujas
                            if (this.cleanBubbles.length === 0 || this.cleaningTimer >= 3.0) {
                                this.gameState.needs.dirt = 0;
                                this.updateNeedBars();
                                this.cleaningState = null;
                                console.log('üßπ LIMPIEZA COMPLETADA');
                            }
                            break;
                    }
                }

                // ü´ß ACTUALIZAR MOVIMIENTO DE BURBUJAS
                const H = this.viewH();
                for (const b of this.cleanBubbles) {
                    b.t += deltaTime;
                    const p = Math.min(1, b.t / (b.dur || 1));
                    b.y = b.y0 - p * (H + 24);
                    b.x = b.x0 + Math.sin(this._time * b.wobSpd + b.wobble) * b.wobAmp;
                }

                // üóëÔ∏è ELIMINAR BURBUJAS QUE SALIERON DE PANTALLA
                for (let i = this.cleanBubbles.length - 1; i >= 0; i--) {
                    const b = this.cleanBubbles[i];
                    if (b.t >= (b.dur || 1) || b.y < -12) {
                        this.cleanBubbles.splice(i, 1);
                    }
                }
            }
            
            drawCleanBubbles() {
                if (!this.cleanBubbles || this.cleanBubbles.length === 0) {
                    return;
                }
                const ctx = this.ctx;
                
                // üéØ ESCALAR CONTEXTO SOLO PARA BURBUJAS (sistema h√≠brido)
                ctx.save();
                const r = this.getDPR();
                ctx.setTransform(r, 0, 0, r, 0, 0);
                ctx.globalCompositeOperation = 'source-over';

                for (const b of this.cleanBubbles) {
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#dff7ff';
                    ctx.fill();
                    ctx.lineWidth = 0.9;
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                    ctx.stroke();
                }
                
                // üîÑ RESTAURAR CONTEXTO NORMAL
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.restore();
            }
            
            updateFood(deltaTime) {
                if (!this.food) {
                    console.log('üçé updateFood: Array food no existe');
                    return;
                }
                
                // üêü PERSECUCI√ìN DE COMIDA MANEJADA EN updateFishMovement()
                
                const h = this.canvas.height;
                const drag = 0.99;
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 254-256
                for (const f of this.food) {
                    if (f.bottomT > 0) {
                        f.bottomT += deltaTime;
                    } else {
                        f.vy = Math.min(f.vy + 80 * deltaTime, 90);
                        f.y += f.vy * deltaTime;
                        f.x += f.vx * deltaTime;
                        f.vx *= drag;
                // USAR SUELO UNIFICADO
                const floorY = this.getFloorY();
                        if (f.y > floorY) {
                            f.y = floorY;
                            f.vy = 0;
                            f.vx = 0;
                            f.bottomT = Math.max(0.001, f.bottomT || 0.001);
                        }
                    }
                }
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 258-269
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const f = this.food[i];
                    const distance = this.fish ? this.dist(this.fish.x, this.fish.y, f.x, f.y) : 999;
                    
                    // üçé COLISI√ìN CON EL PEZ (radio de colisi√≥n m√°s amplio)
                    if (this.fish && distance < 28) { // Aumentado de 22 a 28 para mejor detecci√≥n
                        console.log(`üçé COLISI√ìN: Pez en (${this.fish.x.toFixed(1)}, ${this.fish.y.toFixed(1)}) come pellet en (${f.x.toFixed(1)}, ${f.y.toFixed(1)}) - Distancia: ${distance.toFixed(1)}`);
                        this.food.splice(i, 1);
                        
                        // üçé COMER CON CONFIG POR ETAPA
                        const cfg = this.getStageCfg(this.gameState);
                        this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger - cfg.eatReduce, 0, 100);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerPellet, 0, 100);
                        
                        console.log(`üçé ¬°PEZ COME! Etapa: ${this.gameState.stage} - Reduce hambre: ${cfg.eatReduce} - A√±ade suciedad: ${cfg.dirtPerPellet}`);
                        
                        // üîä SONIDO SIEMPRE
                        if (window.audioManager) {
                            window.audioManager.playSound('eat');
                        }
                        
                        // üé¨ √ëAM SIEMPRE
                        this.labels.push({
                            x: this.fish.x,
                            y: this.fish.y - 12,
                            text: "√ëam",
                            a: 1,
                            vy: 40,
                            life: 1.4
                        });
                        
                        this.fish.happyBurst = Math.max(this.fish.happyBurst, 1.2);
                        this.fish.spinKind = "eat";
                        
                        // üìä ACTUALIZAR BARRAS SIEMPRE
                        this.updateCrisisFlags();
                        this.updateNeedBars();
                        
                        console.log(`üçé ¬°√ëam completo! Nueva hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                        
                        // ‚ö†Ô∏è ELIMINADO: No limitar hambre en crisis para que siga persiguiendo
                        // if (this.gameState.crisis.hunger) {
                        //     this.gameState.needs.hunger = Math.min(this.gameState.needs.hunger, 60);
                        // }
                        
                        this.updateCrisisFlags();
                        this.updateNeedBars();
                        continue; // Importante: saltar al siguiente pellet
                    } 
                    
                    // üóëÔ∏è PUDRIR COMIDA VIEJA (despu√©s de 8 segundos en el fondo)
                    if (f.bottomT > 0 && f.bottomT > 8) {
                        console.log(`üóëÔ∏è Pellet podrido despu√©s de ${f.bottomT.toFixed(1)}s en el fondo`);
                        const cfg = this.getStageCfg(this.gameState);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + cfg.dirtPerRotten, 0, 100);
                        console.log(`ü¶† Suciedad por pudrici√≥n: +${cfg.dirtPerRotten} (total: ${this.gameState.needs.dirt.toFixed(1)}%)`);
                        this.updateNeedBars();
                        this.food.splice(i, 1);
                    }
                }
                
                // üìä LOG PERI√ìDICO PARA DEBUG
                // Log reducido: solo cada 5 segundos o cuando cambia significativamente
                this.lastFoodLogTime = this.lastFoodLogTime || 0;
                if (Date.now() - this.lastFoodLogTime > 5000) {
                    console.log(`üçé Estado: ${this.food.length} pellets - Hambre: ${this.gameState.needs.hunger.toFixed(1)}%`);
                    this.lastFoodLogTime = Date.now();
                }
            }
            
            drawFood() {
                if (!this.food || this.food.length === 0) {
                    // console.log('üçé drawFood: No hay comida que dibujar');
                    return;
                }
                
                // Solo log cuando hay cambios importantes
                if (this.food.length > (this.lastFoodCount || 0)) {
                    console.log('üçé Comida a√±adida:', this.food.length, 'pellets');
                    this.lastFoodCount = this.food.length;
                }
                
                this.ctx.save();
                for (let i = 0; i < this.food.length; i++) {
                    const f = this.food[i];
                    // console.log(`üçé Dibujando pellet ${i}:`, f.x, f.y, f.r); // Log deshabilitado para performance
                    
                    this.ctx.beginPath();
                    this.ctx.arc(f.x, f.y, f.r || 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = f.colorFill || '#ffd166';
                    this.ctx.fill();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = f.colorStroke || '#cc8400';
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }
            
            // üçé FUNCIONES DE COMIDA
            nearestFood() {
                let best = null, bestD = 1e9;
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                return best || null;
            }
            
            // ‚ù§Ô∏è CORAZ√ìN VOLADOR (cuando tocas el pez)
            launchHeartToFun() {
                // VERSI√ìN CHATGPT: Convertir coords DOM de la barra a coords canvas
                const barF = document.getElementById('funBarHeader'); // Barra de diversi√≥n del header
                if (!barF) {
                    console.log('‚ùå No se encontr√≥ barra de diversi√≥n');
                    return;
                }
                
                const crect = this.canvas.getBoundingClientRect();
                const frect = barF.getBoundingClientRect();
                
                const sx = this.fish.x, sy = this.fish.y; // origen coraz√≥n (pez)
                const ex = frect.left + frect.width * 0.9 - crect.left; // destino barra
                const ey = frect.top + frect.height * 0.5 - crect.top;
                
                // control point para Bezier (curvita agradable)
                const cx = (sx + ex) / 2;
                const cy = Math.min(sy, ey) - 100;
                
                this.flyers.push({ 
                    t: 0, dur: 1.8, sx, sy, cx, cy, ex, ey, given: false 
                });
                
                console.log('‚ù§Ô∏è Coraz√≥n lanzado hacia barra de diversi√≥n (coords DOM)');
            }
            
            // ü´ß BURBUJAS DE RESPIRACI√ìN (desde la boca)
            emitMouthBubbles(n = 4, x0, y0) {
                const fish = this.fish;
                if (!fish) return;
                
                // Posici√≥n de la boca del pez
                const bodyW = fish.size * 0.4;
                const bodyH = fish.size * 0.24;
                const mx = fish.x + (fish.facing > 0 ? 1 : -1) * (bodyW * 0.42);
                const my = fish.y - bodyH * 0.12;
                
                for (let i = 0; i < n; i++) {
                    this.tinyBubbles.push({
                        x: mx + (Math.random() * 6 - 3),
                        y: my + (Math.random() * 6 - 3),
                        r: 0.9 + Math.random() * 1.3,
                        vy: 50 + Math.random() * 40,
                        wob: Math.random() * Math.PI * 2,
                        wobSpd: 1.2 + Math.random() * 0.8,
                        wobAmp: 3 + Math.random() * 4,
                        a: 1,
                        life: 1.2
                    });
                }
            }
            
            // ü´ß BURBUJITAS SUTILES DE AMBIENTE (REALMENTE SUTILES)
            drawAmbientBubbles() {
                const time = this.gameTime || Date.now() * 0.001;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                this.ctx.save();
                
                // 8 burbujitas REALMENTE peque√±as y sutiles
                for (let i = 0; i < 8; i++) {
                    // Posici√≥n que se mueve muy lentamente
                    const baseX = (i * 97 + (time * 15) % W) % W;
                    const baseY = H - ((time * 25 + i * 80) % H);
                    
                    // Peque√±o wobble muy sutil
                    const x = baseX + Math.sin(time * 1.5 + i) * 4;
                    const y = baseY + Math.cos(time * 1.2 + i) * 3;
                    
                    // Tama√±o muy peque√±o (1-3px)
                    const size = 1 + (i % 2) + Math.sin(time * 2 + i) * 0.3;
                    
                    // MUY transparente
                    this.ctx.globalAlpha = 0.15 + Math.sin(time * 1.8 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    this.ctx.shadowBlur = 0; // Sin sombra
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // ü´ß BURBUJITAS SUTILES DURANTE GESTACI√ìN DEL HUEVO
            drawEggGestationBubbles() {
                const time = (Date.now() * 0.001) % 1000; // Tiempo lento
                const eggX = 0; // Relativo al huevo (ya transformado)
                const eggY = 0;
                const eggSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--egg-size'));
                
                // 6 burbujitas muy sutiles alrededor del huevo
                for (let i = 0; i < 6; i++) {
                    const angle = (time * 0.3 + i * Math.PI / 3) % (Math.PI * 2);
                    const radius = eggSize * 0.35 + Math.sin(time * 2 + i) * 10;
                    
                    const x = eggX + Math.cos(angle) * radius;
                    const y = eggY + Math.sin(angle) * radius * 0.6; // M√°s ovalado
                    
                    // Tama√±o muy peque√±o (2-4px)
                    const size = 2 + Math.sin(time * 3 + i) * 1;
                    
                    // MUY transparente y suave
                    this.ctx.globalAlpha = 0.1 + Math.sin(time * 1.5 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // 3 burbujitas m√°s grandes que suben lentamente
                for (let i = 0; i < 3; i++) {
                    const yOffset = ((time * 20 + i * 40) % 120) - 60; // Suben lentamente
                    const x = eggX + (i - 1) * 25 + Math.sin(time * 2 + i) * 8;
                    const y = eggY - eggSize * 0.4 - yOffset;
                    
                    const size = 3 + i * 0.5;
                    this.ctx.globalAlpha = 0.15 - (yOffset / 120) * 0.1; // Se desvanecen al subir
                    this.ctx.fillStyle = '#b3e5fc'; // Azul claro
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // üçé ACTUALIZAR Y DIBUJAR LABELS ("√ëam", etc.)
            updateLabels(deltaTime) {
                for (let i = this.labels.length - 1; i >= 0; i--) {
                    const label = this.labels[i];
                    label.life -= deltaTime;
                    label.y -= label.vy * deltaTime;
                    label.a = Math.max(0, label.life / 1.4); // Fade out
                    
                    if (label.life <= 0) {
                        this.labels.splice(i, 1);
                    }
                }
            }
            
            drawLabels() {
                this.ctx.save();
                this.ctx.font = 'bold 18px system-ui';
                this.ctx.textAlign = 'center';
                
                for (const label of this.labels) {
                    this.ctx.globalAlpha = label.a;
                    this.ctx.fillStyle = '#ff6b35';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.strokeText(label.text, label.x, label.y);
                    this.ctx.fillText(label.text, label.x, label.y);
                }
                
                this.ctx.restore();
            }
            
            // üéØ VIEW HELPERS - COORDENADAS SIMPLES 
        // üåç TAMA√ëO CANVAS SIMPLE (VERSI√ìN QUE FUNCIONABA)
        viewW() { return this.canvas.width; }
        viewH() { return this.canvas.height; }
        
        // ü´ß GESTI√ìN CAPA OFFSCREEN
        ensureBubLayer() {
            if (!this.bubLayer) {
                this.bubLayer = document.createElement('canvas');
                this.bubCtx = this.bubLayer.getContext('2d');
            }
            this.resizeBubLayer();
        }
        
        resizeBubLayer() {
            if (!this.bubLayer) return;
            const dpr = window.devicePixelRatio || 1;
            const w = this.viewW(), h = this.viewH();
            this.bubLayer.width = Math.max(1, Math.floor(w * dpr));
            this.bubLayer.height = Math.max(1, Math.floor(h * dpr));
            this.bubLayer.style.width = w + 'px';
            this.bubLayer.style.height = h + 'px';
        }
        
        // ü´ß DIBUJAR BURBUJAS EN CAPA OFFSCREEN
        drawBubblesLayer() {
            this.ensureBubLayer();
            const dpr = window.devicePixelRatio || 1;
            
            // Limpiar offscreen en device px y fijar su DPR
            this.bubCtx.setTransform(1, 0, 0, 1, 0, 0);
            this.bubCtx.clearRect(0, 0, this.bubLayer.width, this.bubLayer.height);
            this.bubCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            // Tiny bubbles (respiraci√≥n)
            for (const b of this.tinyBubbles) {
                this.bubCtx.globalAlpha = Math.max(0.2, b.a || 0.8);
                this.bubCtx.beginPath(); 
                this.bubCtx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                this.bubCtx.fillStyle = '#e8fbff'; 
                this.bubCtx.fill();
                this.bubCtx.lineWidth = 0.7; 
                this.bubCtx.strokeStyle = 'rgba(255,255,255,0.8)'; 
                this.bubCtx.stroke();
            }
        }
            
            // üêü MOVIMIENTO FLUIDO CON F√çSICA AVANZADA (DESDE movimiento_pez_final.html)
            updateFishMovement(deltaTime) {
                if (!this.fish) return;
                const fish = this.fish;

                // Inicializar propiedades de f√≠sica si no existen
                if (!fish.maxSpeed) fish.maxSpeed = 300;
                if (!fish.maxAccel) fish.maxAccel = 900;
                if (!fish.baseSpeed) fish.baseSpeed = 140;
                if (!fish.facing) fish.facing = 1;
                if (!fish.wanderTimer) fish.wanderTimer = 0;
                if (!fish.wanderDir) fish.wanderDir = {x: 1, y: 0};
                if (fish.desire === undefined) fish.desire = null;

                // Animaciones b√°sicas
                fish.blinkT = Math.max(0, (fish.blinkT || 0) - deltaTime);
                fish.nextBlink = (fish.nextBlink || 2) - deltaTime;
                if (fish.nextBlink <= 0 && fish.blinkT <= 0) {
                    fish.blinkT = 0.12;
                    fish.nextBlink = 2 + Math.random() * 4;
                }

                // Burbujas de respiraci√≥n
                fish.breathT = (fish.breathT || 2) - deltaTime;
                if (fish.breathT <= 0 && !this.cleaningState) {
                    this.emitMouthBubbles(3 + Math.floor(Math.random() * 3));
                    fish.breathT = 2 + Math.random() * 3;
                }

                fish.swimPhase = (fish.swimPhase || 0) + deltaTime * 3.2;
                let targetV = {vx: 0, vy: 0};
                let speedMul = 1.0;

                // üî• TURBO DE DEDO (decaimiento)
                fish.fingerBoostT = Math.max(0, (fish.fingerBoostT || 0) - deltaTime);

                // üåÄ EFECTO GIRATORIO (happyBurst)
                if (fish.happyBurst && fish.happyBurst > 0) {
                    const w = (fish.spinKind === "clean") ? 13.0 : 6.0;
                    const R = (fish.spinKind === "clean") ? 140 : 55;
                    const a = (this._time || 0) * w;
                    targetV = {vx: Math.cos(a) * R * 0.65, vy: Math.sin(a) * R * 0.65};
                    speedMul = (fish.spinKind === "clean") ? 1.8 : 1.25;
                    fish.happyBurst = Math.max(0, fish.happyBurst - (fish.spinKind === "clean" ? 0.6 : 1.6) * deltaTime);
                }
                // üëÜ SEGUIR DEDO (PRIORIDAD M√ÅXIMA) - USANDO fish.desire COMO EL EJEMPLO
                else if (fish.desire) {
                    const s = this.seek(fish.x, fish.y, fish.desire.x, fish.desire.y, fish.maxSpeed * 0.9);
                    const t = this.clamp(s.dist / 120, 0.25, 1);
                    targetV = {vx: s.vx * t, vy: s.vy * t};
                    speedMul = 1.5;
                    
                    if (s.dist < 40) {
                        // üíñ PEZ LLEG√ì AL DEDO - LANZAR CORAZ√ìN CON SONIDO
                        fish.desire = null;
                        targetV = {vx: 0, vy: 0};
                        this.launchHeartToFun(fish.x, fish.y);
                        
                        // üîä SONIDO DE CORAZ√ìN/BURBUJA
                        if (window.audioManager) {
                            window.audioManager.playSound('heart');
                        }
                        
                        console.log('üíñ ¬°Pez lleg√≥ al dedo! Coraz√≥n lanzado con sonido');
                    }
                }
                // üçé PERSEGUIR COMIDA (cuando hay hambre)
                else if (this.food.length > 0 && this.gameState.needs.hunger > 1) {
                    const closest = this.nearestFood();
                    if (closest) {
                        const d = this.dist(fish.x, fish.y, closest.x, closest.y);
                        const s = this.seek(fish.x, fish.y, closest.x, closest.y, fish.maxSpeed * 0.9);
                        const t = this.clamp(d / 200, 0.35, 1); // Rango ampliado a 200px
                        targetV = {vx: s.vx * t, vy: s.vy * t};
                        speedMul = 1.3;
                        fish.isChasing = true;
                    }
                }
                // üéØ MOVIMIENTO ALEATORIO FLUIDO (cuando no hay objetivos)
                else {
                    fish.wanderTimer -= deltaTime;
                    if (fish.wanderTimer <= 0) {
                        const angle = Math.random() * Math.PI * 2;
                        fish.wanderDir.x = Math.cos(angle);
                        fish.wanderDir.y = Math.sin(angle) * 0.33; // Menos movimiento vertical
                        fish.wanderTimer = 0.8 + Math.random() * 1.1;
                    }
                    const cruise = fish.baseSpeed * 1.1;
                    targetV = {
                        vx: fish.wanderDir.x * cruise + Math.cos(fish.swimPhase) * 16,
                        vy: fish.wanderDir.y * cruise + Math.sin(fish.swimPhase * 1.8) * 16
                    };
                    speedMul = 0.8;
                }

                // üèä F√çSICA AVANZADA: ACELERACI√ìN GRADUAL
                const maxSpeed = fish.maxSpeed * speedMul;
                const maxAccel = fish.maxAccel * speedMul;
                
                fish.vx = fish.vx || 0;
                fish.vy = fish.vy || 0;
                
                const ax = this.clamp(targetV.vx - fish.vx, -maxAccel, maxAccel);
                const ay = this.clamp(targetV.vy - fish.vy, -maxAccel, maxAccel);
                
                fish.vx += ax * deltaTime;
                fish.vy += ay * deltaTime;

                // üöÄ MOVER PEZ
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;

                // üß± L√çMITES DE PANTALLA CON REBOTE SUAVE
                const pad = 16;
                const W = this.canvas.width;
                const H = this.getFloorY();
                
                if (fish.x < pad) { fish.x = pad; if (fish.vx < 0) fish.vx *= -0.5; }
                if (fish.x > W - pad) { fish.x = W - pad; if (fish.vx > 0) fish.vx *= -0.5; }
                if (fish.y < 125) { fish.y = 125; if (fish.vy < 0) fish.vy *= -0.5; }
                if (fish.y > H - pad) { fish.y = H - pad; if (fish.vy > 0) fish.vy *= -0.5; }

                // üêü ORIENTACI√ìN FLUIDA (mirar hacia donde nada)
                if (Math.abs(fish.vx) > 2) {
                    fish.facing = fish.vx > 0 ? 1 : -1;
                    fish.facingRight = fish.vx > 0; // Para compatibilidad
                }
            }
            
            // üéØ FUNCI√ìN SEEK PARA MOVIMIENTO FLUIDO (DESDE movimiento_pez_final.html)
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            // üçé ENCONTRAR COMIDA M√ÅS CERCANA
            nearestFood() {
                if (!this.food || this.food.length === 0) return null;
                
                let best = null;
                let bestD = Infinity;
                
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                
                return best;
            }
            
            // ‚Äî‚Äî‚Äî CONFIG POR ETAPA ‚Äî‚Äî‚Äî
        getStageCfg(state) {
            var STAGE_RATES = {
                baby:  { hungerHours: 2, dirtHours: 4, funHours: 3, eatReduce: 30, dirtPerPellet: 3, dirtPerRotten: 6 },
                young: { hungerHours: 6, dirtHours: 8, funHours: 4, eatReduce: 25, dirtPerPellet: 2, dirtPerRotten: 5 },
                adult: { hungerHours: 8, dirtHours:10, funHours: 5, eatReduce: 20, dirtPerPellet: 1, dirtPerRotten: 4 },
            };
            var st = (state && state.stage) || 'baby';
            return STAGE_RATES[st] || STAGE_RATES.baby;
        }
        
        // üîß FUNCIONES QUE FALTAN PARA EL SISTEMA REALISTA
        updateAutoNeeds(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;

                const cfg = this.getStageCfg(this.gameState);
                const hungerInc = (100 / (cfg.hungerHours * 3600)) * deltaTime;
                const dirtInc   = (100 / (cfg.dirtHours   * 3600)) * deltaTime;
                const funDec    = (100 / (cfg.funHours    * 3600)) * deltaTime;

                this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger + hungerInc, 0, 100);
                this.gameState.needs.dirt   = this.clamp(this.gameState.needs.dirt   + dirtInc,   0, 100);
                this.gameState.needs.fun    = this.clamp(this.gameState.needs.fun    - funDec,    0, 100);
                
                // Actualizar barras visuales
                this.updateNeedBars();
            }
            
            resetForEgg() {
                this.food = [];
                this.cleanBubbles = [];
                this.labels = [];
                this.flyers = [];
                if (this.fish) this.fish.desire = null; // Limpiar desire del pez
                this.cleaning = null;

                this.gameState.needs = { hunger: 15, dirt: 0, fun: 95 };
                this.updateNeedBars?.();
                this.gameState.stage = 'egg';

                // Si tienes contadores de monedas/estrellas, pon sus valores de inicio acordados
                // this.gameState.coins = 0;
                // this.gameState.stars = 0;
                
                console.log('ü•ö Reset completo para huevo - Todo limpio');
            }
            
            updateNeedBars() {
                // Actualizar las barras visuales (FLOTANTES - OCULTAS)
                const hungerBar = document.getElementById('hungerBar');
                const dirtBar = document.getElementById('dirtBar');
                const funBar = document.getElementById('funBar');
                
                if (hungerBar) hungerBar.style.width = this.gameState.needs.hunger + '%';
                if (dirtBar) dirtBar.style.width = this.gameState.needs.dirt + '%';
                if (funBar) funBar.style.width = this.gameState.needs.fun + '%';
                
                // üìä ACTUALIZAR BARRAS DEL HEADER (NUEVAS)
                const hungerBarHeader = document.getElementById('hungerBarHeader');
                const dirtBarHeader = document.getElementById('dirtBarHeader');
                const funBarHeader = document.getElementById('funBarHeader');
                
                if (hungerBarHeader) hungerBarHeader.style.width = this.gameState.needs.hunger + '%';
                if (dirtBarHeader) dirtBarHeader.style.width = this.gameState.needs.dirt + '%';
                if (funBarHeader) {
                    funBarHeader.style.width = this.gameState.needs.fun + '%';
                    // BORDE ROJO cuando diversi√≥n est√° baja (aburrido)
                    if (this.gameState.needs.fun <= 25) {
                        funBarHeader.style.border = '2px solid #ff4444';
                        funBarHeader.style.boxShadow = '0 0 8px rgba(255, 68, 68, 0.6)';
                    } else {
                        funBarHeader.style.border = 'none';
                        funBarHeader.style.boxShadow = 'none';
                    }
                }
            }
            
            updateCrisisFlags() {
                const CRISIS_LVL = 75;
                this.gameState.crisis.hunger = this.gameState.needs.hunger >= CRISIS_LVL;
                this.gameState.crisis.dirt = this.gameState.needs.dirt >= CRISIS_LVL;
                this.gameState.crisis.bored = this.gameState.needs.fun <= 25; // Aburrido cuando diversi√≥n < 25%
            }
            
            updateTinyBubbles(deltaTime) {
                // Actualizar burbujas de respiraci√≥n
                for (const b of this.tinyBubbles) {
                    b.y -= b.vy * deltaTime;
                    b.x += Math.sin((this.state?.time || Date.now() * 0.001) * b.wobSpd + b.wob) * b.wobAmp * deltaTime;
                    b.life -= deltaTime;
                    b.a = Math.max(0, b.life / 1.2);
                }
                
                // Eliminar burbujas muertas
                for (let i = this.tinyBubbles.length - 1; i >= 0; i--) {
                    const b = this.tinyBubbles[i];
                    if (b.life <= 0 || b.y < -12) {
                        this.tinyBubbles.splice(i, 1);
                    }
                }
            }
            
            updateFlyers(deltaTime) {
                if (!this.flyers) this.flyers = [];
                
                // VERSI√ìN CHATGPT: Actualizar progreso de corazones
                for (const f of this.flyers) {
                    f.t += deltaTime / f.dur;
                }
                
                // Purgar completados y dar diversi√≥n
                for (let i = this.flyers.length - 1; i >= 0; i--) {
                    const f = this.flyers[i];
                    if (f.t >= 1) {
                        if (!f.given) {
                            // SUMAR DIVERSI√ìN +0.25
                            this.gameState.needs.fun = this.clamp(this.gameState.needs.fun + 25, 0, 100); // +25 = +0.25 en escala 0-100
                            this.updateNeedBars();
                            
                            // Efecto visual en la barra
                            const barF = document.getElementById('funBarHeader');
                            if (barF) {
                                barF.classList.remove('pulse'); 
                                void barF.offsetWidth; 
                                barF.classList.add('pulse');
                            }
                            
                            f.given = true;
                            console.log('üíñ +25 diversi√≥n por tocar al pez');
                        }
                        this.flyers.splice(i, 1);
                    }
                }
            }
            
            // üíñ DIBUJAR CORAZONES VOLADORES
            drawFlyers() {
                if (!this.flyers) return;
                
                // VERSI√ìN CHATGPT: Curva de Bezier
                for (const f of this.flyers) {
                    const t = Math.min(1, f.t), u = 1 - t;
                    // curva de Bezier 2 puntos
                    const x = u*u*f.sx + 2*u*t*f.cx + t*t*f.ex;
                    const y = u*u*f.sy + 2*u*t*f.cy + t*t*f.ey;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.font = 'bold 18px system-ui, Segoe UI, Arial';
                    this.ctx.fillStyle = 'rgba(255,120,160,1)';
                    this.ctx.fillText('‚ù§', x - 6, y);
                    this.ctx.restore();
                }
            }
        }
        
        // üåê Exponer game para debug
        window.game = game;
        
        // üö® SISTEMA DE EMERGENCIA PARA MODALES
        setTimeout(() => {
            console.log('üö® Activando sistema de emergencia para modales...');
            
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            const invBtn = document.getElementById('inventoryButton');
            const invModal = document.getElementById('inventoryModal');
            
            // Funci√≥n para abrir modal de juegos
            window.openGamesModal = function() {
                console.log('üéÆ Abriendo modal de juegos (funci√≥n de emergencia)');
                if (gamesModal) {
                    gamesModal.style.display = 'flex';
                    gamesModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n para abrir modal de inventario
            window.openInventoryModal = function() {
                console.log('üéí Abriendo modal de inventario (funci√≥n de emergencia)');
                if (invModal) {
                    invModal.style.display = 'flex';
                    invModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n S√öPER SIMPLE para juego de burbujas
            window.startBubbleGameDirect = function() {
                console.log('ü´ß Iniciando juego SIMPLE');
                
                // Si window.game existe, usar su m√©todo
                if (window.game && window.game.runBubbleGame) {
                    window.game.runBubbleGame();
                    return;
                }
                
                // Pantalla simple
                document.body.innerHTML += `
                    <div id="bubbleGameOverlay" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                        z-index: 10000;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding: 20px;
                        font-family: Comic Sans MS, cursive;
                    ">
                        <div style="
                            color: white;
                            text-align: center;
                            margin-bottom: 15px;
                            font-size: 20px;
                            font-weight: bold;
                            background: rgba(255,255,255,0.1);
                            padding: 10px 20px;
                            border-radius: 15px;
                            border: 2px solid rgba(255,255,255,0.3);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                                <div>‚è±Ô∏è <span id="bubbleTimer">20</span>s</div>
                                <div>ü´ß <span id="bubbleScore">0</span></div>
                                <button onclick="document.getElementById('bubbleGameOverlay').remove()" style="
                                    background: rgba(255,255,255,0.2);
                                    border: 2px solid rgba(255,255,255,0.5);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    color: white;
                                    font-size: 18px;
                                    cursor: pointer;
                                ">‚ùå</button>
                            </div>
                        </div>
                        
                        <div id="bubbleGameArea" style="
                            position: relative;
                            width: 100%;
                            max-width: 350px;
                            height: 450px;
                            border-radius: 20px;
                            overflow: hidden;
                            cursor: pointer;
                            background: rgba(255,255,255,0.05);
                            border: 3px solid rgba(255,255,255,0.2);
                        "></div>
                    </div>
                `;
                
                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                
                const gameArea = document.getElementById('bubbleGameArea');
                
                // Funci√≥n simple para crear burbujas
                function createBubble() {
                    if (!gameActive) return;
                    
                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35;
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: \${size}px;
                        height: \${size}px;
                        border-radius: 50%;
                        background: \${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid white;
                        cursor: pointer;
                        top: 450px;
                        left: \${Math.random() * (300)}px;
                        transition: top 3s linear;
                    `;
                    
                    bubble.onclick = function() {
                        if (isGood) {
                            score += 3;
                            timeLeft += 1;
                        } else {
                            score = Math.max(0, score - 2);
                        }
                        document.getElementById('bubbleScore').textContent = score;
                        bubble.remove();
                    };
                    
                    gameArea.appendChild(bubble);
                    
                    // Animar hacia arriba
                    setTimeout(() => bubble.style.top = '-50px', 10);
                    
                    // Remover autom√°ticamente
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, 3000);
                }
                
                // Timer simple
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(timer);
                        clearInterval(spawner);
                        
                        gameArea.innerHTML = `
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                text-align: center;
                                color: white;
                                font-size: 24px;
                                font-weight: bold;
                                background: rgba(255,255,255,0.1);
                                padding: 20px;
                                border-radius: 15px;
                            ">
                                üéâ ¬°Terminado!<br>
                                ü´ß \${score} puntos<br>
                                ‚≠ê 1 estrella
                            </div>
                        `;
                    }
                }, 1000);
                
                // Spawner simple
                const spawner = setInterval(() => {
                    if (gameActive) createBubble();
                }, 800);
                
                // Burbujas iniciales
                setTimeout(() => createBubble(), 500);
                setTimeout(() => createBubble(), 1000);
            };
            
            // Event listeners de emergencia - ELIMINADO (YA EXISTE ARRIBA)
            
            if (invBtn) {
                invBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('üö® CLICK DETECTADO - Abriendo inventario');
                    window.openInventoryModal();
                };
            }
            
            // Botones de cierre
            const closeGames = document.getElementById('closeGames');
            const closeInventory = document.getElementById('closeInventory');
            
            if (closeGames) {
                closeGames.onclick = function() {
                    gamesModal.style.display = 'none';
                };
            }
            
            if (closeInventory) {
                closeInventory.onclick = function() {
                    invModal.style.display = 'none';
                };
            }
            
            // Event listeners para las tarjetas de juegos cuadradas
            const gameCards = document.querySelectorAll('.game-card-square');
            gameCards.forEach(card => {
                card.onclick = function(e) {
                    e.preventDefault();
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    console.log(`üéÆ Click en juego: ${gameId}, bloqueado: ${isLocked}`);
                    
                    if (!isLocked) {
                        console.log(`üöÄ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        gamesModal.style.display = 'none';
                        
                        // Iniciar juego usando window.game o funci√≥n de emergencia
                        if (window.game && window.game.startGame) {
                            window.game.startGame(gameId);
                        } else if (gameId === 'bubbles') {
                            console.log('üö® Usando funci√≥n de emergencia para burbujas');
                            window.startBubbleGameDirect();
                        } else {
                            console.error('‚ùå window.game no disponible y no hay funci√≥n de emergencia para:', gameId);
                            alert(`üöß Juego ${gameId} no disponible temporalmente`);
                        }
                    } else {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        alert(`üîí Juego bloqueado. Necesitas m√°s estrellas.`);
                    }
                };
            });
            
            console.log('‚úÖ Sistema de emergencia activado');
        }, 1000);

        // üéµ SISTEMA DE AUDIO COMPLETO
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.backgroundMusic = null;
                this.isMuted = localStorage.getItem('miPececito_muted') === 'true';
                this.volume = parseFloat(localStorage.getItem('miPececito_volume')) || 0.7;
                this.musicVolume = 0.55; // M√∫sica de fondo bien audible
                this.effectsVolume = 0.4; // Efectos a volumen medio
                
                this.initAudioContext();
                this.loadSounds();
                this.createGeneratedSounds();
            }
            
            async initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('üéµ AudioContext creado correctamente');
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo crear AudioContext:', error);
                }
            }
            
            async loadSounds() {
                const soundFiles = {
                    background: './sound/fondo.mp3',
                    eat: './sound/comer.mp3',
                    hatch: './sound/eclosionar.mp3',
                    clean: './sound/limpiar.mp3'
                };
                
                for (const [name, url] of Object.entries(soundFiles)) {
                    try {
                        const audio = new Audio(url);
                        audio.preload = 'auto';
                        this.sounds[name] = audio;
                        console.log(`üéµ Sonido cargado: ${name}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Error cargando ${name}:`, error);
                    }
                }
                
                // Configurar m√∫sica de fondo
                if (this.sounds.background) {
                    this.sounds.background.loop = true;
                    this.sounds.background.volume = this.musicVolume * this.volume;
                    this.backgroundMusic = this.sounds.background;
                }
            }
            
            createGeneratedSounds() {
                // Sonidos que crearemos con Web Audio API si no existen
                this.createHeartSound();
                this.createBirthSound();
                this.createClickSound();
            }
            
            createHeartSound() {
                // Sonido de campanita suave para el coraz√≥n
                this.sounds.heart = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createBirthSound() {
                // Fanfarria suave para el nacimiento
                this.sounds.birth = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const notes = [523, 659, 784, 1047]; // Do, Mi, Sol, Do alto
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.2, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                            
                            oscillator.type = 'triangle';
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.3);
                        }, i * 100);
                    });
                };
            }
            
            createClickSound() {
                // Sonido sutil de click/burbuja
                this.sounds.click = () => {
                    if (!this.audioContext || this.isMuted) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.effectsVolume * this.volume * 0.1, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
                    
                    oscillator.type = 'sine';
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }
            
            playSound(soundName) {
                if (this.isMuted) return;
                
                const sound = this.sounds[soundName];
                if (!sound) {
                    console.warn(`‚ö†Ô∏è Sonido no encontrado: ${soundName}`);
                    return;
                }
                
                try {
                    if (typeof sound === 'function') {
                        // Sonido generado
                        sound();
                    } else {
                        // Archivo de audio
                        sound.currentTime = 0;
                        sound.volume = this.effectsVolume * this.volume;
                        sound.play();
                    }
                    console.log(`üîä Reproduciendo: ${soundName}`);
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error reproduciendo ${soundName}:`, error);
                }
            }
            
            startBackgroundMusic() {
                if (this.isMuted || !this.backgroundMusic) return;
                
                this.backgroundMusic.volume = this.musicVolume * this.volume;
                
                const playPromise = this.backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('üéµ M√∫sica de fondo iniciada correctamente');
                        })
                        .catch(error => {
                            console.warn('‚ö†Ô∏è Autoplay bloqueado por el navegador:', error);
                            console.log('üéµ La m√∫sica se iniciar√° tras la primera interacci√≥n del usuario');
                        });
                } else {
                    console.log('üéµ M√∫sica de fondo iniciada (navegador antiguo)');
                }
            }
            
            stopBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                    this.backgroundMusic.currentTime = 0;
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('miPececito_muted', this.isMuted.toString());
                
                if (this.isMuted) {
                    this.stopBackgroundMusic();
                } else {
                    this.startBackgroundMusic();
                }
                
                this.updateVolumeButton();
                console.log(`üîä Audio ${this.isMuted ? 'silenciado' : 'activado'}`);
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                localStorage.setItem('miPececito_volume', this.volume.toString());
                
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume * this.volume;
                }
            }
            
            updateVolumeButton() {
                const volumeBtn = document.getElementById('volumeBtn');
                const volumeIcon = document.getElementById('volumeIcon');
                
                if (volumeBtn && volumeIcon) {
                    volumeIcon.src = this.isMuted ? './images/ui/sonidoOff.png' : './images/ui/sonidoOn.png';
                    volumeBtn.title = this.isMuted ? 'Activar sonido' : 'Silenciar sonido';
                    volumeBtn.classList.toggle('muted', this.isMuted);
                }
            }
        }
        
        // üéÆ JUEGO DE BURBUJAS INTEGRADO HERMOSO
        function startBubbleGame() {
            console.log('ü´ß Iniciando juego de burbujas integrado...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear modal del juego con dise√±o hermoso
            const gameModal = document.createElement('div');
            gameModal.className = 'bubble-game-modal';
            gameModal.innerHTML = `
                <div class="bubble-game-container">
                    <!-- üèÜ HEADER DEL JUEGO -->
                    <div class="bubble-game-header">
                        <div class="game-title">ü´ß Atrapa Burbujas</div>
                        <div class="game-stats">
                            <span>Puntos: <span id="bubble-score">0</span></span>
                            <span>R√©cord: <span id="bubble-best">0</span></span>
                            <span>‚≠ê <span id="bubble-stars">0</span></span>
                        </div>
                    </div>
                    
                    <!-- üìñ LEYENDA -->
                    <div class="bubble-legend">
                        <div class="legend-item good">‚úÖ üêü üê† üêö ü™∏ ‚≠ê</div>
                        <div class="legend-item bad">‚ùå üíÄ ü¶à ‚ö†Ô∏è üß® ü™ù</div>
                    </div>
                    
                    <!-- üéØ √ÅREA DE JUEGO -->
                    <div class="bubble-stage-container">
                        <div id="bubbleStage" class="bubble-stage"></div>
                        <div class="game-instructions">Toca ‚úÖ Evita ‚ùå</div>
                    </div>
                    
                    <!-- üéÆ CONTROLES -->
                    <div class="bubble-controls">
                        <button id="bubbleStartBtn" class="bubble-btn primary">‚ñ∂Ô∏è JUGAR</button>
                        <button class="bubble-btn secondary bubble-back-btn">üè† SALIR</button>
                    </div>
                </div>
                
                <!-- üèÜ MODAL DE RESULTADOS -->
                <div class="bubble-results-modal" style="display: none;">
                    <div class="results-content">
                        <h2 id="results-title">¬°Fin de partida!</h2>
                        <div class="results-stats">
                            <div class="result-item">
                                <span class="result-label">Puntos</span>
                                <span class="result-value" id="final-score">0</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">R√©cord</span>
                                <span class="result-value" id="final-best">0</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">‚≠ê Ganadas</span>
                                <span class="result-value" id="final-stars">1</span>
                            </div>
                        </div>
                        <div class="results-buttons">
                            <button id="bubble-again-btn" class="bubble-btn primary">OTRA</button>
                            <button id="bubble-finish-btn" class="bubble-btn secondary">SALIR</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(gameModal);
            
            
            // üé® APLICAR ESTILOS Y INICIALIZAR JUEGO
            applyBubbleGameStyles(gameModal);
            initBubbleGameLogic(gameModal);
        }
        
        // üé® ESTILOS COLORIDOS TIPO JUEGO PARA BURBUJAS
        function applyBubbleGameStyles(gameModal) {
            // Modal principal - M√°s colorido y menos oscuro
            gameModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(41, 182, 246, 0.15) 50%, 
                    rgba(13, 71, 161, 0.3) 100%);
                backdrop-filter: blur(20px) saturate(200%);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.4s ease;
            `;
            
            // Contenedor principal - Dise√±o tipo acuario colorido
            const container = gameModal.querySelector('.bubble-game-container');
            container.style.cssText = `
                background: linear-gradient(180deg, 
                    rgba(129, 212, 250, 0.25) 0%,
                    rgba(79, 195, 247, 0.2) 30%,
                    rgba(41, 182, 246, 0.15) 70%,
                    rgba(13, 71, 161, 0.2) 100%);
                backdrop-filter: blur(30px) saturate(200%);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 28px;
                width: 95vw;
                height: 95vh;
                max-width: 420px;
                max-height: 800px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                box-shadow: 
                    0 30px 100px rgba(79, 195, 247, 0.3),
                    0 0 60px rgba(129, 212, 250, 0.2),
                    inset 0 2px 0 rgba(255, 255, 255, 0.4);
            `;
            
            // Header del juego - M√°s colorido
            const header = gameModal.querySelector('.bubble-game-header');
            header.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.3) 0%, 
                    rgba(129, 212, 250, 0.2) 100%);
                padding: 12px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(255, 255, 255, 0.25);
                gap: 15px;
            `;
            
            // T√≠tulo m√°s llamativo
            const title = gameModal.querySelector('.game-title');
            title.style.cssText = `
                font-size: 22px;
                font-weight: 800;
                color: #fff;
                text-shadow: 
                    0 2px 8px rgba(79, 195, 247, 0.8),
                    0 0 20px rgba(129, 212, 250, 0.6);
                letter-spacing: 0.5px;
            `;
            
            // Stats m√°s vistosas
            const stats = gameModal.querySelector('.game-stats');
            stats.style.cssText = `
                display: flex;
                gap: 20px;
                font-size: 14px;
                font-weight: 700;
                color: #ffd700;
                text-shadow: 
                    0 2px 4px rgba(0, 0, 0, 0.5),
                    0 0 10px rgba(255, 215, 0, 0.6);
            `;
            
            
            // Leyenda m√°s colorida
            const legend = gameModal.querySelector('.bubble-legend');
            legend.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(76, 175, 80, 0.15) 0%, 
                    rgba(244, 67, 54, 0.15) 100%);
                padding: 10px 20px;
                display: flex;
                justify-content: space-around;
                flex-wrap: wrap;
                gap: 15px;
                border-bottom: 2px solid rgba(255, 255, 255, 0.2);
                font-size: 13px;
                font-weight: 600;
            `;
            
            // Items de leyenda m√°s vistosos
            const goodLegend = gameModal.querySelector('.legend-item.good');
            goodLegend.style.cssText = `
                background: linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(139, 195, 74, 0.2));
                border: 2px solid rgba(76, 175, 80, 0.6);
                border-radius: 25px;
                padding: 6px 12px;
                color: #4caf50;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
                font-weight: 700;
            `;
            
            const badLegend = gameModal.querySelector('.legend-item.bad');
            badLegend.style.cssText = `
                background: linear-gradient(135deg, rgba(244, 67, 54, 0.3), rgba(229, 57, 53, 0.2));
                border: 2px solid rgba(244, 67, 54, 0.6);
                border-radius: 25px;
                padding: 6px 12px;
                color: #f44336;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
                font-weight: 700;
            `;
            
            // √Årea de juego - Fondo tipo acuario brillante
            const stageContainer = gameModal.querySelector('.bubble-stage-container');
            stageContainer.style.cssText = `
                flex: 1;
                position: relative;
                margin: 15px;
                border-radius: 20px;
                overflow: hidden;
                background: 
                    radial-gradient(ellipse 80% 60% at 50% 20%, rgba(129, 212, 250, 0.4) 0%, transparent 60%),
                    radial-gradient(ellipse 60% 40% at 20% 80%, rgba(79, 195, 247, 0.3) 0%, transparent 50%),
                    radial-gradient(ellipse 60% 40% at 80% 80%, rgba(41, 182, 246, 0.3) 0%, transparent 50%),
                    linear-gradient(180deg, #4fc3f7 0%, #29b6f6 30%, #0288d1 70%, #0277bd 100%);
                border: 3px solid rgba(255, 255, 255, 0.4);
                box-shadow: 
                    inset 0 0 80px rgba(255, 255, 255, 0.1),
                    0 10px 40px rgba(79, 195, 247, 0.3);
                animation: aquarium-glow 4s ease-in-out infinite alternate;
            `;
            
            const stage = gameModal.querySelector('#bubbleStage');
            stage.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 35px;
                overflow: hidden;
            `;
            
            // Instrucciones m√°s llamativas
            const instructions = gameModal.querySelector('.game-instructions');
            instructions.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 35px;
                background: linear-gradient(135deg, rgba(79, 195, 247, 0.4), rgba(129, 212, 250, 0.3));
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                color: white;
                font-weight: 700;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                border-top: 2px solid rgba(255, 255, 255, 0.3);
            `;
            
            // Controles m√°s gaming
            const controls = gameModal.querySelector('.bubble-controls');
            controls.style.cssText = `
                background: linear-gradient(135deg, 
                    rgba(79, 195, 247, 0.2) 0%, 
                    rgba(129, 212, 250, 0.15) 100%);
                padding: 12px;
                display: flex;
                justify-content: center;
                gap: 15px;
                border-top: 2px solid rgba(255, 255, 255, 0.25);
            `;
            
            // Bot√≥n JUGAR - M√°s llamativo
            const startBtn = gameModal.querySelector('.bubble-btn.primary');
            startBtn.style.cssText = `
                background: linear-gradient(135deg, #4caf50, #66bb6a);
                border: 3px solid rgba(255, 255, 255, 0.4);
                border-radius: 25px;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: 800;
                color: white;
                cursor: pointer;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                box-shadow: 
                    0 8px 25px rgba(76, 175, 80, 0.4),
                    inset 0 2px 0 rgba(255, 255, 255, 0.3);
                letter-spacing: 1px;
            `;
            
            startBtn.addEventListener('mouseenter', () => {
                startBtn.style.transform = 'translateY(-3px) scale(1.05)';
                startBtn.style.boxShadow = '0 12px 35px rgba(76, 175, 80, 0.6)';
                startBtn.style.background = 'linear-gradient(135deg, #66bb6a, #4caf50)';
            });
            
            startBtn.addEventListener('mouseleave', () => {
                startBtn.style.transform = 'translateY(0) scale(1)';
                startBtn.style.boxShadow = '0 8px 25px rgba(76, 175, 80, 0.4)';
                startBtn.style.background = 'linear-gradient(135deg, #4caf50, #66bb6a)';
            });
            
            // Bot√≥n SALIR - M√°s sutil pero elegante
            const backBtn = gameModal.querySelector('.bubble-btn.secondary');
            backBtn.style.cssText = `
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 20px;
                padding: 8px 16px;
                font-size: 12px;
                font-weight: 600;
                color: white;
                cursor: pointer;
                transition: all 0.3s ease;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                box-shadow: 
                    0 6px 20px rgba(255, 255, 255, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            `;
            
            backBtn.addEventListener('mouseenter', () => {
                backBtn.style.transform = 'translateY(-2px)';
                backBtn.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2))';
                backBtn.style.boxShadow = '0 8px 25px rgba(255, 255, 255, 0.2)';
            });
            
            backBtn.addEventListener('mouseleave', () => {
                backBtn.style.transform = 'translateY(0)';
                backBtn.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1))';
                backBtn.style.boxShadow = '0 6px 20px rgba(255, 255, 255, 0.1)';
            });
            
            // A√±adir animaci√≥n de acuario
            const style = document.createElement('style');
            style.textContent = `
                @keyframes aquarium-glow {
                    from { 
                        filter: brightness(1) saturate(100%);
                        box-shadow: 
                            inset 0 0 80px rgba(255, 255, 255, 0.1),
                            0 10px 40px rgba(79, 195, 247, 0.3);
                    }
                    to { 
                        filter: brightness(1.1) saturate(120%);
                        box-shadow: 
                            inset 0 0 100px rgba(255, 255, 255, 0.15),
                            0 15px 50px rgba(129, 212, 250, 0.4);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // üéÆ L√ìGICA DEL JUEGO DE BURBUJAS
        function initBubbleGameLogic(gameModal) {
            const GOOD_EMOJIS = ["üêü","üê†","üêö","ü™∏","‚≠ê"];
            const BAD_EMOJIS = ["üíÄ","ü¶à","‚ö†Ô∏è","üß®","ü™ù"];
            
            let gameState = {
                running: false,
                score: 0,
                lastSpawn: 0,
                spawnEvery: 800,
                bubbles: [],
                rafId: null,
                startTime: 0
            };
            
            const elements = {
                stage: gameModal.querySelector('#bubbleStage'),
                scoreEl: gameModal.querySelector('#bubble-score'),
                bestEl: gameModal.querySelector('#bubble-best'),
                starsEl: gameModal.querySelector('#bubble-stars'),
                startBtn: gameModal.querySelector('#bubbleStartBtn'),
                backBtn: gameModal.querySelector('.bubble-back-btn'),
                resultsModal: gameModal.querySelector('.bubble-results-modal')
            };
            
            // Persistencia
            const getBest = () => Number(localStorage.getItem('bubbles_best') || 0);
            const setBest = (v) => localStorage.setItem('bubbles_best', String(v));
            const getStars = () => Number(localStorage.getItem('bubbles_stars') || 0);
            const addStars = (n) => {
                const total = getStars() + n;
                localStorage.setItem('bubbles_stars', String(total));
                return total;
            };
            
            // UI inicial
            elements.bestEl.textContent = getBest();
            elements.starsEl.textContent = getStars();
            
            // ü´ß CREAR BURBUJA
            function createBubble(now) {
                if (now - gameState.lastSpawn < gameState.spawnEvery) return;
                gameState.lastSpawn = now;
                
                const isGood = Math.random() < 0.7;
                const size = 35 + Math.random() * 25; // 35-60px
                const stageRect = elements.stage.getBoundingClientRect();
                const x = size + Math.random() * (stageRect.width - size * 2);
                const y = stageRect.height + size;
                const speed = 80 + Math.random() * 60 + gameState.score * 0.8;
                const drift = (Math.random() - 0.5) * 40;
                
                const bubbleEl = document.createElement('div');
                bubbleEl.className = 'game-bubble ' + (isGood ? 'good' : 'bad');
                bubbleEl.innerHTML = `<div class="bubble-emoji">${isGood ? 
                    GOOD_EMOJIS[Math.floor(Math.random() * GOOD_EMOJIS.length)] : 
                    BAD_EMOJIS[Math.floor(Math.random() * BAD_EMOJIS.length)]
                }</div>`;
                
                // Estilo de la burbuja
                bubbleEl.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size}px;
                    border-radius: 50%;
                    background: radial-gradient(120% 100% at 30% 25%, 
                        rgba(255,255,255,0.25), 
                        rgba(255,255,255,0.08) 55%, 
                        rgba(255,255,255,0.03) 70%);
                    border: 2px solid ${isGood ? 'rgba(76, 175, 80, 0.4)' : 'rgba(244, 67, 54, 0.4)'};
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 2px 0 rgba(255, 255, 255, 0.3);
                    cursor: pointer;
                    user-select: none;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transform: translate(${x - size/2}px, ${y - size/2}px);
                    transition: transform 0.1s ease;
                `;
                
                bubbleEl.querySelector('.bubble-emoji').style.cssText = `
                    font-size: ${size * 0.5}px;
                    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
                `;
                
                elements.stage.appendChild(bubbleEl);
                
                const bubble = { el: bubbleEl, x, y, size, vy: -speed, vx: drift, isGood };
                gameState.bubbles.push(bubble);
                
                // Click en burbuja
                bubbleEl.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!gameState.running) return;
                    
                    if (bubble.isGood) {
                        gameState.score++;
                        elements.scoreEl.textContent = gameState.score;
                        removeBubble(bubble, true);
                        bubbleEl.style.transform += ' scale(1.2)';
                        bubbleEl.style.opacity = '0';
                        setTimeout(() => bubbleEl.remove(), 200);
                    } else {
                        endGame(false, "¬°Tocaste una mala!");
                    }
                });
                
                gameState.spawnEvery = Math.max(300, 800 - gameState.score * 10);
            }
            
            // üóëÔ∏è REMOVER BURBUJA
            function removeBubble(bubble, silent = false) {
                const index = gameState.bubbles.indexOf(bubble);
                if (index >= 0) {
                    gameState.bubbles.splice(index, 1);
                    if (!silent) {
                        bubble.el.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                        bubble.el.style.opacity = '0';
                        bubble.el.style.transform += ' scale(0.8)';
                        setTimeout(() => bubble.el.remove(), 200);
                    } else {
                        bubble.el.remove();
                    }
                }
            }
            
            // üéÆ LOOP DEL JUEGO
            function gameLoop(now) {
                if (!gameState.running) return;
                
                if (!gameState.startTime) gameState.startTime = now;
                const deltaTime = (now - gameState.startTime) / 1000;
                gameState.startTime = now;
                
                createBubble(now);
                
                // Mover burbujas
                for (let i = gameState.bubbles.length - 1; i >= 0; i--) {
                    const bubble = gameState.bubbles[i];
                    bubble.y += bubble.vy * deltaTime;
                    bubble.x += bubble.vx * deltaTime;
                    bubble.vx += Math.sin(now / 400 + i) * 50 * deltaTime;
                    
                    const stageRect = elements.stage.getBoundingClientRect();
                    if (bubble.x - bubble.size/2 < 0 || bubble.x + bubble.size/2 > stageRect.width) {
                        bubble.vx *= -0.9;
                    }
                    
                    bubble.el.style.transform = `translate(${bubble.x - bubble.size/2}px, ${bubble.y - bubble.size/2}px)`;
                    
                    if (bubble.y + bubble.size/2 < 0) {
                        if (bubble.isGood) {
                            endGame(false, "¬°Dejaste escapar una buena!");
                            return;
                        } else {
                            removeBubble(bubble, true);
                        }
                    }
                }
                
                gameState.rafId = requestAnimationFrame(gameLoop);
            }
            
            // üèÜ TERMINAR JUEGO
            function endGame(won, reason) {
                gameState.running = false;
                if (gameState.rafId) cancelAnimationFrame(gameState.rafId);
                
                gameState.bubbles.forEach(bubble => bubble.el.remove());
                gameState.bubbles = [];
                
                const finalScore = gameState.score;
                const bestPrev = getBest();
                let starsWon = 1;
                
                if (finalScore > bestPrev) {
                    starsWon = 2;
                    setBest(finalScore);
                }
                
                const totalStars = addStars(starsWon);
                elements.bestEl.textContent = getBest();
                elements.starsEl.textContent = totalStars;
                
                // Mostrar resultados
                gameModal.querySelector('#results-title').textContent = won ? "¬°Perfecto!" : "Fin de partida";
                gameModal.querySelector('#final-score').textContent = finalScore;
                gameModal.querySelector('#final-best').textContent = getBest();
                gameModal.querySelector('#final-stars').textContent = starsWon;
                
                elements.resultsModal.style.display = 'flex';
                elements.resultsModal.style.cssText += `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(135deg, 
                        rgba(25, 30, 40, 0.85) 0%, 
                        rgba(20, 25, 35, 0.9) 50%, 
                        rgba(15, 20, 30, 0.95) 100%);
                    backdrop-filter: blur(12px) saturate(100%);
                    align-items: center;
                    justify-content: center;
                    animation: fadeIn 0.5s ease;
                `;
                
                // Estilo del contenido de resultados
                const resultsContent = gameModal.querySelector('.results-content');
                resultsContent.style.cssText = `
                    background: linear-gradient(145deg, 
                        rgba(35, 40, 50, 0.9) 0%, 
                        rgba(30, 35, 45, 0.95) 50%, 
                        rgba(25, 30, 40, 1) 100%);
                    backdrop-filter: blur(15px);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 25px;
                    padding: 35px;
                    text-align: center;
                    color: white;
                    max-width: 320px;
                    box-shadow: 
                        0 15px 40px rgba(0, 0, 0, 0.3),
                        0 0 30px rgba(0, 0, 0, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                `;
                
                // T√≠tulo de resultados
                const resultsTitle = gameModal.querySelector('#results-title');
                resultsTitle.style.cssText = `
                    font-size: 24px;
                    font-weight: 800;
                    margin-bottom: 20px;
                    text-shadow: 
                        0 2px 4px rgba(0, 0, 0, 0.5),
                        0 0 8px rgba(255, 255, 255, 0.1);
                    color: ${won ? '#4caf50' : '#ff9800'};
                `;
                
                // Stats de resultados
                const resultsStats = gameModal.querySelector('.results-stats');
                resultsStats.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    margin-bottom: 25px;
                `;
                
                gameModal.querySelectorAll('.result-item').forEach(item => {
                    item.style.cssText = `
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        background: rgba(255, 255, 255, 0.08);
                        border-radius: 15px;
                        padding: 12px 18px;
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        font-weight: 600;
                    `;
                });
                
                // Botones de resultados
                const resultsButtons = gameModal.querySelector('.results-buttons');
                resultsButtons.style.cssText = `
                    display: flex;
                    gap: 15px;
                    justify-content: center;
                `;
                
                gameModal.querySelectorAll('#bubble-again-btn, #bubble-finish-btn').forEach(btn => {
                    const isAgain = btn.id === 'bubble-again-btn';
                    btn.style.cssText = `
                        background: linear-gradient(135deg, 
                            ${isAgain ? '#4caf50, #66bb6a' : 'rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1)'});
                        border: 2px solid ${isAgain ? 'rgba(76, 175, 80, 0.6)' : 'rgba(255, 255, 255, 0.3)'};
                        border-radius: 20px;
                        padding: 12px 25px;
                        font-size: 14px;
                        font-weight: 700;
                        color: white;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                        box-shadow: 0 6px 20px ${isAgain ? 'rgba(76, 175, 80, 0.4)' : 'rgba(255, 255, 255, 0.2)'};
                    `;
                });
                
                console.log(`üèÜ Juego terminado: ${finalScore} puntos, ${starsWon} estrellas`);
                
                // Agregar estrellas al pez
                if (window.game && window.game.gameState) {
                    window.game.gameState.stars = (window.game.gameState.stars || 0) + starsWon;
                    window.game.saveGame();
                }
            }
            
            // üöÄ INICIAR JUEGO
            function startGame() {
                gameState.running = true;
                gameState.score = 0;
                gameState.lastSpawn = 0;
                gameState.spawnEvery = 800;
                gameState.startTime = 0;
                
                elements.scoreEl.textContent = '0';
                elements.resultsModal.style.display = 'none';
                
                gameState.bubbles.forEach(bubble => bubble.el.remove());
                gameState.bubbles = [];
                
                console.log('ü´ß ¬°Juego iniciado!');
                requestAnimationFrame(gameLoop);
            }
            
            // üì± EVENT LISTENERS
            elements.startBtn.addEventListener('click', startGame);
            gameModal.querySelector('#bubble-again-btn').addEventListener('click', startGame);
            
            const closeGame = () => {
                if (gameState.rafId) cancelAnimationFrame(gameState.rafId);
                gameState.running = false;
                gameModal.remove();
                console.log('ü´ß Juego cerrado');
            };
            
            elements.backBtn.addEventListener('click', closeGame);
            gameModal.querySelector('#bubble-finish-btn').addEventListener('click', closeGame);
            
            console.log('üéÆ Juego de burbujas inicializado completamente');
        }
        
        // üíé JUEGO DE BLOQUES (MAR MATCH-3)
        function startBloquesGame() {
            console.log('üíé Iniciando juego Mar Match-3...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üíé Mar Match-3</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego bloques.html" class="game-iframe"></iframe>
                </div>
            `;
            
            // Aplicar estilos
            gameModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, 
                    rgba(25, 30, 40, 0.9) 0%, 
                    rgba(15, 20, 30, 0.95) 100%);
                backdrop-filter: blur(15px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.3s ease;
            `;
            
            const container = gameModal.querySelector('.game-iframe-container');
            container.style.cssText = `
                background: rgba(35, 40, 50, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                width: 95vw;
                height: 95vh;
                max-width: 800px;
                max-height: 700px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            `;
            
            const header = gameModal.querySelector('.game-iframe-header');
            header.style.cssText = `
                background: rgba(79, 195, 247, 0.2);
                padding: 15px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            `;
            
            const title = header.querySelector('h2');
            title.style.cssText = `
                color: white;
                margin: 0;
                font-size: 20px;
                font-weight: 800;
            `;
            
            const closeBtn = gameModal.querySelector('.game-close-btn');
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                color: white;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            `;
            
            const iframe = gameModal.querySelector('.game-iframe');
            iframe.style.cssText = `
                flex: 1;
                border: none;
                width: 100%;
                background: white;
            `;
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                gameModal.remove();
                console.log('üíé Juego Mar Match-3 cerrado');
            });
            
            gameModal.addEventListener('click', (e) => {
                if (e.target === gameModal) {
                    gameModal.remove();
                }
            });
            
            document.body.appendChild(gameModal);
            console.log('üíé Juego Mar Match-3 iniciado');
        }
        
        // üß† JUEGO DE MEMORIA
        function startMemoriaGame() {
            console.log('üß† Iniciando juego Memoflip...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üß† Memoflip</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego memoria.html" class="game-iframe"></iframe>
                </div>
            `;
            
            // Reutilizar estilos de bloques
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üß† Juego Memoflip iniciado');
        }
        
        // üéµ JUEGO DE SIM√ìN MARINO
        function startSimonGame() {
            console.log('üéµ Iniciando juego Sim√≥n Marino...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üéµ Sim√≥n Marino</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego Simon.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üéµ Juego Sim√≥n Marino iniciado');
        }
        
        // üê¨ JUEGO DEL CARRIL DEL DELF√çN
        function startCarrilGame() {
            console.log('üê¨ Iniciando juego Carril del Delf√≠n...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üê¨ Carril del Delf√≠n</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego carril.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üê¨ Juego Carril del Delf√≠n iniciado');
        }
        
        // üêâ JUEGO DEL DRAG√ìN MARINO
        function startCorrerGame() {
            console.log('üêâ Iniciando juego Drag√≥n Marino...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üêâ Drag√≥n Marino</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego Correr y saltar.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üêâ Juego Drag√≥n Marino iniciado');
        }
        
        // üéØ JUEGO DE CAZA DE PECES
        function startCazaGame() {
            console.log('üéØ Iniciando juego Caza de Peces...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üéØ Caza de Peces</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego de caza.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üéØ Juego Caza de Peces iniciado');
        }
        
        // üåä JUEGO DE SECUENCIA DE MAREAS
        function startSecuenciaGame() {
            console.log('üåä Iniciando juego Secuencia de Mareas...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üåä Secuencia de Mareas</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego secuencia.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üåä Juego Secuencia de Mareas iniciado');
        }
        
        // üèñÔ∏è JUEGO DE TOCA-3 MARINO
        function startToca3Game() {
            console.log('üèñÔ∏è Iniciando juego Toca-3 Marino...');
            
            // Cerrar modal de juegos
            document.getElementById('gamesModal').style.display = 'none';
            
            // Crear iframe con el juego completo
            const gameModal = document.createElement('div');
            gameModal.className = 'game-iframe-modal';
            gameModal.innerHTML = `
                <div class="game-iframe-container">
                    <div class="game-iframe-header">
                        <h2>üèñÔ∏è Toca-3 Marino</h2>
                        <button class="game-close-btn">‚úï</button>
                    </div>
                    <iframe src="./ejemplos/juegos/Juego Toca3.html" class="game-iframe"></iframe>
                </div>
            `;
            
            applyGameIframeStyles(gameModal);
            
            document.body.appendChild(gameModal);
            console.log('üèñÔ∏è Juego Toca-3 Marino iniciado');
        }
        
        // üé® FUNCI√ìN AUXILIAR PARA APLICAR ESTILOS A IFRAMES DE JUEGOS
        function applyGameIframeStyles(gameModal) {
            gameModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, 
                    rgba(25, 30, 40, 0.9) 0%, 
                    rgba(15, 20, 30, 0.95) 100%);
                backdrop-filter: blur(15px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.3s ease;
            `;
            
            const container = gameModal.querySelector('.game-iframe-container');
            container.style.cssText = `
                background: rgba(35, 40, 50, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                width: 95vw;
                height: 95vh;
                max-width: 800px;
                max-height: 700px;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            `;
            
            const header = gameModal.querySelector('.game-iframe-header');
            header.style.cssText = `
                background: rgba(79, 195, 247, 0.2);
                padding: 15px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            `;
            
            const title = header.querySelector('h2');
            title.style.cssText = `
                color: white;
                margin: 0;
                font-size: 20px;
                font-weight: 800;
            `;
            
            const closeBtn = gameModal.querySelector('.game-close-btn');
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 50%;
                width: 35px;
                height: 35px;
                color: white;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            `;
            
            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                closeBtn.style.transform = 'scale(1.1)';
            });
            
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                closeBtn.style.transform = 'scale(1)';
            });
            
            const iframe = gameModal.querySelector('.game-iframe');
            iframe.style.cssText = `
                flex: 1;
                border: none;
                width: 100%;
                background: white;
            `;
            
            // Event listeners
            closeBtn.addEventListener('click', () => {
                gameModal.remove();
            });
            
            gameModal.addEventListener('click', (e) => {
                if (e.target === gameModal) {
                    gameModal.remove();
                }
            });
        }
    </script>
</body>
</html>

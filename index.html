<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üê† Mi Pececito - Tamagotchi Virtual</title>
    
    <!-- üé® CSS INTEGRADO PARA EVITAR PROBLEMAS DE CARGA -->
    
    <style>
        /* üé® VARIABLES CSS GLOBALES */
        :root {
          --bg-primary: #08243a;
          --bg-secondary: #1d4b6b;
          --bg-accent: #2a6287;
          --text-primary: #e9f6ff;
          --text-secondary: rgba(233, 246, 255, 0.8);
          --fish-baby-body: #d9ccff;
          --fish-baby-tail: #ff9ecf;
          --fish-baby-fin: #ffd0e2;
          --fish-baby-stripe: #ffba7a;
          --fish-young-body: #b1a1ff;
          --fish-young-tail: #f191cd;
          --fish-young-fin: #f1c4e4;
          --fish-young-stripe: #ffa960;
          --fish-adult-body: #5a48c8;
          --fish-adult-tail: #d073c6;
          --fish-adult-fin: #e2a8d6;
          --fish-adult-stripe: #ff9745;
          --button-primary: #205b86;
          --button-hover: #2a6287;
          --button-active: #1a4a73;
          --button-radius: 12px;
          --button-size: 80px;
          --badge-size: 64px;
          --bubble-size: 48px;
          --good-item: #4CAF50;
          --bad-item: #F44336;
          --star-color: #FFD700;
          --coin-color: #FF8C42;
          --fish-baby-size: 46px;
          --fish-young-size: 52px;
          --fish-adult-size: 60px;
          --egg-size: 64px;
          --pellet-size: 16px;
          --star-size: 32px;
          --transition-fast: 0.15s ease;
          --transition-smooth: 0.3s ease;
          --transition-slow: 0.6s ease;
          --bounce-animation: cubic-bezier(0.68, -0.55, 0.265, 1.55);
          --mobile-padding: 12px;
          --desktop-padding: 20px;
          --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.25);
          --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.4);
          --blur-light: blur(4px);
          --blur-strong: blur(10px);
          --rank-bronze: #CD7F32;
          --rank-silver: #C0C0C0;
          --rank-gold: #FFD700;
          --rank-diamond: #B9F2FF;
        }

        /* üîò COMPONENTES UNIVERSALES */
        .universal-btn {
          width: var(--button-size);
          height: var(--button-size);
          background: var(--button-primary);
          color: var(--text-primary);
          border: none;
          border-radius: var(--button-radius);
          box-shadow: var(--shadow-soft);
          transition: all var(--transition-fast);
          cursor: pointer;
          font-weight: 600;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
          font-size: 14px;
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }

        .universal-btn:hover {
          background: var(--button-hover);
          transform: translateY(-2px);
          box-shadow: var(--shadow-strong);
        }

        .universal-btn:active {
          background: var(--button-active);
          transform: translateY(0);
          box-shadow: var(--shadow-soft);
        }

        .fade-in {
          animation: fadeIn var(--transition-smooth) ease;
        }

        .bounce-in {
          animation: bounceIn 0.5s var(--bounce-animation);
        }

        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes bounceIn {
          0% { transform: scale(0.3); opacity: 0; }
          50% { transform: scale(1.05); }
          70% { transform: scale(0.9); }
          100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }

        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-6px); }
        }
        /* üì± Estilos base m√≥vil-first */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            touch-action: manipulation;
        }
        
        /* üèÜ CABECERA DEL JUEGO */
        #gameHeader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(13, 71, 161, 0.4);
            z-index: 1000;
            border-bottom: 3px solid #0d47a1;
            backdrop-filter: blur(10px);
        }
        
        .fish-info-expanded {
            flex: 1;
            text-align: center;
            color: #fff;
            padding: 0 20px;
        }
        
        #fishAge {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        
        #fishName {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            background: linear-gradient(45deg, #26c6da, #4fc3f7);
            border: 3px solid #81d4fa;
            color: white;
            padding: 8px;
            border-radius: 50%;
            font-size: 18px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(38, 198, 218, 0.3);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(38, 198, 218, 0.4);
            border-color: #4fc3f7;
        }
        
        .action-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéí MODAL DE INVENTARIO */
        #inventoryModal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 600px;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255,255,255,0.3);
        }
        
        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(255, 82, 82, 0.3);
        }
        
        .close-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 12px rgba(255, 82, 82, 0.4);
        }
        
        .inventory-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
        }
        
        .tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255,255,255,0.8);
            padding: 15px 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 4px solid transparent;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .tab-btn.active {
            color: white;
            border-bottom-color: white;
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }
        
        .inventory-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .item-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .item-card:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4fc3f7;
        }
        
        .item-card.selected {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        .item-preview {
            width: 80px;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            margin: 0 auto 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .item-name {
            color: #fff;
            font-size: 10px;
            font-weight: bold;
        }
        
        .item-cost {
            color: #4fc3f7;
            font-size: 9px;
            margin-top: 2px;
        }
        
        .coming-soon {
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-style: italic;
            padding: 40px 20px;
        }
        
        .locked-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        
        /* üé® MODALES BONITOS */
        @keyframes modalPop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes bubbleFloat {
            from {
                top: 100%;
                opacity: 0.8;
            }
            to {
                top: -10%;
                opacity: 0;
            }
        }
        
        /* üéÆ MODALES DE JUEGO MEJORADAS */
        .game-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-modal-overlay[style*="block"] {
            opacity: 1;
        }
        
        .game-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 4px solid #ffffff;
            border-radius: 25px;
            width: 95%;
            max-width: 650px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.4s ease-out;
            position: relative;
        }
        
        .games-modal {
            max-width: 700px;
        }
        
        .game-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .game-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .game-close-btn {
            background: linear-gradient(45deg, #ff5252, #ff7043);
            border: 2px solid white;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 82, 82, 0.3);
        }
        
        .game-close-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 15px rgba(255, 82, 82, 0.5);
        }
        
        .game-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-tab-btn {
            flex: 1;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            padding: 16px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 4px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .game-tab-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-2px);
        }
        
        .game-tab-btn.active {
            color: white;
            border-bottom-color: #ffffff;
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .tab-icon {
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .tab-text {
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-modal-body {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-tab-content {
            display: none;
        }
        
        .game-tab-content.active {
            display: block;
            animation: fadeInUp 0.3s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .game-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        
        .game-item-card {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .game-item-card:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .game-item-card.available {
            border-color: #4caf50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .game-item-card.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-item-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 12px;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }
        
        .game-item-info {
            text-align: center;
            margin-bottom: 16px;
        }
        
        .game-item-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-reward {
            color: #4caf50;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-item-unlock {
            color: #ff9800;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-play-btn {
            width: 100%;
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 12px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .game-play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 18px rgba(76, 175, 80, 0.4);
            background: linear-gradient(45deg, #66bb6a, #4caf50);
        }
        
        .game-play-btn:active {
            transform: scale(0.98);
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .game-locked-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 16px;
        }
        
        .lock-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        .lock-text {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .coming-soon-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .coming-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .coming-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .coming-desc {
            font-size: 14px;
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* üì± MODALES M√ìVILES SIMPLES */
        .mobile-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .mobile-modal-overlay[style*="flex"] {
            opacity: 1;
        }
        
        .mobile-modal-content {
            background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
            border: 3px solid #ffffff;
            border-radius: 20px;
            width: 95%;
            max-width: 400px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(38, 198, 218, 0.4);
            animation: modalPop 0.3s ease-out;
        }
        
        .mobile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mobile-modal-header h2 {
            color: white;
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .mobile-close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .mobile-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .mobile-close-btn:active {
            transform: scale(0.95);
        }
        
        /* üéÆ GRID DE JUEGOS 3x3 */
        .games-grid-3x3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .game-card-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .game-card-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }
        
        .game-card-square:active {
            transform: scale(0.98);
        }
        
        .game-card-square.available {
            border-color: #4caf50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .game-card-square.available:hover {
            border-color: #66bb6a;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }
        
        .game-card-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .game-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .game-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .game-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .game-card-square.locked .game-lock-overlay {
            opacity: 1;
        }
        
        .lock-icon-small {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .lock-stars {
            color: #ffa726;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* üéí INVENTARIO SIMPLE */
        .inventory-grid-simple {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .inventory-item-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .inventory-item-square:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }
        
        .inventory-item-square:active {
            transform: scale(0.98);
        }
        
        .inventory-item-square.available {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }
        
        .inventory-item-square.available:hover {
            border-color: #42a5f5;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }
        
        .inventory-item-square.locked {
            opacity: 0.7;
            border-color: #ff9800;
        }
        
        .inventory-square-icon {
            font-size: 32px;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .inventory-square-name {
            color: white;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .inventory-lock-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .inventory-item-square.locked .inventory-lock-overlay {
            opacity: 1;
        }
        
        /* üì± RESPONSIVE PARA MODALES M√ìVILES */
        @media (max-width: 480px) {
            .mobile-modal-content {
                width: 98%;
                max-width: 350px;
                border-radius: 16px;
            }
            
            .mobile-modal-header {
                padding: 14px 18px;
            }
            
            .mobile-modal-header h2 {
                font-size: 16px;
            }
            
            .mobile-close-btn {
                width: 36px;
                height: 36px;
                font-size: 20px;
            }
            
            .games-grid-3x3 {
                gap: 10px;
                padding: 16px;
            }
            
            .game-card-square {
                border-radius: 10px;
            }
            
            .game-square-icon {
                font-size: 28px;
                margin-bottom: 4px;
            }
            
            .game-square-name {
                font-size: 10px;
            }
            
            .lock-icon-small {
                font-size: 18px;
            }
            
            .lock-stars {
                font-size: 9px;
            }
        }
        
        @media (max-width: 360px) {
            .games-grid-3x3 {
                gap: 8px;
                padding: 14px;
            }
            
            .game-square-icon {
                font-size: 24px;
            }
            
            .game-square-name {
                font-size: 9px;
            }
        }
        
        /* üìä BARRAS DE NECESIDADES */
        .needs-bars {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .need-bar {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-icon {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        
        .bar-container {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .bar-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .bar-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .bar-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üìä BARRA DE NECESIDADES COMPACTA DEBAJO DE CABECERA */
        .needs-header-bar {
            background: linear-gradient(135deg, rgba(0, 80, 120, 0.9), rgba(0, 120, 180, 0.9)) !important;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 15px;
            display: none; /* OCULTA POR DEFECTO - SOLO VISIBLE CON PEZ */
            justify-content: center;
            align-items: center;
            gap: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 999;
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            height: 0; /* ALTURA 0 CUANDO EST√Å OCULTA */
            overflow: hidden;
            transition: height 0.3s ease;
        }
        
        /* CUANDO SE MUESTRA, TIENE ALTURA */
        .needs-header-bar[style*="flex"] {
            height: 35px !important;
        }
        
        .need-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .need-emoji {
            font-size: 16px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }
        
        .need-bar-mini {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .need-fill-mini {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        
        .need-fill-mini.hunger {
            background: linear-gradient(90deg, #4caf50, #ff5722);
        }
        
        .need-fill-mini.dirt {
            background: linear-gradient(90deg, #4caf50, #8bc34a, #cddc39, #ffeb3b, #ff9800, #795548);
        }
        
        .need-fill-mini.fun {
            background: linear-gradient(90deg, #f44336, #ff9800, #ffeb3b, #4caf50, #2196f3, #9c27b0);
        }
        
        /* üéÆ CANVAS CON FONDO COMPLETO (SIN ESPACIO AZUL) */
        #gameCanvas {
            background: radial-gradient(ellipse at center, #1e3a5f 0%, #0f2a44 100%) !important;
            z-index: 1;
        }
        
        /* üìä BARRAS FLOTANTES COMPACTAS (OCULTAS) */
        .needs-overlay {
            display: none; /* OCULTAR las flotantes */
            position: absolute;
            top: 70px;
            right: 15px;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .need-mini {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .need-mini span {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .mini-bar {
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .mini-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .mini-fill.hunger {
            background: linear-gradient(90deg, #ef476f, #ff8fab);
        }
        
        .mini-fill.dirt {
            background: linear-gradient(90deg, #7cc000, #a3f07f);
        }
        
        .mini-fill.fun {
            background: linear-gradient(90deg, #5ce1e6, #9be7ff);
        }
        
        /* üì± RESPONSIVE PARA M√ìVILES */
        @media (max-width: 768px) {
            .game-modal-content {
                width: 98%;
                max-height: 95vh;
                border-radius: 20px;
            }
            
            .game-modal-header {
                padding: 16px 20px;
            }
            
            .game-modal-header h2 {
                font-size: 18px;
            }
            
            .game-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .game-tabs {
                overflow-x: auto;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .game-tabs::-webkit-scrollbar {
                display: none;
            }
            
            .game-tab-btn {
                padding: 12px 8px;
                min-width: 80px;
            }
            
            .tab-icon {
                font-size: 18px;
            }
            
            .tab-text {
                font-size: 11px;
            }
            
            .game-modal-body {
                padding: 16px;
                max-height: 400px;
            }
            
            .game-items-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .game-item-card {
                padding: 16px;
            }
            
            .game-item-icon {
                font-size: 40px;
            }
            
            .game-item-name {
                font-size: 16px;
            }
            
            .game-item-description {
                font-size: 13px;
            }
            
            .game-play-btn {
                padding: 10px 14px;
                font-size: 13px;
            }
            
            .coming-soon-card {
                padding: 30px 16px;
            }
            
            .coming-icon {
                font-size: 40px;
            }
            
            .coming-text {
                font-size: 16px;
            }
            
            .coming-desc {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .game-modal-content {
                border-radius: 16px;
            }
            
            .game-modal-header {
                padding: 12px 16px;
            }
            
            .game-modal-header h2 {
                font-size: 16px;
            }
            
            .game-modal-body {
                padding: 12px;
                max-height: 350px;
            }
            
            .game-item-card {
                padding: 12px;
            }
            
            .game-item-icon {
                font-size: 36px;
            }
            
            .tab-icon {
                font-size: 16px;
            }
            
            .tab-text {
                font-size: 10px;
            }
        }
        
        .custom-modal h2 {
            color: white;
            font-size: 18px;
            margin: 0 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .custom-modal p {
            color: white;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .custom-input {
            width: 100%;
            padding: 12px;
            border: 3px solid white;
            border-radius: 15px;
            font-size: 16px;
            text-align: center;
            margin: 10px 0;
            background: rgba(255,255,255,0.9);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .custom-input:focus {
            outline: none;
            border-color: #81d4fa;
            box-shadow: 0 0 10px rgba(129, 212, 250, 0.5);
        }
        
        .custom-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .custom-btn {
            flex: 1;
            padding: 12px;
            border: 3px solid white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .confirm-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            color: white;
        }
        
        .cancel-btn {
            background: linear-gradient(45deg, #ff9800, #ffb74d);
            color: white;
        }
        
        .custom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .custom-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* üéÆ TARJETAS DE JUEGOS */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .game-card {
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .game-card.available {
            cursor: pointer;
        }
        
        .game-card.available:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: white;
            box-shadow: 0 8px 20px rgba(255,255,255,0.2);
        }
        
        .game-card.locked {
            filter: grayscale(70%);
            opacity: 0.6;
        }
        
        .game-icon {
            font-size: 40px;
            margin-bottom: 15px;
        }
        
        .game-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .game-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .game-reward {
            color: #81d4fa;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .game-unlock {
            color: #ffab91;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4caf50, #66bb6a);
            border: 2px solid white;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .play-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 12px rgba(76, 175, 80, 0.4);
        }
        
        /* üì∏ √ÅLBUM/DIARIO */
        .album-modal {
            max-width: 700px;
            max-height: 85%;
        }
        
        .album-content {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .album-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .stat-item {
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .stat-item span {
            display: block;
            font-size: 16px;
            color: #81d4fa;
            margin-top: 5px;
        }
        
        .album-timeline {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .album-entry {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .album-entry:hover {
            transform: translateY(-2px);
            border-color: white;
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
        }
        
        .album-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .album-entry-title {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        .album-entry-date {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .album-entry-description {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .album-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: rgba(255,255,255,0.6);
        }
        
        .album-entry-age {
            background: rgba(129, 212, 250, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        #gameCanvas {
            position: fixed;
            top: 100px; /* Header (60px) + Barra necesidades (40px) */
            left: 0;
            right: 0;
            bottom: 90px; /* Espacio para barra inferior */
            touch-action: none;
            background: var(--bg-primary);
        }
        
        /* üéÆ UI Overlay */
        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-overlay > * {
            pointer-events: auto;
        }
        
        /* üí∞ CONTADORES FLOTANTES */
        #currencyOverlay {
            position: absolute;
            top: 85px; /* M√°s cerca de la cabecera */
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px; /* M√°s compacto */
        }
        
        .currency-float {
            display: flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(38, 198, 218, 0.95), rgba(79, 195, 247, 0.95));
            border: 2px solid rgba(255,255,255,0.9);
            padding: 4px 6px;
            border-radius: 18px;
            box-shadow: 0 2px 6px rgba(38, 198, 218, 0.4);
            backdrop-filter: blur(6px);
            transition: all 0.3s ease;
            min-width: 55px;
        }
        
        .currency-float:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(38, 198, 218, 0.4);
        }
        
        .currency-float .currency-icon {
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .currency-float span:last-child {
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            min-width: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Animaci√≥n cuando cambia el valor */
        .currency-float.updated {
            animation: currencyPulse 0.5s ease-out;
        }
        
        @keyframes currencyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 8px 20px rgba(76, 175, 80, 0.5); }
            100% { transform: scale(1); }
        }
        
        /* üí® Badge Turbo */
        #turboBadge {
            position: fixed;
            right: var(--mobile-padding);
            top: var(--mobile-padding);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: var(--blur-light);
            font-weight: 700;
            font-size: 14px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none;
        }
        
        #turboBadge.active {
            opacity: 1;
        }
        
        /* üéØ Loading Screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity var(--transition-smooth);
            color: white;
            text-align: center;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content h2 {
            margin: 20px 0 10px 0;
            font-size: 24px;
            font-weight: bold;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            animation: logoFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .loading-dots {
            font-size: 30px;
            animation: loadingPulse 1.5s infinite;
        }

        .loading-dots span {
            animation: dotBounce 1.4s infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes dotBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-20px); }
        }

        /* üéÜ EFECTOS DE RECOMPENSA */
        .reward-bubble {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(100,200,255,0.6));
            border: 3px solid rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 2000;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(100,200,255,0.6);
            animation: rewardBubbleFloat 2s ease-out forwards;
        }

        @keyframes rewardBubbleFloat {
            0% {
                transform: scale(0.5) translateY(0);
                opacity: 0;
            }
            20% {
                transform: scale(1.2) translateY(-20px);
                opacity: 1;
            }
            50% {
                transform: scale(1) translateY(-60px);
                opacity: 1;
            }
            100% {
                transform: scale(2) translateY(-100px);
                opacity: 0;
            }
        }

        .reward-explosion {
            position: fixed;
            width: 70px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8), transparent);
            z-index: 1999;
            pointer-events: none;
            animation: rewardExplosion 0.8s ease-out forwards;
        }

        @keyframes rewardExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(233, 246, 255, 0.3);
            border-top: 3px solid var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes floatBubble {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            25% {
                transform: translateY(-8px) scale(1.05);
            }
            50% {
                transform: translateY(-3px) scale(0.98);
            }
            75% {
                transform: translateY(-12px) scale(1.02);
            }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.8;
        }
        
        /* üö® Error Screen */
        #errorScreen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: var(--mobile-padding);
            text-align: center;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .error-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .error-message {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 24px;
        }
        
        .retry-button {
            padding: 12px 24px;
            border: none;
            border-radius: var(--button-radius);
            background: var(--button-primary);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: background var(--transition-fast);
        }
        
        .retry-button:hover {
            background: var(--button-hover);
        }
        
        /* üîß Barra de Debug (solo en desarrollo) */
        #debugBar {
            position: fixed;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            padding: 6px 4px;
            display: none;
            flex-direction: column;
            gap: 3px;
            z-index: 1002;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
            width: 80px; /* Ancho fijo m√°s peque√±o */
        }
        
        #debugInfo {
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 7px;
            text-align: center;
            margin-bottom: 4px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-btn {
            padding: 4px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            font-size: 16px; /* Solo emoji */
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        
        .debug-btn.danger {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .debug-btn.primary {
            border-color: #4488ff;
            color: #4488ff;
        }
        
        .debug-btn.warning {
            border-color: #ffaa44;
            color: #ffaa44;
        }
        
        .debug-btn.success {
            border-color: #4caf50;
            color: #4caf50;
        }
        
        .debug-btn.info {
            border-color: #00bcd4;
            color: #00bcd4;
        }
        
        .debug-btn.purple {
            border-color: #9c27b0;
            color: #9c27b0;
        }
        
        /* üéÆ BARRA DE HERRAMIENTAS COMPACTA COMO CABECERA */
        .action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px; /* M√ÅS COMPACTA (era 90px) */
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2); /* IGUAL QUE CABECERA */
            box-shadow: 0 -4px 20px rgba(13, 71, 161, 0.4); /* SOMBRA HACIA ARRIBA */
            border-top: 3px solid #0d47a1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #0d47a1, #1565c0);
            backdrop-filter: blur(20px);
            border-radius: 0; /* SIN ESQUINAS REDONDEADAS */
            padding: 8px 15px;
            z-index: 40;
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: none; /* SIN BORDES */
        }
        
        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none; /* SIN BORDES OSCUROS */
            border-radius: 0; /* SIN RADIO - TODO AZUL COMO CABECERA */
            padding: 8px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            width: 48px;
            height: 48px;
            overflow: hidden;
        }
        
        .menu-btn:hover:not(.disabled) {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-8px) scale(1.1);
            box-shadow: 0 8px 25px rgba(79, 195, 247, 0.6);
        }
        
        .menu-btn.disabled {
            background: linear-gradient(135deg, #bbb, #999);
            border: none; /* SIN BORDES EN DESHABILITADOS TAMBI√âN */
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .menu-btn.disabled:hover {
            transform: none;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        
        .menu-icon {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .menu-btn:hover:not(.disabled) .menu-icon {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4)) brightness(1.2);
        }
        
        .menu-btn.disabled .menu-icon {
            filter: grayscale(100%) drop-shadow(0 2px 6px rgba(0,0,0,0.3));
        }
        
        /* üé® LOGO DE LA WEB */
        .logo-container {
            display: flex;
            align-items: center;
        }
        
        .game-logo {
            height: 40px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.3s ease;
        }
        
        .game-logo:hover {
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.4)) brightness(1.1);
            transform: scale(1.05);
        }
        
        /* üìù INFO EN DOS L√çNEAS */
        .fish-info-stacked {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            text-align: center;
        }
        
        .fish-info-stacked #fishAge {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 2px;
        }
        
        .fish-info-stacked #fishName {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* üí∞ CONTADORES VERTICALES */
        .header-currency-vertical {
            display: flex;
            align-items: center;
        }
        
        .currency-stack {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .currency-row {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .currency-row .currency-icon {
            font-size: 12px;
        }
        
        .currency-row span {
            color: white;
            font-weight: bold;
            font-size: 11px;
        }
        
        /* üéØ ICONOS DE NECESIDADES FLOTANTES (SOLO VISUALES) */
        .need-bubble-game {
            position: absolute;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* NO clickeables */
            animation: needPulse 2s infinite ease-in-out;
            z-index: 90;
            opacity: 0.4; /* M√ÅS TRANSPARENTE Y SUTIL */
        }
        
        .need-icon {
            width: 32px;
            height: 32px;
            transition: all 0.3s ease;
        }
        
        /* üé≠ TRANSICIONES SUAVES PARA MOVIMIENTO DE ICONOS */
        .need-bubble-game {
            transition: opacity 1.8s ease, transform 1.8s ease;
        }
        
        /* üçΩÔ∏è ICONO DE COMIDA CON EFECTO ROJO */
        .need-bubble-game.hunger .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 50, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 50, 50, 0.6))
                hue-rotate(-15deg) 
                saturate(1.5) 
                brightness(1.2);
        }
        
        /* üßΩ ICONO DE LIMPIEZA CON EFECTO AZUL */
        .need-bubble-game.dirty .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 150, 255, 0.8))
                drop-shadow(0 0 12px rgba(50, 150, 255, 0.6))
                hue-rotate(20deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üíä ICONO DE MEDICINA CON EFECTO VERDE */
        .need-bubble-game.medicine .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(50, 255, 100, 0.8))
                drop-shadow(0 0 12px rgba(50, 255, 100, 0.6))
                hue-rotate(30deg) 
                saturate(1.4) 
                brightness(1.1);
        }
        
        /* üéÆ ICONO DE JUEGO CON EFECTO NARANJA */
        .need-bubble-game.play .need-icon {
            filter: 
                drop-shadow(0 3px 8px rgba(255, 150, 50, 0.8))
                drop-shadow(0 0 12px rgba(255, 150, 50, 0.6))
                hue-rotate(-30deg) 
                saturate(1.3) 
                brightness(1.1);
        }
        
        @keyframes needPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* üéâ Pantalla de bienvenida - ESTILO MARINO BONITO */
        #welcomeScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
            padding: var(--mobile-padding);
        }

        /* üì± Ocultar header durante bienvenida */
        #welcomeScreen:not([style*="display: none"]) + * #gameHeader,
        #welcomeScreen[style*="flex"] ~ #gameHeader {
            display: none !important;
        }
        
        .welcome-content {
            text-align: center;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.15);
            padding: 32px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .welcome-content h1 {
            font-size: 28px;
            margin-bottom: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .welcome-content p {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 24px;
        }
        
        .welcome-features {
            margin: 24px 0;
        }
        
        .feature {
            padding: 8px 0;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .start-button {
            padding: 16px 32px;
            border: 3px solid #01579b;
            border-radius: 25px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: white;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.6);
        }
        
        .start-button:hover {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.8);
        }
        
        /* üîÑ BOT√ìN DE RESET BONITO */
        .reset-button {
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .reset-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
        }
        
        /* üé® LOGO ANIMADO */
        .logo-animated {
            margin-bottom: 20px;
        }
        
        .logo-bounce {
            width: 80px;
            height: 60px;
            animation: logoBounce 3s ease-in-out infinite;
            filter: drop-shadow(0 4px 15px rgba(79, 195, 247, 0.6));
        }
        
        @keyframes logoBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-10px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.02); }
            75% { transform: translateY(-15px) scale(1.08); }
        }
        
        /* üåä BURBUJAS ANIMADAS DE FONDO */
        .welcome-bubbles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .bubble {
            position: absolute;
            font-size: 20px;
            opacity: 0.7;
            animation: bubbleFloat 4s ease-in-out infinite;
        }
        
        .bubble-1 { left: 10%; animation-delay: 0s; }
        .bubble-2 { left: 20%; animation-delay: 1s; }
        .bubble-3 { left: 80%; animation-delay: 2s; }
        .bubble-4 { left: 90%; animation-delay: 0.5s; }
        .bubble-5 { left: 60%; animation-delay: 1.5s; }
        
        @keyframes bubbleFloat {
            0% { transform: translateY(100vh) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-20px) scale(1.2); opacity: 0; }
        }
        
        /* üéÆ GRID DE JUEGOS COMPACTO MARINO */
        .games-grid-simple {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .game-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(240,248,255,0.9) 100%);
            border: 2px solid rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #0066cc;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,150,255,0.2);
            backdrop-filter: blur(15px);
        }
        
        .game-card.locked {
            background: linear-gradient(135deg, rgba(200,200,200,0.6) 0%, rgba(180,180,180,0.5) 100%);
            border-color: rgba(150,150,150,0.6);
            color: #999;
            opacity: 0.8;
        }
        
        .game-card:hover:not(.locked) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(0,150,255,0.25);
            border-color: rgba(0,200,255,0.9);
            background: linear-gradient(135deg, rgba(255,255,255,0.95) 0%, rgba(230,248,255,0.9) 100%);
        }
        
        .game-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .game-name {
            font-weight: bold;
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1.1;
        }
        
        .game-requirement {
            font-size: 11px;
            opacity: 0.8;
        }
        
        /* üéì Pantalla de tutorial - ESTILO MARINO BONITO */
        #tutorialScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d47a1, #1565c0, #1976d2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 998;
            padding: var(--mobile-padding);
        }
        
        .tutorial-content {
            text-align: center;
            max-width: 350px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            padding: 24px;
            border-radius: 16px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(13, 71, 161, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        .tutorial-content h2 {
            margin-bottom: 16px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .tutorial-hint {
            background: #f0f8ff;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-size: 14px;
        }
        
        /* Eliminado - Ya no hay bot√≥n saltar */
        
        /* üéÆ Responsive ajustes */
        @media (max-width: 480px) {
            #turboBadge {
                font-size: 12px;
                padding: 4px 8px;
            }
        }
    </style>
</head>
<body>
    <!-- üèÜ CABECERA CON LOGO -->
    <div id="gameHeader">
        <!-- üé® LOGO DE LA WEB -->
        <div class="logo-container">
            <img src="./images/ui/logo.png" alt="Mi Pececito" class="game-logo">
        </div>
        
        <!-- üìù INFO EN DOS L√çNEAS -->
        <div class="fish-info-stacked">
            <div id="fishAge">Huevo</div>
            <div id="fishName">Mi Pececito</div>
        </div>
        
        <!-- üí∞ CONTADORES VERTICALES -->
        <div class="header-currency-vertical">
            <div class="currency-stack">
                <div class="currency-row">
                    <span class="currency-icon">ü´ß</span>
                    <span id="bubblesCount">0</span>
                </div>
                <div class="currency-row">
                    <span class="currency-icon">‚≠ê</span>
                    <span id="starsCount">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- üìä BARRA DE NECESIDADES (SIEMPRE VISIBLE) -->
    <div id="needsHeaderBar" class="needs-header-bar">
        <div class="need-compact" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <span class="need-emoji">üçé</span>
            <div class="need-bar-mini">
                <div class="need-fill-mini hunger" id="hungerBarHeader" style="width: 80%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Suciedad: M√ÅS VERDE = M√ÅS SUCIO">
            <span class="need-emoji">üßπ</span>
            <div class="need-bar-mini">
                <div class="need-fill-mini dirt" id="dirtBarHeader" style="width: 65%"></div>
            </div>
        </div>
        
        <div class="need-compact" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <span class="need-emoji">üéâ</span>
            <div class="need-bar-mini">
                <div class="need-fill-mini fun" id="funBarHeader" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üéÆ BARRA DE MEN√ö LIMPIA SIN TEXTO -->
    <div class="action-bar">
        <button class="menu-btn disabled" id="feedBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_hunger.png" alt="Comida" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn disabled" id="cleanBtn">
            <div class="btn-icon">
                <img src="./images/ui/badge_dirty.png" alt="Limpiar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="playButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_play.png" alt="Jugar" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="inventoryButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_inventario.png" alt="Inventario" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="albumButton">
            <div class="btn-icon">
                <img src="./images/ui/badge_fotos.png" alt="√Ålbum" class="menu-icon">
            </div>
        </button>
        <button class="menu-btn" id="resetButton" title="Cuidar otro pececito">
            <div class="btn-icon">
                <img src="./images/ui/badge_caravera.png" alt="Reset" class="menu-icon">
            </div>
        </button>
    </div>

    <!-- üéÆ Canvas principal del juego -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- üìä BARRAS DE NECESIDADES FLOTANTES -->
    <div class="needs-overlay">
        <div class="need-mini" title="Hambre: M√ÅS ROJO = M√ÅS HAMBRE">
            <span>üçé</span>
            <div class="mini-bar">
                <div class="mini-fill hunger" id="hungerBar" style="width: 80%"></div>
            </div>
        </div>
        <div class="need-mini" title="Suciedad: M√ÅS VERDE = M√ÅS SUCIO">
            <span>üßπ</span>
            <div class="mini-bar">
                <div class="mini-fill dirt" id="dirtBar" style="width: 65%"></div>
            </div>
        </div>
        <div class="need-mini" title="Diversi√≥n: M√ÅS AZUL = M√ÅS FELIZ">
            <span>üéâ</span>
            <div class="mini-bar">
                <div class="mini-fill fun" id="funBar" style="width: 70%"></div>
            </div>
        </div>
    </div>
    
    <!-- üê† CONTENEDOR LOTTIE PARA EL PEZ -->
    <div id="lottieContainer" style="
        position: absolute;
        width: 60px;
        height: 60px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        pointer-events: none;
        display: none;
        /* filter: brightness(1.3) contrast(1.1) saturate(1.2); */ /* DESHABILITADO - conflicto con JS din√°mico */
    "></div>
    
    <!-- üéØ UI Overlay -->
    <div class="ui-overlay">
        <!-- üí® Badge de turbo -->
        <div id="turboBadge">TURBO üí®</div>
        
        
        <!-- üéØ ICONOS DE NECESIDADES (SOLO VISUALES - NO CLICKEABLES) -->
        <!-- ICONOS FLOTANTES ELIMINADOS - ERAN MOLESTOS -->
    </div>
    
    <!-- üì± Pantalla de carga -->
    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Cargando Mi Pececito...</div>
    </div>
    
    <!-- üéâ Pantalla de bienvenida (primera vez) -->
    <div id="welcomeScreen" style="display: none;">
        <div class="welcome-content">
            <!-- üé® LOGO ANIMADO -->
            <div class="logo-animated">
                <img src="./images/ui/logo.png" alt="Mi Pececito" class="logo-bounce">
            </div>
            
            <h1>¬°Bienvenido a<br>Mi Pececito!</h1>
            <p>Tu aventura de mascota virtual comienza aqu√≠</p>
            
            <!-- üåä BURBUJAS ANIMADAS DE FONDO -->
            <div class="welcome-bubbles">
                <div class="bubble bubble-1">ü´ß</div>
                <div class="bubble bubble-2">ü´ß</div>
                <div class="bubble bubble-3">ü´ß</div>
                <div class="bubble bubble-4">ü´ß</div>
                <div class="bubble bubble-5">ü´ß</div>
            </div>
            
            <button id="startGameBtn" class="start-button">¬°Empezar Aventura!</button>
            
            <!-- Bot√≥n de reset eliminado - Solo aparece en men√∫ si ya tienes pez -->
        </div>
    </div>
    
    <!-- üéì Pantalla de tutorial -->
    <div id="tutorialScreen" style="display: none;">
        <div class="tutorial-content">
            <h2>ü•ö Tu Primer Huevo</h2>
            <p>Toca la pantalla para colocar tu huevo en el acuario</p>
            <div class="tutorial-hint">üí° El huevo tardar√° 24 horas en eclosionar</div>
        </div>
    </div>

    <!-- üéí MODAL DE INVENTARIO SIMPLE -->
    <div id="inventoryModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üéí Inventario</h2>
                <button id="closeInventory" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="inventory-grid-simple">
                <!-- Fondos disponibles -->
                <div class="inventory-item-square available" data-item="bg-default">
                    <div class="inventory-square-icon">üåä</div>
                    <div class="inventory-square-name">Oc√©ano</div>
            </div>
            
                <div class="inventory-item-square locked" data-item="bg-coral">
                    <div class="inventory-square-icon">ü™∏</div>
                    <div class="inventory-square-name">Coral</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">5‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="bg-deep">
                    <div class="inventory-square-icon">üåå</div>
                    <div class="inventory-square-name">Abismo</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">15‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="bg-tropical">
                    <div class="inventory-square-icon">üèùÔ∏è</div>
                    <div class="inventory-square-name">Tropical</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">25‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="food-special">
                    <div class="inventory-square-icon">üçé</div>
                    <div class="inventory-square-name">Comida</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">30‚≠ê</div>
                    </div>
                </div>
                
                <div class="inventory-item-square locked" data-item="decoration">
                    <div class="inventory-square-icon">üè∫</div>
                    <div class="inventory-square-name">Deco</div>
                    <div class="inventory-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">40‚≠ê</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- üéÆ MODAL DE JUEGOS SIMPLE -->
    <div id="gamesModal" class="mobile-modal-overlay" style="display: none;">
        <div class="mobile-modal-content">
            <div class="mobile-modal-header">
                <h2>üéÆ Juegos</h2>
                <button id="closeGames" class="mobile-close-btn">√ó</button>
            </div>
            
            <div class="games-grid-3x3">
                <!-- Fila 1 -->
                <div class="game-card-square available" data-game="bubbles">
                    <div class="game-square-icon">ü´ß</div>
                    <div class="game-square-name">Burbujas</div>
            </div>
            
                <div class="game-card-square available" data-game="memory">
                    <div class="game-square-icon">üß†</div>
                    <div class="game-square-name">Memoria</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">10‚≠ê</div>
                    </div>
                        </div>
                        
                <div class="game-card-square available" data-game="snake">
                    <div class="game-square-icon">üêç</div>
                    <div class="game-square-name">Serpiente</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">25‚≠ê</div>
                        </div>
                </div>
                
                <!-- Fila 2 -->
                <div class="game-card-square locked" data-game="puzzle">
                    <div class="game-square-icon">üß©</div>
                    <div class="game-square-name">Puzzle</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">50‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="race">
                    <div class="game-square-icon">üèÉ</div>
                    <div class="game-square-name">Carrera</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">75‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="target">
                    <div class="game-square-icon">üéØ</div>
                    <div class="game-square-name">Punter√≠a</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">100‚≠ê</div>
                        </div>
                    </div>
                
                <!-- Fila 3 -->
                <div class="game-card-square locked" data-game="adventure">
                    <div class="game-square-icon">üó∫Ô∏è</div>
                    <div class="game-square-name">Aventura</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">150‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="tower">
                    <div class="game-square-icon">üèóÔ∏è</div>
                    <div class="game-square-name">Torre</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">200‚≠ê</div>
                    </div>
                </div>
                
                <div class="game-card-square locked" data-game="boss">
                    <div class="game-square-icon">üëæ</div>
                    <div class="game-square-name">Jefe Final</div>
                    <div class="game-lock-overlay">
                        <div class="lock-icon-small">üîí</div>
                        <div class="lock-stars">300‚≠ê</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- üì∏ MODAL DE √ÅLBUM -->
    <div id="albumModal" style="display: none;">
        <div class="modal-content album-modal">
            <div class="modal-header">
                <h2>üì∏ √Ålbum de Mi Pececito</h2>
                <button id="closeAlbum" class="close-btn">‚ùå</button>
            </div>
            
            <div class="album-content">
                <div class="album-stats">
                    <div class="stat-item">üìÖ D√≠as juntos: <span id="albumDays">0</span></div>
                    <div class="stat-item">üì∏ Recuerdos: <span id="albumEvents">0</span></div>
                    <div class="stat-item">üéâ Hitos: <span id="albumMilestones">0</span></div>
                </div>
                
                <div class="album-timeline" id="albumTimeline">
                    <!-- Se llenar√° din√°micamente -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- üö® Pantalla de error -->
    <div id="errorScreen">
        <div class="error-icon">üò¢</div>
        <div class="error-title">¬°Oops! Algo sali√≥ mal</div>
        <div class="error-message">No se pudo cargar el juego. Verifica tu conexi√≥n.</div>
        <button class="retry-button" onclick="location.reload()">Reintentar</button>
    </div>
    
    <!-- üîß Barra de Debug (solo desarrollo) -->
    <div id="debugBar">
        <div id="debugInfo">
            --fps
        </div>
        <button class="debug-btn danger" id="debugResetBtn" title="Reset juego">üîÑ</button>
        <button class="debug-btn primary" id="forceHatchBtn" title="Forzar eclosi√≥n">üê£</button>
        <button class="debug-btn warning" id="timeAdvanceBtn" title="Avanzar tiempo">‚è∞</button>
        <button class="debug-btn success" id="maxFoodBtn" title="M√°xima comida">üçé</button>
        <button class="debug-btn info" id="maxCleanBtn" title="M√°xima limpieza">üßπ</button>
        <button class="debug-btn danger" id="minFunBtn" title="M√≠nima diversi√≥n">üò¢</button>
        <button class="debug-btn purple" id="simulatePlayBtn" title="Simular juego">üéÆ</button>
        <button class="debug-btn" id="addBubblesBtn" title="A√±adir burbujas">ü´ß</button>
        <button class="debug-btn" id="addStarsBtn" title="A√±adir estrellas">‚≠ê</button>
    </div>
    
    <!-- üé® Librer√≠a Lottie -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- üöÄ Script principal -->
    <script>
        // VERSI√ìN CON LOTTIE REAL
        // import { createGame } from './src/core/Game.js';
        
        // üéÆ Variables globales
        let game = null;
        
        // üöÄ Inicializar juego
        async function initializeGame() {
            const loadingScreen = document.getElementById('loadingScreen');
            const welcomeScreen = document.getElementById('welcomeScreen');
            const errorScreen = document.getElementById('errorScreen');
            
            try {
                console.log('üéÆ Iniciando Mi Pececito...');
                console.log('üîß Creando CompleteGame...');
                
                // Crear juego completo
                game = new CompleteGame();
                console.log('‚úÖ CompleteGame creado correctamente');
                
                // üìä FORZAR ACTUALIZACI√ìN DE BARRAS DE NECESIDADES
                setTimeout(() => {
                    if (game && game.updateNeedBars) {
                        game.updateNeedBars();
                        console.log('üìä Barras de necesidades actualizadas');
                    }
                }, 500);
                
                // Configurar eventos globales
                setupGlobalEvents();
                
                // Verificar si es primera vez (sin huevo colocado)
                const savedData = localStorage.getItem('miPececito_gameState');
                const isFirstTime = !savedData || !localStorage.getItem('miPececito_hasPlayed');
                console.log('üîç Primera vez:', isFirstTime);
                
                // IR DIRECTO A BIENVENIDA (sin pantalla de carga)
                loadingScreen.style.display = 'none';
                
                // L√ìGICA CORRECTA: Solo bienvenida si NO hay pez
                if (isFirstTime) {
                    // Primera vez: mostrar bienvenida
                    welcomeScreen.style.display = 'flex';
                    setupWelcomeFlow();
                } else {
                    // Ya tiene pez: mostrar pantalla de carga personalizada
                    this.showLoadingWithFishName();
                    // A√±adir bot√≥n reset al men√∫
                    this.addResetButtonToMenu();
                }
                
                console.log('‚úÖ ¬°Juego listo!', isFirstTime ? '(Primera vez)' : '(Jugador veterano)');
                
            } catch (error) {
                console.error('‚ùå Error inicializando juego:', error);
                
                // Mostrar pantalla de error
                loadingScreen.style.display = 'none';
                errorScreen.style.display = 'flex';
            }
        }
        
        // üéâ Configurar flujo de bienvenida
        function setupWelcomeFlow() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const tutorialScreen = document.getElementById('tutorialScreen');
            const startGameBtn = document.getElementById('startGameBtn');
            
            // Bot√≥n "Empezar Aventura"
            startGameBtn.addEventListener('click', () => {
                console.log('üöÄ Empezar aventura clickeado');
                welcomeScreen.style.display = 'none';
                
                // Marcar como jugado
                localStorage.setItem('miPececito_hasPlayed', 'true');
                
                // Mostrar modal de tutorial bonito
                if (game) {
                    game.showTutorialModal();
                } else {
                    // Fallback si game no est√° listo
                    setTimeout(() => {
                        if (game) game.showTutorialModal();
                    }, 500);
                }
            });
            
            // Bot√≥n "Cuidar otro pececito" ELIMINADO - Solo aparece en men√∫ din√°micamente
            /*
            const resetGameBtn = document.getElementById('resetGameBtn');
            if (false) { // DESHABILITADO
                resetGameBtn.addEventListener('click', () => {
                    if (game) {
                        game.showCustomModal({
                            title: 'üåä Despedida de tu Pececito',
                            message: `üê†üí≠ "¬øDe verdad me vas a dejar libre?"\n\nüè† Volver√© al oc√©ano y ser√© feliz\nüíï Siempre recordar√© nuestros momentos\nüéÆ Podr√°s cuidar a un nuevo compa√±ero\n\n‚ö†Ô∏è Se perder√° todo el progreso actual`,
                            confirmText: 'üåä ¬°S√© libre y feliz!',
                            cancelText: 'üíï ¬°No, te quiero!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            },
                            onCancel: () => {
                                game.showCustomModal({
                                    title: 'üíï ¬°Qu√© alegr√≠a!',
                                    message: 'üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos jugando juntos! üéÆ',
                                    confirmText: 'ü•∞ ¬°Siempre!',
                                    onConfirm: () => {}
                                });
                            }
                        });
                    }
                });
            }
            */
        }
        
        // üéì Configurar handler del tutorial
        function setupTutorialHandler() {
            const tutorialScreen = document.getElementById('tutorialScreen');
            
            // Tutorial: Toque ANYWHERE para colocar huevo
            const tutorialHandler = (e) => {
                console.log('üëÜ Toque detectado en tutorial');
                
                // Cerrar tutorial inmediatamente
                tutorialScreen.style.display = 'none';
                
                // Colocar huevo en el centro (o donde toc√≥ si es en canvas)
                let x = window.innerWidth / 2;
                let y = window.innerHeight / 2;
                
                // Si toc√≥ en el canvas, usar esa posici√≥n
                if (e.target.id === 'gameCanvas') {
                    const rect = e.target.getBoundingClientRect();
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                if (game) {
                    game.placeFirstEgg(x, y);
                }
                
                // Remover listener del tutorial
                document.removeEventListener('click', tutorialHandler);
                
                console.log('ü•ö Primer huevo colocado - Tutorial cerrado');
            };
            
            // Escuchar toques en TODA la pantalla
            document.addEventListener('click', tutorialHandler);
        }
        
        // ‚öôÔ∏è Configurar eventos globales
        function setupGlobalEvents() {
            // Badge de turbo
            const turboBadge = document.getElementById('turboBadge');
            
            // Escuchar eventos del juego
            document.addEventListener('turboStart', () => {
                turboBadge.classList.add('active');
            });
            
            document.addEventListener('turboEnd', () => {
                turboBadge.classList.remove('active');
            });
            
            // Prevenir zoom en m√≥viles
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            
            // Debug info (solo en desarrollo)
            if (window.location.hostname === 'localhost') {
                setupDebugInfo();
            }
            
        // Event listeners de la cabecera
        setupHeaderEvents();
        }
        
        // üèÜ Configurar eventos de cabecera
        function setupHeaderEvents() {
            console.log('üîß Configurando eventos de cabecera...');
            
            // Verificar que el bot√≥n existe
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            
            console.log('üéÆ Bot√≥n de jugar encontrado:', !!playBtn);
            console.log('üéÆ Modal de juegos encontrada:', !!gamesModal);
            
            if (!playBtn) {
                console.error('‚ùå Bot√≥n playButton no encontrado!');
                return;
            }
            
            if (!gamesModal) {
                console.error('‚ùå Modal gamesModal no encontrada!');
                return;
            }
            
            // Bot√≥n de jugar
            playBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('üéÆ ¬°CLICK EN BOT√ìN JUGAR DETECTADO!');
                
                // Abrir modal directamente
                console.log('üéÆ Abriendo modal de juegos...');
                gamesModal.style.display = 'flex';
                
                // Forzar la animaci√≥n
                requestAnimationFrame(() => {
                    gamesModal.style.opacity = '1';
                });
                
                console.log('üéÆ Modal abierta, display:', gamesModal.style.display);
            });
            
            // Bot√≥n de inventario
            document.getElementById('inventoryButton').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.display = 'flex';
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de items
                if (window.game) {
                    window.game.updateInventoryAvailability?.();
                }
            });
            
            // Cerrar inventario con animaci√≥n
            document.getElementById('closeInventory').addEventListener('click', () => {
                const modal = document.getElementById('inventoryModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Cerrar juegos con animaci√≥n
            document.getElementById('closeGames').addEventListener('click', () => {
                const modal = document.getElementById('gamesModal');
                modal.style.opacity = '0';
                setTimeout(() => modal.style.display = 'none', 300);
            });
            
            // Event listeners para las tarjetas de juegos cuadradas
            document.querySelectorAll('.game-card-square').forEach(card => {
                card.addEventListener('click', () => {
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('gamesModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            window.game.startGame(gameId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showGameLocked(starsNeeded);
                    }
                });
            });
            
            // Event listeners para las tarjetas de inventario cuadradas
            document.querySelectorAll('.inventory-item-square').forEach(card => {
                card.addEventListener('click', () => {
                    const itemId = card.dataset.item;
                    const isLocked = card.classList.contains('locked');
                    
                    if (!isLocked && window.game) {
                        console.log(`üéí Usando item: ${itemId}`);
                        // Cerrar modal primero
                        const modal = document.getElementById('inventoryModal');
                        modal.style.opacity = '0';
                        setTimeout(() => {
                            modal.style.display = 'none';
                            // Aqu√≠ puedes a√±adir la l√≥gica para usar el item
                            window.game.useInventoryItem?.(itemId);
                        }, 300);
                    } else if (isLocked) {
                        console.log(`üîí Item bloqueado: ${itemId}`);
                        // Mostrar mensaje de item bloqueado
                        const starsNeeded = card.querySelector('.lock-stars')?.textContent || '';
                        window.game?.showItemLocked?.(starsNeeded);
                    }
                });
            });
            
            // Bot√≥n de √°lbum
            document.getElementById('albumButton').addEventListener('click', () => {
                if (game) {
                    game.showAlbum();
                }
            });

            // Bot√≥n de reset (calavera)
            document.getElementById('resetButton').addEventListener('click', () => {
                if (game) {
                    game.showResetModal();
                }
            });
            
            // üçé BOT√ìN DE ALIMENTACI√ìN (UNA BOLITA COMO EN ORIGINAL)
            document.getElementById('feedBtn').addEventListener('click', () => {
                if (game && game.fish && !game.fish.isDepressed) {
                    game.dropFood(); // UNA SOLA BOLITA
                    console.log('üçé Una bolita peque√±a soltada');
                }
            });
            
            // üßπ BOT√ìN DE LIMPIEZA
            document.getElementById('cleanBtn').addEventListener('click', () => {
                if (game && game.fish && !game.fish.isDepressed) {
                    game.startCleaning();
                    console.log('üßπ Limpiando la pecera...');
                }
            });
            
            // üíä BOT√ìN DE MEDICINA
            // üíä BOT√ìN DE MEDICINA - ELIMINADO (YA NO SE USA)
            
            // Bot√≥n de reset se a√±ade din√°micamente
            
            // Cerrar √°lbum
            document.getElementById('closeAlbum').addEventListener('click', () => {
                document.getElementById('albumModal').style.display = 'none';
            });
            
            // Tabs del inventario y juegos (sistema unificado)
            document.querySelectorAll('.game-tab-btn, .tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    const modalContainer = btn.closest('.game-modal-content') || btn.closest('.modal-content');
                    
                    if (modalContainer) {
                        // Cambiar tab activo en el modal espec√≠fico
                        modalContainer.querySelectorAll('.game-tab-btn, .tab-btn').forEach(b => b.classList.remove('active'));
                        modalContainer.querySelectorAll('.game-tab-content, .tab-content').forEach(c => c.classList.remove('active'));
                    
                    btn.classList.add('active');
                        const targetTab = document.getElementById(tab + '-tab');
                        if (targetTab) {
                            targetTab.classList.add('active');
                        }
                    }
                });
            });
            
            // Botones de jugar en las modales mejoradas
            document.querySelectorAll('.game-play-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const gameId = btn.dataset.game;
                    if (gameId && window.game) {
                        console.log(`üéÆ Iniciando juego: ${gameId}`);
                        window.game.startGame(gameId);
                    }
                });
            });
        }
        
        // üîß Configurar barra de debug
        function setupDebugInfo() {
            const debugBar = document.getElementById('debugBar');
            const debugInfo = document.getElementById('debugInfo');
            debugBar.style.display = 'flex';
            
            // Actualizar info cada segundo
            setInterval(() => {
                if (game) {
                    const info = game.getGameInfo();
                    const elapsed = info.eggTime || 0;
                    const hours = Math.floor(elapsed / (1000 * 60 * 60));
                    const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
                    
                    // Debug expandido con necesidades y edad
                    const hungerHours = Math.floor((Date.now() - game.gameState.lastFeed) / (1000 * 60 * 60));
                    const playHours = Math.floor((Date.now() - game.gameState.lastPlay) / (1000 * 60 * 60));
                    const cleanHours = Math.floor((Date.now() - game.gameState.lastClean) / (1000 * 60 * 60));
                    
                    debugInfo.innerHTML = `${Math.round(1 / (game.deltaTime || 0.016))}fps`;
                }
            }, 1000);
            
            // BOTONES DE DEBUG
            document.getElementById('debugResetBtn').addEventListener('click', () => {
                if (confirm('üîÑ ¬øResetear todo el juego?')) {
                    console.log('üîÑ Reseteando juego completo...');
                    
                    // Limpiar TODO el localStorage AGRESIVAMENTE
                    console.log('üßπ LIMPIEZA TOTAL del localStorage...');
                    localStorage.removeItem('miPececito_gameState');
                    localStorage.removeItem('miPececito_gameData');
                    localStorage.removeItem('miPececito_hasPlayed');
                    localStorage.removeItem('bubbleGame_personalRecord');
                    localStorage.removeItem('bubbleGame_globalRecord');
                    localStorage.clear(); // Por si hay m√°s
                    console.log('‚úÖ localStorage completamente limpio');
                    
                    // Recargar p√°gina para volver al inicio
                    setTimeout(() => {
                        location.reload();
                    }, 100);
                }
            });
            
            document.getElementById('forceHatchBtn').addEventListener('click', () => {
                if (game) {
                    game.setEggTimeToFinalSeconds(); // Ir a los √∫ltimos 5 segundos
                    console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
                }
            });
            
            
            document.getElementById('addBubblesBtn').addEventListener('click', () => {
                if (game) {
                    game.addCurrency('bubbles', 100);
                    console.log('üí∞ +100 burbujas');
                }
            });
            
            document.getElementById('addStarsBtn').addEventListener('click', () => {
                if (game) {
                    game.addCurrency('stars', 10);
                    console.log('‚≠ê +10 estrellas');
                }
            });
            
            document.getElementById('timeAdvanceBtn').addEventListener('click', () => {
                if (game) {
                    game.advanceGameTime(1); // Avanzar 1 hora
                    console.log('‚è∞ Tiempo del juego avanzado +1 hora');
                }
            });
            
            // üçé M√ÅXIMA COMIDA
            document.getElementById('maxFoodBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.hunger = 0; // Sin hambre
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üçé Pez alimentado al M√ÅXIMO (hambre = 0)');
                }
            });
            
            // üßπ M√ÅXIMA LIMPIEZA
            document.getElementById('maxCleanBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.dirt = 0; // S√∫per limpio
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üßπ Pecera S√öPER LIMPIA (suciedad = 0)');
                }
            });
            
            // üò¢ M√çNIMA DIVERSI√ìN
            document.getElementById('minFunBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.fun = 0; // S√∫per aburrido
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    console.log('üò¢ Pez S√öPER ABURRIDO (diversi√≥n = 0)');
                }
            });
            
            // üéÆ SIMULAR JUEGO
            document.getElementById('simulatePlayBtn').addEventListener('click', () => {
                if (game && game.gameState.needs) {
                    game.gameState.needs.fun = Math.min(100, game.gameState.needs.fun + 30); // +30 diversi√≥n
                    game.updateCrisisFlags();
                    game.updateNeedBars();
                    // A√±adir recompensas como si hubiera jugado
                    game.addCurrency('bubbles', 5);
                    game.addCurrency('stars', 1);
                    console.log('üéÆ SIMULADO: Pez ha jugado (+30 diversi√≥n, +5 burbujas, +1 estrella)');
                }
            });
        }
        
        // üéØ Manejar errores globales
        window.addEventListener('error', (e) => {
            console.error('‚ùå Error global:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('‚ùå Promesa rechazada:', e.reason);
        });
        
        // üöÄ Iniciar cuando la p√°gina est√© lista
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        // üéÆ SISTEMA COMPLETO DE JUEGO
        class CompleteGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Estado del juego
                this.gameState = {
                    stage: 'waiting', // NUEVO: Esperando a colocar huevo
                    eggStartTime: null, // NO hay tiempo hasta colocar huevo
                    bubbles: 10,  // Empezar con pocas burbujas
                    stars: 0,     // Sin estrellas al inicio
                    currentBackground: 'basic',
                    bubblesCreated: false,
                    
                    // üìä SISTEMA DE NECESIDADES REALISTA (0-100)
                    needs: {
                        hunger: 80,  // NACE CON HAMBRE (crisis)
                        dirt: 65,    // 0=limpio, 100=s√∫per sucio  
                        fun: 70      // 0=deprimido, 100=s√∫per feliz
                    },
                    
                    // üö® FLAGS DE CRISIS (75+ es crisis)
                    crisis: {
                        hunger: false,
                        dirt: false, 
                        bored: false
                    },
                    
                    // Sistema de edad
                    birthDate: null,
                    ageInDays: 0,
                    // Nombre del pez
                    fishName: null,
                    hasAskedForName: false,
                    // Sistema de √°lbum/diario
                    album: [],
                    lastEventTime: Date.now()
                };
                
                // Sistema de huevo
                this.egg = {
                    x: 0, y: 0,
                    floatTime: 0,
                    bobSpeed: 2,
                    bobAmount: 8
                };
                
                // Im√°genes del huevo
                this.eggImages = {};
                this.bgImage = null;
                this.loadAssets();
                
                // Efectos
                this.bgBubbles = [];
                this.explosionBubbles = [];
                this.lightRays = [];
                this.explosionHappened = false;
                
                // üçé ARRAYS DEL SISTEMA REALISTA
                this.food = [];           // Comida que cae
                this.cleanBubbles = [];   // Burbujas de limpieza  
                this.tinyBubbles = [];    // Burbujas de respiraci√≥n
                this.flyers = [];         // Corazones voladores
                this.ripples = [];        // Ondas de click
                this.labels = [];         // Textos flotantes
                
                // üßπ ESTADO DE LIMPIEZA
                this.cleaningActive = false;
                this.cleanEmitT = 0;
                this.cleanDur = 2.6;
                this.dirtStart = 0;
                
                // ‚è∞ TIEMPO DEL JUEGO (para animaciones)
                this.gameTime = 0;
                
                // Burbujas de necesidades
                this.needBubbles = [];
                
                // Pez
                this.fish = null;
                this.lottieAnimation = null;
                
                this.setupBubbles();
                
                // NUNCA cargar datos en primera vez
                const isFirstTime = !localStorage.getItem('miPececito_hasPlayed');
                if (isFirstTime) {
                    console.log('üéâ Primera vez - Empezar completamente limpio');
                    // NO cargar nada, mantener estado inicial 'waiting'
                } else {
                    // Solo cargar si es veterano
                    if (!this.loadGame()) {
                        console.log('üÜï Veterano sin datos - empezar nuevo');
                    }
                }
                
                // Cargar fondos disponibles
                this.availableBackgrounds = [];
                this.loadAvailableBackgrounds();
                
                this.startLoop();
                this.startAutoSave();
                this.updateUI();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    
                    // CANVAS SIEMPRE DESDE EL HEADER (SIN ESPACIO AZUL)
                    this.canvas.height = window.innerHeight - 130; // 70px header + 60px botones
                    this.canvas.style.top = '70px'; // SIEMPRE PEGADO AL HEADER
                    
                    this.canvas.style.position = 'fixed';
                    this.canvas.style.left = '0';
                    this.canvas.style.right = '0';
                    this.canvas.style.bottom = '60px'; // Espacio para botones compactos
                };
                window.addEventListener('resize', resize);
                resize();
                
                // A√ëADIR EVENT LISTENER PARA CLICK EN CANVAS
                this.canvas.addEventListener('click', (event) => {
                    this.handleCanvasClick(event);
                });
                
                console.log('üëÜ Click en canvas habilitado - El pez vendr√° a tu dedo');
            }
            
            async loadAssets() {
                console.log('üìÅ Cargando assets...');
                
                // Cargar im√°genes del huevo
                const eggStages = ['00', '01', '02', '03', '04'];
                for (const stage of eggStages) {
                    try {
                        const img = new Image();
                        img.src = `./images/fish/egg_${stage}_clean.png`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                        });
                        this.eggImages[stage] = img;
                        console.log(`‚úÖ Cargado: egg_${stage}_clean.png`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar egg_${stage}_clean.png`);
                    }
                }
                
                // Cargar fondo
                try {
                    this.bgImage = new Image();
                    this.bgImage.src = './images/backgrounds/bg_basic.png';
                    await new Promise((resolve, reject) => {
                        this.bgImage.onload = resolve;
                        this.bgImage.onerror = reject;
                    });
                    console.log('‚úÖ Fondo cargado: bg_basic.png');
                } catch (error) {
                    console.warn('‚ö†Ô∏è No se pudo cargar bg_basic.png');
                }
            }
            
            setupBubbles() {
                // Burbujas de fondo
                for (let i = 0; i < 15; i++) {
                    this.bgBubbles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        r: 1 + Math.random() * 4,
                        speed: 20 + Math.random() * 30,
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }
            
            startLoop() {
                let lastTime = 0;
                const loop = (currentTime) => {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
            
            update(deltaTime) {
                this.gameTime += deltaTime; // Actualizar tiempo del juego
                
                // Posici√≥n del huevo (centro de la pantalla)
                this.egg.x = this.canvas.width / 2;
                this.egg.y = this.canvas.height * 0.6;
                this.egg.floatTime += deltaTime;
                
                // Burbujas de fondo
                for (const bubble of this.bgBubbles) {
                    bubble.y -= bubble.speed * deltaTime;
                    if (bubble.y < 0) {
                        bubble.y = this.canvas.height + 10;
                        bubble.x = Math.random() * this.canvas.width;
                    }
                }
                
                // Actualizar burbujas de explosi√≥n
                for (let i = this.explosionBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.explosionBubbles[i];
                    bubble.x += bubble.vx * deltaTime;
                    bubble.y += bubble.vy * deltaTime;
                    bubble.life -= deltaTime;
                    
                    if (bubble.life <= 0) {
                        this.explosionBubbles.splice(i, 1);
                    }
                }
                
                // Actualizar rayos de luz
                for (let i = this.lightRays.length - 1; i >= 0; i--) {
                    const ray = this.lightRays[i];
                    ray.length = Math.min(ray.length + 200 * deltaTime, ray.maxLength);
                    ray.life -= deltaTime;
                    
                    if (ray.life <= 0) {
                        this.lightRays.splice(i, 1);
                    }
                }
                
                // L√≥gica de eclosi√≥n (solo si hay huevo colocado)
                if (this.gameState.stage === 'egg' && this.gameState.eggStartTime) {
                    const elapsed = Date.now() - this.gameState.eggStartTime;
                    const total = 24 * 60 * 60 * 1000; // 24 horas
                    
                    if (elapsed >= total) {
                        this.startHatching();
                    }
                }
                
                // Movimiento del pez (todas las etapas)
                if (this.fish && (this.gameState.stage === 'baby' || this.gameState.stage === 'young' || this.gameState.stage === 'adult')) {
                    // üöÄ SISTEMA REALISTA COMPLETO
                    this.updateAutoNeeds(deltaTime);      // Necesidades autom√°ticas
                    this.updateCrisisFlags();             // Flags de crisis
                    this.updateFood(deltaTime);           // üçé COMIDA DEL DOCUMENTO
                    this.updateFishMovement(deltaTime);    // Movimiento realista
                    this.updateTinyBubbles(deltaTime);     // Burbujas de respiraci√≥n
                    this.updateFlyers(deltaTime);          // Corazones voladores
                    
                    // Actualizar UI cada pocos segundos
                    if (Math.random() < 0.01) {
                        this.updateUI();
                        this.checkForAlbumEvents(); // Verificar eventos del √°lbum
                        this.checkEvolution(); // Verificar evoluci√≥n
                    }
                }
                
                // Actualizar burbujas de necesidades (DESACTIVADO - ICONOS SOBRAN)
                // for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                //     const bubble = this.needBubbles[i];
                //     bubble.life -= deltaTime;
                //     bubble.y += Math.sin(bubble.life * 3) * 10 * deltaTime;
                //     
                //     if (bubble.life <= 0) {
                //         this.needBubbles.splice(i, 1);
                //     }
                // }
            }
            
            render() {
                // Limpiar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Fondo
                if (this.bgImage && this.bgImage.complete) {
                    this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo degradado como fallback
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#0b1b2b');
                    gradient.addColorStop(1, '#133754');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // ‚ú® EFECTOS M√ÅGICOS: MUCHAS BURBUJITAS QUE TAPAN EL HUEVO
                if (this.gameState.stage === 'egg' && this.gameState.showMagicBubbles) {
                    this.ctx.save();
                    
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const time = Date.now() * 0.001;
                    const effectTime = time - (this.gameState.magicStartTime || time);
                    
                    // FASE 1: MUCH√çSIMAS burbujitas peque√±as que TAPAN todo (primeros 2 segundos)
                    if (effectTime < 2) {
                        const density = Math.max(0, 1 - effectTime / 2); // Se reduce con el tiempo
                        const numBubbles = Math.floor(800 * density); // 800 ‚Üí 0 burbujas (EXPLOSI√ìN MASIVA)
                        
                        // CAPA 1: Burbujas grandes de fondo
                        for (let i = 0; i < Math.floor(numBubbles * 0.3); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 140;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 15 + Math.random() * 10; // Grandes (15-25px)
                            
                            this.ctx.globalAlpha = 0.3 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${180 + Math.random() * 60}, 70%, ${70 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 12;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 2: Burbujas medianas
                        for (let i = 0; i < Math.floor(numBubbles * 0.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 100;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 8 + Math.random() * 8; // Medianas (8-16px)
                            
                            this.ctx.globalAlpha = 0.5 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${190 + Math.random() * 40}, 80%, ${65 + Math.random() * 25}%)`;
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 3: Burbujitas peque√±as (las que m√°s tapan)
                        for (let i = 0; i < Math.floor(numBubbles * 0.7); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance;
                            const size = 3 + Math.random() * 6; // Peque√±itas (3-9px)
                            
                            this.ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${60 + Math.random() * 30}%)`;
                            
                            // Muchas con brillo
                            if (Math.random() > 0.5) {
                                this.ctx.shadowBlur = 4;
                                this.ctx.shadowColor = this.ctx.fillStyle;
                            } else {
                                this.ctx.shadowBlur = 0;
                            }
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 4: Micro-burbujas como las del agua (MUCH√çSIMAS)
                        for (let i = 0; i < Math.floor(numBubbles * 1.5); i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const x = centerX + Math.cos(angle) * distance + (Math.random() - 0.5) * 30;
                            const y = centerY + Math.sin(angle) * distance + (Math.random() - 0.5) * 30;
                            const size = 0.5 + Math.random() * 2; // Micro-burbujas (0.5-2.5px)
                            
                            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                            this.ctx.fillStyle = `hsl(${200 + Math.random() * 30}, 90%, ${75 + Math.random() * 20}%)`;
                            this.ctx.shadowBlur = 1;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // CAPA 5: Espuma densa (como burbujas de jab√≥n)
                        for (let i = 0; i < Math.floor(numBubbles * 2); i++) {
                            const x = centerX + (Math.random() - 0.5) * 160;
                            const y = centerY + (Math.random() - 0.5) * 160;
                            const size = 0.3 + Math.random() * 1.5; // S√∫per micro (0.3-1.8px)
                            
                            this.ctx.globalAlpha = 0.4 + Math.random() * 0.3;
                            this.ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#f0f8ff';
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    // FASE 2: Burbujas decorativas flotantes (despu√©s de 1.5s)
                    if (effectTime > 1.5) {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + time * 0.3;
                            const distance = 100 + Math.sin(time * 2 + i) * 40;
                            const x = centerX + Math.cos(angle) * distance;
                            const y = centerY + Math.sin(angle) * distance + Math.sin(time * 1.5 + i) * 25;
                            const size = 8 + Math.sin(time * 4 + i) * 4;
                            
                            this.ctx.globalAlpha = 0.5 + Math.sin(time * 3 + i) * 0.3;
                            this.ctx.fillStyle = i % 3 === 0 ? '#87ceeb' : i % 3 === 1 ? '#add8e6' : '#b0e0e6';
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = this.ctx.fillStyle;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // ü´ß BURBUJITAS SUTILES DEL AGUA (AMBIENTE)
                this.drawAmbientBubbles();
                
                // Burbujas de fondo (sistema original - DESACTIVADO)
                // this.drawBackgroundBubbles();
                
                // Haces de luz ocasionales durante el juego
                this.drawOccasionalLightRays();
                
                // Efecto de suciedad en toda la pecera
                this.drawDirtyEffect();
                
                // Huevo (solo si est√° en stage 'egg')
                if (this.gameState.stage === 'egg') {
                    this.drawEgg();
                    this.drawEggTimer(); // Timer bonito en pantalla
                } else if (this.gameState.stage === 'waiting') {
                    // ESPERANDO: No dibujar nada hasta colocar huevo
                    this.ctx.save();
                    this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.font = 'bold 20px Comic Sans MS';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('üåä Esperando tu primer huevito... ü•ö', this.canvas.width/2, this.canvas.height/2);
                    this.ctx.restore();
                }
                
                // Burbujas de explosi√≥n
                this.drawExplosionBubbles();
                
                // Pez (solo si no es Lottie)
                if (this.fish && !this.fish.isLottie) {
                    this.drawFish();
                }
                
                // Actualizar posici√≥n del Lottie
                if (this.fish && this.fish.isLottie) {
                    this.updateLottiePosition();
                }
                
                // Part√≠culas de comida
                this.drawFoodParticles();
                
                // Comida cayendo
                this.drawFallingFood();
                
                // Burbujas de limpieza
                this.drawCleaningBubbles();
                
                // Burbujas de necesidades (DESACTIVADAS)
                // this.drawNeedBubbles();
                
                // Efectos de comer (DESACTIVADOS)
                // this.drawEatingEffects();
                
                // Textos flotantes (DESACTIVADOS)
                // this.drawFloatingTexts();
                
                // Burbujas de necesidades (DESACTIVADAS)  
                // this.drawNeedBubbles();
                
                // üíñ DIBUJAR CORAZONES VOLADORES
                this.drawFlyers();
                
                // üçé DIBUJAR COMIDA DEL DOCUMENTO
                this.drawFood();
            }
            
            // üñåÔ∏è M√âTODOS DE RENDERIZADO
            
            drawBackgroundBubbles() {
                // SISTEMA COPIADO DEL TEST QUE FUNCIONA
                for (let i = this.bgBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bgBubbles[i];
                    
                    // ü´ß BURBUJAS DEL TEST (NUEVO SISTEMA)
                    if (bubble.isTestBubble) {
                        // Actualizar posici√≥n
                        bubble.x += bubble.vx;
                        bubble.y += bubble.vy;
                        bubble.life--;
                        
                        // Eliminar si se acab√≥ la vida
                        if (bubble.life <= 0) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar burbuja
                        this.ctx.save();
                        
                        if (bubble.sparkle) {
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = bubble.color;
                        }
                        
                        this.ctx.globalAlpha = bubble.alpha;
                        this.ctx.fillStyle = bubble.color;
                        this.ctx.beginPath();
                        this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                        continue;
                    }
                    
                    // üéÜ SISTEMA VIEJO (APARICI√ìN)
                    if (bubble.isAppearanceEffect) {
                        bubble.x += bubble.vx;
                        bubble.y += bubble.vy;
                        bubble.life -= 16.67; // ~60fps
                        
                        // Eliminar si se acab√≥ la vida (EXCEPTO inmortales)
                        if (bubble.life <= 0 && !bubble.immortal) {
                            this.bgBubbles.splice(i, 1);
                            continue;
                        }
                        
                        // Calcular alpha basado en vida restante
                        const maxLife = bubble.maxLife || 3000; // Fallback
                        const lifeRatio = bubble.life / maxLife;
                        bubble.opacity = (bubble.alpha || 1) * lifeRatio;
                    }
                    
                    this.ctx.save();
                    
                    // üéÜ EFECTO DE BRILLO PARA PART√çCULAS M√ÅGICAS
                    if (bubble.sparkle) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = bubble.color || '#ffd700';
                        
                        // Brillo pulsante
                        const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
                        this.ctx.globalAlpha = (bubble.alpha || bubble.opacity || 1) * pulse;
                    } else {
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = bubble.alpha || bubble.opacity || 1;
                    }
                    
                    this.ctx.fillStyle = bubble.color || '#87ceeb';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size || bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // DEBUG: Log de burbujas rojas de aparici√≥n (DESACTIVADO)
                    // if (bubble.isAppearanceEffect && bubble.color === '#ff0000') {
                    //     console.log(`üî¥ DIBUJANDO burbuja roja en (${bubble.x.toFixed(0)}, ${bubble.y.toFixed(0)}) tama√±o ${bubble.r}`);
                    // }
                    this.ctx.restore();
                }
            }
            
            drawEgg() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                const total = 24 * 60 * 60 * 1000; // 24 horas
                const progress = Math.min(elapsed / total, 1);
                
                // üéÜ ANIMACI√ìN DE APARICI√ìN GRADUAL
                if (this.egg.appearing) {
                    // Crecimiento gradual
                    if (this.egg.scale < this.egg.targetScale) {
                        this.egg.scale += 0.03; // Aparici√≥n suave
                    }
                    
                    // Fade in gradual
                    if (this.egg.alpha < this.egg.targetAlpha) {
                        this.egg.alpha += 0.02; // Aparici√≥n suave
                    }
                    
                    // Terminar animaci√≥n cuando est√© completo
                    if (this.egg.scale >= this.egg.targetScale && this.egg.alpha >= this.egg.targetAlpha) {
                        this.egg.appearing = false;
                        this.egg.scale = 1;
                        this.egg.alpha = 1;
                        console.log('‚ú® Animaci√≥n de aparici√≥n completada');
                    }
                }
                
                // Obtener imagen correcta del huevo
                const currentImage = this.getCurrentEggImage(progress);
                
                if (currentImage) {
                    // Animaci√≥n de flotaci√≥n
                    const floatOffset = Math.sin(this.egg.floatTime * this.egg.bobSpeed) * this.egg.bobAmount;
                    const drawY = this.egg.y + floatOffset;
                    
                    // TEMBLOR cuando se acerca la eclosi√≥n
                    let shakeX = 0;
                    let shakeY = 0;
                    
                    if (progress > 0.85) { // √öltimos 15% = 3.6 horas
                        const shakeIntensity = (progress - 0.85) / 0.15; // 0 a 1
                        const maxShake = 6;
                        
                        shakeX = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        shakeY = (Math.random() - 0.5) * maxShake * shakeIntensity;
                        
                        // Temblor INTENSO en los √∫ltimos segundos
                        if (progress > 0.98) { // √öltimos 2%
                            shakeX *= 2.5;
                            shakeY *= 2.5;
                        }
                    }
                    
                    // Dibujar huevo M√ÅS GRANDE Y ALTO CON ANIMACI√ìN
                    const eggWidth = 100; // M√°s ancho (vs 80)
                    const eggHeight = 120; // M√°s alto para forma de huevo
                    
                    this.ctx.save();
                    
                    // üéÜ APLICAR ANIMACI√ìN DE APARICI√ìN
                    const scale = this.egg.scale || 1;
                    const alpha = this.egg.alpha || 1;
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.translate(this.egg.x + shakeX, drawY + shakeY);
                    this.ctx.scale(scale, scale);
                    
                    this.ctx.drawImage(
                        currentImage,
                        -eggWidth/2,
                        -eggHeight/2,
                        eggWidth,
                        eggHeight
                    );
                    
                    this.ctx.restore();
                } else {
                    // Fallback: huevo dibujado M√ÅS GRANDE
                    this.ctx.fillStyle = '#8ad7ff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(this.egg.x, this.egg.y, 50, 60, 0, 0, Math.PI * 2); // M√°s grande
                    this.ctx.fill();
                }
            }
            
            getCurrentEggImage(progress) {
                if (progress < 0.2) return this.eggImages['00'];
                if (progress < 0.4) return this.eggImages['01'];
                if (progress < 0.6) return this.eggImages['02'];
                if (progress < 0.8) return this.eggImages['03'];
                return this.eggImages['04'];
            }
            
            drawEggTimer() {
                if (this.gameState.stage !== 'egg' || !this.gameState.eggStartTime) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.gameState.eggStartTime;
                const total = 24 * 60 * 60 * 1000; // 24 HORAS
                const remaining = Math.max(0, total - elapsed);
                
                // DEBUG: Verificar que el tiempo avanza
                if (Math.random() < 0.02) { // Log m√°s frecuente para debug
                    console.log(`‚è∞ Timer Debug:`);
                    console.log(`   Current: ${new Date(currentTime).toLocaleTimeString()}`);
                    console.log(`   EggStart: ${new Date(this.gameState.eggStartTime).toLocaleTimeString()}`);
                    console.log(`   Elapsed: ${(elapsed/1000/60).toFixed(1)}min`);
                    console.log(`   Remaining: ${(remaining/1000/60).toFixed(1)}min`);
                }
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                // Progreso para efectos del cron√≥metro
                const timerProgress = elapsed / total;
                
                // CRON√ìMETRO BONITO EN PANTALLA
                const centerX = this.canvas.width / 2;
                const timerY = 80; // M√°s arriba y visible
                
                this.ctx.save();
                
                // CRON√ìMETRO SUTIL SIN FONDO NEGRO
                this.ctx.textAlign = 'center';
                
                // Sombra sutil para el texto
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 8;
                this.ctx.shadowOffsetY = 2;
                
                // T√≠tulo m√°s sutil SIN EMOJI
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = 'bold 14px system-ui';
                this.ctx.fillText('Nacer√° en:', centerX, timerY - 20);
                
                // Countdown principal
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 24px system-ui';
                
                let timeText;
                if (hours > 0) {
                    timeText = `${hours}h ${minutes}m ${seconds}s`; // SIEMPRE mostrar segundos
                } else if (minutes > 0) {
                    timeText = `${minutes}m ${seconds}s`;
                } else {
                    // √öltimos segundos - MUY dram√°tico
                    this.ctx.fillStyle = remaining < 10000 ? '#ff6b6b' : '#ffeb3b';
                    timeText = `${seconds}s`;
                }
                
                this.ctx.fillText(timeText, centerX, timerY);
                
                this.ctx.restore();
            }
            
            drawLightRays() {
                for (const ray of this.lightRays) {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height * 0.6;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.opacity * (ray.life / ray.maxLife);
                    this.ctx.strokeStyle = '#ffdd44';
                    this.ctx.lineWidth = ray.width;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#ffdd44';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(ray.angle) * ray.length,
                        centerY + Math.sin(ray.angle) * ray.length
                    );
                    this.ctx.stroke();
                    this.ctx.restore();
                }
            }
            
            // ‚ú® HACES DE LUZ OCASIONALES
            drawOccasionalLightRays() {
                // Inicializar timer de rayos si no existe
                if (!this.lightRayTimer) this.lightRayTimer = 0;
                if (!this.occasionalRays) this.occasionalRays = [];
                
                this.lightRayTimer += 1/60; // Asumiendo 60fps
                
                // Crear rayos ocasionalmente (cada 20-40 segundos)
                if (this.lightRayTimer > 20 + Math.random() * 20) {
                    this.createOccasionalLightRay();
                    this.lightRayTimer = 0;
                }
                
                // Dibujar y actualizar rayos existentes
                for (let i = this.occasionalRays.length - 1; i >= 0; i--) {
                    const ray = this.occasionalRays[i];
                    
                    // Actualizar rayo
                    ray.life -= 1/60;
                    ray.alpha = Math.max(0, ray.life / ray.maxLife);
                    
                    // Eliminar si expir√≥
                    if (ray.life <= 0) {
                        this.occasionalRays.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar REFLEJO SUTIL como luz real del sol
                    this.ctx.save();
                    this.ctx.globalAlpha = ray.alpha * 0.08; // S√öPER sutil
                    this.ctx.globalCompositeOperation = 'lighter';
                    
                    const gradient = this.ctx.createLinearGradient(ray.x1, ray.y1, ray.x2, ray.y2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(0.2, 'rgba(255, 255, 240, 0.3)'); // Amarillo muy suave
                    gradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.4)'); // Azul casi transparente
                    gradient.addColorStop(0.8, 'rgba(255, 255, 240, 0.2)'); // Amarillo suave otra vez
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = ray.width * 0.8; // M√°s finos
                    this.ctx.shadowBlur = 1;
                    this.ctx.shadowColor = 'rgba(255, 255, 240, 0.2)';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(ray.x1, ray.y1);
                    this.ctx.lineTo(ray.x2, ray.y2);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
            }
            
            createOccasionalLightRay() {
                // Crear 2-4 REFLEJOS DEL SOL desde arriba
                const numRays = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numRays; i++) {
                    // Rayos vienen desde arriba con √°ngulos naturales
                    const startX = Math.random() * this.canvas.width;
                    const startY = -50; // Empiezan fuera de la pantalla arriba
                    
                    // √Ångulo hacia abajo con ligera inclinaci√≥n
                    const angle = Math.PI/2 + (Math.random() - 0.5) * 0.6; // 90¬∞ ¬± 30¬∞
                    const length = this.canvas.height + 100; // Atraviesan toda la pantalla
                    
                    const ray = {
                        x1: startX,
                        y1: startY,
                        x2: startX + Math.cos(angle) * length,
                        y2: startY + Math.sin(angle) * length,
                        width: 2 + Math.random() * 3,
                        life: 5 + Math.random() * 4, // M√°s duraderos
                        maxLife: 5 + Math.random() * 4,
                        alpha: 1
                    };
                    
                    this.occasionalRays.push(ray);
                }
                
                console.log(`‚òÄÔ∏è Reflejos del sol creados (${numRays} rayos desde arriba)`);
            }
            
            // ü¶† EFECTO DE SUCIEDAD EN TODA LA PECERA
            drawDirtyEffect() {
                if (!this.gameState.lastClean) return;
                
                const currentTime = Date.now();
                const timeSinceClean = currentTime - this.gameState.lastClean;
                const currentStage = this.gameState.stage;
                
                // Umbrales de suciedad seg√∫n la edad
                let dirtyThreshold;
                switch(currentStage) {
                    case 'baby':
                        dirtyThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        break;
                    case 'young':
                        dirtyThreshold = 2 * 24 * 60 * 60 * 1000; // 2 d√≠as
                        break;
                    case 'adult':
                        dirtyThreshold = 3 * 24 * 60 * 60 * 1000; // 3 d√≠as
                        break;
                    default:
                        dirtyThreshold = 24 * 60 * 60 * 1000;
                }
                
                if (timeSinceClean > dirtyThreshold) {
                    // Calcular nivel de suciedad (0 a 1)
                    const dirtLevel = Math.min((timeSinceClean - dirtyThreshold) / dirtyThreshold, 1);
                    
                    // Crear overlay de suciedad
                    this.ctx.save();
                    this.ctx.globalAlpha = dirtLevel * 0.3; // M√°ximo 30% opacidad
                    this.ctx.globalCompositeOperation = 'multiply';
                    
                    // Gradiente de suciedad
                    const gradient = this.ctx.createRadialGradient(
                        this.canvas.width / 2, this.canvas.height / 2, 0,
                        this.canvas.width / 2, this.canvas.height / 2, this.canvas.width
                    );
                    gradient.addColorStop(0, 'rgba(139, 115, 85, 0.2)'); // Marr√≥n claro centro
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)'); // Marr√≥n medio
                    gradient.addColorStop(1, 'rgba(62, 39, 35, 0.6)'); // Marr√≥n oscuro bordes
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Part√≠culas de suciedad flotando
                    if (!this.dirtParticles) this.dirtParticles = [];
                    
                    // Crear part√≠culas ocasionalmente
                    if (Math.random() < 0.02 * dirtLevel) {
                        this.dirtParticles.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            size: 1 + Math.random() * 3,
                            life: 5 + Math.random() * 5,
                            maxLife: 5 + Math.random() * 5,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10
                        });
                    }
                    
                    // Dibujar part√≠culas de suciedad
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = Math.min(0.9, dirtLevel * 2.0); // MUCHO M√ÅS OPACO
                    
                    for (let i = this.dirtParticles.length - 1; i >= 0; i--) {
                        const particle = this.dirtParticles[i];
                        
                        // Actualizar part√≠cula
                        particle.x += particle.vx * (1/60);
                        particle.y += particle.vy * (1/60);
                        particle.life -= 1/60;
                        
                        // Eliminar si expir√≥
                        if (particle.life <= 0) {
                            this.dirtParticles.splice(i, 1);
                            continue;
                        }
                        
                        // Dibujar part√≠cula sucia
                        const alpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha = alpha * dirtLevel * 1.5; // MUCHO M√ÅS DENSA
                        this.ctx.fillStyle = '#8b7355';
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                    
                    // OVERLAY GENERAL DE SUCIEDAD (agua SUPER turbia como algas)
                    this.ctx.globalAlpha = Math.min(0.8, dirtLevel * 1.5); // MUCHO m√°s denso
                    
                    // Gradiente marr√≥n-verde como algas
                    const dirtGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    dirtGradient.addColorStop(0, 'rgba(139, 115, 85, 0.6)'); // Marr√≥n arriba
                    dirtGradient.addColorStop(0.5, 'rgba(101, 67, 33, 0.8)'); // Marr√≥n oscuro medio
                    dirtGradient.addColorStop(1, 'rgba(46, 125, 50, 0.7)'); // Verde algas abajo
                    
                    this.ctx.fillStyle = dirtGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.globalAlpha = 1;
                    
                    // Log ocasional
                    if (Math.random() < 0.005) {
                        console.log(`ü¶† Pecera sucia - Nivel: ${(dirtLevel * 100).toFixed(0)}%`);
                    }
                } else {
                    // Limpiar part√≠culas cuando no est√° sucio
                    if (this.dirtParticles) {
                        this.dirtParticles = [];
                    }
                }
            }
            
            drawExplosionBubbles() {
                for (const bubble of this.explosionBubbles) {
                    this.ctx.save();
                    
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha;
                    
                    if (bubble.isLight) {
                        // Part√≠culas de luz
                        this.ctx.fillStyle = '#ffeb3b';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#ffeb3b';
                    } else {
                        // Burbujas normales
                        this.ctx.fillStyle = `hsl(${200 + Math.random() * 60}, 70%, 80%)`;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(bubble.x - 1, bubble.y - 1, 2, 2);
                    }
                    
                    this.ctx.restore();
                }
            }
            
            drawFish() {
                if (!this.fish) return;
                
                const fish = this.fish;
                const size = fish.size;
                const colors = this.getFishColors();
                
                this.ctx.save();
                this.ctx.translate(fish.x, fish.y);
                this.ctx.rotate(-25 * Math.PI / 180); // Inclinaci√≥n del Lottie
                
                // ü´Å APLICAR RESPIRACI√ìN
                this.ctx.scale(fish.breatheScale, fish.breatheScale);
                
                // üêü COLA PRINCIPAL (forma exacta del Lottie)
                this.ctx.save();
                this.ctx.translate(-size * 0.8, 0);
                this.ctx.rotate(fish.finRotation); // Ondulaci√≥n -36¬∞ a +4¬∞
                
                this.ctx.fillStyle = colors.tail;
                this.ctx.beginPath();
                // Forma de cola del Lottie (m√°s org√°nica)
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.3, -size * 0.4, -size * 0.6, -size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.7, 0, -size * 0.6, size * 0.2);
                this.ctx.quadraticCurveTo(-size * 0.3, size * 0.4, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üê† CUERPO PRINCIPAL (forma org√°nica del Lottie)
                this.ctx.fillStyle = colors.body;
                this.ctx.beginPath();
                // Forma de pez m√°s realista basada en el JSON
                this.ctx.moveTo(size * 0.6, 0);
                this.ctx.quadraticCurveTo(size * 0.4, -size * 0.5, 0, -size * 0.4);
                this.ctx.quadraticCurveTo(-size * 0.6, -size * 0.3, -size * 0.7, 0);
                this.ctx.quadraticCurveTo(-size * 0.6, size * 0.3, 0, size * 0.4);
                this.ctx.quadraticCurveTo(size * 0.4, size * 0.5, size * 0.6, 0);
                this.ctx.fill();
                
                // üé® FRANJAS (patr√≥n del Lottie)
                this.ctx.fillStyle = colors.stripes;
                this.ctx.beginPath();
                // Franja superior
                this.ctx.moveTo(size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(0, -size * 0.25, -size * 0.4, -size * 0.15);
                this.ctx.quadraticCurveTo(-size * 0.2, -size * 0.05, size * 0.4, -size * 0.15);
                this.ctx.fill();
                
                // Franja inferior (solo para beb√©)
                if (this.gameState.stage === 'baby') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(0, size * 0.25, -size * 0.4, size * 0.15);
                    this.ctx.quadraticCurveTo(-size * 0.2, size * 0.05, size * 0.4, size * 0.15);
                    this.ctx.fill();
                }
                
                // üêü ALETA SUPERIOR (forma del Lottie)
                this.ctx.save();
                this.ctx.translate(size * 0.1, -size * 0.4);
                this.ctx.rotate(fish.finRotation * 0.6); // Ondulaci√≥n sutil
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                // Forma de aleta org√°nica
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.15, -size * 0.3, size * 0.05, -size * 0.35);
                this.ctx.quadraticCurveTo(size * 0.2, -size * 0.25, size * 0.15, -size * 0.1);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üêü ALETA INFERIOR
                this.ctx.save();
                this.ctx.translate(size * 0.2, size * 0.5);
                this.ctx.rotate(-fish.finRotation * 0.4);
                
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.quadraticCurveTo(-size * 0.1, size * 0.2, size * 0.05, size * 0.25);
                this.ctx.quadraticCurveTo(size * 0.15, size * 0.15, size * 0.1, size * 0.05);
                this.ctx.quadraticCurveTo(size * 0.05, 0, 0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // üëÅÔ∏è OJO EXACTO DEL LOTTIE
                if (fish.eyeOpen > 0) {
                    // Ojo blanco (forma org√°nica del Lottie)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.3, -size * 0.05, size * 0.2, size * 0.15 * fish.eyeOpen, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Pupila negra
                    this.ctx.fillStyle = '#323232'; // Color exacto [0.1961,0.1961,0.1961]
                    this.ctx.beginPath();
                    this.ctx.ellipse(size * 0.32, -size * 0.05, size * 0.08, size * 0.1 * fish.eyeOpen, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo en el ojo (peque√±o punto blanco)
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.34, -size * 0.08, size * 0.03, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // üëÑ BOCA PEQUE√ëA (del Lottie)
                this.ctx.fillStyle = colors.fins;
                this.ctx.beginPath();
                this.ctx.ellipse(size * 0.5, size * 0.05, size * 0.05, size * 0.03, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // üçº CHUPETE (solo para beb√©)
                if (this.gameState.stage === 'baby' && colors.pacifier) {
                    // Chupete principal
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.12, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Anillo del chupete
                    this.ctx.strokeStyle = colors.pacifier;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(size * 0.6, size * 0.1, size * 0.16, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Mango del chupete
                    this.ctx.fillStyle = colors.pacifier;
                    this.ctx.fillRect(size * 0.72, size * 0.08, size * 0.08, size * 0.04);
                }
                
                this.ctx.restore();
            }
            
            // üé® COLORES EXACTOS DEL LOTTIE
            getFishColors() {
                const stage = this.gameState.stage;
                const ageInDays = this.gameState.ageInDays || 0;
                
                // Beb√© (0-2 d√≠as) - Colores Lottie + chupete
                if (stage === 'baby' || ageInDays < 3) {
                    return {
                        body: '#978bd8',      // Color exacto Lottie [0.5922,0.5451,0.8471]
                        stripes: '#9f8cb9',   // Franjas Lottie [0.6235,0.549,0.7255]
                        tail: '#d14444',      // Cola roja Lottie [0.8196,0.2667,0.2667]
                        fins: '#d78383',      // Aletas rosa Lottie [0.8431,0.5137,0.5137]
                        pacifier: '#ff9ecf'   // Chupete rosa para beb√©
                    };
                }
                
                // Joven (3-7 d√≠as) - Variaci√≥n m√°s intensa
                if (stage === 'young' || ageInDays < 8) {
                    return {
                        body: '#8a7bd8',      // Morado m√°s intenso
                        stripes: '#8f7cb9',   // Franjas m√°s marcadas
                        tail: '#c13434',      // Cola m√°s intensa
                        fins: '#c77373',      // Aletas m√°s fuertes
                        pacifier: null        // Sin chupete
                    };
                }
                
                // Adulto (8+ d√≠as) - Colores maduros
                return {
                    body: '#7d6bd8',        // Morado profundo
                    stripes: '#7f6cb9',     // Franjas sutiles
                    tail: '#b12424',        // Cola madura
                    fins: '#b76363',        // Aletas elegantes
                    pacifier: null          // Sin chupete
                };
            }
            
            // üìè ANCHO DE FRANJA POR EDAD
            getStripeWidth() {
                const ageInDays = this.gameState.ageInDays || 0;
                
                if (ageInDays < 3) return 0.25;      // Beb√©: franja ancha
                if (ageInDays < 8) return 0.18;      // Joven: franja media
                return 0.12;                          // Adulto: franja fina
            }
            
            // ü´ß CREAR BURBUJA DEL PEZ
            createFishBubble() {
                if (!this.fish) return;
                
                // Crear burbuja peque√±a que sale de la boca
                this.bgBubbles.push({
                    x: this.fish.x + this.fish.size * 0.5,
                    y: this.fish.y,
                    r: 2 + Math.random() * 3,
                    speed: 30 + Math.random() * 20,
                    opacity: 0.6 + Math.random() * 0.3,
                    life: 3 + Math.random() * 2,
                    maxLife: 3 + Math.random() * 2,
                    fromFish: true
                });
            }
            
            drawNeedBubbles() {
                for (const bubble of this.needBubbles) {
                    this.ctx.save();
                    this.ctx.globalAlpha = Math.min(bubble.life / 2, 1);
                    
                    // Burbuja de fondo
                    this.ctx.fillStyle = bubble.urgent ? '#ff6b6b' : '#4ecdc4';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Icono (emoji simple)
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px system-ui';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bubble.icon, bubble.x, bubble.y + 7);
                    
                    this.ctx.restore();
                }
            }
            
            // üê£ SISTEMA DE ECLOSI√ìN
            
            startHatching() {
                if (this.gameState.stage !== 'egg') return;
                
                console.log('üê£ ¬°ECLOSI√ìN INICIADA!');
                this.gameState.stage = 'hatching';
                this.createExplosionBubbles();
                
                // Crear pez M√ÅS TEMPRANO - despu√©s de 1 segundo
                setTimeout(() => {
                    this.createFish();
                    this.gameState.stage = 'baby';
                }, 1000); // Reducido de 2000ms a 1000ms
            }
            
            createEggBubbles() {
                console.log('ü•ö Creando burbujitas blancas para el huevo');
                
                this.explosionBubbles.length = 0;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // BURBUJITAS BLANCAS SUAVES (COMO LAS DE NACIMIENTO PERO M√ÅS BLANCAS)
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 15 + Math.random() * 40; // M√°s suaves
                    const size = 2 + Math.random() * 8; // M√°s peque√±as
                    const life = 3 + Math.random() * 2;
                    
                    // COLORES M√ÅS BLANCOS
                    const colors = ['#FFFFFF', '#F8FCFF', '#F0F8FF', '#E8F4FF', '#E0F0FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 30,
                        y: centerY + (Math.random() - 0.5) * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 20,
                        r: size,
                        life: life,
                        maxLife: life,
                        color: color,
                        alpha: 0.8
                    });
                }
                
                console.log('ü•ö 80 burbujitas blancas creadas para el huevo');
            }
            
            createExplosionBubbles() {
                if (this.explosionHappened) return;
                
                this.explosionBubbles.length = 0;
                this.lightRays.length = 0;
                this.explosionHappened = true;
                
                console.log('‚ú® Creando efecto suave de nacimiento');
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height * 0.6;
                
                // EXPLOSI√ìN MASIVA DE BURBUJAS - LLENAR TODA LA PANTALLA
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 100; // Velocidad variada
                    const size = 3 + Math.random() * 12; // Tama√±os muy variados
                    const life = 4 + Math.random() * 3; // M√°s duraderas
                    
                    // Colores azules brillantes y blancos
                    const colors = ['#FFFFFF', '#E6F3FF', '#CCE7FF', '#99D6FF', '#66C7FF', '#33B8FF', '#00A9FF'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    this.explosionBubbles.push({
                        x: centerX + (Math.random() - 0.5) * 50,
                        y: centerY + (Math.random() - 0.5) * 50,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 30, // Impulso hacia arriba
                        r: size,
                        life: life,
                        maxLife: life,
                        sparkle: Math.random() < 0.3, // M√°s brillo
                        isLight: false
                    });
                }
                
                // ONDAS MASIVAS: 4 ondas consecutivas
                for (let wave = 0; wave < 4; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            const speed = 50 + Math.random() * 80;
                            const size = 2 + Math.random() * 8;
                            
                            this.explosionBubbles.push({
                                x: centerX + (Math.random() - 0.5) * 20,
                                y: centerY + (Math.random() - 0.5) * 20,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: size,
                                life: 3 + Math.random() * 2,
                                maxLife: 3 + Math.random() * 2,
                                sparkle: Math.random() < 0.4,
                                isLight: false
                            });
                        }
                    }, wave * 200);
                }
                
                console.log(`‚ú® Efecto suave creado: ${this.explosionBubbles.length} burbujas delicadas (sin rayos amarillos)`);
            }
            
            async createFish() {
                // Crear pez Lottie REAL
                await this.createLottieFish();
                
                this.fish = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height * 0.6,
                    size: 80, // Tama√±o del contenedor Lottie (m√°s peque√±o)
                    birthTime: Date.now(),
                    isLottie: true,
                    scale: 0.1, // Empezar muy peque√±o
                    targetScale: 1.0, // Crecer hasta tama√±o normal
                    growing: true,
                    
                    // üöÄ PROPIEDADES DEL SISTEMA REALISTA (EXACTAS DEL C√ìDIGO)
                    vx: 0, vy: 0, // Velocidades actuales
                    facing: 1, // Direcci√≥n (-1 izquierda, 1 derecha)
                    baseSpeed: 140, // Velocidad base EXACTA
                    maxSpeed: 300, // Velocidad m√°xima EXACTA
                    maxAccel: 900, // Aceleraci√≥n m√°xima EXACTA
                    wanderTimer: 0, // Timer para cambio de direcci√≥n
                    wanderDir: {x: 1, y: 0}, // Direcci√≥n de vagabundeo
                    swimPhase: 0, // Fase de nataci√≥n para ondulaci√≥n
                    desire: null, // Objetivo al que ir (click)
                    happyBurst: 0, // Tiempo de celebraci√≥n
                    spinKind: "eat", // Tipo de giro (eat/clean)
                    blinkT: 0, // Tiempo de parpadeo
                    nextBlink: 2 + Math.random() * 4, // Pr√≥ximo parpadeo
                    breathT: 2 + Math.random() * 3 // Pr√≥xima respiraci√≥n
                };
                
                // Establecer fecha de nacimiento
                this.gameState.birthDate = Date.now();
                this.gameState.ageInDays = 0;
                
                // üçé NACER CON HAMBRE (CRISIS)
                this.gameState.needs.hunger = 80; // Crisis de hambre
                this.updateCrisisFlags(); // Activar flags
                this.updateNeedBars(); // Actualizar barras
                
                console.log('üçé Pez naci√≥ con hambre - Crisis activada');
                
                // üìä MOSTRAR BARRAS DE NECESIDADES CUANDO NACE EL PEZ
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'flex';
                    this.setupCanvas(); // REAJUSTAR CANVAS CON BARRAS
                    console.log('üìä Barras de necesidades activadas + Canvas reajustado');
                }
                
                // Bonus de bienvenida
                this.gameState.bubbles += 5; // 5 burbujas de regalo por nacer
                this.gameState.stars += 1;   // 1 estrella de regalo
                
                // üéÜ BURBUJAS ANTES DEL PEZ (INMEDIATAS)
                this.explosionHappened = false; // RESETEAR FLAG
                this.createExplosionBubbles(); // BURBUJAS PRIMERO
                
                console.log('üéÜ Burbujas de nacimiento creadas ANTES del pez');
                
                console.log('üê† ¬°PEZ LOTTIE NACIDO! +5 ü´ß +1 ‚≠ê de regalo');
                this.updateUI();
                
                // Forzar actualizaci√≥n inmediata de necesidades (beb√© nace con hambre)
                setTimeout(() => {
                    // this.updateAllNeedBubbles(); // DESHABILITADO - iconos eliminados
                    this.updateButtonStates();
                    console.log('üçΩÔ∏è Verificando necesidades del beb√© reci√©n nacido...');
                }, 1000); // Despu√©s de 1 segundo para asegurar que todo est√© inicializado
                
                // Pedir nombre despu√©s de 3 segundos
                setTimeout(() => {
                    this.askForFishName();
                }, 3000);
                
                // A√±adir evento de nacimiento al √°lbum
                this.addAlbumEvent('birth', 'üê£ ¬°He nacido!', 'Mi primer d√≠a en el mundo. Todo es nuevo y emocionante.');
            }
            
            async createLottieFish() {
                try {
                    // Cargar JSON del pez
                    const response = await fetch('./ejemplos/bebe.json');
                    const animationData = await response.json();
                    
                    const container = document.getElementById('lottieContainer');
                    container.style.display = 'block';
                    
                    // Crear animaci√≥n Lottie
                    this.lottieAnimation = lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: animationData
                    });
                    
                    console.log('üé® Pez Lottie cargado correctamente');
                    
                    // Posicionar el contenedor
                    this.updateLottiePosition();
                    
                } catch (error) {
                    console.error('‚ùå Error cargando Lottie:', error);
                    // Fallback al pez Canvas
                    this.createCanvasFish();
                }
            }
            
            updateLottiePosition() {
                if (!this.fish || !this.lottieAnimation) return;
                
                const container = document.getElementById('lottieContainer');
                const rect = this.canvas.getBoundingClientRect();
                
                // CRECIMIENTO GRADUAL del pez reci√©n nacido
                if (this.fish.growing && this.fish.scale < this.fish.targetScale) {
                    this.fish.scale += 0.02; // Crecimiento visible
                    
                    if (this.fish.scale >= this.fish.targetScale) {
                        this.fish.scale = this.fish.targetScale;
                        this.fish.growing = false;
                        console.log('üê† Pez alcanz√≥ tama√±o completo');
                    }
                }
                
                // Posici√≥n relativa al canvas
                const x = this.fish.x;
                const y = this.fish.y;
                const currentScale = this.fish.scale || 1;
                const facing = this.fish.facing || 1;
                
                container.style.left = (rect.left + x - 30) + 'px'; // Centrar (60px/2 = 30)
                container.style.top = (rect.top + y - 30) + 'px';
                
                // üîÑ ORIENTACI√ìN CORREGIDA: Lottie mira IZQUIERDA por defecto
                // facing = 1 (derecha) ‚Üí scaleX(-1)
                // facing = -1 (izquierda) ‚Üí scaleX(1) 
                const scaleX = facing > 0 ? -1 : 1; // INVERTIDO para corregir orientaci√≥n
                
                // APLICAR INCLINACI√ìN Y EFECTOS DE ESTADO DE √ÅNIMO
                const tilt = this.fish.tilt || 0;
                const tiltDegrees = tilt * (180 / Math.PI); // Convertir a grados
                
                // üé® COLOR FIJO - NO M√ÅS CAMBIOS RAROS
                const fixedFilter = 'brightness(1.2) contrast(1.1) saturate(1.2)'; // Color fijo y bonito
                
                container.style.transform = `translate(-50%, -50%) scaleX(${scaleX}) scale(${currentScale}) rotate(${tiltDegrees}deg)`;
                container.style.filter = fixedFilter; // SIEMPRE EL MISMO
                container.style.opacity = 1; // Siempre visible
                
                // Reducir felicidad gradualmente
                if (this.fish.happyTime > 0) {
                    this.fish.happyTime -= 1/60;
                    if (this.fish.happyTime <= 0) {
                        this.fish.excited = false;
                    }
                }
            }
            
            createCanvasFish() {
                // Fallback al pez Canvas original
                this.fish = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height * 0.6,
                    size: 45,
                    birthTime: Date.now(),
                    isLottie: false
                };
                console.log('üê† Pez Canvas creado (fallback)');
            }
            
            // üèä MOVIMIENTO DEL PEZ
            // üèä MOVIMIENTO DEL PEZ REALISTA (COPIADO DEL C√ìDIGO PERFECTO)
            updateFishMovement(deltaTime) {
                if (!this.fish) return;
                
                const fish = this.fish;
                
                // üëÅÔ∏è Parpadeo y respiraci√≥n
                fish.blinkT = Math.max(0, fish.blinkT - deltaTime);
                fish.nextBlink -= deltaTime;
                if (fish.nextBlink <= 0 && fish.blinkT <= 0) {
                    fish.blinkT = 0.12;
                    fish.nextBlink = 2 + Math.random() * 4;
                }
                
                fish.breathT -= deltaTime;
                if (fish.breathT <= 0 && !this.cleaningActive) {
                    this.emitMouthBubbles(3 + Math.floor(Math.random() * 3));
                    fish.breathT = 2 + Math.random() * 3;
                }
                
                fish.swimPhase += deltaTime * 3.2;
                let targetV = {vx: 0, vy: 0};
                let speedMul = 1.0;
                
                // üö® ESTADOS DE CRISIS
                const inHunger = this.gameState.crisis.hunger;
                const inDirt = this.gameState.crisis.dirt;
                const inBored = this.gameState.crisis.bored;
                
                // üéâ CELEBRACI√ìN (giros de felicidad)
                if (fish.happyBurst > 0) {
                    const w = (fish.spinKind === "clean") ? 13.0 : 6.0;
                    const R = (fish.spinKind === "clean") ? 140 : 55;
                    const a = this.gameTime * w;
                    targetV = {vx: Math.cos(a) * R * 0.65, vy: Math.sin(a) * R * 0.65};
                    speedMul = (fish.spinKind === "clean") ? 1.8 : 1.25;
                    fish.happyBurst = Math.max(0, fish.happyBurst - (fish.spinKind === "clean" ? 0.6 : 1.6) * deltaTime);
                }
                // üçé CRISIS HAMBRE + comida disponible
                else if (inHunger && this.food.length) {
                    const best = this.nearestFood();
                    const s = this.seek(fish.x, fish.y, best.x, best.y, fish.maxSpeed * 1.0);
                    speedMul = 1.25;
                    targetV = {vx: s.vx, vy: s.vy};
                }
                // üçé CRISIS HAMBRE sin comida (esquina superior)
                else if (inHunger) {
                    const home = {x: 70, y: 70}; // Esquina superior
                    const s = this.seek(fish.x, fish.y, home.x, home.y, 60);
                    speedMul = 0.5;
                    if (s.dist > 20) {
                        targetV = {vx: s.vx * 0.5, vy: s.vy * 0.5};
                } else {
                        targetV = {vx: Math.sin(fish.swimPhase) * 6, vy: Math.cos(fish.swimPhase * 1.2) * 3};
                    }
                }
                // üßπ CRISIS SUCIEDAD + comida (come pero lento)
                else if (inDirt && this.food.length) {
                    const best = this.nearestFood();
                    const s = this.seek(fish.x, fish.y, best.x, best.y, fish.maxSpeed * 0.6);
                    speedMul = 0.85;
                    targetV = {vx: s.vx, vy: s.vy};
                }
                // üßπ CRISIS SUCIEDAD sin comida (esquina inferior)
                else if (inDirt) {
                    const home = {x: this.canvas.width - 70, y: this.canvas.height - 70}; // Esquina inferior
                    const s = this.seek(fish.x, fish.y, home.x, home.y, 70);
                    speedMul = 0.7;
                    if (s.dist > 20) {
                        targetV = {vx: s.vx * 0.5, vy: s.vy * 0.5};
                    } else {
                        targetV = {vx: Math.sin(fish.swimPhase) * 5, vy: Math.cos(fish.swimPhase * 1.2) * 2};
                    }
                }
                // üò¥ CRISIS ABURRIMIENTO (centro, pasa de clicks)
                else if (inBored) {
                    const home = {x: this.canvas.width * 0.5, y: this.canvas.height - 70};
                    const s = this.seek(fish.x, fish.y, home.x, home.y, 80);
                    speedMul = 0.9;
                    if (s.dist > 18) {
                        targetV = {vx: s.vx * 0.6, vy: s.vy * 0.6};
                    } else {
                        targetV = {vx: Math.sin(fish.swimPhase) * 7, vy: Math.cos(fish.swimPhase * 1.5) * 3};
                    }
                }
                // üëÜ CLICK del usuario (ir al dedo) - VELOCIDAD R√ÅPIDA
                else if (fish.desire) {
                    const desireSpeed = fish.desireSpeed || fish.maxSpeed; // Usar velocidad r√°pida si est√° disponible
                    const s = this.seek(fish.x, fish.y, fish.desire.x, fish.desire.y, desireSpeed);
                    const t = this.clamp(s.dist / 120, 0.25, 1);
                    targetV = {vx: s.vx * t, vy: s.vy * t};
                    if (s.dist < 22) {
                        fish.desire = null;
                        targetV = {vx: 0, vy: 0};
                        this.launchHeartToFun(fish.x, fish.y); // Coraz√≥n volador desde el pez
                    }
                }
                // üçé HAY COMIDA (ir a comer)
                else if (this.food.length) {
                    const f = this.nearestFood();
                    const d = this.dist(fish.x, fish.y, f.x, f.y);
                    const s = this.seek(fish.x, fish.y, f.x, f.y, fish.maxSpeed * 0.9);
                    const t = this.clamp(d / 90, 0.35, 1);
                    targetV = {vx: s.vx * t, vy: s.vy * t};
                }
                // üèä MOVIMIENTO LIBRE (vagabundeo natural)
                else {
                    fish.wanderTimer -= deltaTime;
                    if (fish.wanderTimer <= 0) {
                        const angle = Math.random() * Math.PI * 2;
                        fish.wanderDir.x = Math.cos(angle);
                        fish.wanderDir.y = Math.sin(angle) * 0.33; // Menos vertical
                        fish.wanderTimer = 0.8 + Math.random() * 1.1;
                    }
                    const cruise = fish.baseSpeed * 1.1;
                    targetV = {
                        vx: fish.wanderDir.x * cruise + Math.cos(fish.swimPhase) * 16,
                        vy: fish.wanderDir.y * cruise + Math.sin(fish.swimPhase * 1.8) * 16
                    };
                }
                
                // üöÄ APLICAR F√çSICA REALISTA (aceleraci√≥n/desaceleraci√≥n)
                const maxSpeed = fish.maxSpeed * speedMul;
                const maxAccel = fish.maxAccel * speedMul;
                const ax = this.clamp(targetV.vx - fish.vx, -maxAccel, maxAccel);
                const ay = this.clamp(targetV.vy - fish.vy, -maxAccel, maxAccel);
                fish.vx += ax * deltaTime;
                fish.vy += ay * deltaTime;
                
                // üìç ACTUALIZAR POSICI√ìN
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;
                
                // üöß L√çMITES M√ìVIL S√öPER SEGUROS
                const fishSize = 60; // Tama√±o del pez
                const safePad = 50; // Padding extra seguro
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                // ZONA SEGURA: Header = 70px, Botones = 90px
                const topLimit = 70 + safePad; // Header + padding
                const bottomLimit = H - 90 - safePad; // Sin botones - padding
                const leftLimit = safePad;
                const rightLimit = W - safePad;
                
                // L√çMITES HORIZONTALES
                if (fish.x < leftLimit) { 
                    fish.x = leftLimit; 
                    fish.vx = Math.abs(fish.vx) * 0.8; // Rebote suave hacia adentro
                }
                if (fish.x > rightLimit) { 
                    fish.x = rightLimit; 
                    fish.vx = -Math.abs(fish.vx) * 0.8; // Rebote suave hacia adentro
                }
                
                // L√çMITES VERTICALES
                if (fish.y < topLimit) { 
                    fish.y = topLimit; 
                    fish.vy = Math.abs(fish.vy) * 0.8; // Rebote suave hacia abajo
                }
                if (fish.y > bottomLimit) { 
                    fish.y = bottomLimit; 
                    fish.vy = -Math.abs(fish.vy) * 0.8; // Rebote suave hacia arriba
                }
                
                // üîÑ ORIENTACI√ìN (cambiar facing solo con movimiento significativo)
                if (Math.abs(fish.vx) > 2) {
                    fish.facing = fish.vx > 0 ? 1 : -1;
                }
                
                // Actualizar posici√≥n Lottie
                if (fish.isLottie) {
                    this.updateLottiePosition();
                }
            }
            
            // üê† L√ìGICA SIMPLE DE PEZ REAL
            updateNaturalFishMovement(deltaTime) {
                const fish = this.fish;
                const currentStage = this.gameState.stage;
                
                // Inicializar pez m√°s r√°pido y variado
                if (!fish.direction) fish.direction = 1; // 1 = derecha, -1 = izquierda
                if (!fish.baseSpeed) fish.baseSpeed = currentStage === 'baby' ? 60 : 45; // Velocidad base
                if (!fish.speed) fish.speed = fish.baseSpeed; // Velocidad actual
                if (!fish.swimPhase) fish.swimPhase = 0;
                if (!fish.facing) fish.facing = 1;
                if (!fish.changeTimer) fish.changeTimer = 0;
                if (!fish.verticalDirection) fish.verticalDirection = 0; // -1 arriba, 0 medio, 1 abajo
                if (!fish.verticalTimer) fish.verticalTimer = 0;
                // BEB√â NACE CON HAMBRE - Configurar tiempo anterior para que tenga hambre inmediatamente
                if (!fish.lastFeedTime) {
                    // Hacer que el beb√© nazca con hambre (4 horas + 1 minuto atr√°s)
                    const hungerTime = 4 * 60 * 60 * 1000 + 60 * 1000; // 4h 1min atr√°s
                    fish.lastFeedTime = Date.now() - hungerTime;
                    console.log('üçº ¬°Beb√© nace con HAMBRE! Necesita comer inmediatamente');
                }
                
                // INICIALIZAR SISTEMA DE BURBUJAS DE NECESIDADES
                if (!fish.needBubbleTimer) fish.needBubbleTimer = 0;
                if (!this.needBubbles) this.needBubbles = [];
                
                // Inicializar otros tiempos si no existen
                if (!this.gameState.lastClean) this.gameState.lastClean = Date.now();
                if (!this.gameState.lastMedicine) this.gameState.lastMedicine = Date.now();
                if (!this.gameState.lastPlay) this.gameState.lastPlay = Date.now();
                
                // Fase de nataci√≥n para ondulaci√≥n
                fish.swimPhase += deltaTime * (currentStage === 'baby' ? 2 : 1.2);
                fish.changeTimer += deltaTime;
                
                // CAMBIOS M√ÅS FRECUENTES para m√°s variedad
                // Beb√©: cada 4-8 segundos, Adulto: cada 6-10 segundos
                const changeInterval = currentStage === 'baby' ? 4 + Math.random() * 4 : 6 + Math.random() * 4;
                fish.verticalTimer += deltaTime;
                
                if (fish.changeTimer > changeInterval) {
                    // 50% chance de cambiar direcci√≥n horizontal
                    if (Math.random() < 0.5) {
                        fish.direction *= -1;
                        console.log(`üê† Cambio horizontal: ${fish.direction === 1 ? 'DERECHA ‚Üí' : 'IZQUIERDA ‚Üê'}`);
                    }
                    
                    // 60% chance de cambiar direcci√≥n vertical
                    if (Math.random() < 0.6) {
                        const options = [-1, 0, 1]; // arriba, medio, abajo
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                        const verticalNames = ['ARRIBA ‚Üë', 'MEDIO ‚Üí', 'ABAJO ‚Üì'];
                        console.log(`üê† Cambio vertical: ${verticalNames[fish.verticalDirection + 1]}`);
                    }
                    
                    fish.changeTimer = 0;
                }
                
                // Cambios verticales independientes (m√°s frecuentes)
                if (fish.verticalTimer > 3 + Math.random() * 3) {
                    if (Math.random() < 0.4) {
                        const options = [-1, 0, 1];
                        fish.verticalDirection = options[Math.floor(Math.random() * options.length)];
                    }
                    fish.verticalTimer = 0;
                }
                
                // ‚úÖ SISTEMA ELIMINADO - SOLO USAMOS EL SISTEMA ORIGINAL DEL DOCUMENTO
                if (fish.isChasing) {
                    // 2. PRIORIDAD: Perseguir comida
                    // Durante persecuci√≥n, usar la velocidad ya calculada en makeFishChaseFood
                    // No sobreescribir fish.vx y fish.vy
                } else if (fish.isCleaning) {
                    // 3. PRIORIDAD: Movimiento de tirabuzones durante limpieza
                    fish.cleaningTime += deltaTime;
                    
                    // MOVIMIENTO EN TIRABUZONES (COSQUILLAS)
                    const spiralSpeed = fish.baseSpeed * 1.5;
                    const spiralRadius = 40 + Math.sin(fish.cleaningTime * 3) * 20;
                    const spiralAngle = fish.cleaningTime * 4; // 4 vueltas por segundo
                    
                    fish.vx = Math.cos(spiralAngle) * spiralRadius * 0.1 + Math.sin(fish.cleaningTime * 8) * spiralSpeed * 0.3;
                    fish.vy = Math.sin(spiralAngle) * spiralRadius * 0.1 + Math.cos(fish.cleaningTime * 6) * spiralSpeed * 0.2;
                    
                    // Movimiento err√°tico como si tuviera cosquillas
                    fish.vx += (Math.random() - 0.5) * spiralSpeed * 0.4;
                    fish.vy += (Math.random() - 0.5) * spiralSpeed * 0.3;
                    
                    console.log(`üåÄ Pez haciendo tirabuzones - tiempo: ${fish.cleaningTime.toFixed(1)}s`);
                } else if (fish.goingToCorner) {
                    // 4. PRIORIDAD: Pez triste va a esquina (SIN desire)
                    const dx = fish.cornerTargetX - fish.x;
                    const dy = fish.cornerTargetY - fish.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 15) {
                        // Movimiento LENTO hacia esquina
                        const slowSpeed = fish.baseSpeed * 0.5; // MUY lento
                        fish.vx = (dx / distance) * slowSpeed;
                        fish.vy = (dy / distance) * slowSpeed;
                        fish.direction = dx > 0 ? 1 : -1;
                    } else {
                        // Lleg√≥ a la esquina - quedarse quieto
                        fish.goingToCorner = false;
                        fish.vx = 0;
                        fish.vy = 0;
                        console.log('üò¢ Pez lleg√≥ a esquina - Se queda quieto');
                    }
                } else {
                    // 5. COMPORTAMIENTO NORMAL: Movimiento libre
                    fish.vx = fish.direction * fish.speed;
                    
                    // Movimiento vertical combinado
                    let baseVerticalMovement = Math.sin(fish.swimPhase) * (currentStage === 'baby' ? 12 : 8); // Ondulaci√≥n natural
                    let directionalVertical = fish.verticalDirection * (fish.speed * 0.4); // Movimiento direccional vertical
                    
                    fish.vy = baseVerticalMovement + directionalVertical;
                }
                
                // Aplicar movimiento
                fish.x += fish.vx * deltaTime;
                fish.y += fish.vy * deltaTime;
                
                // GIRO SIMPLE: Solo cuando llega al borde
                this.handleSimpleFishBoundaries();
                
                // Orientaci√≥n simple
                this.updateFishOrientation();
                
                // SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
                this.updateNeedBubbles(deltaTime);
                
                // Sistema de necesidades - Solo botones (iconos flotantes eliminados)
                // this.updateAllNeedBubbles(); // DESHABILITADO - iconos molestos
                
                // Sistema de apat√≠a y tristeza
                this.updateFishMood();
                
                // Actualizar estado de botones
                this.updateButtonStates();
            }
            
            // üëÜ CLICK EN PANTALLA - PEZ VIENE AL DEDO (SISTEMA DEL DEMO)
            handleCanvasClick(event) {
                if (!this.fish || this.gameState.stage === 'egg' || this.fish.isDepressed) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                
                // SISTEMA DEL DEMO: fish.desire con l√≠mites
                this.fish.desire = { 
                    x: Math.max(30, Math.min(this.canvas.width - 30, clickX)), 
                    y: Math.max(30, Math.min(this.canvas.height - 30, clickY)) 
                };
                
                this.fish.excited = true;
                
                // üíñ SISTEMA DE CORAZONES - AUMENTA DIVERSI√ìN
                this.fish.happyBurst = 3; // 3 segundos de felicidad
                
                // üíñ LANZAR CORAZ√ìN FLOTANTE
                this.launchHeartToFun(clickX, clickY);
                
                // üéØ VELOCIDAD R√ÅPIDA AL DEDO (usar maxSpeed del sistema original)
                this.fish.desireSpeed = this.fish.maxSpeed * 1.5; // 1.5x la velocidad m√°xima
                
                console.log(`üëÜ ¬°Pez DESIRE hacia el dedo! (${clickX.toFixed(0)}, ${clickY.toFixed(0)}) + üíñ Coraz√≥n!`);
                
                // Quitar emoci√≥n despu√©s de llegar
                setTimeout(() => {
                    this.fish.excited = false;
                    this.fish.desireSpeed = null; // Volver a velocidad normal (maxSpeed)
                }, 3000);
            }
            
            // üíñ LANZAR CORAZ√ìN QUE AUMENTA DIVERSI√ìN
            launchHeartToFun(x, y) {
                // Crear coraz√≥n visual
                const heart = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 50, // Velocidad horizontal aleatoria
                    vy: -80, // Velocidad hacia arriba
                    life: 2.0, // 2 segundos de vida
                    maxLife: 2.0,
                    size: 20 + Math.random() * 10,
                    color: ['üíñ', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú'][Math.floor(Math.random() * 7)]
                };
                
                if (!this.flyers) this.flyers = [];
                this.flyers.push(heart);
                
                // üéâ AUMENTAR DIVERSI√ìN
                this.gameState.needs.fun = Math.max(0, this.gameState.needs.fun - 5); // -5 diversi√≥n (menos rojo = m√°s feliz)
                this.updateCrisisFlags();
                this.updateNeedBars();
                
                console.log(`üíñ Coraz√≥n lanzado! Diversi√≥n: ${this.gameState.needs.fun}`);
            }
            
            // YA NO NECESITAMOS CAMBIOS DE COMPORTAMIENTO
            // El pez simplemente NADA en una direcci√≥n hasta llegar al borde
            
            // üçΩÔ∏è SISTEMA DE HAMBRE
            updateHunger() {
                if (!this.fish || !this.fish.lastFeedTime) return;
                
                const currentTime = Date.now();
                const timeSinceLastFeed = currentTime - this.fish.lastFeedTime;
                // CONFIGURACI√ìN REAL: Beb√© tiene hambre cada 4 horas
                const currentStage = this.gameState.stage;
                let hungerThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000; // Default beb√©
                }
                
                const hungerBubble = document.getElementById('hungerBubble');
                if (!hungerBubble) return;
                
                if (timeSinceLastFeed > hungerThreshold) {
                    // Mostrar burbuja de hambre cerca del pez
                    this.showHungerBubble();
                } else {
                    // Ocultar burbuja
                    hungerBubble.style.display = 'none';
                }
            }
            
            showHungerBubble() {
                this.showNeedBubble('hungerBubble', 'hunger', 15, -45);
            }
            
            // üéØ MOSTRAR BURBUJA DE NECESIDAD GEN√âRICA
            showNeedBubble(bubbleId, needType, offsetX, offsetY) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Posicionar la burbuja cerca del pez
                bubble.style.display = 'block';
                bubble.style.left = (this.fish.x + offsetX) + 'px';
                bubble.style.top = (this.fish.y + offsetY) + 'px';
                
                const needNames = {
                    'hunger': 'COMIDA üçΩÔ∏è',
                    'dirty': 'LIMPIEZA üßΩ', 
                    'medicine': 'MEDICINA üíä',
                    'play': 'JUGAR üéÆ'
                };
                console.log(`üéØ Pez necesita: ${needNames[needType] || needType}`);
                
                // DEBUG: Verificar que se muestra el icono, no texto
                console.log(`üìç Burbuja ${bubbleId} posicionada en (${this.fish.x + offsetX}, ${this.fish.y + offsetY})`);
            }
            
            // üéØ MOSTRAR ICONO QUE SE MUEVE (APARECE/DESAPARECE/CAMBIA LUGAR)
            showFixedNeedIcon(bubbleId, needType) {
                const bubble = document.getElementById(bubbleId);
                if (!bubble || !this.fish) return;
                
                // Inicializar timer de movimiento si no existe
                if (!bubble.moveTimer) bubble.moveTimer = 0;
                if (!bubble.currentPosition) bubble.currentPosition = 0;
                
                bubble.moveTimer += 1/60;
                
                // Cambiar posici√≥n cada 8-15 segundos (M√ÅS LENTO)
                if (bubble.moveTimer > 8 + Math.random() * 7) {
                    bubble.currentPosition = (bubble.currentPosition + 1) % 4; // Rotar entre 4 posiciones
                    bubble.moveTimer = 0;
                    
                    // DESAPARECER MUY LENTAMENTE (1.5 segundos)
                    bubble.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
                    bubble.style.opacity = '0';
                    bubble.style.transform = 'scale(0.7)';
                    
                    setTimeout(() => {
                        // Cambiar posici√≥n mientras est√° invisible
                        this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                        
                        // APARECER MUY LENTAMENTE (2 segundos)
                        setTimeout(() => {
                            bubble.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
                            bubble.style.opacity = '1';
                            bubble.style.transform = 'scale(1)';
                        }, 200);
                        
                    }, 1500); // Esperar a que termine de desaparecer
                    
                    console.log(`üéØ Icono ${needType} se mueve SUAVEMENTE a nueva posici√≥n`);
                } else {
                    // Mantener posici√≥n actual
                    this.updateIconPosition(bubble, bubbleId, bubble.currentPosition);
                }
                
                bubble.style.display = 'block';
            }
            
            updateIconPosition(bubble, bubbleId, positionIndex) {
                // 4 posiciones diferentes para cada icono
                const allPositions = [
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.25 }, // Superior izquierda
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.25 }, // Superior derecha
                    { x: this.canvas.width * 0.85, y: this.canvas.height * 0.75 }, // Inferior derecha
                    { x: this.canvas.width * 0.15, y: this.canvas.height * 0.75 }  // Inferior izquierda
                ];
                
                const pos = allPositions[positionIndex] || allPositions[0];
                
                bubble.style.left = pos.x + 'px';
                bubble.style.top = pos.y + 'px';
            }
            
            // üò¢ SISTEMA DE APAT√çA Y TRISTEZA
            updateFishMood() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Calcular tiempo sin atender necesidades
                const timeSinceFood = this.fish.lastFeedTime ? currentTime - this.fish.lastFeedTime : 0;
                const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                const timeSinceClean = this.gameState.lastClean ? currentTime - this.gameState.lastClean : 0;
                
                // Umbrales de descuido (8 horas sin atender)
                const neglectThreshold = 8 * 60 * 60 * 1000; // 8 horas
                
                const isNeglected = timeSinceFood > neglectThreshold || 
                                  timeSincePlay > neglectThreshold || 
                                  timeSinceClean > neglectThreshold;
                
                if (isNeglected) {
                    // PEZ TRISTE Y AP√ÅTICO - L√ìGICA MEJORADA
                    this.fish.baseSpeed = (currentStage === 'baby' ? 60 : 45) * 0.3; // MUY lento
                    this.fish.isDepressed = true;
                    this.fish.hideTimer = (this.fish.hideTimer || 0) + 1/60;
                    
                    // Se va a una esquina y se queda quieto M√ÅS TIEMPO
                    if (!this.fish.isInCorner && this.fish.hideTimer > 3) {
                        // Ir a una esquina aleatoria
                        const corners = [
                            { x: 100, y: this.canvas.height * 0.2 }, // Esquina superior izquierda
                            { x: this.canvas.width - 100, y: this.canvas.height * 0.2 }, // Superior derecha
                            { x: 100, y: this.canvas.height * 0.8 }, // Inferior izquierda
                            { x: this.canvas.width - 100, y: this.canvas.height * 0.8 } // Inferior derecha
                        ];
                        
                        const corner = corners[Math.floor(Math.random() * corners.length)];
                        this.fish.targetX = corner.x;
                        this.fish.targetY = corner.y;
                        // Pez triste va LENTO a esquina (SIN desire para evitar conflictos)
                        this.fish.cornerTargetX = corner.x;
                        this.fish.cornerTargetY = corner.y;
                        this.fish.goingToCorner = true;
                        this.fish.isInCorner = true;
                        this.fish.cornerTime = 8 + Math.random() * 12; // 8-20 segundos en esquina
                        console.log('üò¢ Pez triste va a esconderse en esquina...');
                    }
                    
                    // Quedarse quieto en la esquina
                    if (this.fish.isInCorner) {
                        this.fish.cornerTime -= 1/60;
                        
                        // Movimiento MUY reducido en la esquina
                        if (this.fish.cornerTime > 0) {
                            this.fish.vx *= 0.95; // Casi inm√≥vil
                            this.fish.vy *= 0.95;
                        } else {
                            this.fish.isInCorner = false;
                            this.fish.hideTimer = 0;
                            console.log('üê† Pez sale de la esquina');
                        }
                    }
                    
                    // No responde al dedo cuando est√° muy triste
                    if (this.fish.isGoingToTarget && !this.fish.isInCorner && Math.random() < 0.8) {
                        this.fish.isGoingToTarget = false;
                        this.fish.targetX = null;
                        this.fish.targetY = null;
                        console.log('üò¢ Pez demasiado triste para venir al dedo');
                    }
                    
                } else {
                    // PEZ NORMAL Y FELIZ
                    this.fish.baseSpeed = currentStage === 'baby' ? 60 : 45; // Velocidad normal
                    this.fish.isDepressed = false;
                    this.fish.isInCorner = false;
                    this.fish.hideTimer = 0;
                }
            }
            
            // üéÆ ACTUALIZAR TODAS LAS BURBUJAS DE NECESIDADES
            updateAllNeedBubbles() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales (mismos que en updateButtonStates)
                let hungerThreshold, cleanThreshold, medicineThreshold, playThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        playThreshold = 5 * 60 * 60 * 1000; // 5 horas
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000;
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 14 * 60 * 60 * 1000;
                        playThreshold = 8 * 60 * 60 * 1000;
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000;
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000;
                        medicineThreshold = 26 * 60 * 60 * 1000;
                        playThreshold = 10 * 60 * 60 * 1000;
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                        playThreshold = 5 * 60 * 60 * 1000;
                }
                
                // Verificar y mostrar/ocultar burbujas
                const needsFood = this.fish.lastFeedTime && (currentTime - this.fish.lastFeedTime) > hungerThreshold;
                const needsCleaning = this.gameState.lastClean && (currentTime - this.gameState.lastClean) > cleanThreshold;
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                const needsPlay = this.gameState.lastPlay && (currentTime - this.gameState.lastPlay) > playThreshold;
                
                // ICONOS APARECEN/DESAPARECEN en posiciones fijas
                if (needsFood) {
                    this.showFixedNeedIcon('hungerBubble', 'hunger');
                } else {
                    document.getElementById('hungerBubble').style.display = 'none';
                }
                
                if (needsCleaning) {
                    this.showFixedNeedIcon('dirtyBubble', 'dirty');
                } else {
                    document.getElementById('dirtyBubble').style.display = 'none';
                }
                
                if (needsMedicine) {
                    this.showFixedNeedIcon('medicineBubble', 'medicine');
                } else {
                    document.getElementById('medicineBubble').style.display = 'none';
                }
                
                if (needsPlay) {
                    this.showFixedNeedIcon('playBubble', 'play');
                } else {
                    document.getElementById('playBubble').style.display = 'none';
                }
            }
            
            // üìç ACTUALIZAR POSICIONES DE BURBUJAS QUE SIGUEN AL PEZ
            updateVisibleBubblesPositions() {
                if (!this.fish) return;
                
                const bubbles = [
                    { id: 'hungerBubble', offsetX: 15, offsetY: -45 },
                    { id: 'dirtyBubble', offsetX: -60, offsetY: -30 },
                    { id: 'medicineBubble', offsetX: 60, offsetY: -30 },
                    { id: 'playBubble', offsetX: 0, offsetY: -70 }
                ];
                
                bubbles.forEach(bubbleInfo => {
                    const bubble = document.getElementById(bubbleInfo.id);
                    if (bubble && bubble.style.display !== 'none') {
                        // Actualizar posici√≥n para que siga al pez
                        bubble.style.left = (this.fish.x + bubbleInfo.offsetX) + 'px';
                        bubble.style.top = (this.fish.y + bubbleInfo.offsetY) + 'px';
                    }
                });
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BOT√ìN (COMIDA CAYENDO)
            startFeeding() {
                if (!this.fish) return;
                
                console.log('üçΩÔ∏è Iniciando alimentaci√≥n - Comida cayendo desde arriba');
                
                // Crear 3 bolitas con MEJOR ESPACIADO
                setTimeout(() => {
                    this.createFallingFood(1); // Primera comida
                }, 0);
                
                setTimeout(() => {
                    this.createFallingFood(2); // Segunda comida
                }, 800); // Despu√©s de 800ms
                
                setTimeout(() => {
                    this.createFallingFood(3); // Tercera comida
                }, 1600); // Despu√©s de 1.6s
                
                // Activar modo persecuci√≥n del pez (velocidad m√°s suave)
                this.fish.isChasing = true;
                this.fish.chaseSpeed = this.fish.speed * 1.5; // Solo 50% m√°s r√°pido
                
                // Desactivar persecuci√≥n despu√©s de 15 segundos
                setTimeout(() => {
                    if (this.fish) {
                        this.fish.isChasing = false;
                        console.log('üê† Pez dej√≥ de perseguir comida - Volviendo a comportamiento normal');
                    }
                }, 15000);
                
                // Actualizar tiempo de alimentaci√≥n
                this.fish.lastFeedTime = Date.now();
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üèÉ ¬°Pez activado en modo persecuci√≥n! Velocidad x1.5 (m√°s natural)');
            }
            
            // üçΩÔ∏è ALIMENTAR DESDE BURBUJA (MODO ORIGINAL)
            feedFish() {
                if (!this.fish) return;
                
                // Actualizar tiempo de √∫ltima comida
                this.fish.lastFeedTime = Date.now();
                
                // Ocultar burbuja
                const hungerBubble = document.getElementById('hungerBubble');
                if (hungerBubble) {
                    hungerBubble.style.display = 'none';
                }
                
                // Efectos de alimentaci√≥n
                this.createFeedingEffects();
                
                // Aumentar felicidad
                this.gameState.happiness = Math.min(100, this.gameState.happiness + 20);
                
                console.log('üçΩÔ∏è Pez alimentado - Felicidad:', this.gameState.happiness);
            }
            
            createFeedingEffects() {
                // Crear part√≠culas de comida cayendo
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.createFoodParticle();
                    }, i * 100);
                }
            }
            
            createFoodParticle() {
                if (!this.fish) return;
                
                const particle = {
                    x: this.fish.x + (Math.random() - 0.5) * 40,
                    y: this.fish.y - 50,
                    vy: 30 + Math.random() * 20,
                    life: 2,
                    maxLife: 2,
                    size: 3 + Math.random() * 3
                };
                
                // A√±adir a array de part√≠culas (si no existe, crear)
                if (!this.foodParticles) this.foodParticles = [];
                this.foodParticles.push(particle);
            }
            
            // üçñ CREAR COMIDA CON POSICIONES ESTRAT√âGICAS
            createFallingFood(foodNumber) {
                if (!this.fallingFood) this.fallingFood = [];
                
                let startX;
                if (this.fish) {
                    const fishX = this.fish.x;
                    const canvasWidth = this.canvas.width;
                    
                    // POSICIONES ESTRAT√âGICAS para cada comida
                    switch(foodNumber) {
                        case 1:
                            // Primera: A la izquierda del pez
                            startX = Math.max(80, fishX - 80 - Math.random() * 60);
                            break;
                        case 2:
                            // Segunda: A la derecha del pez
                            startX = Math.min(canvasWidth - 80, fishX + 80 + Math.random() * 60);
                            break;
                        case 3:
                            // Tercera: Cerca del pez (arriba o centro)
                            startX = fishX + (Math.random() - 0.5) * 100;
                            startX = Math.max(80, Math.min(canvasWidth - 80, startX));
                            break;
                        default:
                            startX = 100 + Math.random() * (canvasWidth - 200);
                    }
                } else {
                    // Si no hay pez, usar posici√≥n aleatoria
                    startX = 100 + Math.random() * (this.canvas.width - 200);
                }
                
                const food = {
                    x: startX,
                    y: this.canvas.height * 0.25, // Un poco m√°s abajo
                    vy: 18 + Math.random() * 8, // Velocidad m√°s lenta para dar tiempo
                    size: 9 + Math.random() * 3, // Tama√±o m√°s visible
                    life: 18, // M√°s tiempo para comer
                    maxLife: 18,
                    eaten: false,
                    type: Math.random() > 0.8 ? 'premium' : 'normal',
                    number: foodNumber
                };
                
                this.fallingFood.push(food);
                console.log(`üçñ Comida #${foodNumber} creada en x:${startX.toFixed(0)} (${foodNumber === 1 ? 'IZQUIERDA' : foodNumber === 2 ? 'DERECHA' : 'CENTRO'})`);
            }
            
            drawFoodParticles() {
                if (!this.foodParticles) return;
                
                // Actualizar y dibujar part√≠culas
                for (let i = this.foodParticles.length - 1; i >= 0; i--) {
                    const particle = this.foodParticles[i];
                    
                    // Actualizar posici√≥n
                    particle.y += particle.vy * (1/60); // Asumiendo 60fps
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.foodParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula de comida
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    // Color marr√≥n/dorado para la comida
                    this.ctx.fillStyle = '#D2691E';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Peque√±o brillo
                    this.ctx.fillStyle = '#F4A460';
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x - 1, particle.y - 1, particle.size * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üçñ DIBUJAR Y ACTUALIZAR COMIDA CAYENDO
            drawFallingFood() {
                if (!this.fallingFood) return;
                
                // Actualizar y dibujar comida cayendo
                for (let i = this.fallingFood.length - 1; i >= 0; i--) {
                    const food = this.fallingFood[i];
                    
                    if (food.eaten) continue;
                    
                    // Actualizar posici√≥n
                    food.y += food.vy * (1/60);
                    food.life -= 1/60;
                    
                    // Eliminar si expir√≥ o sali√≥ de pantalla
                    if (food.life <= 0 || food.y > this.canvas.height + 50) {
                        this.fallingFood.splice(i, 1);
                        continue;
                    }
                    
                    // Verificar si el pez la alcanz√≥
                    if (this.fish && !food.eaten) {
                        const distance = Math.sqrt(
                            Math.pow(this.fish.x - food.x, 2) + 
                            Math.pow(this.fish.y - food.y, 2)
                        );
                        
                        if (distance < 30) { // Pez alcanz√≥ la comida (√°rea m√°s grande)
                            food.eaten = true;
                            this.createEatingEffect(food.x, food.y);
                            this.createBigEatingEffect(food.x, food.y, food.type);
                            console.log(`üçΩÔ∏è ¬°Pez comi√≥ comida ${food.type}! ¬°√ëAM √ëAM!`);
                            
                            // ACTUALIZAR TIEMPO DE COMIDA Y ESTADO
                            this.fish.lastFeedTime = Date.now();
                            this.fish.excited = true; // ¬°FELIZ AL COMER!
                            console.log('üòä ¬°Pez feliz despu√©s de comer!');
                            
                            // Quitar felicidad despu√©s de 3 segundos
                            setTimeout(() => {
                                this.fish.excited = false;
                            }, 3000);
                            
                            // Quitar comida despu√©s de un momento
                            setTimeout(() => {
                                const index = this.fallingFood.indexOf(food);
                                if (index > -1) this.fallingFood.splice(index, 1);
                            }, 100);
                            continue;
                        }
                        
                    }
                    
                    // Dibujar comida
                    this.ctx.save();
                    
                    // Color seg√∫n tipo
                    const color = food.type === 'premium' ? '#FFD700' : '#D2691E';
                    const highlightColor = food.type === 'premium' ? '#FFF8DC' : '#F4A460';
                    
                    // Sombra
                    this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetY = 2;
                    
                    // Comida principal
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo
                    this.ctx.fillStyle = highlightColor;
                    this.ctx.beginPath();
                    this.ctx.arc(food.x - 2, food.y - 2, food.size * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Si el pez est√° persiguiendo, encontrar la comida m√°s cercana
                if (this.fish && this.fish.isChasing && this.fallingFood.length > 0) {
                    this.findAndChaseClosestFood();
                }
            }
            
            // üîç ENCONTRAR Y PERSEGUIR LA COMIDA M√ÅS CERCANA
            findAndChaseClosestFood() {
                if (!this.fallingFood || this.fallingFood.length === 0) return;
                
                const fish = this.fish;
                let closestFood = null;
                let closestDistance = Infinity;
                
                // Encontrar la comida m√°s cercana
                for (const food of this.fallingFood) {
                    if (food.eaten) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(fish.x - food.x, 2) + 
                        Math.pow(fish.y - food.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
                
                // Si encontramos comida, perseguirla
                if (closestFood) {
                    this.makeFishChaseFood(closestFood);
                }
            }
            
            // üèÉ HACER QUE EL PEZ PERSIGA LA COMIDA (SIN GIROS LOCOS)
            makeFishChaseFood(food) {
                const fish = this.fish;
                
                // Calcular direcci√≥n hacia la comida
                const dx = food.x - fish.x;
                const dy = food.y - fish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Velocidad de persecuci√≥n m√°s natural
                    const chaseSpeed = fish.chaseSpeed || (fish.speed * 1.5); // 50% m√°s r√°pido
                    
                    // Normalizar y aplicar velocidad
                    fish.vx = (dx / distance) * chaseSpeed;
                    fish.vy = (dy / distance) * chaseSpeed;
                    
                    // SOLO cambiar orientaci√≥n si hay un cambio SIGNIFICATIVO
                    const significantChange = Math.abs(dx) > 20; // Solo si est√° a m√°s de 20px
                    if (significantChange) {
                        const newDirection = dx > 0 ? 1 : -1;
                        // Solo cambiar si es realmente diferente
                        if (newDirection !== fish.direction) {
                            fish.direction = newDirection;
                            console.log(`üîÑ Pez cambi√≥ orientaci√≥n: ${fish.direction === 1 ? 'DERECHA' : 'IZQUIERDA'}`);
                        }
                    }
                    
                    // Log menos spam
                    if (Math.random() < 0.1) { // Solo 10% de las veces
                        console.log(`üèÉ Persiguiendo comida: ${distance.toFixed(0)}px`);
                    }
                }
            }
            
            // ‚ú® EFECTO AL COMER
            createEatingEffect(x, y) {
                // Peque√±as part√≠culas al comer
                for (let i = 0; i < 5; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 30,
                        vy: (Math.random() - 0.5) * 30,
                        life: 0.5,
                        maxLife: 0.5,
                        size: 2 + Math.random() * 2,
                        color: '#FFD700'
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
            }
            
            // üí• EFECTO GRANDE AL COMER
            createBigEatingEffect(x, y, type) {
                // Crear muchas part√≠culas espectaculares
                const particleCount = type === 'premium' ? 15 : 10;
                const colors = type === 'premium' 
                    ? ['#FFD700', '#FFF8DC', '#FFFF00', '#FFE55C'] 
                    : ['#D2691E', '#F4A460', '#DEB887', '#CD853F'];
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 40 + Math.random() * 30;
                    
                    const particle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.5,
                        maxLife: 1.5,
                        size: 3 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    };
                    
                    if (!this.eatingEffects) this.eatingEffects = [];
                    this.eatingEffects.push(particle);
                }
                
                // Texto "√ëAM √ëAM" flotante
                this.createFloatingText(x, y, type === 'premium' ? '¬°√ëAM √ëAM!' : '√±am √±am', 
                                       type === 'premium' ? '#FFD700' : '#D2691E');
            }
            
            // üìù TEXTO FLOTANTE
            createFloatingText(x, y, text, color) {
                const textEffect = {
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 2,
                    maxLife: 2,
                    vy: -30 // Flota hacia arriba
                };
                
                if (!this.floatingTexts) this.floatingTexts = [];
                this.floatingTexts.push(textEffect);
            }
            
            // üé® DIBUJAR EFECTOS DE COMER
            drawEatingEffects() {
                if (!this.eatingEffects) return;
                
                for (let i = this.eatingEffects.length - 1; i >= 0; i--) {
                    const particle = this.eatingEffects[i];
                    
                    // Actualizar part√≠cula
                    particle.x += particle.vx * (1/60);
                    particle.y += particle.vy * (1/60);
                    particle.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (particle.life <= 0) {
                        this.eatingEffects.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar part√≠cula
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // üìù DIBUJAR TEXTOS FLOTANTES
            drawFloatingTexts() {
                if (!this.floatingTexts) return;
                
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    
                    // Actualizar texto
                    text.y += text.vy * (1/60);
                    text.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar texto
                    const alpha = text.life / text.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.fillStyle = text.color;
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.textAlign = 'center';
                    
                    // Contorno blanco
                    this.ctx.strokeText(text.text, text.x, text.y);
                    // Texto principal
                    this.ctx.fillText(text.text, text.x, text.y);
                    
                    this.ctx.restore();
                }
            }
            
            // ‚è∞ AVANZAR TIEMPO DEL JUEGO (DEBUG)
            advanceGameTime(hours) {
                if (!this.fish) return;
                
                const timeAdvance = hours * 60 * 60 * 1000; // Convertir horas a milisegundos
                
                // Avanzar TODOS los tiempos del juego
                if (this.fish.lastFeedTime) {
                    this.fish.lastFeedTime -= timeAdvance; // Retroceder = como si hubiera pasado tiempo
                }
                
                if (this.gameState.lastPlay) {
                    this.gameState.lastPlay -= timeAdvance;
                }
                
                if (this.gameState.lastClean) {
                    this.gameState.lastClean -= timeAdvance;
                }
                
                if (this.gameState.birthDate) {
                    this.gameState.birthDate -= timeAdvance; // Hacer m√°s viejo
                }
                
                // Actualizar edad
                this.updateAgeDisplay();
                
                console.log(`‚è∞ Tiempo del juego avanzado +${hours} hora(s)`);
                console.log(`üçΩÔ∏è √öltima comida: hace ${Math.round((Date.now() - this.fish.lastFeedTime) / (60*60*1000))} horas`);
            }
            
            // üéÆ ACTUALIZAR ESTADO DE BOTONES
            updateButtonStates() {
                if (!this.fish) return;
                
                const currentTime = Date.now();
                const currentStage = this.gameState.stage;
                
                // Configurar umbrales seg√∫n la edad
                let hungerThreshold, cleanThreshold, medicineThreshold;
                
                switch(currentStage) {
                    case 'baby':
                        hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                        cleanThreshold = 24 * 60 * 60 * 1000; // 1 d√≠a
                        medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas descuido
                        break;
                    case 'young':
                        hungerThreshold = 6 * 60 * 60 * 1000; // 6 horas
                        cleanThreshold = 2 * 24 * 60 * 60 * 1000; // 2 d√≠as
                        medicineThreshold = 14 * 60 * 60 * 1000; // 14 horas
                        break;
                    case 'adult':
                        hungerThreshold = 8 * 60 * 60 * 1000; // 8 horas
                        cleanThreshold = 3 * 24 * 60 * 60 * 1000; // 3 d√≠as
                        medicineThreshold = 26 * 60 * 60 * 1000; // 26 horas
                        break;
                    default:
                        hungerThreshold = 4 * 60 * 60 * 1000;
                        cleanThreshold = 24 * 60 * 60 * 1000;
                        medicineThreshold = 8 * 60 * 60 * 1000;
                }
                
                // Verificar necesidades BASADAS EN LOS VALORES REALES
                const needsFood = this.gameState.needs.hunger > 60; // Si hambre > 60%, activar bot√≥n
                const needsCleaning = this.gameState.needs.dirt > 70; // Si suciedad > 70%, activar bot√≥n  
                const needsMedicine = this.gameState.lastMedicine && (currentTime - this.gameState.lastMedicine) > medicineThreshold;
                
                // Actualizar botones (MEDICINA ELIMINADA)
                this.toggleButton('feedBtn', needsFood);
                this.toggleButton('cleanBtn', needsCleaning);
                // this.toggleButton('medicineBtn', needsMedicine); // ELIMINADO
            }
            
            // üîò HABILITAR/DESHABILITAR BOT√ìN
            toggleButton(buttonId, enabled) {
                const button = document.getElementById(buttonId);
                if (!button) return;
                
                if (enabled) {
                    button.classList.remove('disabled');
                    button.onclick = () => {
                        switch(buttonId) {
                            case 'feedBtn': this.startFeeding(); break;
                            case 'cleanBtn': this.startCleaning(); break;
                            // case 'medicineBtn': this.giveMedicine(); break; // ELIMINADO
                        }
                    };
                } else {
                    button.classList.add('disabled');
                    button.onclick = () => {
                        console.log(`‚ùå ${buttonId}: El pez no necesita esto ahora`);
                    };
                }
            }
            
            // üßΩ LIMPIAR ACUARIO - EFECTO COMPLETO CON BURBUJAS Y TIRABUZONES
            startCleaning() {
                console.log('üßΩ Limpiando acuario...');
                
                // Actualizar stats
                this.gameState.lastClean = Date.now();
                this.gameState.cleanliness = Math.min(100, this.gameState.cleanliness + 30);
                
                // EFECTO DE LIMPIEZA: Burbujas que rodean al pez
                this.fish.isCleaning = true;
                this.fish.cleaningTime = 0;
                this.fish.cleaningDuration = 5; // 5 segundos de limpieza
                
                // Crear MUCHAS burbujas de limpieza
                this.cleaningBubbles = [];
                for (let i = 0; i < 60; i++) {
                    this.createCleaningBubble();
                }
                
                // M√°s burbujas cada 200ms durante la limpieza
                this.cleaningInterval = setInterval(() => {
                    if (this.fish.isCleaning) {
                        for (let i = 0; i < 8; i++) {
                            this.createCleaningBubble();
                        }
                    }
                }, 200);
                
                // Terminar limpieza despu√©s de 5 segundos
                setTimeout(() => {
                    this.finishCleaning();
                }, 5000);
                
                console.log('‚ú® ¬°Efecto de limpieza iniciado! Burbujas y tirabuzones');
            }
            
            createCleaningBubble() {
                if (!this.cleaningBubbles) this.cleaningBubbles = [];
                
                // Burbujas que aparecen cerca del pez
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 100;
                
                this.cleaningBubbles.push({
                    x: this.fish.x + Math.cos(angle) * distance,
                    y: this.fish.y + Math.sin(angle) * distance,
                    size: 3 + Math.random() * 8,
                    vx: (Math.random() - 0.5) * 40,
                    vy: -20 - Math.random() * 30,
                    life: 3 + Math.random() * 2,
                    maxLife: 3 + Math.random() * 2,
                    sparkle: Math.random() < 0.3
                });
            }
            
            finishCleaning() {
                this.fish.isCleaning = false;
                this.fish.cleaningTime = 0;
                
                // Parar creaci√≥n de nuevas burbujas
                if (this.cleaningInterval) {
                    clearInterval(this.cleaningInterval);
                    this.cleaningInterval = null;
                }
                
                // Las burbujas existentes seguir√°n hasta desaparecer naturalmente
                console.log('‚ú® Limpieza terminada - Acuario brillante');
            }
            
            // ü´ß SISTEMA DE BURBUJAS CON ICONOS DE NECESIDADES
            updateNeedBubbles(deltaTime) {
                if (!this.fish || this.gameState.stage === 'egg') return;
                
                const fish = this.fish;
                fish.needBubbleTimer += deltaTime;
                
                // Crear burbuja cada 3-5 segundos si tiene necesidades
                if (fish.needBubbleTimer > 3 + Math.random() * 2) {
                    fish.needBubbleTimer = 0;
                    
                    const currentTime = Date.now();
                    const currentStage = this.gameState.stage;
                    
                    // Verificar necesidades
                    const timeSinceFood = fish.lastFeedTime ? currentTime - fish.lastFeedTime : 0;
                    const timeSincePlay = this.gameState.lastPlay ? currentTime - this.gameState.lastPlay : 0;
                    const timeSinceMedicine = this.gameState.lastMedicine ? currentTime - this.gameState.lastMedicine : 0;
                    
                    // Umbrales
                    const hungerThreshold = 4 * 60 * 60 * 1000; // 4 horas
                    const playThreshold = 5 * 60 * 60 * 1000;   // 5 horas
                    const medicineThreshold = 8 * 60 * 60 * 1000; // 8 horas
                    
                    // Crear burbujas seg√∫n necesidades (en orden de prioridad)
                    if (timeSinceFood > hungerThreshold) {
                        this.createNeedBubble('./images/ui/badge_hunger.png', '#ff5555');
                        console.log('ü´ß Burbuja de HAMBRE creada');
                    }
                    
                    if (timeSinceMedicine > medicineThreshold) {
                        this.createNeedBubble('./images/ui/badge_medicine.png', '#55ff55');
                        console.log('ü´ß Burbuja de MEDICINA creada');
                    }
                    
                    if (timeSincePlay > playThreshold) {
                        this.createNeedBubble('./images/ui/badge_play.png', '#ffaa55');
                        console.log('ü´ß Burbuja de JUEGO creada');
                    }
                }
                
                // Actualizar burbujas existentes
                this.updateExistingNeedBubbles(deltaTime);
            }
            
            createNeedBubble(icon, color) {
                if (!this.fish) return;
                
                // Posici√≥n desde la boca del pez
                const fish = this.fish;
                const direction = fish.direction || 1;
                const mouthX = fish.x + (direction > 0 ? 30 : -30); // Boca del pez
                const mouthY = fish.y;
                
                this.needBubbles.push({
                    x: mouthX,
                    y: mouthY,
                    vx: (Math.random() - 0.5) * 3, // MUY lento horizontal
                    vy: -8 - Math.random() * 5, // MUY lento hacia arriba
                    size: 22, // Tama√±o para ver bien el icono
                    life: 5 + Math.random() * 2, // Duran m√°s tiempo
                    maxLife: 5 + Math.random() * 2,
                    iconPath: icon, // Ruta de la imagen PNG
                    color: color,
                    alpha: 1,
                    iconImage: null // Se cargar√° din√°micamente
                });
            }
            
            updateExistingNeedBubbles(deltaTime) {
                if (!this.needBubbles) return;
                
                for (let i = this.needBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.needBubbles[i];
                    
                    // Actualizar posici√≥n (COMO BURBUJAS NORMALES)
                    bubble.x += bubble.vx; // Sin deltaTime - movimiento frame por frame
                    bubble.y += bubble.vy;
                    bubble.life -= deltaTime;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.needBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Actualizar alpha
                    bubble.alpha = bubble.life / bubble.maxLife;
                }
            }
            
            drawNeedBubbles() {
                if (!this.needBubbles || this.needBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (const bubble of this.needBubbles) {
                    this.ctx.globalAlpha = bubble.alpha * 0.7; // M√ÅS TRANSL√öCIDA
                    
                    // Dibujar burbuja base (m√°s transl√∫cida)
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.strokeStyle = bubble.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = bubble.color;
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Cargar y dibujar icono PNG
                    if (!bubble.iconImage) {
                        bubble.iconImage = new Image();
                        bubble.iconImage.src = bubble.iconPath;
                    }
                    
                    if (bubble.iconImage && bubble.iconImage.complete) {
                        this.ctx.globalAlpha = bubble.alpha;
                        const iconSize = bubble.size * 0.7;
                        this.ctx.drawImage(
                            bubble.iconImage,
                            bubble.x - iconSize/2,
                            bubble.y - iconSize/2,
                            iconSize,
                            iconSize
                        );
                    }
                    
                    this.ctx.shadowBlur = 0; // Limpiar sombra
                }
                
                this.ctx.restore();
            }
            
            // ‚ú® DIBUJAR BURBUJAS DE LIMPIEZA
            drawCleaningBubbles() {
                if (!this.cleaningBubbles || this.cleaningBubbles.length === 0) return;
                
                this.ctx.save();
                
                for (let i = this.cleaningBubbles.length - 1; i >= 0; i--) {
                    const bubble = this.cleaningBubbles[i];
                    
                    // Actualizar burbuja
                    bubble.x += bubble.vx * (1/60);
                    bubble.y += bubble.vy * (1/60);
                    bubble.life -= 1/60;
                    
                    // Eliminar si expir√≥
                    if (bubble.life <= 0) {
                        this.cleaningBubbles.splice(i, 1);
                        continue;
                    }
                    
                    // Dibujar burbuja de limpieza
                    const alpha = bubble.life / bubble.maxLife;
                    this.ctx.globalAlpha = alpha * 0.8;
                    
                    // Color azul brillante para limpieza
                    if (bubble.sparkle) {
                        this.ctx.fillStyle = '#ffffff'; // Burbujas brillantes
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#00bfff';
                    } else {
                        this.ctx.fillStyle = '#87ceeb'; // Burbujas normales azul cielo
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#4169e1';
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brillo interno
                    this.ctx.globalAlpha = alpha * 0.4;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // üéÆ FUNCIONES DE JUEGOS
            playBubbleGame() {
                this.showCustomModal({
                    title: 'ü´ß Juego de Burbujas',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüéÆ ¬°Ser√° s√∫per divertido!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            playMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: 'üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\nüöß Pr√≥ximamente disponible...\n\nüß† ¬°Ser√° s√∫per desafiante!',
                    confirmText: 'üëç ¬°Esperar√©!',
                    onConfirm: () => {}
                });
            }
            
            showGameLocked(starsNeeded) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesitamos m√°s estrellas para este juego!"\n\n‚≠ê Tienes: ${this.gameState.stars || 0} estrellas\n‚≠ê Necesitas: ${starsNeeded} estrellas\n\nüéÆ ¬°Juega otros juegos para ganar estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            startGame(gameId) {
                // Cerrar modal de juegos
                document.getElementById('gamesModal').style.display = 'none';
                
                switch(gameId) {
                    case 'bubbles':
                        this.startBubbleGame();
                        break;
                    case 'memory':
                        this.startMemoryGame();
                        break;
                    default:
                        this.showCustomModal({
                            title: 'üöß En Desarrollo',
                            message: `üê†üí≠ "¬°Este juego est√° en desarrollo!"\n\n‚ú® Pr√≥ximamente disponible...`,
                            confirmText: 'üëç ¬°Esperar√©!',
                            onConfirm: () => {}
                        });
                }
            }

            showGameLocked(starsRequired) {
                this.showCustomModal({
                    title: 'üîí Juego Bloqueado',
                    message: `üê†üí≠ "¬°Necesito m√°s estrellas para jugar!"\n\n‚≠ê Necesitas: ${starsRequired} estrellas\n‚≠ê Tienes: ${this.gameState.stars}\n\nüéÆ ¬°Juega m√°s para conseguir estrellas!`,
                    confirmText: 'üí™ ¬°Entendido!',
                    onConfirm: () => {}
                });
            }
            
            // üåä MODAL DE RESET EMOTIVO
            showResetModal() {
                const fishName = this.gameState.fishName || 'tu pececito';
                
                this.showCustomModal({
                    title: 'üåä Despedida de tu Pececito',
                    message: `üê†üí≠ "${fishName === 'tu pececito' ? 'Hola' : 'Soy ' + fishName}... ¬øde verdad me vas a dejar libre?"

üè† Volver√© al oc√©ano infinito y ser√© feliz
üíï Siempre recordar√© nuestros momentos juntos
üéÆ Podr√°s cuidar a un nuevo compa√±ero
üì∏ Nuestros recuerdos quedar√°n en mi coraz√≥n

‚ö†Ô∏è **Se perder√° todo el progreso actual**
ü´ß Burbujas: ${this.gameState.bubbles || 0}
‚≠ê Estrellas: ${this.gameState.stars || 0}
üìÖ D√≠as juntos: ${this.gameState.ageInDays || 0}`,
                    confirmText: 'üåä ¬°S√© libre y feliz!',
                    cancelText: 'üíï ¬°No, te quiero!',
                    onConfirm: () => {
                        this.showCustomModal({
                            title: 'üåä ¬°Hasta siempre!',
                            message: `üê†üíï "¬°Gracias por todo! ¬°Fui muy feliz contigo!"\n\nüåä *Nada hacia el oc√©ano infinito*\n\n‚ú® Tu nueva aventura comenzar√° en un momento...`,
                            confirmText: 'üëã ¬°Adi√≥s!',
                            onConfirm: () => {
                                // Limpiar localStorage y recargar
                                localStorage.clear();
                                location.reload();
                            }
                        });
                    },
                    onCancel: () => {
                        this.showCustomModal({
                            title: 'üíï ¬°Qu√© alegr√≠a!',
                            message: `üê†üí≠ "¬°Sab√≠a que no me abandonar√≠as!"\n\n¬°Sigamos siendo los mejores amigos! üéÆ\n\nüí™ ¬°Vamos a vivir m√°s aventuras juntos!`,
                            confirmText: 'ü•∞ ¬°Siempre juntos!',
                            onConfirm: () => {}
                        });
                    }
                });
            }

            // üéÆ Pantalla de carga personalizada con nombre del pez
            showLoadingWithFishName() {
                const savedData = localStorage.getItem('miPececito_gameState');
                let fishName = 'tu pececito';
                
                if (savedData) {
                    try {
                        const gameData = JSON.parse(savedData);
                        fishName = gameData.fishName || 'tu pececito';
                    } catch (e) {
                        console.log('Error leyendo nombre del pez');
                    }
                }

                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.innerHTML = `
                    <div class="loading-content">
                        <div class="logo-container">
                            <img src="./images/ui/logo.png" alt="Mi Pececito" class="loading-logo">
                        </div>
                        <div class="loading-text">
                            <h2>üê† Cargando a ${fishName}...</h2>
                            <div class="loading-dots">
                                <span>.</span><span>.</span><span>.</span>
                            </div>
                        </div>
                    </div>
                `;
                
                loadingScreen.style.display = 'flex';
                
                // Ocultar despu√©s de 1.5 segundos
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1500);
            }

            // üíÄ A√±adir bot√≥n reset al men√∫ solo si ya tienes pez
            addResetButtonToMenu() {
                const actionBar = document.querySelector('.action-bar');
                if (!document.getElementById('resetButton')) {
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'menu-btn';
                    resetBtn.id = 'resetButton';
                    resetBtn.title = 'Cuidar otro pececito';
                    resetBtn.innerHTML = '<div class="btn-icon">üíÄ</div>';
                    
                    resetBtn.addEventListener('click', () => {
                        this.showResetModal();
                    });
                    
                    actionBar.appendChild(resetBtn);
                    console.log('üíÄ Bot√≥n reset a√±adido al men√∫');
                }
            }
            
            // ü´ß JUEGO DE BURBUJAS - DIRECTO
            startBubbleGame() {
                console.log('ü´ß Iniciando juego de burbujas...');
                // Ir directo al juego sin modal previo
                this.runBubbleGame();
            }
            
            runBubbleGame() {
                // Crear overlay del juego completo
                const gameOverlay = document.createElement('div');
                gameOverlay.id = 'bubbleGameOverlay';
                gameOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                    z-index: 2000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    padding: 20px;
                    font-family: 'Comic Sans MS', cursive;
                    overflow: hidden;
                `;

                // UI del juego
                const gameUI = document.createElement('div');
                gameUI.style.cssText = `
                    color: white;
                    text-align: center;
                    margin-bottom: 15px;
                    font-size: 20px;
                    font-weight: bold;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
                    background: rgba(255,255,255,0.1);
                    padding: 10px 20px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.3);
                `;
                gameUI.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                        <div>‚è±Ô∏è Tiempo: <span id="bubbleTimer">20</span>s</div>
                        <div>ü´ß Puntos: <span id="bubbleScore">0</span></div>
                        <button id="exitGameBtn" style="
                            background: rgba(255,255,255,0.2);
                            border: 2px solid rgba(255,255,255,0.5);
                            border-radius: 50%;
                            width: 40px;
                            height: 40px;
                            color: white;
                            font-size: 18px;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">‚ùå</button>
                    </div>
                    <div style="
                        color: rgba(255,255,255,0.8);
                        font-size: 12px;
                        text-align: center;
                        margin-top: 8px;
                        line-height: 1.3;
                    ">
                        üîµ Toca burbujas azules (+3 pts +tiempo) üî¥ Evita rojas (-2 pts)<br>
                        ‚≠ê 1 estrella por jugar ‚Ä¢ 2 por r√©cord personal ‚Ä¢ 3 por r√©cord global
                    </div>
                `;

                const gameArea = document.createElement('div');
                gameArea.id = 'bubbleGameArea';
                gameArea.style.cssText = `
                    position: relative;
                    width: 100%;
                    max-width: 350px;
                    height: 450px;
                    border-radius: 20px;
                    overflow: hidden;
                    cursor: pointer;
                    background: rgba(255,255,255,0.05);
                    border: 3px solid rgba(255,255,255,0.2);
                `;

                gameOverlay.appendChild(gameUI);
                gameOverlay.appendChild(gameArea);
                document.body.appendChild(gameOverlay);

                // Bot√≥n de salir
                document.getElementById('exitGameBtn').addEventListener('click', () => {
                    gameActive = false;
                    clearInterval(gameTimer);
                    clearInterval(bubbleSpawner);
                    document.body.removeChild(gameOverlay);
                    if (document.head.contains(style)) {
                        document.head.removeChild(style);
                    }
                });

                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                let baseSpawnRate = 800; // Velocidad base de aparici√≥n
                let currentSpawnRate = baseSpawnRate;
                let gameStartTime = Date.now();
                
                // Sistema de r√©cords
                const personalRecord = parseInt(localStorage.getItem('bubbleGame_personalRecord') || '0');
                const globalRecord = parseInt(localStorage.getItem('bubbleGame_globalRecord') || '50'); // R√©cord global inicial

                // Actualizar UI
                const updateUI = () => {
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    document.getElementById('bubbleScore').textContent = score;
                };

                // Crear burbuja
                const createBubble = () => {
                    if (!gameActive) return;

                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35; // 65% buenas, 35% malas
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        border-radius: 50%;
                        background: ${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid ${isGood ? '#ffffff' : '#ffdddd'};
                        box-shadow: 0 0 12px ${isGood ? 'rgba(135,206,235,0.8)' : 'rgba(255,107,107,0.8)'};
                        cursor: pointer;
                        animation: bubbleFloat 3.5s linear;
                        top: 100%;
                        left: ${Math.random() * (350 - size)}px;
                        z-index: 1001;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${size * 0.4}px;
                        color: white;
                        font-weight: bold;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                    `;

                    bubble.innerHTML = isGood ? 'üîµ' : 'üî¥';
                    bubble.dataset.good = isGood;
                    
                    bubble.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!gameActive) return;

                        if (isGood) {
                            score += 3;
                            // ‚è∞ A√ëADIR TIEMPO POR BURBUJA BUENA
                            timeLeft += 1; // +1 segundo por burbuja buena
                            bubble.style.background = 'radial-gradient(circle, #00ff88, #32cd32)';
                            bubble.innerHTML = '+3 +1s';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                            
                            // üöÄ AUMENTAR DIFICULTAD PROGRESIVAMENTE
                            if (score > 0 && score % 15 === 0) { // Cada 15 puntos
                                currentSpawnRate = Math.max(300, currentSpawnRate - 50); // M√°s r√°pido, m√≠nimo 300ms
                                console.log(`üöÄ Dificultad aumentada: ${currentSpawnRate}ms`);
                            }
                        } else {
                            score = Math.max(0, score - 2);
                            bubble.style.background = 'radial-gradient(circle, #ff4444, #dc143c)';
                            bubble.innerHTML = '-2';
                            bubble.style.fontSize = (size * 0.4) + 'px';
                        }
                        
                        updateUI();
                        
                        setTimeout(() => {
                            if (bubble.parentNode) bubble.remove();
                        }, 600);
                    });

                    gameArea.appendChild(bubble);
                    bubbles.push(bubble);

                    // Remover burbuja despu√©s de la animaci√≥n
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                        const index = bubbles.indexOf(bubble);
                        if (index > -1) bubbles.splice(index, 1);
                    }, 3500);
                };

                // A√±adir CSS de animaci√≥n
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes bubbleFloat {
                        0% { 
                            transform: translateY(0) rotate(0deg) scale(0.8);
                            opacity: 0.7;
                        }
                        10% { 
                            opacity: 1;
                            transform: translateY(-40px) rotate(20deg) scale(1);
                        }
                        100% { 
                            transform: translateY(-500px) rotate(360deg) scale(0.9);
                            opacity: 0.8;
                        }
                    }
                `;
                document.head.appendChild(style);

                // Timer del juego
                const gameTimer = setInterval(() => {
                    timeLeft--;
                    updateUI();

                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        clearInterval(bubbleSpawner);
                        
                        // Finalizar juego
                        setTimeout(() => {
                            document.body.removeChild(gameOverlay);
                            document.head.removeChild(style);
                            
                            // Actualizar burbujas del jugador
                            const finalScore = Math.max(0, score);
                            this.gameState.bubbles += finalScore;
                            
                            // ‚≠ê SISTEMA DE ESTRELLAS SEG√öN RENDIMIENTO
                            let starsEarned = 1; // 1 estrella por jugar
                            let achievement = 'Partida completada';
                            
                            if (finalScore > personalRecord) {
                                starsEarned = 2; // 2 estrellas por r√©cord personal
                                achievement = '¬°Nuevo r√©cord personal!';
                                localStorage.setItem('bubbleGame_personalRecord', finalScore.toString());
                            }
                            
                            if (finalScore > globalRecord) {
                                starsEarned = 3; // 3 estrellas por r√©cord global
                                achievement = '¬°R√âCORD GLOBAL! ¬°Eres incre√≠ble!';
                                localStorage.setItem('bubbleGame_globalRecord', finalScore.toString());
                            }
                            
                            this.gameState.stars += starsEarned;
                            
                            // üéÜ EFECTOS VISUALES DE RECOMPENSA
                            if (finalScore > 0) {
                                this.showRewardEffect('bubbles', finalScore);
                                setTimeout(() => {
                                    this.showRewardEffect('stars', starsEarned);
                                }, 800);
                            }
                            
                            this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                            this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                            this.saveGame();

                            // Mostrar resultado
                            this.showCustomModal({
                                title: starsEarned === 3 ? 'üèÜ ¬°R√âCORD GLOBAL!' : starsEarned === 2 ? 'üéâ ¬°Nuevo R√©cord!' : 'üéÆ ¬°Bien Jugado!',
                                message: `üê†üí≠ "${achievement}"\n\nü´ß Puntos: ${finalScore}\n‚≠ê Estrellas ganadas: ${starsEarned}\nüìä R√©cord personal: ${Math.max(personalRecord, finalScore)}\nüèÜ R√©cord global: ${Math.max(globalRecord, finalScore)}\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                                confirmText: 'üéÆ ¬°Genial!'
                            });
                        }, 1000);
                    }
                }, 1000);

                // Spawner de burbujas din√°mico
                const bubbleSpawner = setInterval(() => {
                    if (gameActive) {
                        createBubble();
                    }
                }, currentSpawnRate);

                // Actualizar spawner din√°micamente
                const updateSpawner = setInterval(() => {
                    if (!gameActive) {
                        clearInterval(updateSpawner);
                        return;
                    }
                    clearInterval(bubbleSpawner);
                    const newSpawner = setInterval(() => {
                        if (gameActive) createBubble();
                    }, currentSpawnRate);
                }, 1000);

                // Crear burbujas iniciales
                setTimeout(() => createBubble(), 300);
                setTimeout(() => createBubble(), 800);
                setTimeout(() => createBubble(), 1200);
            }
            
            // üß† JUEGO DE MEMORIA
            startMemoryGame() {
                this.showCustomModal({
                    title: 'üß† Juego de Memoria',
                    message: `üê†üí≠ "¬°A ejercitar la mente!"\n\nüéØ **Objetivo:**\nEncuentra todas las parejas de cartas\nRecuerda d√≥nde est√°n las im√°genes\n\nüèÜ **Recompensas:**\n+3 burbujas por pareja encontrada\nBonus de velocidad\n\nüÉè Cartas: 8 parejas (16 cartas)`,
                    confirmText: 'üß† ¬°Empezar!',
                    cancelText: '‚ùå Cancelar',
                    onConfirm: () => {
                        this.runMemoryGame();
                    }
                });
            }
            
            runMemoryGame() {
                // Implementaci√≥n del juego de memoria
                this.showCustomModal({
                    title: 'üß† ¬°Jugando Memoria!',
                    message: `üéÆ **DEMO DEL JUEGO**\n\nüÉè Parejas encontradas: 6/8\nüëÅÔ∏è Cartas volteadas: 18\n‚è±Ô∏è Tiempo: 45s\n\nüèÜ Puntuaci√≥n actual: +18 burbujas`,
                    confirmText: '‚úÖ Terminar',
                    onConfirm: () => {
                        // Dar recompensa
                        this.gameState.bubbles += 18;
                        this.gameState.stars += 3;
                        this.updateUI();
                        
                        this.showCustomModal({
                            title: 'üèÜ ¬°Excelente Memoria!',
                            message: `üê†üí≠ "¬°Tienes una memoria incre√≠ble!"\n\nüéâ **Recompensas obtenidas:**\nü´ß +18 burbujas\n‚≠ê +3 estrellas\n\nüí∞ Total: ü´ß ${this.gameState.bubbles} | ‚≠ê ${this.gameState.stars}`,
                            confirmText: 'ü•∞ ¬°Gracias!',
                            onConfirm: () => {}
                        });
                    }
                });
            }
            
            // üíä DAR MEDICINA (PLACEHOLDER)
            giveMedicine() {
                console.log('üíä Dando medicina al pez...');
                this.gameState.lastMedicine = Date.now();
                this.gameState.health = Math.min(100, this.gameState.health + 40);
                console.log('üè• Pez curado - Salud:', this.gameState.health);
            }

            // üí∞ SISTEMA DE COSTOS PROGRESIVOS
            getBackgroundCost(bgName) {
                const costs = {
                    'cartoon': 15,   // Primer fondo - f√°cil de conseguir
                    'coral': 25,     // Segundo fondo
                    'mario': 40,     // M√°s caro
                    'minecraft': 60  // El m√°s caro
                };
                return costs[bgName] || 30; // Costo por defecto
            }

            // üéÜ EFECTOS DE RECOMPENSA
            showRewardEffect(type, amount, sourceElement = null) {
                const emoji = type === 'bubbles' ? 'ü´ß' : '‚≠ê';
                const color = type === 'bubbles' ? 'rgba(100,200,255,0.6)' : 'rgba(255,215,0,0.6)';
                
                // Posici√≥n de origen (elemento fuente o centro de pantalla)
                let startX, startY;
                if (sourceElement) {
                    const rect = sourceElement.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                } else {
                    startX = window.innerWidth / 2;
                    startY = window.innerHeight / 2;
                }

                // Crear m√∫ltiples burbujas seg√∫n la cantidad
                const bubbleCount = Math.min(amount, 5); // M√°ximo 5 burbujas
                for (let i = 0; i < bubbleCount; i++) {
                    setTimeout(() => {
                        this.createRewardBubble(emoji, color, startX, startY, i);
                    }, i * 150); // Delay escalonado
                }

                // Explosi√≥n dorada al final
                setTimeout(() => {
                    this.createRewardExplosion(startX, startY);
                }, bubbleCount * 150 + 500);
            }

            createRewardBubble(emoji, color, startX, startY, index) {
                const bubble = document.createElement('div');
                bubble.className = 'reward-bubble';
                bubble.textContent = emoji;
                bubble.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), ${color})`;
                bubble.style.boxShadow = `0 0 20px ${color}`;
                
                // Posici√≥n inicial con variaci√≥n
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 50;
                bubble.style.left = (startX + offsetX - 30) + 'px';
                bubble.style.top = (startY + offsetY - 30) + 'px';
                
                document.body.appendChild(bubble);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                }, 2000);
            }

            createRewardExplosion(x, y) {
                const explosion = document.createElement('div');
                explosion.className = 'reward-explosion';
                explosion.style.left = (x - 50) + 'px';
                explosion.style.top = (y - 50) + 'px';
                
                document.body.appendChild(explosion);
                
                // Limpiar despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.remove();
                    }
                }, 800);
            }

            // üéì MODAL DE TUTORIAL BONITO
            showTutorialModal() {
                this.showCustomModal({
                    title: 'Tu Primera Aventura Marina',
                    message: `"¬°Hola! Soy tu nuevo compa√±ero virtual."\n\nü•ö Primero aparecer√© como un huevito\n‚è∞ En 24 horas eclosionar√© y nadar√© contigo\nüéÆ Mientras tanto, puedes jugar minijuegos\n\n¬°Clica aqu√≠ y aparecer√° tu huevito de pez!`,
                    confirmText: '¬°Colocar mi huevo!',
                    onConfirm: () => {
                        // CERRAR MODAL PRIMERO para ver el efecto
                        const customModal = document.querySelector('.custom-modal');
                        if (customModal) {
                            customModal.remove();
                        }
                        
                        // Peque√±o delay para que se vea el cierre
                        setTimeout(() => {
                            this.startEggPlacement();
                        }, 300);
                    }
                });
            }

            // ü•ö INICIAR COLOCACI√ìN DEL HUEVO
            startEggPlacement() {
                console.log('‚ú® INICIANDO MAGIA DEL HUEVO...');
                
                // CERRAR MODAL INMEDIATAMENTE para que no se vea el huevo
                const modals = document.querySelectorAll('.custom-modal, .modal-overlay, .game-modal-overlay');
                modals.forEach(modal => {
                    modal.remove();
                    console.log('üö™ Modal eliminada');
                });
                
                // Tambi√©n ocultar cualquier modal por CSS
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    document.body.style.overflow = '';
                }, 100);
                
                // ASEGURAR que NO hay huevo todav√≠a
                this.gameState.stage = 'waiting';
                this.gameState.eggStartTime = null;
                
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                // PASO 1: Activar efectos m√°gicos INMEDIATAMENTE
                this.gameState.showMagicBubbles = true;
                this.gameState.magicStartTime = Date.now() * 0.001;
                    
                console.log('ü´ß Tormenta de burbujas iniciada...');
                
                // PASO 2: Colocar huevo y EMPEZAR CRON√ìMETRO (2.2s)
                    setTimeout(() => {
                    const now = Date.now();
                    
                    // Colocar huevo Y empezar cron√≥metro AL MISMO TIEMPO
                    this.gameState.stage = 'egg';
                    this.gameState.eggStartTime = now;
                    this.egg.x = centerX;
                    this.egg.y = centerY;
                    
                    // Iniciar animaci√≥n de aparici√≥n del huevo
                    this.startEggAppearanceAnimation();
                    
                    console.log('ü•ö ¬°Huevo + cron√≥metro iniciados!');
                }, 2200);
                
                // PASO 3: Desactivar efectos gradualmente (6s total)
                setTimeout(() => {
                    this.gameState.showMagicBubbles = false;
                    console.log('‚ú® Magia completada');
                }, 6000);
            }

            // ü´ß BURBUJAS COPIADAS DEL TEST QUE FUNCIONA
            createSimpleBubbles() {
                console.log('‚ú® COPIANDO SISTEMA DEL TEST...');
                
                // LIMPIAR COMPLETAMENTE
                this.bgBubbles = [];
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // EXACTAMENTE como en el test que funciona
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 150;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const burbuja = {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        r: 8 + Math.random() * 12,
                        alpha: 0.6 + Math.random() * 0.4,
                        color: `hsl(${190 + Math.random() * 40}, 70%, 70%)`,
                        life: 120, // 2 segundos a 60fps
                        sparkle: Math.random() > 0.5,
                        isTestBubble: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(burbuja);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas TEST creadas`);
            }

            // üå´Ô∏è EFECTOS ANTES DEL HUEVO - SISTEMA PERSISTENTE (VIEJO)
            createPreEggEffects() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                console.log('‚ú® TEST BURBUJAS INMORTALES...');
                
                // LIMPIAR burbujas existentes
                this.bgBubbles = [];
                
                // TEST: 10 burbujas INMORTALES que NUNCA se eliminen
                for (let i = 0; i < 10; i++) {
                    const x = 50 + i * 35;
                    const y = 150;
                    
                    const bubble = {
                        x: x,
                        y: y,
                        vx: 0, // SIN MOVIMIENTO
                        vy: 0, // EST√ÅTICAS
                        r: 25, // GRANDES
                        alpha: 1, // OPACAS
                        color: '#ff0000', // ROJO BRILLANTE
                        life: 999999, // VIDA INFINITA
                        maxLife: 999999,
                        sparkle: false,
                        isAppearanceEffect: true,
                        immortal: true // MARCADOR ESPECIAL
                    };
                    
                    this.bgBubbles.push(bubble);
                    console.log(`üî¥ Burbuja INMORTAL ${i+1} en (${x}, ${y})`);
                }
                
                console.log(`ü´ß ${this.bgBubbles.length} burbujas INMORTALES creadas`);
            }

            // üí¨ MENSAJE TEMPORAL EN PANTALLA
            showTemporaryMessage(text, duration) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 40%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 50, 100, 0.8);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 12px;
                    font-size: 14px;
                    font-weight: bold;
                    text-align: center;
                    z-index: 1500;
                    border: 2px solid rgba(255,255,255,0.4);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    animation: messageFloat 0.5s ease-out;
                `;
                messageDiv.textContent = text;
                
                // A√±adir CSS de animaci√≥n si no existe
                if (!document.getElementById('messageFloatStyle')) {
                    const style = document.createElement('style');
                    style.id = 'messageFloatStyle';
                    style.textContent = `
                        @keyframes messageFloat {
                            from { 
                                transform: translate(-50%, -50%) scale(0.8);
                                opacity: 0;
                            }
                            to { 
                                transform: translate(-50%, -50%) scale(1);
                                opacity: 1;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(messageDiv);
                
                // Remover despu√©s del tiempo especificado
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, duration);
            }
            
            // üéÆ MOSTRAR JUEGOS - MODAL SIMPLE Y FUNCIONAL
            showGames() {
                console.log('üéÆ Abriendo modal de juegos simple...');
                
                // Usar la nueva modal simple
                const modal = document.getElementById('gamesModal');
                modal.style.display = 'flex';
                
                // Trigger animation
                setTimeout(() => modal.style.opacity = '1', 10);
                
                // Actualizar disponibilidad de juegos din√°micamente
                this.updateGameAvailabilitySquare();
            }
            
            // üéØ ACTUALIZAR DISPONIBILIDAD DE JUEGOS CUADRADOS
            updateGameAvailabilitySquare() {
                const stars = this.gameState.stars || 0;
                
                const gameRequirements = {
                    'bubbles': 0,
                    'memory': 10,
                    'snake': 25,
                    'puzzle': 50,
                    'race': 75,
                    'target': 100,
                    'adventure': 150,
                    'tower': 200,
                    'boss': 300
                };
                
                // Actualizar cada juego seg√∫n las estrellas disponibles
                Object.entries(gameRequirements).forEach(([gameId, requiredStars]) => {
                    const card = document.querySelector(`[data-game="${gameId}"]`);
                    if (card) {
                        if (stars >= requiredStars) {
                            card.classList.remove('locked');
                            card.classList.add('available');
                        } else {
                            card.classList.add('locked');
                            card.classList.remove('available');
                        }
                    }
                });
                
                console.log(`üéÆ Juegos cuadrados actualizados. Estrellas: ${stars}`);
            }
            
            // Funci√≥n temporal para mantener compatibilidad
            populateGamesGrid() {
                // Esta funci√≥n ya no es necesaria con el nuevo dise√±o
                console.log('üéÆ populateGamesGrid() - Ya no es necesaria con el nuevo dise√±o');

                const buttonsHTML = gameButtons.map(game => {
                    if (game.available) {
                        return `<button onclick="game.startGame('${game.id}')" style="
                            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
                            border: 2px solid #0277bd;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: white;
                            font-size: 16px;
                            cursor: pointer;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                        </button>`;
                    } else {
                        return `<button style="
                            background: linear-gradient(135deg, #bbb, #999);
                            border: 2px solid #666;
                            border-radius: 12px;
                            padding: 15px;
                            margin: 5px;
                            color: #666;
                            font-size: 16px;
                            cursor: not-allowed;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            min-width: 80px;
                            opacity: 0.6;
                        ">
                            <div style="font-size: 24px; margin-bottom: 5px;">${game.icon}</div>
                            <div style="font-weight: bold;">${game.name}</div>
                            <div style="font-size: 10px;">‚≠ê ${game.stars}</div>
                        </button>`;
                    }
                }).join('');

                this.showCustomModal({
                    title: 'üéÆ Minijuegos',
                    message: `üê†üí≠ "¬°Elige un juego para divertirnos!"\n\n<div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 5px;">${buttonsHTML}</div>`,
                    confirmText: '‚ùå Cerrar',
                    onConfirm: () => {}
                });
            }
            
            populateGamesGrid() {
                const gamesGrid = document.getElementById('gamesGrid');
                if (!gamesGrid) return;
                
                const games = [
                    { id: 'bubbles', icon: 'ü´ß', name: 'Burbujas', available: true, stars: 0 },
                    { id: 'memory', icon: 'üß†', name: 'Memoria', available: this.gameState.stars >= 10, stars: 10 },
                    { id: 'target', icon: 'üéØ', name: 'Punter√≠a', available: false, stars: 25 },
                    { id: 'race', icon: 'üèÉ', name: 'Carrera', available: false, stars: 50 },
                    { id: 'puzzle', icon: 'üß©', name: 'Puzzle', available: false, stars: 75 },
                    { id: 'adventure', icon: 'üó∫Ô∏è', name: 'Aventura', available: false, stars: 100 }
                ];
                
                gamesGrid.innerHTML = games.map(game => {
                    const isAvailable = game.available;
                    
                    return `
                        <div class="game-card ${isAvailable ? 'available' : 'locked'}" 
                             data-game-id="${game.id}" 
                             data-available="${isAvailable}"
                             data-stars="${game.stars}">
                            <div class="game-icon">${game.icon}</div>
                            <div class="game-name">${game.name}</div>
                            ${!isAvailable ? `<div class="game-requirement">‚≠ê ${game.stars}</div>` : ''}
                        </div>
                    `;
                }).join('');

                // A√±adir event listeners a las cartas de juego
                setTimeout(() => {
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.addEventListener('click', (e) => {
                            const gameId = card.dataset.gameId;
                            const isAvailable = card.dataset.available === 'true';
                            const stars = parseInt(card.dataset.stars);

                            console.log(`üéÆ Click en juego: ${gameId}, disponible: ${isAvailable}`);

                            if (isAvailable) {
                                console.log(`üöÄ Iniciando juego: ${gameId}`);
                                // CERRAR MODAL ANTES DE INICIAR JUEGO
                                const customModal = document.querySelector('.custom-modal');
                                if (customModal) {
                                    customModal.remove();
                                }
                                this.startGame(gameId);
                            } else {
                                console.log(`üîí Juego bloqueado: ${gameId}, necesita ${stars} estrellas`);
                                this.showGameLocked(stars);
                            }
                        });
                    });
                }, 100);
            }
            
            // üéí MOSTRAR INVENTARIO (PLACEHOLDER)
            showInventory() {
                console.log('üéí Abriendo inventario...');
                
                this.showCustomModal({
                    title: 'üéí Mi Inventario',
                    message: `üê†üí≠ "¬°Mira todas mis cosas!"

üí∞ Tienes: ü´ß ${this.gameState.bubbles || 0} burbujas | ‚≠ê ${this.gameState.stars || 0} estrellas

üåä **Fondos de Pecera** - DISPONIBLE
Cambia el fondo de tu acuario
üñºÔ∏è ${this.availableBackgrounds ? this.availableBackgrounds.length : 5} fondos disponibles

üé® **Decoraciones** - PR√ìXIMAMENTE
Rocas, plantas, castillos...
üöß En desarrollo

üçΩÔ∏è **Comida Especial** - PR√ìXIMAMENTE  
Comida premium y de cumplea√±os
üöß En desarrollo`,
                    confirmText: 'üåä Ver Fondos',
                    cancelText: '‚ùå Cerrar',
                    onConfirm: () => {
                        // Abrir selector de fondos (funci√≥n existente)
                        document.getElementById('inventoryModal').style.display = 'flex';
                    },
                    onCancel: () => {
                        console.log('üéí Inventario cerrado');
                    }
                });
            }
            
            // üì∏ MOSTRAR √ÅLBUM (PLACEHOLDER)
            showAlbum() {
                console.log('üì∏ Abriendo √°lbum...');
                
                this.showCustomModal({
                    title: 'üì∏ √Ålbum de Mi Pececito',
                    message: `
                        <div style="text-align: center; padding: 20px;">
                            <div style="margin-bottom: 15px; font-size: 16px;">üìÖ Momentos Especiales</div>
                            <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <div style="font-weight: bold; margin-bottom: 5px;">üê£ ¬°He nacido!</div>
                                <div style="font-size: 12px; color: #666;">Mi primer d√≠a en el mundo</div>
                                <div style="font-size: 11px; color: #999;">Hace unos momentos</div>
                            </div>
                            <div style="color: #666; font-style: italic;">M√°s recuerdos aparecer√°n aqu√≠...</div>
                        </div>
                    `,
                    confirmText: '‚ùå Cerrar',
                    showCancel: false,
                    onConfirm: () => {
                        console.log('üì∏ √Ålbum cerrado');
                    }
                });
            }
            
            // üîÑ DETECCI√ìN MUY TEMPRANA DE BORDES
            handleSimpleFishBoundaries() {
                const fish = this.fish;
                const fishSize = 60; // Tama√±o aproximado del pez Lottie
                const padding = fishSize + 40; // MARGEN MUY GRANDE (100px total)
                
                // DETECCI√ìN TEMPRANA: Antes de que se salga del borde
                
                // BORDE IZQUIERDO
                if (fish.x <= padding && fish.direction === -1) {
                    fish.direction = 1; // Girar a la derecha
                    fish.x = padding + 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana IZQUIERDO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la DERECHA`);
                }
                
                // BORDE DERECHO  
                if (fish.x >= this.canvas.width - padding && fish.direction === 1) {
                    fish.direction = -1; // Girar a la izquierda
                    fish.x = this.canvas.width - padding - 10; // Reposicionar M√ÅS adentro
                    console.log(`üê† Detecci√≥n MUY temprana DERECHO (x=${fish.x.toFixed(0)}) ‚Üí Gira a la IZQUIERDA`);
                }
                
                // BORDE SUPERIOR - M√°s margen
                if (fish.y <= this.canvas.height * 0.2 && fish.verticalDirection === -1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : 1;
                    fish.y = this.canvas.height * 0.2 + 10;
                    console.log(`üê† Detecci√≥n MUY temprana SUPERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ABAJO ‚Üì'}`);
                }
                
                // BORDE INFERIOR - M√°s margen
                if (fish.y >= this.canvas.height * 0.8 && fish.verticalDirection === 1) {
                    fish.verticalDirection = Math.random() > 0.5 ? 0 : -1;
                    fish.y = this.canvas.height * 0.8 - 10;
                    console.log(`üê† Detecci√≥n MUY temprana INFERIOR (y=${fish.y.toFixed(0)}) ‚Üí Cambio: ${fish.verticalDirection === 0 ? 'MEDIO' : 'ARRIBA ‚Üë'}`);
                }
                
                // SEGURIDAD SILENCIOSA: Solo reposicionar sin spam de logs
                const safetyMargin = 80;
                if (fish.x < safetyMargin) {
                    fish.x = safetyMargin;
                    fish.direction = 1; // Forzar direcci√≥n hacia la derecha
                }
                if (fish.x > this.canvas.width - safetyMargin) {
                    fish.x = this.canvas.width - safetyMargin;
                    fish.direction = -1; // Forzar direcci√≥n hacia la izquierda
                }
                if (fish.y < safetyMargin) {
                    fish.y = safetyMargin;
                    fish.verticalDirection = 1; // Forzar hacia abajo
                }
                if (fish.y > this.canvas.height - safetyMargin) {
                    fish.y = this.canvas.height - safetyMargin;
                    fish.verticalDirection = -1; // Forzar hacia arriba
                }
            }
            
            // üîÑ ORIENTACI√ìN CORREGIDA
            updateFishOrientation() {
                const fish = this.fish;
                const container = document.getElementById('lottieContainer');
                if (!container) return;
                
                // EL PEZ LOTTIE MIRA HACIA LA IZQUIERDA POR DEFECTO
                // Para que vaya a la DERECHA necesitamos invertirlo
                // direction = 1 (derecha) ‚Üí scaleX(-1) invertido
                // direction = -1 (izquierda) ‚Üí scaleX(1) normal
                
                const scaleX = fish.direction === 1 ? -1 : 1;
                
                // Solo cambiar si es diferente
                if (fish.facing !== scaleX) {
                    fish.facing = scaleX;
                    container.style.transform = `translate(-50%, -50%) scaleX(${scaleX})`;
                    
                    console.log(`üîÑ Pez orientado: ${fish.direction === 1 ? 'DERECHA ‚Üí (scaleX -1)' : 'IZQUIERDA ‚Üê (scaleX 1)'}`);
                }
            }
            
            updateCanvasFishAnimations(deltaTime) {
                const fish = this.fish;
                
                // Actualizar timers de animaci√≥n
                if (!fish.breatheTime) fish.breatheTime = 0;
                if (!fish.blinkTime) fish.blinkTime = 0;
                if (!fish.finTime) fish.finTime = 0;
                if (!fish.bubbleTime) fish.bubbleTime = 0;
                if (!fish.floatTime) fish.floatTime = 0;
                if (!fish.baseY) fish.baseY = this.canvas.height * 0.6;
                
                fish.breatheTime += deltaTime * 1.5;
                fish.blinkTime += deltaTime;
                fish.finTime += deltaTime * 2;
                fish.bubbleTime += deltaTime;
                fish.floatTime += deltaTime * 0.8;
                
                // Animaciones Canvas
                const breatheCycle = fish.breatheTime % (2.5 * Math.PI);
                fish.breatheScale = 1 + Math.sin(breatheCycle) * 0.06;
                
                if (fish.blinkTime > 4 + Math.random() * 3) {
                    fish.eyeOpen = 0;
                    setTimeout(() => {
                        if (this.fish) this.fish.eyeOpen = 1;
                    }, 200);
                    fish.blinkTime = 0;
                }
                
                const finCycle = (fish.finTime % (2.5 * Math.PI)) / (2.5 * Math.PI);
                const minRotation = -36 * Math.PI / 180;
                const maxRotation = 4 * Math.PI / 180;
                fish.finRotation = minRotation + (maxRotation - minRotation) * (Math.sin(finCycle * Math.PI * 2) * 0.5 + 0.5);
                
                const floatCycle = fish.floatTime % (2.5 * Math.PI);
                const floatAmount = 10;
                fish.y = fish.baseY + Math.sin(floatCycle) * floatAmount;
                
                if (fish.bubbleTime > 4 + Math.random() * 6) {
                    this.createFishBubble();
                    fish.bubbleTime = 0;
                }
            }
            
            // üîÑ EVOLUCI√ìN AUTOM√ÅTICA
            checkEvolution() {
                if (!this.fish) return;
                
                const ageInDays = this.gameState.ageInDays || 0;
                const currentStage = this.gameState.stage;
                
                // Beb√© ‚Üí Joven (3 d√≠as)
                if (currentStage === 'baby' && ageInDays >= 3) {
                    this.gameState.stage = 'young';
                    this.addAlbumEvent('evolution', 'üå± ¬°He crecido!', 'Ya no soy un beb√©. ¬°Ahora soy un pez joven!');
                    console.log('üå± Evoluci√≥n: Beb√© ‚Üí Joven');
                }
                
                // Joven ‚Üí Adulto (8 d√≠as)
                if (currentStage === 'young' && ageInDays >= 8) {
                    this.gameState.stage = 'adult';
                    this.addAlbumEvent('evolution', 'üëë ¬°Soy adulto!', 'He crecido completamente. ¬°Ahora soy un pez adulto!');
                    console.log('üëë Evoluci√≥n: Joven ‚Üí Adulto');
                }
            }
            
            // üçé SISTEMA DE NECESIDADES
            
            // FUNCI√ìN VIEJA DESHABILITADA - Usamos updateAllNeedBubbles ahora
            // updateNeeds(deltaTime) {
            //     // Esta funci√≥n vieja estaba mostrando texto en lugar de iconos
            //     // Ahora usamos updateAllNeedBubbles() que muestra los iconos correctamente
            // }
            
            // FUNCI√ìN VIEJA DESHABILITADA - Mostraba texto en lugar de iconos
            // showNeedBubble(icon, urgent = false) {
            //     // Esta funci√≥n vieja est√° comentada porque mostraba texto
            //     // Usamos la nueva showNeedBubble(bubbleId, needType, offsetX, offsetY)
            // }
            
            // üé® SISTEMA DE FONDOS
            
            async loadAvailableBackgrounds() {
                // Lista de fondos conocidos (se expandir√° autom√°ticamente)
                const knownBackgrounds = [
                    'bg_basic.png',
                    'bg_cartoon.png', 
                    'bg_coral.png',
                    'bg_mario.png',
                    'bg_minecraft.png'
                ];
                
                for (const bgFile of knownBackgrounds) {
                    const bgName = bgFile.replace('bg_', '').replace('.png', '');
                    try {
                        const img = new Image();
                        img.src = `./images/backgrounds/${bgFile}`;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            setTimeout(reject, 2000); // Timeout de 2s
                        });
                        
                        this.availableBackgrounds.push({
                            name: bgName,
                            file: bgFile,
                            image: img,
                            cost: bgName === 'basic' ? 0 : this.getBackgroundCost(bgName), // Costos progresivos
                            unlocked: bgName === 'basic' // Solo basic desbloqueado
                        });
                        
                        console.log(`‚úÖ Fondo cargado: ${bgName}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar: ${bgFile}`);
                    }
                }
                
                console.log(`üé® ${this.availableBackgrounds.length} fondos disponibles`);
                this.populateBackgroundsGrid();
            }
            
            populateBackgroundsGrid() {
                const grid = document.getElementById('backgroundsGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                for (const bg of this.availableBackgrounds) {
                    const card = document.createElement('div');
                    card.className = 'item-card';
                    if (this.gameState.currentBackground === bg.name) {
                        card.classList.add('selected');
                    }
                    
                    const isLocked = bg.cost > 0 && this.gameState.bubbles < bg.cost;
                    
                    card.innerHTML = `
                        <div class="item-preview" style="background-image: url('./images/backgrounds/${bg.file}')${isLocked ? '; filter: grayscale(100%) brightness(0.5);' : ''}"></div>
                        <div class="item-name">${bg.name.charAt(0).toUpperCase() + bg.name.slice(1)}</div>
                        <div class="item-cost">${bg.cost === 0 ? 'Gratis' : bg.cost + ' ü´ß'}</div>
                        ${isLocked ? '<div class="locked-overlay">üîí</div>' : ''}
                    `;
                    
                    card.addEventListener('click', () => {
                        this.selectBackground(bg.name);
                    });
                    
                    grid.appendChild(card);
                }
            }
            
            selectBackground(bgName) {
                const bg = this.availableBackgrounds.find(b => b.name === bgName);
                if (!bg) return;
                
                // Si ya est√° seleccionado, no hacer nada
                if (this.gameState.currentBackground === bgName) {
                    console.log('üé® Ya tienes este fondo seleccionado');
                    return;
                }
                
                // Si cuesta burbujas, pedir confirmaci√≥n
                if (bg.cost > 0) {
                    // Verificar si tiene suficientes burbujas
                    if (this.gameState.bubbles < bg.cost) {
                        const needed = bg.cost - this.gameState.bubbles;
                        this.showCustomModal({
                            title: 'üê†üí≠ ¬°Me encanta este fondo!',
                            message: `Pero necesitamos m√°s burbujas...\n\nü´ß Necesitas: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n‚ùå Te faltan: ${needed} burbujas\n\nüéÆ ¬°Juega minijuegos para ganar m√°s burbujas!`,
                            confirmText: 'üéÆ ¬°Vamos a jugar!',
                            onConfirm: () => {}
                        });
                        return;
                    }
                    
                    // Mensajes personalizados por fondo
                    const bgDisplayName = bg.name.charAt(0).toUpperCase() + bg.name.slice(1);
                    const fishMessages = {
                        'cartoon': 'üê†üí≠ "¬°Wow! Este lugar parece s√∫per divertido!"',
                        'coral': 'üê†üí≠ "¬°Me encanta nadar entre corales!"',
                        'mario': 'üê†üí≠ "¬°Como en los videojuegos! ¬°Genial!"',
                        'minecraft': 'üê†üí≠ "¬°Un mundo de bloques para explorar!"'
                    };
                    
                    const fishMessage = fishMessages[bg.name] || 'üê†üí≠ "¬°Este lugar se ve genial para nadar!"';
                    
                    this.showCustomModal({
                        title: 'üè† ¬°Tu pececito quiere un nuevo hogar!',
                        message: `üé® Fondo: ${bgDisplayName}\nü´ß Cuesta: ${bg.cost} burbujas\nü´ß Tienes: ${this.gameState.bubbles} burbujas\n\n${fishMessage}`,
                        confirmText: '‚ú® ¬°Desbloquear fondo!',
                        cancelText: 'üö´ Mejor no',
                        onConfirm: () => {
                            // Proceder con la compra
                            this.completePurchase(bg);
                        },
                        onCancel: () => {
                            console.log('üö´ Compra cancelada');
                        }
                    });
                    return; // Salir aqu√≠, la compra se completa en completePurchase
                }
                
                // Si es gratis, comprar directamente
                this.completePurchase(bg);
            }
            
            completePurchase(bg) {
                // Cobrar
                if (bg.cost > 0) {
                    this.gameState.bubbles -= bg.cost;
                    console.log(`üí≥ Pagado: ${bg.cost} burbujas`);
                }
                
                // Cambiar fondo
                this.gameState.currentBackground = bg.name;
                this.bgImage = bg.image;
                
                // Mensaje de √©xito
                if (bg.cost > 0) {
                    const successMessages = {
                        'cartoon': 'üéâ ¬°Tu pececito est√° s√∫per feliz en su nuevo hogar cartoon!',
                        'coral': 'üéâ ¬°Tu pececito nada feliz entre los corales!',
                        'mario': 'üéâ ¬°Tu pececito se siente como en un videojuego!',
                        'minecraft': 'üéâ ¬°Tu pececito explora su mundo de bloques!'
                    };
                    
                    const successMsg = successMessages[bg.name] || 'üéâ ¬°Tu pececito ama su nuevo hogar!';
                    
                    // Mostrar mensaje de √©xito con modal bonito
                    this.showCustomModal({
                        title: 'üéâ ¬°Fondo desbloqueado!',
                        message: `${successMsg}\n\nüê†üí≠ "¬°Gracias! ¬°Me encanta!"`,
                        confirmText: 'ü•∞ ¬°De nada!',
                        onConfirm: () => {}
                    });
                }
                
                // A√±adir evento al √°lbum
                this.addAlbumEvent('background', `üé® Nuevo hogar: ${bg.name}`, `He cambiado mi acuario por uno ${bg.name}. ¬°Me encanta mi nuevo hogar!`);
                
                console.log(`üé® Fondo cambiado a: ${bg.name}`);
                this.populateBackgroundsGrid(); // Actualizar selecci√≥n
                this.updateUI();
                this.saveGame();
            }
            
            // üñ•Ô∏è ACTUALIZACI√ìN DE UI
            
            updateUI() {
                // Actualizar contadores con animaci√≥n
                this.updateCurrencyDisplay('bubblesCount', this.gameState.bubbles);
                this.updateCurrencyDisplay('starsCount', this.gameState.stars);
                
                // Actualizar edad y nombre
                this.updateAgeDisplay();
            }
            
            updateCurrencyDisplay(elementId, newValue) {
                const element = document.getElementById(elementId);
                const currentValue = parseInt(element.textContent) || 0;
                
                if (newValue !== currentValue) {
                    element.textContent = newValue;
                    
                    // A√±adir animaci√≥n
                    const floatContainer = element.closest('.currency-float');
                    if (floatContainer) {
                        floatContainer.classList.add('updated');
                        setTimeout(() => {
                            floatContainer.classList.remove('updated');
                        }, 500);
                    }
                }
            }
            
            updateAgeDisplay() {
                const fishAge = document.getElementById('fishAge');
                const fishName = document.getElementById('fishName');
                
                if (this.gameState.stage === 'waiting') {
                    fishAge.textContent = 'Esperando...';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.gameState.stage === 'egg') {
                    fishAge.textContent = 'Huevo';
                    fishName.textContent = 'Mi Pececito';
                } else if (this.fish && this.gameState.birthDate) {
                    // Calcular edad en d√≠as
                    const now = Date.now();
                    const ageInMs = now - this.gameState.birthDate;
                    const ageInDays = Math.floor(ageInMs / (24 * 60 * 60 * 1000));
                    this.gameState.ageInDays = ageInDays;
                    
                    // Mostrar etapa y edad
                    const stageEmojis = {
                        'baby': 'üçº',
                        'young': 'üå±', 
                        'adult': 'üëë'
                    };
                    
                    const stageNames = {
                        'baby': 'Beb√©',
                        'young': 'Joven',
                        'adult': 'Adulto'
                    };
                    
                    const stageName = stageNames[this.gameState.stage] || 'Pez';
                    
                    fishAge.textContent = `${stageName} - ${ageInDays} d√≠a${ageInDays !== 1 ? 's' : ''}`;
                    
                    // Nombre del juego con el nombre del pez
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                } else {
                    fishAge.textContent = 'üçº Beb√©';
                    if (this.gameState.fishName) {
                        fishName.textContent = `Mi Pececito ${this.gameState.fishName}`;
                    } else {
                        fishName.textContent = 'Mi Pececito';
                    }
                }
            }
            
            // üê† SISTEMA DE NOMBRE
            
            askForFishName() {
                if (this.gameState.hasAskedForName || this.gameState.fishName) return;
                
                this.gameState.hasAskedForName = true;
                
                // Mostrar burbuja de nombre
                this.showNameBubble();
            }
            
            showNameBubble() {
                if (!this.fish) return;
                
                // Crear modal bonito para el nombre
                this.showCustomModal({
                    title: 'üê† ¬°Hola! Soy tu nuevo pececito beb√©',
                    message: 'üè∑Ô∏è ¬øC√≥mo quieres que me llame?\n\nüí° Elige un nombre bonito para m√≠:',
                    input: true,
                    inputPlaceholder: 'Escribe mi nombre...',
                    confirmText: '‚ú® ¬°Ese nombre me gusta!',
                    cancelText: 'üé≤ Sorpr√©ndeme',
                    onConfirm: (name) => {
                        if (name && name.trim()) {
                            this.gameState.fishName = name.trim();
                            console.log(`üè∑Ô∏è Pez nombrado: ${this.gameState.fishName}`);
                            
                            this.showCustomModal({
                                title: 'üéâ ¬°Perfecto!',
                                message: `üê†üí≠ "¬°Me encanta mi nombre: ${this.gameState.fishName}!"\n\n¬°Ahora somos mejores amigos! üíï`,
                                confirmText: 'ü•∞ ¬°Me alegra!',
                                onConfirm: () => {}
                            });
                        } else {
                            this.setRandomName();
                        }
                        this.updateUI();
                        this.saveGame();
                    },
                    onCancel: () => {
                        this.setRandomName();
                        this.updateUI();
                        this.saveGame();
                    }
                });
            }
            
            setRandomName() {
                const randomNames = ['Burbuj√≠n', 'Nadador', 'Azulito', 'Brillante', 'Saltar√≠n', 'Coralito'];
                this.gameState.fishName = randomNames[Math.floor(Math.random() * randomNames.length)];
                
                this.showCustomModal({
                    title: 'üé≤ ¬°Sorpresa!',
                    message: `üê†üí≠ "¬°Me llamar√© ${this.gameState.fishName}!"\n\n¬°Espero que te guste mi nombre! üòä`,
                    confirmText: 'üíï ¬°Me encanta!',
                    onConfirm: () => {}
                });
            }
            
            // üé® MODAL PERSONALIZADO BONITO
            showCustomModal(options) {
                // Crear modal din√°micamente
                const modal = document.createElement('div');
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <div class="custom-modal-content">
                        <div class="custom-modal-header">
                            <h2>${options.title}</h2>
                        </div>
                        <div class="custom-modal-body">
                            <p>${options.message.replace(/\n/g, '<br>')}</p>
                            ${options.input ? `<input type="text" class="custom-input" placeholder="${options.inputPlaceholder}" maxlength="15">` : ''}
                        </div>
                        <div class="custom-modal-buttons">
                            <button class="custom-btn confirm-btn">${options.confirmText}</button>
                            ${options.cancelText ? `<button class="custom-btn cancel-btn">${options.cancelText}</button>` : ''}
                        </div>
                    </div>
                `;
                
                // A√±adir estilos inline para que funcione inmediatamente
                modal.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 3000;
                `;
                
                const content = modal.querySelector('.custom-modal-content');
                content.style.cssText = `
                    background: linear-gradient(135deg, #26c6da 0%, #4fc3f7 50%, #81d4fa 100%);
                    border: 4px solid #ffffff;
                    border-radius: 25px;
                    padding: 25px;
                    max-width: 350px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    animation: modalPop 0.3s ease-out;
                `;
                
                // Event listeners
                const confirmBtn = modal.querySelector('.confirm-btn');
                const cancelBtn = modal.querySelector('.cancel-btn');
                const input = modal.querySelector('.custom-input');
                
                confirmBtn.addEventListener('click', () => {
                    const value = input ? input.value : null;
                    document.body.removeChild(modal);
                    options.onConfirm(value);
                });
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        options.onCancel();
                    });
                }
                
                // Focus en input si existe
                document.body.appendChild(modal);
                if (input) {
                    input.focus();
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            confirmBtn.click();
                        }
                    });
                }
            }
            
            // üì∏ MOSTRAR √ÅLBUM
            
            showAlbum() {
                this.populateAlbum();
                document.getElementById('albumModal').style.display = 'flex';
            }
            
            populateAlbum() {
                const albumTimeline = document.getElementById('albumTimeline');
                const albumDays = document.getElementById('albumDays');
                const albumEvents = document.getElementById('albumEvents');
                const albumMilestones = document.getElementById('albumMilestones');
                
                // Estad√≠sticas
                const daysSinceBirth = this.gameState.birthDate ? 
                    Math.floor((Date.now() - this.gameState.birthDate) / (24 * 60 * 60 * 1000)) : 0;
                const totalEvents = this.gameState.album?.length || 0;
                const milestones = this.gameState.album?.filter(e => 
                    ['birth', 'naming', 'background'].includes(e.type)).length || 0;
                
                albumDays.textContent = daysSinceBirth;
                albumEvents.textContent = totalEvents;
                albumMilestones.textContent = milestones;
                
                // Timeline
                albumTimeline.innerHTML = '';
                
                if (!this.gameState.album || this.gameState.album.length === 0) {
                    albumTimeline.innerHTML = `
                        <div class="album-entry">
                            <div class="album-entry-title">üìù Diario vac√≠o</div>
                            <div class="album-entry-description">¬°Los recuerdos aparecer√°n aqu√≠ mientras juegas!</div>
                        </div>
                    `;
                    return;
                }
                
                // Mostrar eventos m√°s recientes primero
                const sortedEvents = [...this.gameState.album].reverse();
                
                sortedEvents.forEach(event => {
                    const entry = document.createElement('div');
                    entry.className = 'album-entry';
                    entry.innerHTML = `
                        <div class="album-entry-header">
                            <div class="album-entry-title">${event.title}</div>
                            <div class="album-entry-date">${event.date} ${event.time}</div>
                        </div>
                        <div class="album-entry-description">${event.description}</div>
                        <div class="album-entry-meta">
                            <div class="album-entry-age">D√≠a ${event.fishAge}</div>
                            <div>${event.fishName}</div>
                        </div>
                    `;
                    albumTimeline.appendChild(entry);
                });
            }
            
            // üì∏ SISTEMA DE √ÅLBUM/DIARIO
            
            addAlbumEvent(type, title, description, photo = null) {
                const event = {
                    id: Date.now() + Math.random(),
                    type: type, // 'birth', 'naming', 'feeding', 'playing', 'background', 'milestone'
                    title: title,
                    description: description,
                    photo: photo, // URL de la foto o null
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString('es-ES'),
                    time: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }),
                    fishAge: this.gameState.ageInDays || 0,
                    fishName: this.gameState.fishName || 'Mi Pececito'
                };
                
                this.gameState.album.push(event);
                
                // Mantener solo los √∫ltimos 50 eventos para no saturar
                if (this.gameState.album.length > 50) {
                    this.gameState.album = this.gameState.album.slice(-50);
                }
                
                console.log(`üì∏ Evento a√±adido al √°lbum: ${title}`);
                this.saveGame();
            }
            
            checkForAlbumEvents() {
                const now = Date.now();
                const hoursSinceLastEvent = (now - this.gameState.lastEventTime) / (1000 * 60 * 60);
                
                // Solo generar eventos cada 2+ horas para no spam
                if (hoursSinceLastEvent < 2) return;
                
                // Eventos aleatorios basados en el estado del pez
                if (this.fish && Math.random() < 0.1) { // 10% chance cada check
                    const randomEvents = [
                        { type: 'swimming', title: 'üèä Nadando feliz', desc: 'Hoy he nadado mucho y me siento muy activo.' },
                        { type: 'exploring', title: 'üîç Explorando', desc: 'He descubierto un rinc√≥n nuevo de mi acuario.' },
                        { type: 'playing', title: 'üéà Jugando', desc: 'He estado jugando con las burbujas. ¬°Qu√© divertido!' },
                        { type: 'resting', title: 'üò¥ Descansando', desc: 'He encontrado un lugar c√≥modo para relajarme.' }
                    ];
                    
                    const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                    this.addAlbumEvent(event.type, event.title, event.desc);
                    this.gameState.lastEventTime = now;
                }
            }
            
            // üíæ SISTEMA DE GUARDADO
            
            saveGame() {
                const saveData = {
                    version: '1.0.0',
                    gameState: this.gameState,
                    egg: this.egg,
                    fish: this.fish,
                    explosionHappened: this.explosionHappened,
                    availableBackgrounds: this.availableBackgrounds?.map(bg => ({
                        name: bg.name,
                        cost: bg.cost,
                        unlocked: bg.unlocked
                    })),
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('miPececito_gameData', JSON.stringify(saveData));
                    console.log('üíæ Juego guardado correctamente');
                    console.log('üìä Guardado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                } catch (error) {
                    console.error('‚ùå Error guardando:', error);
                }
            }
            
            loadGame() {
                try {
                    const savedData = localStorage.getItem('miPececito_gameData');
                    if (!savedData) return false;
                    
                    const data = JSON.parse(savedData);
                    
                    // Restaurar estado del juego
                    if (data.gameState) {
                        this.gameState = { ...this.gameState, ...data.gameState };
                    }
                    
                    // Restaurar huevo y pez
                    if (data.egg) {
                        this.egg = { ...this.egg, ...data.egg };
                    }
                    
                    if (data.fish) {
                        this.fish = { ...this.fish, ...data.fish };
                    }
                    
                    // Restaurar explosi√≥n
                    this.explosionHappened = data.explosionHappened || false;
                    
                    // Restaurar fondos desbloqueados
                    if (data.availableBackgrounds && this.availableBackgrounds) {
                        data.availableBackgrounds.forEach(savedBg => {
                            const bg = this.availableBackgrounds.find(b => b.name === savedBg.name);
                            if (bg) {
                                bg.unlocked = savedBg.unlocked;
                            }
                        });
                    }
                    
                    console.log('üìÅ Juego cargado correctamente');
                    console.log('üìä Cargado:', {
                        nombre: this.gameState.fishName,
                        fondo: this.gameState.currentBackground,
                        burbujas: this.gameState.bubbles,
                        estrellas: this.gameState.stars,
                        edad: this.gameState.ageInDays
                    });
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Error cargando:', error);
                    return false;
                }
            }
            
            // Auto-guardado cada 30 segundos
            startAutoSave() {
                setInterval(() => {
                    this.saveGame();
                }, 30000);
            }
            
            // üîß M√âTODOS DE DEBUG
            
            placeFirstEgg(x, y) {
                const now = Date.now();
                
                // CAMBIAR STAGE A 'EGG' Y INICIAR TIEMPO
                this.gameState.stage = 'egg';
                this.gameState.eggStartTime = now;
                
                // üìä OCULTAR BARRAS DE NECESIDADES CON HUEVO
                const needsBar = document.getElementById('needsHeaderBar');
                if (needsBar) {
                    needsBar.style.display = 'none';
                    this.setupCanvas(); // REAJUSTAR CANVAS SIN BARRAS
                    console.log('üìä Barras ocultas con huevo + Canvas reajustado');
                }
                
                // üéÜ BURBUJITAS BLANCAS PRIMERO, LUEGO HUEVO
                this.createEggBubbles();
                
                // ESPERAR 1 SEGUNDO PARA QUE SE VEAN LAS BURBUJAS PRIMERO
                setTimeout(() => {
                    this.egg.x = x || this.canvas.width / 2;
                    this.egg.y = y || this.canvas.height * 0.6;
                    this.startEggAppearanceAnimation();
                    console.log('ü•ö Huevo aparece DESPU√âS de las burbujas');
                }, 1000);
                
                this.saveGame(); // Guardar al colocar huevo
                console.log(`ü•ö Huevo colocado - Stage cambiado a 'egg'`);
                console.log(`ü•ö Tiempo inicio: ${new Date(now).toLocaleTimeString()}`);
                console.log(`‚è∞ EggStartTime configurado: ${this.gameState.eggStartTime}`);
            }

            // üéÜ ANIMACI√ìN DE APARICI√ìN DEL HUEVO (SOLO APARICI√ìN)
            startEggAppearanceAnimation() {
                // Inicializar propiedades de animaci√≥n del huevo
                this.egg.appearing = true;
                this.egg.scale = 0;
                this.egg.targetScale = 1;
                this.egg.alpha = 0;
                this.egg.targetAlpha = 1;
                
                console.log('ü•ö Iniciando aparici√≥n gradual del huevo...');
            }

            // üå´Ô∏è BURBUJAS DE APARICI√ìN - TEST VISUAL DIRECTO
            createEggAppearanceBubbles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`üå´Ô∏è Creando burbujas de aparici√≥n en (${centerX}, ${centerY})`);
                console.log(`üîç bgBubbles array actual: ${this.bgBubbles.length} burbujas`);
                
                // LIMPIAR burbujas existentes para evitar conflictos
                this.bgBubbles = [];
                
                // Crear 10 burbujas GRANDES y VISIBLES para test
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = 50 + i * 20; // Distancias variadas
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const testBubble = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2 - 3, // Hacia arriba
                        r: 20, // TAMA√ëO FIJO GRANDE
                        size: 20,
                        opacity: 1,
                        alpha: 1,
                        life: 5000, // 5 segundos fijos
                        maxLife: 5000,
                        color: i % 2 === 0 ? '#ff0000' : '#00ff00', // ROJO/VERDE ALTERNADO para ver
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(testBubble);
                    console.log(`üî¥üü¢ Burbuja TEST ${i+1}/10 creada: ${testBubble.color} en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
                
                console.log(`üéØ TEST: ${this.bgBubbles.length} burbujas grandes creadas`);
            }

            // ‚ú® PART√çCULAS M√ÅGICAS - TEST VISUAL
            createMagicParticles() {
                const centerX = this.egg.x;
                const centerY = this.egg.y;
                
                console.log(`‚ú® Creando part√≠culas m√°gicas en (${centerX}, ${centerY})`);
                
                // Crear 5 part√≠culas ENORMES y DORADAS para test
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 80 + i * 15;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const magicParticle = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1 - 2,
                        r: 25, // ENORMES para test
                        size: 25,
                        opacity: 1,
                        alpha: 1,
                        life: 6000, // 6 segundos
                        maxLife: 6000,
                        color: '#ffff00', // AMARILLO PURO
                        sparkle: true,
                        isAppearanceEffect: true
                    };
                    
                    this.bgBubbles.push(magicParticle);
                    console.log(`‚≠ê Part√≠cula TEST ${i+1}/5 creada: AMARILLA 25px en (${x.toFixed(0)}, ${y.toFixed(0)})`);
                }
            }
            
            setEggTimeToFinalSeconds() {
                const total = 24 * 60 * 60 * 1000;
                this.gameState.eggStartTime = Date.now() - (total - 5000);
                console.log('üê£ Huevo a punto de eclosionar (5 segundos)');
            }
            
            addTime(ms) {
                this.gameState.eggStartTime -= ms;
                console.log(`‚è∞ +${ms/1000/60/60}h a√±adidas`);
            }
            
            toggleBackground() {
                // Por ahora solo tenemos basic
                console.log('üñºÔ∏è Fondo cambiado (solo basic disponible)');
            }
            
            addCurrency(type, amount) {
                if (type === 'bubbles') {
                    this.gameState.bubbles += amount;
                } else if (type === 'stars') {
                    this.gameState.stars += amount;
                }
                console.log(`üí∞ +${amount} ${type} a√±adidas`);
                this.updateUI(); // ACTUALIZAR UI INMEDIATAMENTE
            }
            
            getGameInfo() {
                const elapsed = Date.now() - this.gameState.eggStartTime;
                return {
                    stage: this.gameState.stage,
                    eggTime: elapsed,
                    bubbles: this.gameState.bubbles,
                    stars: this.gameState.stars
                };
            }
            
            // üîß FUNCIONES HELPER COPIADAS DEL C√ìDIGO REALISTA
            clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }
            
            dist(x1, y1, x2, y2) {
                return Math.hypot(x2 - x1, y2 - y1);
            }
            
            seek(fx, fy, tx, ty, maxSpeed) {
                const dx = tx - fx;
                const dy = ty - fy;
                const d = Math.hypot(dx, dy) || 1;
                return {
                    vx: dx / d * maxSpeed,
                    vy: dy / d * maxSpeed,
                    dist: d
                };
            }
            
            vary(val, amt, min, max) {
                const v = val + (Math.random() * 2 - 1) * amt;
                return this.clamp(v, min, max);
            }
            
            // üçé SISTEMA DE COMIDA SEG√öN CHAT
            pelletColors() {
                const PELLET_FAMILIES = [
                    {h:38,s:85,l:62},{h:30,s:80,l:58},{h:46,s:68,l:70},
                    {h:28,s:60,l:55},{h:60,s:35,l:65},{h:22,s:55,l:54}
                ];
                const b = PELLET_FAMILIES[Math.floor(Math.random() * PELLET_FAMILIES.length)];
                const h = this.vary(b.h, 5, 10, 70);
                const s = this.vary(b.s, 10, 20, 95);
                const l = this.vary(b.l, 8, 35, 85);
                const strokeL = Math.max(10, l - 22);
                const strokeS = Math.max(25, Math.round(s * 0.85));
                return { 
                    fill: `hsl(${Math.round(h)} ${Math.round(s)}% ${Math.round(l)}%)`, 
                    stroke: `hsl(${Math.round(h)} ${Math.round(strokeS)}% ${Math.round(strokeL)}%)` 
                };
            }
            
            dropFood() {
                const x = Math.random() * this.canvas.width;
                const col = this.pelletColors();
                const r = 2.6 + Math.random() * 1.2;
                
                this.food.push({
                    x: x,
                    y: 10,
                    vx: 0,
                    vy: 6 + Math.random() * 6, // CA√çDA LENTA COMO EN ORIGINAL
                    bottomT: 0,
                    colorFill: col.fill,
                    colorStroke: col.stroke,
                    r: r
                });
                
                console.log('üçé Comida soltada:', x, r, 'Total food:', this.food.length);
            }
            
            updateFood(deltaTime) {
                const h = this.canvas.height;
                const drag = 0.99;
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 254-256
                for (const f of this.food) {
                    if (f.bottomT > 0) {
                        f.bottomT += deltaTime;
                    } else {
                        f.vy = Math.min(f.vy + 80 * deltaTime, 90);
                        f.y += f.vy * deltaTime;
                        f.x += f.vx * deltaTime;
                        f.vx *= drag;
                        if (f.y > h - 12) {
                            f.y = h - 12;
                            f.vy = 0;
                            f.vx = 0;
                            f.bottomT = 0.001;
                        }
                    }
                }
                
                // EXACTO DEL DOCUMENTO - L√çNEAS 258-269
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const f = this.food[i];
                    if (this.fish && this.dist(this.fish.x, this.fish.y, f.x, f.y) < 22) {
                        this.food.splice(i, 1);
                        this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger - 35, 0, 100);
                        this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + 8, 0, 100);
                        
                        this.labels.push({
                            x: this.fish.x,
                            y: this.fish.y - 12,
                            text: "√ëam",
                            a: 1,
                            vy: 40,
                            life: 1.4
                        });
                        
                        this.fish.happyBurst = Math.max(this.fish.happyBurst, 1.2);
                        this.fish.spinKind = "eat";
                        
                        if (this.gameState.crisis.hunger) {
                            this.gameState.needs.hunger = Math.min(this.gameState.needs.hunger, 60);
                        }
                        
                        this.updateCrisisFlags();
                        this.updateNeedBars();
                    } else if (f.bottomT > 0 && f.bottomT > 8) {
                        this.food.splice(i, 1);
                    }
                }
            }
            
            drawFood() {
                this.ctx.save();
                for (const f of this.food) {
                    this.ctx.beginPath();
                    this.ctx.arc(f.x, f.y, f.r || 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = f.colorFill || '#ffd166';
                    this.ctx.fill();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = f.colorStroke || '#cc8400';
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }
            
            // üçé FUNCIONES DE COMIDA
            nearestFood() {
                let best = null, bestD = 1e9;
                for (const f of this.food) {
                    const d = this.dist(this.fish.x, this.fish.y, f.x, f.y);
                    if (d < bestD) {
                        bestD = d;
                        best = f;
                    }
                }
                return best || null;
            }
            
            // ‚ù§Ô∏è CORAZ√ìN VOLADOR (cuando tocas el pez)
            launchHeartToFun() {
                // Crear coraz√≥n que vuela hacia la barra de diversi√≥n
                const sx = this.fish.x;
                const sy = this.fish.y;
                const ex = this.canvas.width * 0.8; // Hacia arriba-derecha
                const ey = 50; // Cerca del header
                const cx = (sx + ex) / 2;
                const cy = Math.min(sy, ey) - 100;
                
                this.flyers.push({
                    t: 0,
                    dur: 1.8,
                    sx, sy, cx, cy, ex, ey,
                    given: false
                });
                
                console.log('‚ù§Ô∏è Coraz√≥n lanzado hacia diversi√≥n');
            }
            
            // ü´ß BURBUJAS DE RESPIRACI√ìN (desde la boca)
            emitMouthBubbles(n = 4, x0, y0) {
                const fish = this.fish;
                if (!fish) return;
                
                // Posici√≥n de la boca del pez
                const bodyW = fish.size * 0.4;
                const bodyH = fish.size * 0.24;
                const mx = fish.x + (fish.facing > 0 ? 1 : -1) * (bodyW * 0.42);
                const my = fish.y - bodyH * 0.12;
                
                for (let i = 0; i < n; i++) {
                    this.tinyBubbles.push({
                        x: mx + (Math.random() * 6 - 3),
                        y: my + (Math.random() * 6 - 3),
                        r: 0.9 + Math.random() * 1.3,
                        vy: 50 + Math.random() * 40,
                        wob: Math.random() * Math.PI * 2,
                        wobSpd: 1.2 + Math.random() * 0.8,
                        wobAmp: 3 + Math.random() * 4,
                        a: 1,
                        life: 1.2
                    });
                }
            }
            
            // ü´ß BURBUJITAS SUTILES DE AMBIENTE (REALMENTE SUTILES)
            drawAmbientBubbles() {
                const time = this.gameTime || Date.now() * 0.001;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                this.ctx.save();
                
                // 8 burbujitas REALMENTE peque√±as y sutiles
                for (let i = 0; i < 8; i++) {
                    // Posici√≥n que se mueve muy lentamente
                    const baseX = (i * 97 + (time * 15) % W) % W;
                    const baseY = H - ((time * 25 + i * 80) % H);
                    
                    // Peque√±o wobble muy sutil
                    const x = baseX + Math.sin(time * 1.5 + i) * 4;
                    const y = baseY + Math.cos(time * 1.2 + i) * 3;
                    
                    // Tama√±o muy peque√±o (1-3px)
                    const size = 1 + (i % 2) + Math.sin(time * 2 + i) * 0.3;
                    
                    // MUY transparente
                    this.ctx.globalAlpha = 0.15 + Math.sin(time * 1.8 + i) * 0.05;
                    this.ctx.fillStyle = '#e8fbff'; // Azul muy claro
                    this.ctx.shadowBlur = 0; // Sin sombra
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            // üîß FUNCIONES QUE FALTAN PARA EL SISTEMA REALISTA
            updateAutoNeeds(deltaTime) {
                // Incremento autom√°tico de necesidades
                const minutes = deltaTime / 60;
                this.gameState.needs.hunger = this.clamp(this.gameState.needs.hunger + 0.1 * minutes, 0, 100);
                this.gameState.needs.dirt = this.clamp(this.gameState.needs.dirt + (1/15) * minutes, 0, 100);
                this.gameState.needs.fun = this.clamp(this.gameState.needs.fun - (1/8) * minutes, 0, 100);
                
                // Actualizar barras visuales
                this.updateNeedBars();
            }
            
            updateNeedBars() {
                // Actualizar las barras visuales (FLOTANTES - OCULTAS)
                const hungerBar = document.getElementById('hungerBar');
                const dirtBar = document.getElementById('dirtBar');
                const funBar = document.getElementById('funBar');
                
                if (hungerBar) hungerBar.style.width = this.gameState.needs.hunger + '%';
                if (dirtBar) dirtBar.style.width = this.gameState.needs.dirt + '%';
                if (funBar) funBar.style.width = this.gameState.needs.fun + '%';
                
                // üìä ACTUALIZAR BARRAS DEL HEADER (NUEVAS)
                const hungerBarHeader = document.getElementById('hungerBarHeader');
                const dirtBarHeader = document.getElementById('dirtBarHeader');
                const funBarHeader = document.getElementById('funBarHeader');
                
                if (hungerBarHeader) hungerBarHeader.style.width = this.gameState.needs.hunger + '%';
                if (dirtBarHeader) dirtBarHeader.style.width = this.gameState.needs.dirt + '%';
                if (funBarHeader) funBarHeader.style.width = this.gameState.needs.fun + '%';
            }
            
            updateCrisisFlags() {
                const CRISIS_LVL = 75;
                this.gameState.crisis.hunger = this.gameState.needs.hunger >= CRISIS_LVL;
                this.gameState.crisis.dirt = this.gameState.needs.dirt >= CRISIS_LVL;
                this.gameState.crisis.bored = this.gameState.needs.fun <= (100 - CRISIS_LVL);
            }
            
            updateTinyBubbles(deltaTime) {
                // Actualizar burbujas de respiraci√≥n
                for (const b of this.tinyBubbles) {
                    b.y -= b.vy * deltaTime;
                    b.x += Math.sin((this.state?.time || Date.now() * 0.001) * b.wobSpd + b.wob) * b.wobAmp * deltaTime;
                    b.life -= deltaTime;
                    b.a = Math.max(0, b.life / 1.2);
                }
                
                // Eliminar burbujas muertas
                for (let i = this.tinyBubbles.length - 1; i >= 0; i--) {
                    const b = this.tinyBubbles[i];
                    if (b.life <= 0 || b.y < -12) {
                        this.tinyBubbles.splice(i, 1);
                    }
                }
            }
            
            updateFlyers(deltaTime) {
                if (!this.flyers) this.flyers = [];
                
                // Actualizar corazones voladores
                for (let i = this.flyers.length - 1; i >= 0; i--) {
                    const heart = this.flyers[i];
                    
                    // Actualizar posici√≥n
                    heart.x += heart.vx * deltaTime;
                    heart.y += heart.vy * deltaTime;
                    
                    // Gravedad suave
                    heart.vy += 20 * deltaTime;
                    
                    // Reducir vida
                    heart.life -= deltaTime;
                    
                    // Eliminar si se acab√≥ la vida
                    if (heart.life <= 0) {
                        this.flyers.splice(i, 1);
                    }
                }
            }
            
            // üíñ DIBUJAR CORAZONES VOLADORES
            drawFlyers() {
                if (!this.flyers) return;
                
                this.ctx.save();
                
                for (const heart of this.flyers) {
                    const alpha = heart.life / heart.maxLife; // Fade out
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.font = `${heart.size}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // Sombra suave
                    this.ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetX = 1;
                    this.ctx.shadowOffsetY = 1;
                    
                    // Dibujar coraz√≥n emoji
                    this.ctx.fillText(heart.color, heart.x, heart.y);
                }
                
                this.ctx.restore();
            }
        }
        
        // üåê Exponer game para debug
        window.game = game;
        
        // üö® SISTEMA DE EMERGENCIA PARA MODALES
        setTimeout(() => {
            console.log('üö® Activando sistema de emergencia para modales...');
            
            const playBtn = document.getElementById('playButton');
            const gamesModal = document.getElementById('gamesModal');
            const invBtn = document.getElementById('inventoryButton');
            const invModal = document.getElementById('inventoryModal');
            
            // Funci√≥n para abrir modal de juegos
            window.openGamesModal = function() {
                console.log('üéÆ Abriendo modal de juegos (funci√≥n de emergencia)');
                if (gamesModal) {
                    gamesModal.style.display = 'flex';
                    gamesModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n para abrir modal de inventario
            window.openInventoryModal = function() {
                console.log('üéí Abriendo modal de inventario (funci√≥n de emergencia)');
                if (invModal) {
                    invModal.style.display = 'flex';
                    invModal.style.opacity = '1';
                }
            };
            
            // Funci√≥n S√öPER SIMPLE para juego de burbujas
            window.startBubbleGameDirect = function() {
                console.log('ü´ß Iniciando juego SIMPLE');
                
                // Si window.game existe, usar su m√©todo
                if (window.game && window.game.runBubbleGame) {
                    window.game.runBubbleGame();
                    return;
                }
                
                // Pantalla simple
                document.body.innerHTML += `
                    <div id="bubbleGameOverlay" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #4a90e2 100%);
                        z-index: 10000;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: flex-start;
                        padding: 20px;
                        font-family: Comic Sans MS, cursive;
                    ">
                        <div style="
                            color: white;
                            text-align: center;
                            margin-bottom: 15px;
                            font-size: 20px;
                            font-weight: bold;
                            background: rgba(255,255,255,0.1);
                            padding: 10px 20px;
                            border-radius: 15px;
                            border: 2px solid rgba(255,255,255,0.3);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 400px;">
                                <div>‚è±Ô∏è <span id="bubbleTimer">20</span>s</div>
                                <div>ü´ß <span id="bubbleScore">0</span></div>
                                <button onclick="document.getElementById('bubbleGameOverlay').remove()" style="
                                    background: rgba(255,255,255,0.2);
                                    border: 2px solid rgba(255,255,255,0.5);
                                    border-radius: 50%;
                                    width: 40px;
                                    height: 40px;
                                    color: white;
                                    font-size: 18px;
                                    cursor: pointer;
                                ">‚ùå</button>
                            </div>
                        </div>
                        
                        <div id="bubbleGameArea" style="
                            position: relative;
                            width: 100%;
                            max-width: 350px;
                            height: 450px;
                            border-radius: 20px;
                            overflow: hidden;
                            cursor: pointer;
                            background: rgba(255,255,255,0.05);
                            border: 3px solid rgba(255,255,255,0.2);
                        "></div>
                    </div>
                `;
                
                // Variables del juego
                let timeLeft = 20;
                let score = 0;
                let gameActive = true;
                const bubbles = [];
                
                const gameArea = document.getElementById('bubbleGameArea');
                
                // Funci√≥n simple para crear burbujas
                function createBubble() {
                    if (!gameActive) return;
                    
                    const bubble = document.createElement('div');
                    const isGood = Math.random() > 0.35;
                    const size = 35 + Math.random() * 25;
                    
                    bubble.style.cssText = `
                        position: absolute;
                        width: \${size}px;
                        height: \${size}px;
                        border-radius: 50%;
                        background: \${isGood ? 
                            'radial-gradient(circle at 30% 30%, #87ceeb, #4682b4)' : 
                            'radial-gradient(circle at 30% 30%, #ff6b6b, #d63031)'
                        };
                        border: 2px solid white;
                        cursor: pointer;
                        top: 450px;
                        left: \${Math.random() * (300)}px;
                        transition: top 3s linear;
                    `;
                    
                    bubble.onclick = function() {
                        if (isGood) {
                            score += 3;
                            timeLeft += 1;
                        } else {
                            score = Math.max(0, score - 2);
                        }
                        document.getElementById('bubbleScore').textContent = score;
                        bubble.remove();
                    };
                    
                    gameArea.appendChild(bubble);
                    
                    // Animar hacia arriba
                    setTimeout(() => bubble.style.top = '-50px', 10);
                    
                    // Remover autom√°ticamente
                    setTimeout(() => {
                        if (bubble.parentNode) bubble.remove();
                    }, 3000);
                }
                
                // Timer simple
                const timer = setInterval(() => {
                    timeLeft--;
                    document.getElementById('bubbleTimer').textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        gameActive = false;
                        clearInterval(timer);
                        clearInterval(spawner);
                        
                        gameArea.innerHTML = `
                            <div style="
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                text-align: center;
                                color: white;
                                font-size: 24px;
                                font-weight: bold;
                                background: rgba(255,255,255,0.1);
                                padding: 20px;
                                border-radius: 15px;
                            ">
                                üéâ ¬°Terminado!<br>
                                ü´ß \${score} puntos<br>
                                ‚≠ê 1 estrella
                            </div>
                        `;
                    }
                }, 1000);
                
                // Spawner simple
                const spawner = setInterval(() => {
                    if (gameActive) createBubble();
                }, 800);
                
                // Burbujas iniciales
                setTimeout(() => createBubble(), 500);
                setTimeout(() => createBubble(), 1000);
            };
            
            // Event listeners de emergencia - ELIMINADO (YA EXISTE ARRIBA)
            
            if (invBtn) {
                invBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('üö® CLICK DETECTADO - Abriendo inventario');
                    window.openInventoryModal();
                };
            }
            
            // Botones de cierre
            const closeGames = document.getElementById('closeGames');
            const closeInventory = document.getElementById('closeInventory');
            
            if (closeGames) {
                closeGames.onclick = function() {
                    gamesModal.style.display = 'none';
                };
            }
            
            if (closeInventory) {
                closeInventory.onclick = function() {
                    invModal.style.display = 'none';
                };
            }
            
            // Event listeners para las tarjetas de juegos cuadradas
            const gameCards = document.querySelectorAll('.game-card-square');
            gameCards.forEach(card => {
                card.onclick = function(e) {
                    e.preventDefault();
                    const gameId = card.dataset.game;
                    const isLocked = card.classList.contains('locked');
                    
                    console.log(`üéÆ Click en juego: ${gameId}, bloqueado: ${isLocked}`);
                    
                    if (!isLocked) {
                        console.log(`üöÄ Iniciando juego: ${gameId}`);
                        // Cerrar modal primero
                        gamesModal.style.display = 'none';
                        
                        // Iniciar juego usando window.game o funci√≥n de emergencia
                        if (window.game && window.game.startGame) {
                            window.game.startGame(gameId);
                        } else if (gameId === 'bubbles') {
                            console.log('üö® Usando funci√≥n de emergencia para burbujas');
                            window.startBubbleGameDirect();
                        } else {
                            console.error('‚ùå window.game no disponible y no hay funci√≥n de emergencia para:', gameId);
                            alert(`üöß Juego ${gameId} no disponible temporalmente`);
                        }
                    } else {
                        console.log(`üîí Juego bloqueado: ${gameId}`);
                        // Mostrar mensaje de juego bloqueado
                        alert(`üîí Juego bloqueado. Necesitas m√°s estrellas.`);
                    }
                };
            });
            
            console.log('‚úÖ Sistema de emergencia activado');
        }, 1000);
    </script>
</body>
</html>
